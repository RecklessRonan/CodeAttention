6398	private function instantiateEntity ( $ entity_name ) { $ entity = null ; if ( $ entity_name == 'weatherPhenomenons' ) { $ entity = new WeatherPhenomenon ( ) ; } else if ( $ entity_name == 'maxTemperature' ) { $ entity = new Temperature ( ) ; } else if ( $ entity_name == 'minTemperature' ) { $ entity = new Temperature ( ) ; } else if ( $ entity_name == 'clouds' ) { $ entity = new CloudLayer ( ) ; } else if ( $ entity_name == 'surfaceWind' ) { $ entity = new SurfaceWind ( ) ; } else if ( $ entity_name = 'visibility' ) { $ entity = new Visibility ( ) ; } return $ entity ; }
11593	public function getAction ( ) { $ id = $ this -> getPageId ( ) ; if ( $ id !== null ) { $ result = $ this -> pageList -> getPage ( $ id ) -> getJSON ( ) ; } else { $ result = array ( ) ; foreach ( $ this -> pageList -> getPages ( ) as $ pageName ) { $ result [ ] = $ this -> pageList -> getPage ( $ pageName ) -> getJSON ( ) ; } } $ this -> environment -> sendJSONResult ( $ result ) ; }
12060	public function getTargetLabel ( ) { if ( ! isset ( $ this -> labels [ $ this -> target ] ) ) { return [ 'long' => 'unknown' , 'short' => 'unknown' ] ; } return $ this -> labels [ $ this -> target ] ; }
10935	public function checkEmailAction ( ) { $ session = $ this -> get ( 'session' ) ; $ email = $ session -> get ( static :: SESSION_EMAIL ) ; $ session -> remove ( static :: SESSION_EMAIL ) ; if ( empty ( $ email ) ) { return new RedirectResponse ( $ this -> get ( 'router' ) -> generate ( 'miky_app_customer_resetting_request' ) ) ; } return $ this -> render ( 'MikyUserBundle:Frontend/Resetting:checkEmail.html.twig' , array ( 'email' => $ email , ) ) ; }
6853	public function onStatus ( PaymentEvent $ event ) { $ payment = $ event -> getPayment ( ) ; $ sale = $ payment -> getSale ( ) ; if ( $ sale instanceof OrderInterface ) { return ; } if ( $ sale instanceof CartInterface && $ sale -> getState ( ) !== CartStates :: STATE_ACCEPTED ) { return ; } if ( $ sale instanceof QuoteInterface && $ sale -> getState ( ) !== QuoteStates :: STATE_ACCEPTED ) { return ; } $ tokens = $ this -> findPaymentTokens ( $ payment ) ; if ( null === $ order = $ this -> transform ( $ sale ) ) { return ; } $ newPayment = null ; foreach ( $ order -> getPayments ( ) as $ p ) { if ( $ p -> getNumber ( ) === $ payment -> getNumber ( ) ) { $ newPayment = $ p ; break ; } } if ( null === $ newPayment ) { throw new RuntimeException ( "Failed to find the transformed payment." ) ; } $ this -> convertTokens ( $ this -> getPaymentIdentity ( $ newPayment ) , $ tokens ) ; $ event -> setPayment ( $ newPayment ) ; }
5481	public function getValue ( SelectorInterface $ selector ) { for ( $ i = 0 , $ count = count ( $ this -> widgets ) ; $ i < $ count ; $ i ++ ) { if ( $ selector -> isMatch ( $ this -> widgets [ $ i ] ) ) { return $ this -> widgets [ $ i ] -> getValue ( ) ; } } foreach ( $ this -> buttons as $ button ) { if ( $ selector -> isMatch ( $ button ) ) { return $ button -> getValue ( ) ; } } return ; }
11214	public function count ( $ coraDbQuery = false ) { if ( ! $ coraDbQuery ) { $ coraDbQuery = $ this -> gateway -> getDb ( ) ; } $ coraDbQuery = $ this -> model :: model_constraints ( $ coraDbQuery ) ; return $ this -> gateway -> count ( $ coraDbQuery ) ; }
2798	public function toArray ( ) { return [ 'file' => $ this -> getMutationFileRelativePath ( ) , 'mutator' => $ this -> mutation -> getMutator ( ) , 'class' => $ this -> mutation -> getClass ( ) , 'method' => $ this -> mutation -> getMethod ( ) , 'line' => $ this -> mutation -> getLine ( ) , 'diff' => $ this -> getDiff ( ) , 'tests' => $ this -> testMethods ] ; }
8804	public function getFlash ( $ key = null ) { if ( ! is_null ( $ key ) ) { $ value = null ; if ( $ this -> hasFlash ( $ key ) ) { $ value = $ this -> get ( '_nur_flash' ) [ $ key ] ; unset ( $ _SESSION [ '_nur_flash' ] [ $ key ] ) ; } return $ value ; } return $ key ; }
10988	public function getConfigTreeBuilder ( ) { $ tree_builder = new TreeBuilder ( ) ; $ tree_builder -> root ( 'anime_db_cache_time_keeper' ) -> children ( ) -> booleanNode ( 'enable' ) -> defaultTrue ( ) -> end ( ) -> scalarNode ( 'use_driver' ) -> cannotBeEmpty ( ) -> defaultValue ( 'file' ) -> end ( ) -> arrayNode ( 'private_headers' ) -> treatNullLike ( [ ] ) -> prototype ( 'scalar' ) -> end ( ) -> defaultValue ( [ 'Authorization' , 'Cookie' ] ) -> end ( ) -> append ( $ this -> getEtagHasher ( ) ) -> append ( $ this -> getTrack ( ) ) -> arrayNode ( 'drivers' ) -> append ( $ this -> getDriverFile ( ) ) -> append ( $ this -> getDriverMemcache ( ) ) -> append ( $ this -> getDriverMulti ( ) ) -> append ( $ this -> getDriverShmop ( ) ) -> end ( ) -> end ( ) ; return $ tree_builder ; }
3185	public function process ( ) { $ this -> validate ( ) ; $ ref = $ this -> getRequestParameter ( 'ref' ) ? : null ; $ itemDuration = null ; $ scope = $ this -> getRequestParameter ( 'scope' ) ; $ start = $ this -> getRequestParameter ( 'start' ) !== false ; try { $ serviceContext = $ this -> getServiceContext ( ) ; $ this -> saveToolStates ( ) ; $ this -> getRunnerService ( ) -> endTimer ( $ serviceContext , $ itemDuration , $ this -> getTime ( ) ) ; if ( $ this -> getRequestParameter ( 'offline' ) === true ) { $ this -> setOffline ( ) ; } $ result = $ this -> getRunnerService ( ) -> skip ( $ serviceContext , $ scope , $ ref ) ; $ response = [ 'success' => $ result , ] ; if ( $ result ) { $ response [ 'testContext' ] = $ this -> getRunnerService ( ) -> getTestContext ( $ serviceContext ) ; if ( $ serviceContext -> containsAdaptive ( ) ) { $ response [ 'testMap' ] = $ this -> getRunnerService ( ) -> getTestMap ( $ serviceContext , true ) ; } } if ( $ start == true ) { $ this -> getRunnerService ( ) -> startTimer ( $ serviceContext , $ this -> getTime ( ) ) ; } } catch ( Exception $ e ) { $ response = $ this -> getErrorResponse ( $ e ) ; } return $ response ; }
6391	public function readScormScoesTrack ( $ userid , $ scormid , $ scoid , $ attempt ) { $ trackingValues = [ ] ; $ scormTracking = $ this -> readStoreRecords ( 'scorm_scoes_track' , [ 'userid' => $ userid , 'scormid' => $ scormid , 'scoid' => $ scoid , 'attempt' => $ attempt ] ) ; foreach ( $ scormTracking as $ st ) { if ( $ st -> element == 'cmi.core.score.min' ) { $ trackingValues [ 'scoremin' ] = $ st -> value ; } else if ( $ st -> element == 'cmi.core.score.max' ) { $ trackingValues [ 'scoremax' ] = $ st -> value ; } else if ( $ st -> element == 'cmi.core.lesson_status' ) { $ trackingValues [ 'status' ] = $ st -> value ; } } return $ trackingValues ; }
8309	public function assertIntOrFalse ( $ config , $ key , $ lowest = null , $ highest = null ) { try { $ this -> assertInteger ( $ config , $ key , $ lowest , $ highest ) ; } catch ( ConfigurationException $ e ) { if ( $ config [ $ key ] !== false ) { throw new ConfigurationException ( "Key `{$key}` can be either false or a non-negative integer." ) ; } } return $ this ; }
11775	protected function getIsEnabled ( ) : \ Illuminate \ Database \ Eloquent \ Model { $ result = Model \ Setting :: find ( 1 ) ; $ result -> value = ( bool ) $ result -> value ; return $ result ; }
6675	public function add_meta_boxes ( $ post_type , $ post ) { App :: setCurrentID ( 'EFG' ) ; $ is_active = $ this -> get_rating_state ( $ post -> ID ) ; if ( App :: main ( ) -> is_publish_post ( $ post ) && $ is_active ) { $ this -> add_styles ( ) ; $ this -> add_scripts ( ) ; add_meta_box ( 'info_movie-rating-movie' , __ ( 'Extensions For Grifus - Custom rating' , 'extensions-for-grifus-rating' ) , [ $ this , 'render_meta_boxes' ] , $ post_type , 'normal' , 'high' ) ; } }
5180	private function addArray ( string $ key , $ value ) : self { $ this -> props [ $ key ] [ ] = $ value ; return $ this ; }
5457	protected function addContentTagToOpenTags ( & $ tag ) { if ( $ tag -> getTagName ( ) != 'option' ) { return ; } foreach ( array_keys ( $ this -> tags ) as $ name ) { for ( $ i = 0 , $ count = count ( $ this -> tags [ $ name ] ) ; $ i < $ count ; $ i ++ ) { $ this -> tags [ $ name ] [ $ i ] -> addTag ( $ tag ) ; } } }
2769	public function addRemote ( string $ name , string $ url , array $ options = [ ] ) : string { $ this -> ensureAddRemoveArgsAreValid ( $ name , $ url ) ; $ args = [ 'add' ] ; foreach ( [ '-f' , '--tags' , '--no-tags' ] as $ option ) { if ( ! empty ( $ options [ $ option ] ) ) { $ args [ ] = $ option ; } } if ( ! empty ( $ options [ '-t' ] ) ) { foreach ( $ options [ '-t' ] as $ branch ) { array_push ( $ args , '-t' , $ branch ) ; } } if ( ! empty ( $ options [ '-m' ] ) ) { array_push ( $ args , '-m' , $ options [ '-m' ] ) ; } array_push ( $ args , $ name , $ url ) ; return $ this -> remote ( ... $ args ) ; }
1431	protected function getSoftDeleteField ( Model $ record ) { if ( $ field = $ this -> softDeleteField ( ) ) { return $ field ; } $ key = $ this -> getSoftDeleteKey ( $ record ) ; return Str :: dasherize ( $ key ) ; }
1092	public function reload ( ) { if ( $ this -> exists || ( $ this -> areSoftDeletesEnabled ( ) && $ this -> trashed ( ) ) ) { $ fresh = $ this -> getFreshInstance ( ) ; if ( is_null ( $ fresh ) ) throw with ( new ModelNotFoundException ) -> setModel ( get_called_class ( ) ) ; $ this -> setRawAttributes ( $ fresh -> getAttributes ( ) , true ) ; $ this -> setRelations ( $ fresh -> getRelations ( ) ) ; $ this -> exists = $ fresh -> exists ; } else { $ this -> attributes = $ this -> original ; } return $ this ; }
10289	protected function executeTasks ( array $ tasks ) { foreach ( $ tasks as $ scheduled => $ taskList ) { foreach ( $ taskList as $ cronjob ) { if ( ( $ task = $ this -> taskFactory -> factory ( $ cronjob -> task , $ scheduled , $ this -> logger ) ) !== false ) { $ this -> logger -> setTask ( $ task -> getId ( ) ) ; $ this -> logger -> log ( 'Start task execution.' ) ; $ status = $ task -> execute ( ) ; switch ( $ status ) { case Executor :: SUCCESS : $ this -> logger -> log ( 'Finished task execution.' ) ; break ; case Executor :: ERROR : $ this -> logger -> log ( 'Error occured during task execution.' , Logger :: WARNING ) ; break ; case Executor :: RESCHEDULE : $ this -> logger -> log ( 'Task will be rescheduled for ' . $ task -> reScheduleTime . ' seconds.' ) ; $ this -> rescheduled [ $ scheduled + $ task -> reScheduleTime ] = $ cronjob ; break ; default : $ this -> logger -> log ( 'Invalid status returned by task.' , Logger :: ERROR ) ; break ; } $ this -> logger -> setTask ( ) ; } } } }
1370	protected function bindExceptionParser ( ) { $ this -> app -> singleton ( ExceptionParserInterface :: class , ExceptionParser :: class ) ; $ this -> app -> alias ( ExceptionParserInterface :: class , 'json-api.exceptions' ) ; }
12366	public function getNextVideoToConvert ( ) { $ query = $ this -> createQueryBuilder ( 'v' ) ; $ this -> onlyUploaded ( $ query ) ; return $ query -> getQuery ( ) -> getOneOrNullResult ( ) ; }
5614	public function paintMethodEnd ( $ message ) { parent :: paintCaseEnd ( $ message ) ; $ node = $ this -> _stack -> pop ( ) ; $ current = $ this -> _stack -> peek ( ) ; if ( $ node -> isFailed ( ) ) { $ current -> fail ( ) ; } $ current -> putChild ( $ node ) ; }
7927	public function registerNamespace ( $ ns , $ def ) { list ( $ ns , $ def ) = $ this -> fireEvent ( 'namespace.register' , [ $ ns , $ def ] ) ; $ this -> namespaces [ $ ns ] = $ def ; return $ this ; }
7465	public static function createFromUploadedFile ( UploadedFile $ upload , $ uploadPath , $ filename = null ) { if ( ! $ upload -> isValid ( ) ) { throw new UploadException ( sprintf ( 'An error occurred during file upload. Error code: %s' , $ upload -> getError ( ) ) ) ; } elseif ( ( $ uploadPath = realpath ( $ uploadPath . '/' ) ) === false ) { throw new UploadException ( 'An error occurred during file upload. The specified upload path is invalid.' ) ; } if ( ! $ filename ) { $ fullPath = sprintf ( '%s%s%s.%s' , rtrim ( $ uploadPath , DIRECTORY_SEPARATOR ) , DIRECTORY_SEPARATOR , uniqid ( ) , ( $ upload -> getExtension ( ) ? : ( $ upload -> guessExtension ( ) ? : 'file' ) ) ) ; } else { $ fullPath = rtrim ( $ uploadPath , DIRECTORY_SEPARATOR ) . DIRECTORY_SEPARATOR . $ filename ; } $ file = new self ( $ fullPath , $ upload -> getClientOriginalName ( ) , $ upload -> getMimeType ( ) , $ upload -> getClientSize ( ) , md5_file ( $ upload -> getRealPath ( ) ) ) ; $ file -> _uploadedFile = $ upload ; return $ file ; }
12252	public function addMissing ( $ objStructure , & $ objElement ) { foreach ( $ objStructure -> attributes ( ) as $ strName => $ objAttribute ) { if ( ! isset ( $ objElement -> attributes ( ) -> $ strName ) ) { $ objElement -> addAttribute ( $ strName , ( string ) $ objAttribute ) ; } } foreach ( $ objStructure -> children ( ) as $ strName => $ varNode ) { if ( count ( $ varNode ) > 0 ) { $ objNode = $ objElement -> addChild ( $ strName ) ; $ this -> addMissing ( $ varNode , $ objNode ) ; } else { $ objElement -> addChild ( $ strName , ( string ) $ varNode ) ; } } }
2237	public function generatePdf ( ) { $ this -> headline = $ this -> title ; $ this -> printable = false ; $ strArticle = $ this -> replaceInsertTags ( $ this -> generate ( ) , false ) ; $ strArticle = html_entity_decode ( $ strArticle , ENT_QUOTES , Config :: get ( 'characterSet' ) ) ; $ strArticle = $ this -> convertRelativeUrls ( $ strArticle , '' , true ) ; $ arrSearch = array ( '@<form.*</form>@Us' , '@<a [^>]*href="[^"]*javascript:[^>]+>.*</a>@Us' ) ; $ strArticle = preg_replace ( $ arrSearch , '' , $ strArticle ) ; if ( empty ( $ GLOBALS [ 'TL_HOOKS' ] [ 'printArticleAsPdf' ] ) ) { throw new \ Exception ( 'No PDF extension found. Did you forget to install contao/tcpdf-bundle?' ) ; } if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'printArticleAsPdf' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'printArticleAsPdf' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'printArticleAsPdf' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ strArticle , $ this ) ; } } }
12192	protected function doSave ( $ id , $ data , $ lifeTime = 0 ) { return $ this -> delegate -> doSave ( $ id , $ data , $ lifeTime ) ; }
11296	public function getAttributeValueExtended ( $ name , $ convertDates = true ) { if ( isset ( $ this -> model_data [ $ name ] ) ) { $ result = $ this -> model_data [ $ name ] ; if ( $ result instanceof \ DateTime && $ convertDates == true ) { $ result = $ result -> format ( 'Y-m-d H:i:s' ) ; } return $ result ; } if ( isset ( $ this -> data -> { $ name } ) ) { return $ this -> data -> { $ name } ; } else if ( isset ( $ this -> model_extends ) && isset ( $ this -> model_attributes [ $ this -> model_extends ] ) ) { $ extendedModel = $ this -> { $ this -> model_extends } ; if ( $ extendedModel && $ result = $ extendedModel -> getAttributeValue ( $ name ) ) { return $ result ; } } return null ; }
5766	private function clear ( ) { if ( ! isset ( $ this -> phpMailer ) ) { return ; } $ this -> phpMailer -> clearAddresses ( ) ; $ this -> phpMailer -> clearCCs ( ) ; $ this -> phpMailer -> clearBCCs ( ) ; $ this -> phpMailer -> clearReplyTos ( ) ; $ this -> phpMailer -> clearAllRecipients ( ) ; $ this -> phpMailer -> clearAttachments ( ) ; $ this -> phpMailer -> clearCustomHeaders ( ) ; }
12590	public function getDataTablesI18nAction ( ) { $ locale = $ this -> get ( 'request_stack' ) -> getCurrentRequest ( ) -> getLocale ( ) ; $ format = $ this -> get ( 'request_stack' ) -> getCurrentRequest ( ) -> getRequestFormat ( ) ; return $ this -> render ( 'AdminBundle:Default/DataTables_i18n:' . $ locale . '.txt.' . $ format ) ; }
80	public static function suppress ( $ mask = null ) { if ( ! isset ( $ mask ) ) { $ mask = E_WARNING | E_NOTICE | E_USER_WARNING | E_USER_NOTICE | E_DEPRECATED | E_USER_DEPRECATED | E_STRICT ; } $ old = error_reporting ( ) ; self :: $ stack [ ] = $ old ; error_reporting ( $ old & ~ $ mask ) ; return $ old ; }
1199	public function addVoter ( VoterInterface $ voter ) { @ trigger_error ( sprintf ( 'The %s() method is deprecated since version 2.3 and will be removed in 3.0. Pass voters in the constructor instead.' , __METHOD__ ) , E_USER_DEPRECATED ) ; if ( $ this -> voters instanceof \ Traversable ) { $ this -> voters = iterator_to_array ( $ this -> voters ) ; } $ this -> voters [ ] = $ voter ; }
5338	public function buildSoapClient ( $ service ) { $ director = new Soap \ SoapClientDirector ( $ this -> username , $ this -> mode , $ this -> endpoint ) ; switch ( $ service ) { case 'DomainService' : return $ director -> build ( new Soap \ Builder \ DomainSoapClientBuilder ) ; case 'ColocationService' : return $ director -> build ( new Soap \ Builder \ ColocationSoapClientBuilder ) ; case 'ForwardService' : return $ director -> build ( new Soap \ Builder \ ForwardSoapClientBuilder ) ; case 'VpsService' : return $ director -> build ( new Soap \ Builder \ VpsSoapClientBuilder ) ; case 'WebhostingService' : return $ director -> build ( new Soap \ Builder \ WebHostingSoapClientBuilder ) ; case 'HaipService' : return $ director -> build ( new Soap \ Builder \ HaipSoapClientBuilder ) ; default : throw new \ InvalidArgumentException ( sprintf ( 'Undefined soap client service builder called: [%s]' , $ service ) ) ; } }
5214	private function findBinding ( $ type , $ name ) { $ bindingName = $ this -> bindingName ( $ name ) ; if ( null !== $ bindingName && isset ( $ this -> index [ $ type . '#' . $ bindingName ] ) ) { return $ this -> index [ $ type . '#' . $ bindingName ] ; } if ( isset ( $ this -> index [ $ type ] ) ) { return $ this -> index [ $ type ] ; } if ( ! in_array ( $ type , [ PropertyBinding :: TYPE , ConstantBinding :: TYPE , ListBinding :: TYPE , MapBinding :: TYPE ] ) ) { $ this -> index [ $ type ] = $ this -> getAnnotatedBinding ( new \ ReflectionClass ( $ type ) ) ; return $ this -> index [ $ type ] ; } return null ; }
445	public function getBehavior ( $ name ) { $ this -> ensureBehaviors ( ) ; return isset ( $ this -> _behaviors [ $ name ] ) ? $ this -> _behaviors [ $ name ] : null ; }
11061	public static function supportedEncodings ( ) { if ( static :: $ supported_encodings === null ) { $ supported = mb_list_encodings ( ) ; foreach ( $ supported as $ key => $ value ) { static :: $ supported_encodings [ strtolower ( $ value ) ] = $ value ; foreach ( mb_encoding_aliases ( $ value ) as $ k => $ v ) { static :: $ supported_encodings [ strtolower ( $ v ) ] = $ value ; } } } return static :: $ supported_encodings ; }
9544	public static function allExcept ( $ except ) { $ result = [ 'parameter' => [ 'longest' => 9 + $ columnPadding , 'values' => [ ] , 'fetch' => function ( $ parameter ) { return $ parameter -> prefix . $ parameter -> parameterName ; } , ] , 'properties' => [ 'longest' => 10 + $ columnPadding , 'values' => [ ] , 'fetch' => function ( $ parameter ) { return $ parameter -> getPropertiesAsString ( ) ; } , ] , 'aliases' => [ 'longest' => 7 + $ columnPadding , 'values' => [ ] , 'fetch' => function ( $ parameter ) { return $ parameter -> getAliasUsage ( false ) ; } , ] , 'description' => [ 'longest' => 11 + $ columnPadding , 'values' => [ ] , 'fetch' => function ( $ parameter ) { return $ parameter -> description ; } , ] , 'required' => [ 'longest' => 8 + $ columnPadding , 'values' => [ ] , 'fetch' => function ( $ parameter ) { return $ parameter -> required ? 'Yes' : '' ; } , ] , ] ; foreach ( $ except as $ exceptKey ) { unset ( $ result [ $ exceptKey ] ) ; } return $ result ; }
1008	public static function suggestionList ( $ input , array $ options ) { $ optionsByDistance = [ ] ; $ inputThreshold = mb_strlen ( $ input ) / 2 ; foreach ( $ options as $ option ) { if ( $ input === $ option ) { $ distance = 0 ; } else { $ distance = ( strtolower ( $ input ) === strtolower ( $ option ) ? 1 : levenshtein ( $ input , $ option ) ) ; } $ threshold = max ( $ inputThreshold , mb_strlen ( $ option ) / 2 , 1 ) ; if ( $ distance > $ threshold ) { continue ; } $ optionsByDistance [ $ option ] = $ distance ; } asort ( $ optionsByDistance ) ; return array_keys ( $ optionsByDistance ) ; }
9237	private function getAmbiguityExceptionMessage ( array $ paths , Vertex $ startVertex , Vertex $ endVertex ) { $ textPaths = [ ] ; $ i = 1 ; foreach ( $ paths as $ path ) { $ textPaths [ ] = 'Path ' . $ i . ': ' . $ this -> getTextualPath ( $ path , $ startVertex ) ; ++ $ i ; } $ msg = sprintf ( "There are many possible shortest paths between table '%s' and table '%s'\n\n" , $ startVertex -> getId ( ) , $ endVertex -> getId ( ) ) ; $ msg .= implode ( "\n\n" , $ textPaths ) ; return $ msg ; }
6938	private function find ( array & $ list , $ oid , StockUnitInterface $ unit ) { if ( ! isset ( $ list [ $ oid ] ) ) { return false ; } if ( null === $ unit -> getId ( ) ) { return array_search ( $ unit , $ list [ $ oid ] , true ) ; } foreach ( $ list [ $ oid ] as $ index => $ u ) { if ( $ u -> getId ( ) == $ unit -> getId ( ) ) { return $ index ; } } return false ; }
4047	public function buildWidget ( BuildWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) || ( $ event -> getProperty ( ) -> getName ( ) !== 'jumpTo' ) ) { return ; } $ model = $ event -> getModel ( ) ; $ metaModel = $ this -> factory -> getMetaModel ( $ this -> factory -> translateIdToMetaModelName ( $ model -> getProperty ( 'pid' ) ) ) ; $ extra = $ event -> getProperty ( ) -> getExtra ( ) ; if ( $ metaModel -> isTranslated ( ) ) { $ arrLanguages = [ ] ; foreach ( ( array ) $ metaModel -> getAvailableLanguages ( ) as $ strLangCode ) { $ arrLanguages [ $ strLangCode ] = $ this -> translator -> trans ( 'LNG.' . $ strLangCode , [ ] , 'contao_languages' ) ; } asort ( $ arrLanguages ) ; $ extra [ 'minCount' ] = count ( $ arrLanguages ) ; $ extra [ 'maxCount' ] = count ( $ arrLanguages ) ; $ extra [ 'columnFields' ] [ 'langcode' ] [ 'options' ] = $ arrLanguages ; } else { $ extra [ 'minCount' ] = 1 ; $ extra [ 'maxCount' ] = 1 ; $ extra [ 'columnFields' ] [ 'langcode' ] [ 'options' ] = [ 'xx' => $ this -> translator -> trans ( 'tl_metamodel_rendersettings.jumpTo_allLanguages' , [ ] , 'contao_tl_metamodel_rendersettings' ) ] ; } $ extra [ 'columnFields' ] [ 'filter' ] [ 'options' ] = $ this -> getFilterSettings ( $ model ) ; $ event -> getProperty ( ) -> setExtra ( $ extra ) ; }
7301	static public function getTargetsForSale ( SaleInterface $ sale ) { if ( $ sale instanceof CartInterface ) { return [ static :: TARGET_ORDER , static :: TARGET_QUOTE ] ; } elseif ( $ sale instanceof OrderInterface ) { if ( $ sale -> getState ( ) !== OrderStates :: STATE_NEW ) { return [ ] ; } return [ static :: TARGET_QUOTE ] ; } elseif ( $ sale instanceof QuoteInterface ) { return [ static :: TARGET_ORDER ] ; } throw new InvalidArgumentException ( "Unexpected sale type." ) ; }
5359	protected function createUrlStatements ( Operation $ operation , $ queryParamVariable ) { $ urlVariable = new Expr \ Variable ( 'url' ) ; $ statements = [ new Expr \ Assign ( $ urlVariable , new Scalar \ String_ ( $ operation -> getPath ( ) ) ) ] ; if ( $ operation -> getOperation ( ) -> getParameters ( ) ) { foreach ( $ operation -> getOperation ( ) -> getParameters ( ) as $ parameter ) { if ( $ parameter instanceof Reference ) { $ parameter = $ this -> resolveParameter ( $ parameter ) ; } if ( $ parameter instanceof PathParameterSubSchema ) { $ statements [ ] = new Expr \ Assign ( $ urlVariable , new Expr \ FuncCall ( new Name ( 'str_replace' ) , [ new Arg ( new Scalar \ String_ ( '{' . $ parameter -> getName ( ) . '}' ) ) , new Arg ( new Expr \ FuncCall ( new Name ( 'urlencode' ) , [ new Arg ( new Expr \ Variable ( Inflector :: camelize ( $ parameter -> getName ( ) ) ) ) , ] ) ) , new Arg ( $ urlVariable ) ] ) ) ; } } } $ statements [ ] = new Expr \ Assign ( $ urlVariable , new Expr \ BinaryOp \ Concat ( $ urlVariable , new Expr \ BinaryOp \ Concat ( new Scalar \ String_ ( '?' ) , new Expr \ MethodCall ( $ queryParamVariable , 'buildQueryString' , [ new Arg ( new Expr \ Variable ( 'parameters' ) ) ] ) ) ) ) ; return [ $ statements , $ urlVariable ] ; }
3257	public function scopeWhereSKU ( $ query , $ sku ) { return $ query -> join ( config ( 'shop.item_table' ) , config ( 'shop.item_table' ) . '.order_id' , '=' , $ this -> table . '.id' ) -> where ( config ( 'shop.item_table' ) . '.sku' , $ sku ) ; }
2419	protected function addTemplatesToArchive ( ZipWriter $ objArchive , $ strFolder ) { $ strFolder = preg_replace ( '@^templates/@' , '' , $ strFolder ) ; if ( $ strFolder == '' ) { $ strFolder = 'templates' ; } else { $ strFolder = 'templates/' . $ strFolder ; } if ( Validator :: isInsecurePath ( $ strFolder ) ) { throw new \ RuntimeException ( 'Insecure path ' . $ strFolder ) ; } if ( ! is_dir ( $ this -> strRootDir . '/' . $ strFolder ) ) { return ; } foreach ( scan ( $ this -> strRootDir . '/' . $ strFolder ) as $ strFile ) { if ( preg_match ( '/\.(html5|sql)$/' , $ strFile ) && strncmp ( $ strFile , 'be_' , 3 ) !== 0 && strncmp ( $ strFile , 'nl_' , 3 ) !== 0 ) { $ objArchive -> addFile ( $ strFolder . '/' . $ strFile ) ; } } }
12555	public function showAction ( Tag $ tag ) { $ deleteForm = $ this -> createDeleteForm ( $ tag ) ; return array ( 'entity' => $ tag , 'delete_form' => $ deleteForm -> createView ( ) , ) ; }
7022	private function formatO ( & $ str ) { if ( strstr ( $ str , '%O' ) ) { $ o = $ this -> timezone -> offset ; $ os = $ o >= 0 ? '+' : '-' ; $ oh = sprintf ( '%02d' , abs ( intval ( $ o ) ) ) ; $ om = sprintf ( '%02d' , abs ( $ o - intval ( $ o ) ) * 60 ) ; $ ofs = "{$os}{$oh}{$om}" ; $ str = str_replace ( '%O' , $ ofs , $ str ) ; } }
11789	public function filesAction ( Request $ request , Application $ app ) { $ options = array ( "connector" => $ app [ "red_kite_cms.elfinder_files_connector" ] , ) ; return parent :: show ( $ options ) ; }
1891	private function hasRequireGranted ( string $ line ) : bool { if ( $ this -> isComment ( $ line ) ) { return false ; } return ( false !== stripos ( $ line , 'Allow from all' ) ) || ( false !== stripos ( $ line , 'Require all granted' ) ) ; }
3605	private function isCacheSupport ( JsonRequest $ jsonRequest ) { try { return $ jsonRequest -> getId ( ) && null !== $ this -> getMethod ( $ jsonRequest ) -> getCache ( ) && ! $ this -> isDebug ( ) && $ this -> getCache ( ) ; } catch ( \ Exception $ e ) { return false ; } }
9551	public function setOrderBy ( $ order_by , $ order = null ) { $ this -> order_by = $ order_by ; $ this -> order = $ order ; return $ this ; }
12239	public function innerXML ( ) { $ xml = $ this -> outerXML ( ) ; $ pos = 1 + strpos ( $ xml , '>' ) ; $ len = strrpos ( $ xml , '<' ) - $ pos ; return substr ( $ xml , $ pos , $ len ) ; }
8064	public function getFreeAndBusyWorkers ( ) { $ free = $ this -> getFreeWorkers ( ) ; return array ( 'free' => $ free , 'busy' => $ this -> workerPoolSize - $ free , 'total' => $ this -> workerPoolSize ) ; }
8308	public function assertArrayOfStrings ( $ config , $ key ) { if ( ! array_key_exists ( $ key , $ config ) ) { return $ this ; } if ( ! is_array ( $ config [ $ key ] ) ) { throw new ConfigurationException ( $ key . " section must be an array." ) ; } foreach ( $ config [ $ key ] as $ value ) { if ( ! is_string ( $ value ) ) { throw new ConfigurationException ( "Values in the `{$key}` must be strings" . gettype ( $ value ) . " found." ) ; } elseif ( $ value === "" ) { throw new ConfigurationException ( "Empty string not allowed in `{$key}` array." ) ; } } return $ this ; }
1707	private function hasCookie ( Response $ response ) : bool { $ cookies = $ response -> headers -> getCookies ( ) ; foreach ( $ cookies as $ cookie ) { if ( self :: COOKIE_NAME === $ cookie -> getName ( ) ) { return true ; } } return false ; }
8068	public function connect ( ) { $ port = $ this -> ssl ? $ this :: PORT_SSL : $ this :: PORT ; $ hostname = $ this -> domainController -> getHostname ( ) ; return $ this -> connection = ldap_connect ( $ hostname , $ port ) ; }
66	public function isSymlinkedDirectory ( $ directory ) { if ( ! is_dir ( $ directory ) ) { return false ; } $ resolved = $ this -> resolveSymlinkedDirectorySymlink ( $ directory ) ; return is_link ( $ resolved ) ; }
12455	public function hasToolbar ( ) { $ fileSkeleton = '/Resources/views/Editor/Toolbar/_toolbar_%s_buttons.html.twig' ; return file_exists ( $ this -> pluginDir . sprintf ( $ fileSkeleton , 'left' ) ) || file_exists ( $ this -> pluginDir . sprintf ( $ fileSkeleton , 'right' ) ) ; }
10749	protected function sendDeleted ( Response $ response , string $ type , array $ ids , array $ extra = [ ] ) : Response { return $ this -> sendVerb ( 'deleted' , $ response , $ type , $ ids , $ extra ) ; }
6244	protected function getPermissionGroupIndex ( $ groups ) { $ index = [ ] ; foreach ( $ groups as $ key => $ presence ) { $ permissions = $ presence -> permissions ( ) ; if ( ! $ permissions ) { continue ; } if ( ! is_array ( $ permissions ) ) { $ permissions = [ $ permissions ] ; } foreach ( $ permissions as $ permission ) { $ index [ $ permission ] = $ key ; } } return $ index ; }
9932	public function addRule ( Column \ Rule $ pRule ) { $ pRule -> setParent ( $ this ) ; $ this -> ruleset [ ] = $ pRule ; return $ this ; }
400	public static function process ( $ markdown , $ flavor = null ) { $ parser = static :: getParser ( $ flavor ) ; return $ parser -> parse ( $ markdown ) ; }
8675	public function merge ( $ list ) { return $ this -> createFrom ( array_merge ( $ this -> items , Arr :: from ( $ list ) ) ) ; }
4554	public function decoded ( JWTDecodedEvent $ event ) { $ payload = $ event -> getPayload ( ) ; $ payload = json_decode ( json_encode ( $ payload ) , true ) ; foreach ( $ this -> removed as $ property ) { if ( array_key_exists ( $ property , $ payload ) ) { $ event -> markAsInvalid ( ) ; break ; } } }
10410	public function createUrlsTempFile ( ) { $ hash = md5 ( microtime ( true ) ) ; $ links = array_merge ( $ this -> getUrls ( ) , $ this -> getUrlsByDocumentParameter ( ) ) ; $ urlsFile = "/tmp/urls_{$hash}.txt" ; $ urls = [ ] ; foreach ( $ links as $ url ) { $ separator = ( $ url [ 0 ] !== '/' ) ? '/' : '' ; $ urls [ ] = $ this -> baseUrl . $ separator . $ url ; } file_put_contents ( $ urlsFile , implode ( PHP_EOL , $ urls ) ) ; return $ urlsFile ; }
3495	public function add ( HttpProtocolVisitorInterface $ visitor , int $ priority = 0 ) : void { $ this -> visitors -> insert ( $ visitor , $ priority ) ; }
6996	public static function parseApplePriceMatrixAll ( $ file , $ directory = null ) { $ dom = new \ DOMDocument ( ) ; $ dom -> loadHTMLFile ( $ file ) ; $ xpath = new \ DOMXPath ( $ dom ) ; $ currencies = array ( ) ; $ currencyElements = $ xpath -> query ( '//table[1]//tr[2]//td[position() > 1]' ) ; foreach ( $ currencyElements as $ currencyElement ) { $ currency = trim ( $ currencyElement -> textContent ) ; if ( 'Euro' == $ currency ) { $ currency = 'EUR' ; } $ currencies [ ] = $ currency ; } if ( ! count ( $ currencies ) ) { throw new \ RuntimeException ( sprintf ( 'Not found currencies in ApplePriceMatrix in file "%s".' , $ file ) ) ; } $ currencies = array_flip ( $ currencies ) ; foreach ( $ currencies as $ currency => $ null ) { $ currencies [ $ currency ] = static :: parseApplePriceMatrix ( $ dom , $ currency , $ directory ) ; } return $ currencies ; }
12848	private function _getPage403 ( ) { var_dump ( debug_backtrace ( ) ) ; header ( "HTTP/1.0 403 Forbidden" ) ; if ( isset ( $ this -> _oRoutes -> e403 ) ) { $ this -> _oRoutes -> e403 -> route = '/' ; $ _SERVER [ 'REQUEST_URI' ] = '/' ; $ this -> _route ( $ this -> _oRoutes -> e403 , $ _SERVER [ 'REQUEST_URI' ] ) ; } exit ; }
6468	public function parseAcceptCharsetHeader ( HttpHeaders $ headers ) : array { $ headerValues = [ ] ; if ( ! $ headers -> tryGet ( 'Accept-Charset' , $ headerValues ) ) { return [ ] ; } $ parsedHeaderValues = [ ] ; $ numHeaderValues = count ( $ headerValues ) ; for ( $ i = 0 ; $ i < $ numHeaderValues ; $ i ++ ) { $ parsedHeaderParameters = $ this -> parseParameters ( $ headers , 'Accept-Charset' , $ i ) ; $ charset = $ parsedHeaderParameters -> getKeys ( ) [ 0 ] ; $ parsedHeaderValues [ ] = new AcceptCharsetHeaderValue ( $ charset , $ parsedHeaderParameters ) ; } return $ parsedHeaderValues ; }
5556	public function getUrlById ( $ id ) { foreach ( $ this -> frames as $ index => $ frame ) { if ( $ url = $ frame -> getUrlById ( $ id ) ) { if ( ! $ url -> gettarget ( ) ) { $ url -> setTarget ( $ this -> getPublicNameFromIndex ( $ index ) ) ; } return $ url ; } } return false ; }
257	public function init ( ) { parent :: init ( ) ; if ( is_array ( $ this -> theme ) ) { if ( ! isset ( $ this -> theme [ 'class' ] ) ) { $ this -> theme [ 'class' ] = 'yii\base\Theme' ; } $ this -> theme = Yii :: createObject ( $ this -> theme ) ; } elseif ( is_string ( $ this -> theme ) ) { $ this -> theme = Yii :: createObject ( $ this -> theme ) ; } }
8510	public function getTransportContent ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_GetTransportContentRequest ) ) { $ request = new FBAInboundServiceMWS_Model_GetTransportContentRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetTransportContent' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_GetTransportContentResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
11726	public function render ( $ filter = null ) : string { if ( empty ( $ this -> output ) ) { extract ( array_merge ( $ this -> vars , View :: $ global_vars ) , EXTR_REFS ) ; ob_start ( ) ; include ( $ this -> view_file ) ; $ this -> output = ob_get_clean ( ) ; } if ( $ filter !== null ) { $ this -> output = call_user_func ( $ filter , $ this -> output ) ; } return $ this -> output ; }
1932	public function parse ( ) { $ strBuffer = parent :: parse ( ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'parseBackendTemplate' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'parseBackendTemplate' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'parseBackendTemplate' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ strBuffer = $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ strBuffer , $ this -> strTemplate ) ; } } return $ strBuffer ; }
975	public function shopWebhooks ( ) { if ( ! $ this -> shopWebhooks ) { $ this -> shopWebhooks = $ this -> api -> rest ( 'GET' , '/admin/webhooks.json' , [ 'limit' => 250 , 'fields' => 'id,address' , ] ) -> body -> webhooks ; } return $ this -> shopWebhooks ; }
5070	protected function determineHeaderTags ( $ topLevel , $ depth ) { $ desired = range ( ( int ) $ topLevel , ( int ) $ topLevel + ( ( int ) $ depth - 1 ) ) ; $ allowed = [ 1 , 2 , 3 , 4 , 5 , 6 ] ; return array_map ( function ( $ val ) { return 'h' . $ val ; } , array_intersect ( $ desired , $ allowed ) ) ; }
25	public function getContents ( $ originUrl , $ fileUrl , $ progress = true , $ options = array ( ) ) { return $ this -> get ( $ originUrl , $ fileUrl , $ options , null , $ progress ) ; }
7002	public function action ( Callable $ action = null ) { if ( $ action ) $ this -> action = $ action ; return $ this -> action ; }
7290	static public function isValidMode ( $ mode , $ throw = true ) { if ( in_array ( $ mode , static :: getModes ( ) , true ) ) { return true ; } if ( $ throw ) { throw new InvalidArgumentException ( 'Invalid adjustment mode.' ) ; } return false ; }
1346	public function isDeleteResource ( ) : bool { return $ this -> isMethod ( 'delete' ) && $ this -> getRoute ( ) -> isResource ( ) && $ this -> getRoute ( ) -> isNotRelationship ( ) ; }
1433	public static function dasherize ( $ value ) { if ( isset ( self :: $ dasherized [ $ value ] ) ) { return self :: $ dasherized [ $ value ] ; } return self :: $ dasherized [ $ value ] = str_replace ( '_' , '-' , self :: decamelize ( $ value ) ) ; }
10075	public static function controlCharacterOOXML2PHP ( $ value ) { self :: buildCharacterSets ( ) ; return str_replace ( array_keys ( self :: $ controlCharacters ) , array_values ( self :: $ controlCharacters ) , $ value ) ; }
10561	public function createController ( $ route , $ params ) { $ control = NULL ; $ route = ltrim ( $ route , '/' ) ; $ route = rtrim ( $ route , '/' ) ; $ vars = explode ( '/' , $ route ) ; if ( 1 === count ( $ vars ) && '' == $ vars [ 0 ] ) { $ control = $ this -> _buildControllerName ( $ this -> defaultController . 'Controller' ) ; $ aName = $ this -> _buildActionName ( $ control , $ this -> defaultAction ) ; } else if ( 1 === count ( $ vars ) ) { $ control = $ this -> _buildControllerName ( $ vars [ 0 ] . 'Controller' ) ; array_shift ( $ vars ) ; $ aName = $ this -> _buildActionName ( $ control , $ this -> defaultAction ) ; } else if ( 2 === count ( $ vars ) ) { $ control = $ this -> _buildControllerName ( $ vars [ 0 ] . 'Controller' ) ; array_shift ( $ vars ) ; $ aName = $ this -> _buildActionName ( $ control , $ vars [ 0 ] ) ; } else if ( 2 < count ( $ vars ) ) { $ control = $ this -> _buildControllerName ( $ vars [ 0 ] . 'Controller' ) ; array_shift ( $ vars ) ; $ aName = $ this -> _buildActionName ( $ control , $ vars [ 0 ] ) ; array_shift ( $ vars ) ; } else { $ control = $ this -> _buildControllerName ( $ this -> defaultController . 'Controller' ) ; $ aName = $ this -> defaultAction . 'Action' ; } $ action = new Action ( $ aName , $ params ) ; $ controller = new $ control ( $ this -> config ) ; $ controller -> setAction ( $ action ) ; $ controller -> setDispatcher ( $ this -> dispatcher ) ; $ controller -> addDefaultListeners ( ) ; return $ controller ; }
1961	public static function encodeEmail ( $ strEmail ) { if ( $ strEmail == '' ) { return '' ; } if ( strpos ( $ strEmail , '@' ) === false ) { return $ strEmail ; } $ arrChunks = explode ( '@' , $ strEmail ) ; $ strHost = static :: encode ( array_pop ( $ arrChunks ) ) ; if ( $ strHost == '' ) { return '' ; } return implode ( '@' , $ arrChunks ) . '@' . $ strHost ; }
9133	public function route ( string $ name , Request $ request ) { $ parts = \ explode ( '/' , $ request -> getOrigin ( ) ) ; $ found = false ; for ( $ i = 0 ; $ i < count ( $ parts ) ; $ i ++ ) { if ( $ parts [ $ i ] === $ name && isset ( $ parts [ $ i + 1 ] ) ) { $ action = $ parts [ $ i + 1 ] ; if ( strpos ( $ action , "?" ) ) { $ action = strstr ( $ action , "?" , true ) ; } $ request -> setAction ( $ action ) ; $ found = true ; } } if ( ! $ found ) { $ request -> setAction ( "index" ) ; } $ controller = $ this -> getRoute ( $ name ) ; $ request -> setController ( $ controller -> getControllerSimpleName ( ) ) ; return $ controller ; }
8331	public function constructPdoDsn ( array $ params ) { if ( PlatformHelper :: isWindows ( ) ) { return $ this -> constructPdoDsnWindows ( $ params ) ; } return $ this -> constructPdoDsnUnix ( $ params ) ; }
1300	private function getLocaleForCacheKey ( string $ locale = null ) : string { if ( $ locale ) { return $ locale ; } return $ this -> getEnvironment ( ) -> getDefaultLocale ( ) -> getCode ( ) ; }
10243	public function isImplemented ( $ pFunction ) { $ pFunction = strtoupper ( $ pFunction ) ; $ notImplemented = ! isset ( self :: $ phpSpreadsheetFunctions [ $ pFunction ] ) || ( is_array ( self :: $ phpSpreadsheetFunctions [ $ pFunction ] [ 'functionCall' ] ) && self :: $ phpSpreadsheetFunctions [ $ pFunction ] [ 'functionCall' ] [ 1 ] === 'DUMMY' ) ; return ! $ notImplemented ; }
9086	public function getName ( ) { if ( 0 === count ( $ this -> queue ) ) { return false ; } foreach ( $ this -> queue as $ detector ) { $ name = $ detector -> getName ( ) ; if ( empty ( $ name ) && $ name !== '0' ) { continue ; } $ this -> lastStrategyFound = $ detector ; return $ name ; } return false ; }
10338	function toXML ( ) { $ xml = new SimpleXMLElement ( "<?xml version=\"1.0\"?><property></property>" ) ; $ xml -> addChild ( "key" , $ this -> key ) ; $ xml -> addChild ( "value" , $ this -> value ) ; return $ xml ; }
2291	public function onKernelTerminate ( PostResponseEvent $ event ) : void { if ( ! $ this -> framework -> isInitialized ( ) ) { return ; } $ request = $ event -> getRequest ( ) ; if ( ! $ request -> isMethod ( Request :: METHOD_GET ) ) { return ; } if ( preg_match ( '~(?:^|/)' . preg_quote ( $ this -> fragmentPath , '~' ) . '/~' , $ request -> getPathInfo ( ) ) ) { return ; } $ frontend = $ this -> framework -> getAdapter ( Frontend :: class ) ; $ frontend -> indexPageIfApplicable ( $ event -> getResponse ( ) ) ; }
3331	public function fromResource ( $ fp ) { $ tmpfile = tempnam ( sys_get_temp_dir ( ) , 'ucr' ) ; $ temp = fopen ( $ tmpfile , 'w' ) ; while ( ! feof ( $ fp ) ) { fwrite ( $ temp , fread ( $ fp , 8192 ) ) ; } fclose ( $ temp ) ; fclose ( $ fp ) ; return $ this -> fromPath ( $ tmpfile ) ; }
9066	public function persist ( MessageInterface $ message ) { if ( $ message -> getMessageId ( ) > 0 ) { $ this -> update ( $ message , null , null , new MessageHydrator ) ; } else { $ this -> insert ( $ message , null , new MessageHydrator ) ; } return $ message ; }
8083	public function & getFormErrors ( $ channel = '' ) { $ channel = $ this -> namespaceChannel ( $ channel ) ; if ( ! isset ( $ this -> console [ 'form' ] [ $ channel ] ) ) { $ this -> console [ 'form' ] [ $ channel ] = array ( ) ; } return $ this -> console [ 'form' ] [ $ channel ] ; }
2313	public function executeResize ( ) { $ image = $ this -> prepareImage ( ) ; $ resizeConfig = $ this -> prepareResizeConfig ( ) ; if ( ! System :: getContainer ( ) -> getParameter ( 'contao.image.bypass_cache' ) && $ this -> getTargetPath ( ) && ! $ this -> getForceOverride ( ) && file_exists ( $ this -> strRootDir . '/' . $ this -> getTargetPath ( ) ) && $ this -> fileObj -> mtime <= filemtime ( $ this -> strRootDir . '/' . $ this -> getTargetPath ( ) ) ) { if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'executeResize' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'executeResize' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'executeResize' ] as $ callback ) { $ return = System :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ this ) ; if ( \ is_string ( $ return ) ) { $ this -> resizedPath = System :: urlEncode ( $ return ) ; return $ this ; } } } $ this -> resizedPath = System :: urlEncode ( $ this -> getTargetPath ( ) ) ; return $ this ; } $ image = System :: getContainer ( ) -> get ( 'contao.image.resizer' ) -> resize ( $ image , $ resizeConfig , ( new ResizeOptions ( ) ) -> setImagineOptions ( System :: getContainer ( ) -> getParameter ( 'contao.image.imagine_options' ) ) -> setTargetPath ( $ this -> targetPath ? $ this -> strRootDir . '/' . $ this -> targetPath : null ) -> setBypassCache ( System :: getContainer ( ) -> getParameter ( 'contao.image.bypass_cache' ) ) ) ; $ this -> resizedPath = $ image -> getUrl ( $ this -> strRootDir ) ; return $ this ; }
5701	protected function createFieldList ( $ buttons ) { $ actions = FieldList :: create ( ) ; foreach ( $ buttons as $ buttonType => $ bool ) { if ( ! $ bool || ! $ buttonType ) { continue ; } if ( substr ( $ buttonType , 0 , 6 ) == "Group_" ) { $ group = $ this -> createButtonGroup ( substr ( $ buttonType , 6 ) ) ; if ( $ group -> children -> exists ( ) ) { $ actions -> push ( $ group ) ; } } elseif ( $ b = $ this -> instantiateButton ( $ buttonType ) ) { $ actions -> push ( $ b ) ; } } return $ actions ; }
4939	public function setAllowedTypes ( $ types ) { if ( is_array ( $ types ) ) { $ types = implode ( ',' , $ types ) ; } return $ this -> setAttribute ( 'data-allowedtypes' , $ types ) ; }
1288	private function buildContentTypeCollection ( array $ data ) { $ items = \ array_merge ( $ data [ 'items' ] , $ data [ 'includes' ] [ 'Entry' ] ?? [ ] ) ; $ ids = \ array_map ( function ( array $ item ) { return 'Entry' === $ item [ 'sys' ] [ 'type' ] ? $ item [ 'sys' ] [ 'contentType' ] [ 'sys' ] [ 'id' ] : null ; } , $ items ) ; $ ids = \ array_filter ( \ array_unique ( $ ids ) , function ( $ id ) : bool { return $ id && ! $ this -> resourcePool -> has ( 'ContentType' , $ id ) ; } ) ; if ( $ ids ) { $ query = ( new Query ( ) ) -> where ( 'sys.id[in]' , \ implode ( ',' , $ ids ) ) ; $ this -> client -> getContentTypes ( $ query ) ; } }
11083	public static function passwdGen ( $ length = 8 , $ flag = 'ALPHANUMERIC' ) { switch ( $ flag ) { case 'NUMERIC' : $ str = '0123456789' ; break ; case 'ALPHA' : $ str = 'abcdefghijkmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' ; break ; case 'ALPHA_LOWER' : $ str = 'abcdefghijkmnopqrstuvwxyz' ; break ; default : $ str = 'abcdefghijkmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' ; break ; } for ( $ i = 0 , $ passwd = '' ; $ i < $ length ; $ i ++ ) { $ passwd .= substr ( $ str , mt_rand ( 0 , \ strlen ( $ str ) - 1 ) , 1 ) ; } return $ passwd ; }
9190	public function render ( array $ classes = [ ] , $ autoEscape = null ) { $ divOpen = '<div class="' . $ this -> divClass . '">' ; $ divClose = '</div>' ; $ hasMessages = false ; foreach ( $ this -> classes as $ namespace => $ namespaceClasses ) { $ namespaceClasses = ArrayUtils :: merge ( $ namespaceClasses , $ classes ) ; if ( $ this -> getFlashMessengerHelper ( ) -> getPluginFlashMessenger ( ) -> hasCurrentMessages ( $ namespace ) ) { $ hasMessages = true ; $ divOpen .= $ this -> getFlashMessengerHelper ( ) -> renderCurrent ( $ namespace , $ namespaceClasses , $ autoEscape ) ; $ this -> getFlashMessengerHelper ( ) -> getPluginFlashMessenger ( ) -> clearCurrentMessagesFromNamespace ( $ namespace ) ; } elseif ( $ this -> getFlashMessengerHelper ( ) -> getPluginFlashMessenger ( ) -> hasMessages ( $ namespace ) ) { $ hasMessages = true ; $ divOpen .= $ this -> getFlashMessengerHelper ( ) -> render ( $ namespace , $ namespaceClasses , $ autoEscape ) ; } } return $ hasMessages ? $ divOpen . $ divClose : '' ; }
11524	public function parseBotUA ( $ botName ) { $ dom = $ this -> getDom ( 'https://udger.com/resources/ua-list/bot-detail?bot=' . $ botName ) ; if ( false === $ dom ) { echo "Can not parse DOM" . PHP_EOL ; return false ; } $ this -> currentBotName = $ botName ; $ crawlerBot = new Crawler ( ) ; $ crawlerBot -> addContent ( $ dom ) ; $ crawlerBot -> filter ( 'body #container table tr td > a' ) -> each ( function ( $ el , $ i ) { if ( strpos ( $ el -> attr ( 'href' ) , '/resources/online-parser' ) !== false ) { $ botUA = $ el -> text ( ) ; $ this -> addBotUA ( $ botUA ) ; } } ) ; return true ; }
4399	protected function saveRepayData ( \ Omnipay \ Common \ Message \ ResponseInterface $ response , $ customerId ) { $ data = [ ] ; if ( method_exists ( $ response , 'getCardReference' ) ) { $ data [ 'token' ] = $ response -> getCardReference ( ) ; } if ( method_exists ( $ response , 'getExpiryMonth' ) ) { $ data [ 'month' ] = $ response -> getExpiryMonth ( ) ; } if ( method_exists ( $ response , 'getExpiryYear' ) ) { $ data [ 'year' ] = $ response -> getExpiryYear ( ) ; } if ( ! empty ( $ data ) ) { $ this -> setCustomerData ( $ customerId , 'repay' , $ data ) ; } }
11225	private static function getErrorCallback ( ) { $ errorCallback = self :: $ errorCallback ; self :: $ errorCallback = false ; if ( ! $ errorCallback ) { return false ; } if ( ! is_object ( $ errorCallback ) ) { return self :: invokeObject ( $ errorCallback ) ; } return call_user_func ( $ errorCallback ) ; }
9918	public function getTableName ( Model $ model , ModelConfig $ config = null ) { if ( empty ( $ this -> models ) ) { throw new \ LogicException ( 'AujaConfigurator not configured yet! Call configure first.' ) ; } if ( ! isset ( $ this -> configs [ $ model -> getName ( ) ] ) ) { throw new \ LogicException ( sprintf ( 'AujaConfigurator not configured for model %s' , $ model -> getName ( ) ) ) ; } $ result = null ; if ( $ config != null && $ config -> getTableName ( ) != null ) { $ result = $ config -> getTableName ( ) ; } else { $ modelConfig = $ this -> configs [ $ model -> getName ( ) ] ; $ result = $ modelConfig -> getTableName ( ) ; } return $ result ; }
10293	protected static function validateTimeZone ( $ timeZone ) { if ( is_object ( $ timeZone ) && $ timeZone instanceof DateTimeZone ) { return $ timeZone ; } elseif ( is_string ( $ timeZone ) ) { return new DateTimeZone ( $ timeZone ) ; } throw new \ Exception ( 'Invalid timezone' ) ; }
2328	public function save ( ) { if ( $ this -> intIndex < 0 ) { $ this -> first ( ) ; } $ this -> arrModels [ $ this -> intIndex ] -> save ( ) ; return $ this ; }
12785	protected function generateIntersection ( $ combinationMask ) { $ combination = [ ] ; foreach ( str_split ( $ combinationMask ) as $ key => $ indicator ) { if ( $ indicator ) { $ combination [ ] = $ this -> arrays [ $ this -> arrayKeys [ $ key ] ] ; } } $ intersection = call_user_func_array ( 'array_intersect_assoc' , $ combination ) ; if ( count ( $ intersection ) >= $ this -> threshold ) { $ this -> intersections [ ] = $ intersection ; return ; } $ this -> noResultMasks [ ] = $ combinationMask ; }
10609	public function classifiedAnswerAction ( ) { $ request = $ this -> getRequest ( ) ; $ response = $ this -> getResponse ( ) ; if ( ! $ request -> isPost ( ) ) { $ response -> setStatusCode ( Response :: STATUS_CODE_500 ) ; return new JsonModel ( array ( 'status' => 'danger' , 'message' => 'Invalid method call' ) ) ; } $ userService = $ this -> getServiceLocator ( ) -> get ( 'user.service.user' ) ; $ data = array_merge_recursive ( $ this -> params ( ) -> fromPost ( ) , Json :: decode ( $ request -> getContent ( ) , Json :: TYPE_ARRAY ) ) ; try { $ response -> setStatusCode ( Response :: STATUS_CODE_200 ) ; $ userService -> classifiedAnswer ( $ data ) ; $ returnData = array ( 'status' => 'success' , 'message' => 'La tua risposta Ã¨ stata inviata!' ) ; } catch ( \ Exception $ e ) { $ response -> setStatusCode ( Response :: STATUS_CODE_500 ) ; $ returnData = @ unserialize ( $ e -> getMessage ( ) ) ; if ( ! is_array ( $ returnData ) ) { $ returnData = array ( 'status' => 'danger' , 'message' => $ e -> getMessage ( ) ) ; } } return new JsonModel ( $ returnData ) ; }
509	public function actionIndex ( $ command = null ) { if ( $ command !== null ) { $ result = Yii :: $ app -> createController ( $ command ) ; if ( $ result === false ) { $ name = $ this -> ansiFormat ( $ command , Console :: FG_YELLOW ) ; throw new Exception ( "No help for unknown command \"$name\"." ) ; } list ( $ controller , $ actionID ) = $ result ; $ actions = $ this -> getActions ( $ controller ) ; if ( $ actionID !== '' || count ( $ actions ) === 1 && $ actions [ 0 ] === $ controller -> defaultAction ) { $ this -> getSubCommandHelp ( $ controller , $ actionID ) ; } else { $ this -> getCommandHelp ( $ controller ) ; } } else { $ this -> getDefaultHelp ( ) ; } }
1610	private function _isRedirectRegex ( $ uri ) { if ( preg_match ( '/\/(.*)\/([g|m|i|x|X|s|u|U|A|J|D]+)/m' , $ uri ) === 0 ) { $ i = preg_match_all ( '/(?<!\\\\)\?(?![^(]*\))/' , $ uri , $ matches , PREG_OFFSET_CAPTURE ) ; while ( $ i -- ) { $ x = $ matches [ 0 ] [ $ i ] [ 1 ] ; $ uri = substr_replace ( $ uri , '\?' , $ x , 1 ) ; } $ i = preg_match_all ( '/(?<!\\\\)\/(?![^(]*\))/' , $ uri , $ matches , PREG_OFFSET_CAPTURE ) ; while ( $ i -- ) { $ x = $ matches [ 0 ] [ $ i ] [ 1 ] ; $ uri = substr_replace ( $ uri , '\/' , $ x , 1 ) ; } } if ( @ preg_match ( $ uri , null ) === false ) $ uri = '/^' . $ uri . '$/i' ; if ( @ preg_match ( $ uri , null ) !== false ) return $ uri ; return false ; }
9398	protected function selectBuilder ( ) { if ( PHP_OS === 'Darwin' ) { if ( exec ( 'which growlnotify' ) ) { return new GrowlNotifyBuilder ; } if ( exec ( 'which terminal-notifier' ) ) { return new TerminalNotifierBuilder ; } } if ( PHP_OS === 'Linux' ) { if ( exec ( 'which notify-send' ) ) { return new NotifySendBuilder ; } } if ( PHP_OS === 'WINNT' ) { if ( exec ( 'where growlnotify' ) ) { return new GrowlNotifyWindowsBuilder ; } } }
2296	public static function addToUrl ( $ strRequest , $ blnAddRef = true , $ arrUnset = array ( ) ) { $ arrUnset [ ] = 'nb' ; return parent :: addToUrl ( $ strRequest . ( ( $ strRequest != '' ) ? '&amp;' : '' ) . 'rt=' . REQUEST_TOKEN , $ blnAddRef , $ arrUnset ) ; }
3506	private function convertAlertToArray ( Alert $ alert ) : array { $ data = [ ] ; if ( $ alert -> getBodyLocalized ( ) -> getKey ( ) ) { $ data [ 'loc-key' ] = $ alert -> getBodyLocalized ( ) -> getKey ( ) ; $ data [ 'loc-args' ] = $ alert -> getBodyLocalized ( ) -> getArgs ( ) ; } else { $ data [ 'body' ] = $ alert -> getBody ( ) ; } if ( $ alert -> getTitleLocalized ( ) -> getKey ( ) ) { $ data [ 'title-loc-key' ] = $ alert -> getTitleLocalized ( ) -> getKey ( ) ; $ data [ 'title-loc-args' ] = $ alert -> getTitleLocalized ( ) -> getArgs ( ) ; } elseif ( $ alert -> getTitle ( ) ) { $ data [ 'title' ] = $ alert -> getTitle ( ) ; } if ( $ alert -> getActionLocalized ( ) -> getKey ( ) ) { $ data [ 'action-loc-key' ] = $ alert -> getActionLocalized ( ) -> getKey ( ) ; } if ( $ alert -> getLaunchImage ( ) ) { $ data [ 'launch-image' ] = $ alert -> getLaunchImage ( ) ; } return $ data ; }
8014	protected function prepareCommand ( $ filename , $ saveToFile , $ pdfIsTemp = false ) { $ resultIsTemp = false ; $ command = new Command ( ) ; $ command -> setPdfFile ( $ filename , $ pdfIsTemp ) ; if ( $ saveToFile === null ) { $ saveToFile = tempnam ( sys_get_temp_dir ( ) , 'pdfbox' ) ; $ resultIsTemp = true ; } $ command -> setTextFile ( $ saveToFile , $ resultIsTemp ) ; return $ command ; }
11962	private function parseConfig ( $ connection ) { $ this -> debug = false ; $ allowed_keys = array_keys ( get_object_vars ( $ this ) ) ; foreach ( $ connection as $ key => $ value ) { if ( $ key === 'host' && substr ( $ value , - 1 ) === '/' ) { $ value = substr ( $ value , 0 , - 1 ) ; } $ this -> setParam ( $ this -> camelCase ( $ key ) , $ value , $ allowed_keys ) ; } $ this -> transactionId = null ; $ this -> query = null ; }
5980	public function socialmedia ( ) { if ( ! $ this -> socialmedia instanceof SocialmediaController ) { $ this -> socialmedia = new SocialmediaController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> socialmedia -> setLogger ( $ this -> logger ) ; } return $ this -> socialmedia ; }
4150	protected function getBinaryFile ( $ filename ) { if ( ! file_exists ( $ filename ) ) { throw new FileNotFoundException ; } if ( ! is_readable ( $ filename ) ) { throw new FileNotReadableException ; } ob_start ( ) ; readfile ( $ filename ) ; $ binary = ob_get_contents ( ) ; ob_end_clean ( ) ; unset ( $ filename ) ; return $ binary ; }
9773	function readable ( ) : self { if ( ! $ this -> hasFlag ( 'directory' ) && ! $ this -> hasFlag ( 'file' ) ) throw new \ BadMethodCallException ( 'This assertion is not a file or directory one.' ) ; return $ this -> expect ( $ this -> target , isReadable ( ) ) ; }
1038	private function executeFields ( ObjectType $ parentType , $ source , $ path , $ fields ) { $ containsPromise = false ; $ finalResults = [ ] ; foreach ( $ fields as $ responseName => $ fieldNodes ) { $ fieldPath = $ path ; $ fieldPath [ ] = $ responseName ; $ result = $ this -> resolveField ( $ parentType , $ source , $ fieldNodes , $ fieldPath ) ; if ( $ result === self :: $ UNDEFINED ) { continue ; } if ( ! $ containsPromise && $ this -> getPromise ( $ result ) ) { $ containsPromise = true ; } $ finalResults [ $ responseName ] = $ result ; } if ( ! $ containsPromise ) { return self :: fixResultsIfEmptyArray ( $ finalResults ) ; } return $ this -> promiseForAssocArray ( $ finalResults ) ; }
2534	public function setSessionData ( array $ sessionData ) { if ( isset ( $ sessionData [ 'sessionId' ] , $ sessionData [ 'sequenceNumber' ] , $ sessionData [ 'securityToken' ] ) ) { $ this -> sessionData [ 'sessionId' ] = $ sessionData [ 'sessionId' ] ; $ this -> sessionData [ 'sequenceNumber' ] = $ sessionData [ 'sequenceNumber' ] ; $ this -> sessionData [ 'securityToken' ] = $ sessionData [ 'securityToken' ] ; $ this -> isAuthenticated = true ; } else { $ this -> isAuthenticated = false ; } return $ this -> isAuthenticated ; }
9350	public function transpose ( ) { $ out = new self ( $ this -> size -> cols , $ this -> size -> rows ) ; foreach ( $ this -> arr as $ row ) { $ out -> addCol ( $ row ) ; } return $ out ; }
9897	private function convertString ( $ string ) { $ string = substr ( $ string , 1 , - 1 ) ; if ( strlen ( $ string ) > 255 ) { throw new WriterException ( 'String is too long' ) ; } return pack ( 'C' , $ this -> ptg [ 'ptgStr' ] ) . StringHelper :: UTF8toBIFF8UnicodeShort ( $ string ) ; }
9659	public static function createReader ( $ readerType ) { if ( ! isset ( self :: $ readers [ $ readerType ] ) ) { throw new Reader \ Exception ( "No reader found for type $readerType" ) ; } $ className = self :: $ readers [ $ readerType ] ; $ reader = new $ className ( ) ; return $ reader ; }
9464	private function registerLogViewerPackage ( ) { $ this -> registerProvider ( LogViewerServiceProvider :: class ) ; $ config = $ this -> config ( ) ; $ config -> set ( 'log-viewer.route.enabled' , false ) ; $ config -> set ( 'log-viewer.menu.filter-route' , $ config -> get ( 'arcanesoft.foundation.log-viewer.filter-route' ) ) ; }
9639	public function setValue ( $ url ) { if ( $ url ) { $ url = $ this -> rebuildURL ( $ url ) ; } parent :: setValue ( $ url ) ; }
2080	public function purgeRegistrations ( ) { $ objMember = MemberModel :: findExpiredRegistrations ( ) ; if ( $ objMember === null ) { return ; } while ( $ objMember -> next ( ) ) { $ objMember -> delete ( ) ; } $ this -> log ( 'Purged the unactivated member registrations' , __METHOD__ , TL_CRON ) ; }
11927	public function actionRunOne ( ) { $ this -> out ( "Run Interface " . $ this -> dataInterface -> object -> name , Console :: UNDERLINE , Console :: FG_GREEN ) ; $ this -> hr ( ) ; $ this -> dataInterface -> run ( null , new ConsoleAction ( ) ) ; }
860	public function clearRange ( $ indexStart , $ indexEnd ) { for ( $ i = $ indexStart ; $ i <= $ indexEnd ; ++ $ i ) { $ this -> clearAt ( $ i ) ; } }
8992	public function getAttributeNames ( $ entity ) { if ( ! $ entity instanceof \ ElggEntity ) { return array ( ) ; } $ default = array ( 'guid' , 'type' , 'subtype' , 'owner_guid' , 'container_guid' , 'site_guid' , 'access_id' , 'time_created' , 'time_updated' , 'last_action' , 'enabled' , ) ; switch ( $ entity -> getType ( ) ) { case 'user' ; $ attributes = array ( 'name' , 'username' , 'email' , 'language' , 'banned' , 'admin' , 'password' , 'salt' ) ; break ; case 'group' : $ attributes = array ( 'name' , 'description' , ) ; break ; case 'object' : $ attributes = array ( 'title' , 'description' , ) ; break ; } return array_merge ( $ default , $ attributes ) ; }
12354	public function setFilePath ( string $ viewFilePath ) : void { if ( ! is_readable ( $ viewFilePath ) ) { throw new Exception ( "The View file {$viewFilePath} isn't readable." ) ; } $ this -> filePath = $ viewFilePath ; }
6263	public function nextkey ( ) { if ( $ this -> keys === null ) { return $ this -> firstkey ( ) ; } return empty ( $ this -> keys ) ? false : array_shift ( $ this -> keys ) ; }
1000	public function getDirective ( $ name ) { foreach ( $ this -> getDirectives ( ) as $ directive ) { if ( $ directive -> name === $ name ) { return $ directive ; } } return null ; }
7968	public function getFaxConsumptions ( $ params = null ) { $ consumptionList = json_decode ( self :: getClient ( ) -> getFaxConsumptions ( $ this -> service , $ this -> billingAccount , $ params ) ) ; $ consumptions = array ( ) ; foreach ( $ consumptionList as $ consumption ) { $ consumptions [ ] = new FaxConsumption ( $ consumption , $ this ) ; } return $ consumptions ; }
7026	public function checkRememberMeCookie ( ) { if ( ! $ this -> loggedIn ( ) && $ this -> Cookie -> read ( 'User.id' ) ) { return $ this -> Cookie -> read ( 'User.id' ) ; } return false ; }
1821	protected function getQuicknavPages ( $ pid , $ level = 1 , $ host = null ) { global $ objPage ; $ groups = array ( ) ; $ arrPages = array ( ) ; if ( FE_USER_LOGGED_IN ) { $ this -> import ( FrontendUser :: class , 'User' ) ; $ groups = $ this -> User -> groups ; } $ objSubpages = PageModel :: findPublishedRegularWithoutGuestsByPid ( $ pid ) ; if ( $ objSubpages === null ) { return array ( ) ; } ++ $ level ; foreach ( $ objSubpages as $ objSubpage ) { $ _groups = StringUtil :: deserialize ( $ objSubpage -> groups ) ; if ( $ host !== null ) { $ objSubpage -> domain = $ host ; } if ( ! $ objSubpage -> protected || $ this -> showProtected || ( \ is_array ( $ _groups ) && \ is_array ( $ groups ) && array_intersect ( $ _groups , $ groups ) ) ) { if ( ! $ objSubpage -> hide || $ this -> showHidden ) { $ arrPages [ ] = array ( 'level' => ( $ level - 2 ) , 'title' => StringUtil :: specialchars ( StringUtil :: stripInsertTags ( $ objSubpage -> pageTitle ? : $ objSubpage -> title ) ) , 'href' => $ objSubpage -> getFrontendUrl ( ) , 'link' => StringUtil :: stripInsertTags ( $ objSubpage -> title ) , 'active' => ( $ objPage -> id == $ objSubpage -> id || ( $ objSubpage -> type == 'forward' && $ objPage -> id == $ objSubpage -> jumpTo ) ) ) ; if ( ! $ this -> showLevel || $ this -> showLevel >= $ level || ( ! $ this -> hardLimit && ( $ objPage -> id == $ objSubpage -> id || \ in_array ( $ objPage -> id , $ this -> Database -> getChildRecords ( $ objSubpage -> id , 'tl_page' ) ) ) ) ) { $ subpages = $ this -> getQuicknavPages ( $ objSubpage -> id , $ level ) ; if ( \ is_array ( $ subpages ) ) { $ arrPages = array_merge ( $ arrPages , $ subpages ) ; } } } } } return $ arrPages ; }
5121	private function sendRequest ( RequestInterface $ request , int $ attempt = 0 ) : \ Psr \ Http \ Message \ StreamInterface { if ( $ attempt >= $ this -> options -> get ( 'max_attempt' ) ) { throw new \ Exception ( 'MAX attempt reached for ' . $ request -> getUri ( ) . ' with payload ' . ( string ) $ request ) ; } try { $ response = $ this -> httpClient -> send ( $ request , [ 'allow_redirects' => false , 'synchronous' => true , 'curl' => [ CURLOPT_FORBID_REUSE => true , CURLOPT_MAXCONNECTS => 30 , CURLOPT_SSL_VERIFYPEER => false , CURLOPT_SSL_VERIFYSTATUS => false , ] , ] ) ; if ( $ response -> getStatusCode ( ) === 200 ) { return $ response -> getBody ( ) ; } return $ this -> sendRequest ( $ request , $ attempt ++ ) ; } catch ( ClientException $ err ) { if ( $ err -> getResponse ( ) -> getStatusCode ( ) === 401 && $ request -> getRequestTarget ( ) !== self :: AUTHENTICATION ) { $ this -> renewAuthToken ( ) ; return $ this -> sendRequest ( $ request , $ attempt ++ ) ; } throw $ err ; } catch ( \ Throwable $ err ) { throw $ err ; } }
1506	protected function buildParams ( EncodingParametersInterface $ parameters ) { return array_filter ( [ QueryParametersParserInterface :: PARAM_FILTER => $ parameters -> getFilteringParameters ( ) , QueryParametersParserInterface :: PARAM_SORT => $ this -> buildSortParams ( ( array ) $ parameters -> getSortParameters ( ) ) ] ) ; }
3922	private function resizeImage ( $ fileName ) { list ( $ width , $ height , $ mode ) = $ this -> getResizeImages ( ) ; if ( $ this -> getShowImages ( ) && ( $ width || $ height || $ mode ) ) { if ( $ this -> imageFactory ) { $ image = $ this -> imageFactory -> create ( $ this -> rootDir . '/' . $ fileName , [ $ width , $ height , $ mode ] ) ; return $ image -> getUrl ( $ this -> rootDir ) ; } $ event = new ResizeImageEvent ( $ fileName , $ width , $ height , $ mode ) ; $ this -> dispatcher -> dispatch ( ContaoEvents :: IMAGE_RESIZE , $ event ) ; return $ event -> getResultImage ( ) ; } return $ fileName ; }
4253	public function processLogEntry ( $ method , $ args = array ( ) , $ meta = array ( ) ) { if ( $ method == 'alert' ) { list ( $ method , $ args ) = $ this -> methodAlert ( $ args , $ meta ) ; } elseif ( $ method == 'assert' ) { \ array_unshift ( $ args , false ) ; } elseif ( \ in_array ( $ method , array ( 'count' , 'time' ) ) ) { $ method = 'log' ; } elseif ( \ in_array ( $ method , array ( 'profileEnd' , 'table' ) ) ) { $ method = 'log' ; if ( \ is_array ( $ args [ 0 ] ) ) { $ method = 'table' ; $ args = array ( $ this -> methodTable ( $ args [ 0 ] , $ meta [ 'columns' ] ) ) ; } elseif ( $ meta [ 'caption' ] ) { \ array_unshift ( $ args , $ meta [ 'caption' ] ) ; } } elseif ( $ method == 'trace' ) { $ method = 'table' ; $ args = array ( $ this -> methodTable ( $ args [ 0 ] , array ( 'function' , 'file' , 'line' ) ) ) ; } elseif ( \ in_array ( $ method , array ( 'error' , 'warn' ) ) ) { if ( isset ( $ meta [ 'file' ] ) ) { $ args [ ] = $ meta [ 'file' ] . ': line ' . $ meta [ 'line' ] ; } } if ( ! \ in_array ( $ method , $ this -> consoleMethods ) ) { $ method = 'log' ; } foreach ( $ args as $ k => $ arg ) { $ args [ $ k ] = \ json_encode ( $ this -> dump ( $ arg ) ) ; } $ str = 'console.' . $ method . '(' . \ implode ( ',' , $ args ) . ');' . "\n" ; $ str = \ str_replace ( \ json_encode ( $ this -> debug -> abstracter -> UNDEFINED ) , 'undefined' , $ str ) ; return $ str ; }
5641	public function paintCaseStart ( $ test_name ) { if ( ! isset ( $ this -> size ) ) { $ this -> size = 1 ; } if ( count ( $ this -> test_stack ) == 0 ) { $ this -> paintHeader ( $ test_name ) ; } $ this -> test_stack [ ] = $ test_name ; }
11076	public function getHttpClient ( ) { if ( null === $ this -> httpClient ) { $ this -> httpClient = new HttpClient ( ) ; $ this -> httpClient -> setAdapter ( $ this -> getHttpAdapter ( ) ) ; } return $ this -> httpClient ; }
5078	public function getSearch ( $ aData = [ ] ) { $ oInput = Factory :: service ( 'Input' ) ; $ oHttpCodes = Factory :: service ( 'HttpCodes' ) ; $ oItemModel = Factory :: model ( static :: CONFIG_MODEL_NAME , static :: CONFIG_MODEL_PROVIDER ) ; $ sKeywords = $ oInput -> get ( 'search' ) ? : $ oInput -> get ( 'keywords' ) ; $ iPage = ( int ) $ oInput -> get ( 'page' ) ; if ( strlen ( $ sKeywords ) < static :: CONFIG_MIN_SEARCH_LENGTH ) { throw new ApiException ( 'Search term must be ' . static :: CONFIG_MIN_SEARCH_LENGTH . ' characters or longer.' , $ oHttpCodes :: STATUS_BAD_REQUEST ) ; } $ oResult = $ oItemModel -> search ( $ sKeywords , $ iPage , static :: CONFIG_MAX_ITEMS_PER_PAGE , $ aData ) ; $ oResponse = Factory :: factory ( 'ApiResponse' , 'nails/module-api' ) ; $ oResponse -> setData ( array_map ( [ $ this , 'formatObject' ] , $ oResult -> data ) ) ; return $ oResponse ; }
1655	public function handleConnectedSocks ( ConnectionInterface $ stream , $ host , $ port , Deferred $ deferred , $ uri ) { $ reader = new StreamReader ( ) ; $ stream -> on ( 'data' , array ( $ reader , 'write' ) ) ; $ stream -> on ( 'error' , $ onError = function ( Exception $ e ) use ( $ deferred , $ uri ) { $ deferred -> reject ( new RuntimeException ( 'Connection to ' . $ uri . ' failed because connection to proxy caused a stream error (EIO)' , defined ( 'SOCKET_EIO' ) ? SOCKET_EIO : 5 , $ e ) ) ; } ) ; $ stream -> on ( 'close' , $ onClose = function ( ) use ( $ deferred , $ uri ) { $ deferred -> reject ( new RuntimeException ( 'Connection to ' . $ uri . ' failed because connection to proxy was lost while waiting for response from proxy (ECONNRESET)' , defined ( 'SOCKET_ECONNRESET' ) ? SOCKET_ECONNRESET : 104 ) ) ; } ) ; if ( $ this -> protocolVersion === 5 ) { $ promise = $ this -> handleSocks5 ( $ stream , $ host , $ port , $ reader , $ uri ) ; } else { $ promise = $ this -> handleSocks4 ( $ stream , $ host , $ port , $ reader , $ uri ) ; } $ promise -> then ( function ( ) use ( $ deferred , $ stream , $ reader , $ onError , $ onClose ) { $ stream -> removeListener ( 'data' , array ( $ reader , 'write' ) ) ; $ stream -> removeListener ( 'error' , $ onError ) ; $ stream -> removeListener ( 'close' , $ onClose ) ; $ deferred -> resolve ( $ stream ) ; } , function ( Exception $ error ) use ( $ deferred , $ stream , $ uri ) { if ( ! $ error instanceof RuntimeException ) { $ error = new RuntimeException ( 'Connection to ' . $ uri . ' failed because proxy returned invalid response (EBADMSG)' , defined ( 'SOCKET_EBADMSG' ) ? SOCKET_EBADMSG : 71 , $ error ) ; } $ deferred -> reject ( $ error ) ; $ stream -> close ( ) ; } ) ; }
1138	public function destroyDescendants ( ) { if ( is_null ( $ this -> getRight ( ) ) || is_null ( $ this -> getLeft ( ) ) ) return ; $ self = $ this ; $ this -> getConnection ( ) -> transaction ( function ( ) use ( $ self ) { $ self -> reload ( ) ; $ lftCol = $ self -> getLeftColumnName ( ) ; $ rgtCol = $ self -> getRightColumnName ( ) ; $ lft = $ self -> getLeft ( ) ; $ rgt = $ self -> getRight ( ) ; $ self -> newNestedSetQuery ( ) -> where ( $ lftCol , '>=' , $ lft ) -> select ( $ self -> getKeyName ( ) ) -> lockForUpdate ( ) -> get ( ) ; $ self -> newNestedSetQuery ( ) -> where ( $ lftCol , '>' , $ lft ) -> where ( $ rgtCol , '<' , $ rgt ) -> delete ( ) ; $ diff = $ rgt - $ lft + 1 ; $ self -> newNestedSetQuery ( ) -> where ( $ lftCol , '>' , $ rgt ) -> decrement ( $ lftCol , $ diff ) ; $ self -> newNestedSetQuery ( ) -> where ( $ rgtCol , '>' , $ rgt ) -> decrement ( $ rgtCol , $ diff ) ; } ) ; }
6674	public function restart_when_add ( ) { $ state = isset ( $ _POST [ 'state' ] ) ? $ _POST [ 'state' ] : null ; $ nonce = isset ( $ _POST [ 'nonce' ] ) ? $ _POST [ 'nonce' ] : '' ; if ( ! wp_verify_nonce ( $ nonce , 'eliasis' ) && ! wp_verify_nonce ( $ nonce , 'customRatingGrifusAdmin' ) ) { die ( 'Busted!' ) ; } App :: setCurrentID ( 'EFG' ) ; $ slug = Module :: CustomRatingGrifus ( ) -> getOption ( 'slug' ) ; $ this -> model -> set_restart_when_add ( $ slug , $ state ) ; $ response = [ 'restart-when-add' => $ state ] ; echo json_encode ( $ response ) ; die ( ) ; }
1730	public function isMemberOf ( $ id ) { if ( ! is_numeric ( $ id ) ) { return false ; } $ groups = StringUtil :: deserialize ( $ this -> groups ) ; if ( empty ( $ groups ) || ! \ is_array ( $ groups ) ) { return false ; } if ( \ in_array ( $ id , $ groups ) ) { return true ; } return false ; }
10192	public static function parseDsn ( $ string = null ) { $ opts = null ; if ( ! empty ( $ string ) ) { $ dsn = ( object ) DsnParser :: parseUrl ( $ string ) -> toArray ( ) ; $ opts = [ 'driver' => $ dsn -> driver , 'host' => $ dsn -> host , 'database' => $ dsn -> dbname , 'username' => $ dsn -> user , 'password' => isset ( $ dsn -> pass ) ? $ dsn -> pass : null ] ; } return $ opts ; }
12121	public function getLastModified ( Request $ request ) { $ minModified = $ this -> getLastMinModifiedDate ( ) ; $ optionalLastModified = Option :: fromValue ( $ this -> cache -> fetch ( $ this -> getCacheKeyRequest ( sha1 ( $ request -> getUri ( ) ) , 'lastmodified' ) ) , false ) ; if ( $ optionalLastModified -> isEmpty ( ) ) { return $ minModified ; } return max ( $ minModified , new \ DateTime ( $ optionalLastModified -> get ( ) ) ) ; }
4493	public function setLocalizedText ( ? string $ key , ? array $ arguments = null ) : self { $ this -> setLocalizedKey ( $ key ) ; $ this -> setLocalizedArguments ( $ arguments ) ; return $ this ; }
4249	public function processLogEntry ( $ method , $ args = array ( ) , $ meta = array ( ) ) { $ value = null ; $ firePhpMeta = $ this -> getMeta ( $ method , $ meta ) ; if ( $ method == 'alert' ) { list ( $ method , $ args ) = $ this -> methodAlert ( $ args , $ meta ) ; $ value = $ args [ 0 ] ; } elseif ( \ in_array ( $ method , array ( 'group' , 'groupCollapsed' ) ) ) { $ firePhpMeta [ 'Label' ] = $ args [ 0 ] ; } elseif ( \ in_array ( $ method , array ( 'profileEnd' , 'table' ) ) ) { $ firePhpMeta [ 'Type' ] = \ is_array ( $ args [ 0 ] ) ? $ this -> firephpMethods [ 'table' ] : $ this -> firephpMethods [ 'log' ] ; $ value = $ this -> methodTable ( $ args [ 0 ] , $ meta [ 'columns' ] ) ; if ( $ meta [ 'caption' ] ) { $ firePhpMeta [ 'Label' ] = $ meta [ 'caption' ] ; } } elseif ( $ method == 'trace' ) { $ firePhpMeta [ 'Type' ] = $ this -> firephpMethods [ 'table' ] ; $ value = $ this -> methodTable ( $ args [ 0 ] , array ( 'function' , 'file' , 'line' ) ) ; $ firePhpMeta [ 'Label' ] = 'trace' ; } elseif ( \ count ( $ args ) ) { if ( \ count ( $ args ) == 1 ) { $ value = $ args [ 0 ] ; } else { $ firePhpMeta [ 'Label' ] = \ array_shift ( $ args ) ; $ value = \ count ( $ args ) > 1 ? $ args : $ args [ 0 ] ; } } $ value = $ this -> dump ( $ value ) ; if ( $ this -> messageIndex < self :: MESSAGE_LIMIT ) { $ this -> setFirephpHeader ( $ firePhpMeta , $ value ) ; } elseif ( $ this -> messageIndex === self :: MESSAGE_LIMIT ) { $ this -> setFirephpHeader ( array ( 'Type' => $ this -> firephpMethods [ 'warn' ] ) , 'FirePhp\'s limit of ' . \ number_format ( self :: MESSAGE_LIMIT ) . ' messages reached!' ) ; } return ; }
3898	public function handleMetaChange ( $ strMetaName , $ varNewValue ) { if ( $ strMetaName == 'colname' ) { if ( $ this -> get ( $ strMetaName ) != $ varNewValue ) { $ this -> renameColumn ( $ varNewValue ) ; } return $ this ; } return parent :: handleMetaChange ( $ strMetaName , $ varNewValue ) ; }
8034	private function buildAttributesFromLdap ( $ entry ) { $ this -> attributes [ 'dn' ] = $ entry [ 'dn' ] ; foreach ( $ entry as $ index => $ key ) { if ( array_key_exists ( $ index , config ( 'ldap.search_fields' ) ) ) { $ this -> attributes [ $ key ] = isset ( $ entry [ $ key ] [ 1 ] ) ? $ entry [ $ key ] : $ entry [ $ key ] [ 0 ] ; } } ; }
6345	public static function filterBy ( Iterator $ unfiltered , string $ className ) : Iterator { return self :: filter ( $ unfiltered , Predicates :: instance ( $ className ) ) ; }
833	private function findFunction ( Tokens $ tokens , $ name , $ startIndex , $ endIndex ) { $ function = $ tokens -> findSequence ( [ [ T_FUNCTION ] , [ T_STRING , $ name ] , '(' , ] , $ startIndex , $ endIndex , false ) ; if ( null === $ function ) { return null ; } $ function = array_keys ( $ function ) ; $ possibleModifiers = [ T_PUBLIC , T_PROTECTED , T_PRIVATE , T_STATIC , T_ABSTRACT , T_FINAL ] ; $ modifiers = [ ] ; $ prevBlock = $ tokens -> getPrevMeaningfulToken ( $ function [ 0 ] ) ; while ( null !== $ prevBlock && $ tokens [ $ prevBlock ] -> isGivenKind ( $ possibleModifiers ) ) { $ modifiers [ $ tokens [ $ prevBlock ] -> getId ( ) ] = $ prevBlock ; $ prevBlock = $ tokens -> getPrevMeaningfulToken ( $ prevBlock ) ; } if ( isset ( $ modifiers [ T_ABSTRACT ] ) ) { $ bodyStart = null ; $ funcEnd = $ tokens -> getNextTokenOfKind ( $ function [ 2 ] , [ ';' ] ) ; } else { $ bodyStart = $ tokens -> getNextTokenOfKind ( $ function [ 2 ] , [ '{' ] ) ; $ funcEnd = null !== $ bodyStart ? $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_CURLY_BRACE , $ bodyStart ) : null ; } return [ 'nameIndex' => $ function [ 1 ] , 'startIndex' => $ prevBlock + 1 , 'endIndex' => $ funcEnd , 'bodyIndex' => $ bodyStart , 'modifiers' => $ modifiers , ] ; }
11900	public function getIsMostRecent ( ) { return ! empty ( $ this -> dataInterface ) && $ this -> dataInterface -> lastDataInterfaceLog && $ this -> dataInterface -> lastDataInterfaceLog -> primaryKey === $ this -> primaryKey ; }
8927	public function fetch ( $ name ) { $ generator = false ; if ( array_key_exists ( $ name , $ this -> generators ) ) { $ generator = $ this -> generators [ $ name ] ; } return $ generator ; }
662	public function transaction ( callable $ callback , $ isolationLevel = null ) { $ transaction = $ this -> beginTransaction ( $ isolationLevel ) ; $ level = $ transaction -> level ; try { $ result = call_user_func ( $ callback , $ this ) ; if ( $ transaction -> isActive && $ transaction -> level === $ level ) { $ transaction -> commit ( ) ; } } catch ( \ Exception $ e ) { $ this -> rollbackTransactionOnLevel ( $ transaction , $ level ) ; throw $ e ; } catch ( \ Throwable $ e ) { $ this -> rollbackTransactionOnLevel ( $ transaction , $ level ) ; throw $ e ; } return $ result ; }
11171	public function getFilters ( $ columnDescriptions = [ ] , $ activeFieldName = false ) { $ filters = [ ] ; if ( count ( $ this -> filtersArray ) > 0 ) { foreach ( $ this -> filtersArray as $ key => $ value ) { if ( isset ( $ this -> filters [ $ key ] ) ) { $ activeFieldName = $ activeFieldName ? : $ this -> filtersArray [ 'orderBy' ] ; $ friendlyFieldName = isset ( $ columnDescriptions [ $ activeFieldName ] ) ? $ columnDescriptions [ $ activeFieldName ] : $ activeFieldName ; $ filters [ ] = sprintf ( $ this -> filters [ $ key ] , $ friendlyFieldName , $ value ) ; } } } return $ filters ; }
9087	public function attach ( ResolverInterface $ detector , $ priority = 1 ) { $ this -> queue -> insert ( $ detector , $ priority ) ; return $ this ; }
8894	protected function _initialize_schema ( ) { $ this -> set_database ( $ this -> _database_group ) ; $ this -> _fetch_table ( ) ; $ this -> _fetch_primary_key ( ) ; if ( $ this -> primary_key == null && $ this -> is_base_model_instance ( ) ) { return ; } $ this -> _fields = $ this -> get_fields ( ) ; $ this -> _guess_is_soft_deletable ( ) ; $ this -> _guess_is_blamable ( ) ; $ this -> _guess_is_timestampable ( ) ; }
8101	public function getRow ( $ arguments ) { $ sql = 'SELECT * FROM _table_ WHERE _arguments_ LIMIT 1' ; if ( ! $ stmt = $ this -> getStatement ( $ sql , $ arguments ) ) { return false ; } else { return $ stmt -> fetch ( ) ; } }
6925	private function getFindOneByCountryAndMethodAndWeightQuery ( ) { if ( null === $ this -> findOneByCountryAndMethodAndWeightQuery ) { $ qb = $ this -> getCollectionQueryBuilder ( 'o' ) ; $ qb -> join ( 'o.zone' , 'z' ) -> join ( 'o.method' , 'm' ) -> andWhere ( $ qb -> expr ( ) -> isMemberOf ( ':country' , 'z.countries' ) ) -> andWhere ( $ qb -> expr ( ) -> gte ( 'o.weight' , ':weight' ) ) -> andWhere ( $ qb -> expr ( ) -> eq ( 'o.method' , ':method' ) ) -> addOrderBy ( 'o.weight' , 'ASC' ) -> setMaxResults ( 1 ) ; $ this -> findOneByCountryAndMethodAndWeightQuery = $ qb -> getQuery ( ) ; } return $ this -> findOneByCountryAndMethodAndWeightQuery ; }
9169	public function setTimestampCreated ( $ postTime ) { if ( $ postTime instanceof DateTime ) { $ this -> timestampCreated = $ postTime ; } else { $ this -> timestampCreated = new DateTime ( $ postTime ) ; } return $ this ; }
9001	public function column_user ( AbstractLog $ item ) { $ user = $ item -> get_user ( ) ; if ( empty ( $ user ) ) { echo '-' ; } else { echo $ user -> display_name ; } }
12641	public function add ( $ key , $ value ) { try { $ this -> getRecursive ( $ key , $ this -> data ) ; } catch ( ElementNotFoundException $ e ) { $ this -> set ( $ key , $ value ) ; } }
7966	public function getProperties ( $ billingAccount ) { if ( ! $ billingAccount ) throw new BadMethodCallException ( 'Parameter $billingAccount is missing.' ) ; try { $ r = $ this -> get ( 'telephony/' . $ billingAccount ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new TelephonyException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
12002	static public function generate ( $ length = 16 , $ algorithm = 'sha256' ) { if ( ! in_array ( $ algorithm , self :: $ allowedAlgorithm ) ) { throw new Exception ( "Hash algorithm $algorithm doesn't exists!" ) ; } $ salt = hash ( $ algorithm , time ( ) ) ; return substr ( hash ( $ algorithm , ( mt_rand ( self :: RAND_MIN , self :: RAND_MAX ) % $ length ) . $ salt . mt_rand ( self :: RAND_MIN , self :: RAND_MAX ) ) , self :: CUT_LEN , $ length ) ; }
5215	private function getAnnotatedBinding ( \ ReflectionClass $ class ) { $ annotations = annotationsOf ( $ class ) ; if ( $ class -> isInterface ( ) && $ annotations -> contain ( 'ImplementedBy' ) ) { return $ this -> bind ( $ class -> getName ( ) ) -> to ( $ this -> findImplementation ( $ annotations , $ class -> getName ( ) ) ) ; } elseif ( $ annotations -> contain ( 'ProvidedBy' ) ) { return $ this -> bind ( $ class -> getName ( ) ) -> toProviderClass ( $ annotations -> firstNamed ( 'ProvidedBy' ) -> getProviderClass ( ) ) ; } return $ this -> getImplicitBinding ( $ class ) ; }
9161	private function addParsedHeader ( $ line ) { if ( strpos ( $ line , ':' ) === false ) { $ this -> responseCode = HttpStatus :: parseStatus ( $ line ) -> getCode ( ) ; } else { $ line = trim ( $ line ) ; list ( $ headerName , $ headerValue ) = explode ( ':' , $ line , 2 ) ; $ this -> headers [ $ headerName ] = trim ( $ headerValue ) ; } }
9148	public function markAsRead ( $ uid ) { if ( ! $ object = $ this -> model -> find ( $ uid ) ) { abort ( 404 ) ; } $ this -> authorize ( 'update' , $ object ) ; $ object -> markAsRead ( ) ; \ Cache :: tags ( 'response' ) -> flush ( ) ; return $ this -> successJsonResponse ( ) ; }
10926	private function renderCell ( $ columnNumber , $ value , $ filler , $ style = '' ) { $ output = [ ] ; $ width = $ this -> getWidth ( $ columnNumber ) ; $ output [ ] = $ filler ; while ( $ this -> length ( $ value ) < $ width ) { $ value .= $ filler ; } $ output [ ] = Style :: applyStyle ( $ value , $ style ) ; $ output [ ] = $ filler ; return implode ( '' , $ output ) ; }
2584	public function analyze ( SendResult $ response ) { $ analyzeResponse = new Result ( $ response ) ; $ domXpath = $ this -> makeDomXpath ( $ response -> responseXml ) ; $ qPassErrors = "//m:passengerErrorInEnhancedData//m:errorDetails/m:errorCode" ; $ qPassErrorCat = "//m:passengerErrorInEnhancedData//m:errorDetails/m:errorCategory" ; $ qPassErrorMsg = "//m:passengerErrorInEnhancedData//m:freeText" ; $ errorCodeNodeList = $ domXpath -> query ( $ qPassErrors ) ; if ( $ errorCodeNodeList -> length > 0 ) { $ analyzeResponse -> status = Result :: STATUS_ERROR ; $ errorCatNode = $ domXpath -> query ( $ qPassErrorCat ) -> item ( 0 ) ; if ( $ errorCatNode instanceof \ DOMNode ) { $ analyzeResponse -> status = $ this -> makeStatusFromErrorQualifier ( $ errorCatNode -> nodeValue ) ; } $ code = $ errorCodeNodeList -> item ( 0 ) -> nodeValue ; $ errorTextNodeList = $ domXpath -> query ( $ qPassErrorMsg ) ; $ message = $ this -> makeMessageFromMessagesNodeList ( $ errorTextNodeList ) ; $ analyzeResponse -> messages [ ] = new Result \ NotOk ( $ code , trim ( $ message ) , 'passenger' ) ; } if ( empty ( $ analyzeResponse -> messages ) && $ analyzeResponse -> status === Result :: STATUS_OK ) { $ analyzeResponse = $ this -> analyzeSimpleResponseErrorCodeAndMessage ( $ response ) ; } return $ analyzeResponse ; }
9567	public function config ( $ configurator ) { if ( $ this -> booted ) { $ this -> invokeConfigurator ( $ configurator ) ; } else { $ this -> configurators -> push ( $ configurator ) ; } }
6910	public function addExtraCopy ( Recipient $ copy ) { if ( ! $ this -> extraCopies -> contains ( $ copy ) ) { $ this -> extraCopies -> add ( $ copy ) ; } return $ this ; }
10955	protected function redirect ( Response $ response , int $ code , string $ url ) : Response { return $ response -> withStatus ( $ code ) -> withHeader ( 'Location' , $ url ) ; }
12054	public function remove ( $ name ) { if ( isset ( $ this -> container [ $ name ] ) ) { unset ( $ this -> container [ $ name ] ) ; } return $ this ; }
7059	public function addClass ( $ class ) { $ classes = $ this -> getClasses ( ) ; if ( ! in_array ( $ class , $ classes ) ) { $ classes [ ] = $ class ; } $ this -> setClasses ( $ classes ) ; return $ this ; }
11933	public function render ( $ view , array $ parameters = array ( ) , Response $ response = null ) { $ parameters [ 'base_template' ] = isset ( $ parameters [ 'base_template' ] ) ? $ parameters [ 'base_template' ] : $ this -> getBaseTemplate ( ) ; $ parameters [ 'admin_pool' ] = $ this -> get ( 'sonata.admin.pool' ) ; return parent :: render ( $ view , $ parameters ) ; }
8580	public function setPromotionAdjustmentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'PromotionAdjustmentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
1095	public function children ( $ node ) { $ query = $ this -> node -> newQuery ( ) ; $ query -> where ( $ this -> node -> getQualifiedParentColumnName ( ) , '=' , $ node -> getKey ( ) ) ; foreach ( $ this -> scopedAttributes ( $ node ) as $ fld => $ value ) $ query -> where ( $ this -> qualify ( $ fld ) , '=' , $ value ) ; $ query -> orderBy ( $ this -> node -> getQualifiedLeftColumnName ( ) ) ; $ query -> orderBy ( $ this -> node -> getQualifiedRightColumnName ( ) ) ; $ query -> orderBy ( $ this -> node -> getQualifiedKeyName ( ) ) ; return $ query -> get ( ) ; }
1521	public function processes ( StoreInterface $ store , FetchProcesses $ request ) { $ result = $ store -> queryRecords ( $ request -> getProcessType ( ) , $ request -> getEncodingParameters ( ) ) ; return $ this -> reply ( ) -> content ( $ result ) ; }
12498	public static function insertOne ( $ document , $ connection ) { $ connection -> query = self :: singleDocument ( $ document ) ; return self :: insert ( $ connection ) ; }
5176	public function add ( string $ key , $ value ) : self { if ( ! array_key_exists ( $ key , $ this -> props ) ) { return $ this -> addNew ( $ key , $ value ) ; } if ( is_array ( $ this -> props [ $ key ] ) ) { return $ this -> addArray ( $ key , $ value ) ; } return $ this -> appendToArray ( $ key , $ value ) ; }
5355	protected function getClassFromOperation ( $ name , Operation $ operation = null , $ reference , $ registry ) { if ( $ operation === null ) { return ; } if ( $ operation -> getParameters ( ) ) { foreach ( $ operation -> getParameters ( ) as $ key => $ parameter ) { if ( $ parameter instanceof BodyParameter ) { $ this -> chainGuesser -> guessClass ( $ parameter -> getSchema ( ) , $ name . 'Body' , $ reference . '/parameters/' . $ key , $ registry ) ; } } } if ( $ operation -> getResponses ( ) ) { foreach ( $ operation -> getResponses ( ) as $ status => $ response ) { if ( $ response instanceof Response ) { $ this -> chainGuesser -> guessClass ( $ response -> getSchema ( ) , $ name . 'Response' . $ status , $ reference . '/responses/' . $ status , $ registry ) ; } } } }
10481	public function getDocuments ( ) { return new SyncStorageImportIterator ( [ 'sync_storage' => $ this -> getSyncStorage ( ) , 'shop_id' => $ this -> getShopId ( ) , 'document_type' => $ this -> getDocumentType ( ) , ] , $ this -> getElasticsearchManager ( ) -> getRepository ( $ this -> getDocumentClass ( ) ) , $ this -> getDoctrineManager ( ) , $ this -> getEntityClass ( ) ) ; }
8578	public function setItemFeeAdjustmentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ItemFeeAdjustmentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
541	protected function serializeModelErrors ( $ model ) { $ this -> response -> setStatusCode ( 422 , 'Data Validation Failed.' ) ; $ result = [ ] ; foreach ( $ model -> getFirstErrors ( ) as $ name => $ message ) { $ result [ ] = [ 'field' => $ name , 'message' => $ message , ] ; } return $ result ; }
10301	private function writeLayout ( XMLWriter $ objWriter , Layout $ layout = null ) { $ objWriter -> startElement ( 'c:layout' ) ; if ( $ layout !== null ) { $ objWriter -> startElement ( 'c:manualLayout' ) ; $ layoutTarget = $ layout -> getLayoutTarget ( ) ; if ( $ layoutTarget !== null ) { $ objWriter -> startElement ( 'c:layoutTarget' ) ; $ objWriter -> writeAttribute ( 'val' , $ layoutTarget ) ; $ objWriter -> endElement ( ) ; } $ xMode = $ layout -> getXMode ( ) ; if ( $ xMode !== null ) { $ objWriter -> startElement ( 'c:xMode' ) ; $ objWriter -> writeAttribute ( 'val' , $ xMode ) ; $ objWriter -> endElement ( ) ; } $ yMode = $ layout -> getYMode ( ) ; if ( $ yMode !== null ) { $ objWriter -> startElement ( 'c:yMode' ) ; $ objWriter -> writeAttribute ( 'val' , $ yMode ) ; $ objWriter -> endElement ( ) ; } $ x = $ layout -> getXPosition ( ) ; if ( $ x !== null ) { $ objWriter -> startElement ( 'c:x' ) ; $ objWriter -> writeAttribute ( 'val' , $ x ) ; $ objWriter -> endElement ( ) ; } $ y = $ layout -> getYPosition ( ) ; if ( $ y !== null ) { $ objWriter -> startElement ( 'c:y' ) ; $ objWriter -> writeAttribute ( 'val' , $ y ) ; $ objWriter -> endElement ( ) ; } $ w = $ layout -> getWidth ( ) ; if ( $ w !== null ) { $ objWriter -> startElement ( 'c:w' ) ; $ objWriter -> writeAttribute ( 'val' , $ w ) ; $ objWriter -> endElement ( ) ; } $ h = $ layout -> getHeight ( ) ; if ( $ h !== null ) { $ objWriter -> startElement ( 'c:h' ) ; $ objWriter -> writeAttribute ( 'val' , $ h ) ; $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; }
1389	protected function resourceExists ( string $ type , string $ id , string $ path = '/data' ) : void { $ this -> errors -> add ( $ this -> translator -> resourceExists ( $ type , $ id , $ path ) ) ; }
466	public function buildInCondition ( $ operator , $ operands , & $ params ) { array_unshift ( $ operands , $ operator ) ; return $ this -> buildCondition ( $ operands , $ params ) ; }
5907	public function retrieveSetting ( $ key , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/settings/' . $ key . '' , $ parameters , $ cachePolicy ) ; return $ result ; }
4880	public function getResource ( ) { if ( $ this -> file instanceof \ Doctrine \ MongoDB \ GridFSFile ) { return $ this -> file -> getMongoGridFSFile ( ) -> getResource ( ) ; } return null ; }
10380	protected static function is_modified_hash ( $ url , $ path ) { if ( self :: is_external_url ( $ url ) ) { if ( sha1_file ( $ url ) !== sha1_file ( $ path ) ) { self :: $ changes = true ; return self :: $ changes ; } } return false ; }
9597	protected function flashMessages ( $ messages ) { $ flashBag = $ this -> getSession ( ) -> getFlashBag ( ) ; foreach ( ( array ) $ messages as $ message ) { $ flashBag -> add ( '_messages' , $ message ) ; } }
4208	private function isObjExcluded ( $ obj ) { if ( \ in_array ( \ get_class ( $ obj ) , $ this -> abstracter -> getCfg ( 'objectsExclude' ) ) ) { return true ; } foreach ( $ this -> abstracter -> getCfg ( 'objectsExclude' ) as $ exclude ) { if ( \ is_subclass_of ( $ obj , $ exclude ) ) { return true ; } } return false ; }
7336	private function getStockSubjectMappings ( ) { return [ [ 'fieldName' => 'stockMode' , 'columnName' => 'stock_mode' , 'type' => 'string' , 'length' => 16 , 'nullable' => false , 'default' => Stock \ StockSubjectModes :: MODE_AUTO , ] , [ 'fieldName' => 'stockState' , 'columnName' => 'stock_state' , 'type' => 'string' , 'length' => 16 , 'nullable' => false , 'default' => Stock \ StockSubjectStates :: STATE_OUT_OF_STOCK , ] , [ 'fieldName' => 'stockFloor' , 'columnName' => 'stock_floor' , 'type' => 'decimal' , 'precision' => 10 , 'scale' => 3 , 'nullable' => true , 'default' => 0 , ] , [ 'fieldName' => 'inStock' , 'columnName' => 'in_stock' , 'type' => 'decimal' , 'precision' => 10 , 'scale' => 3 , 'nullable' => false , 'default' => 0 , ] , [ 'fieldName' => 'availableStock' , 'columnName' => 'available_stock' , 'type' => 'decimal' , 'precision' => 10 , 'scale' => 3 , 'nullable' => false , 'default' => 0 , ] , [ 'fieldName' => 'virtualStock' , 'columnName' => 'virtual_stock' , 'type' => 'decimal' , 'precision' => 10 , 'scale' => 3 , 'nullable' => false , 'default' => 0 , ] , [ 'fieldName' => 'replenishmentTime' , 'columnName' => 'replenishment_time' , 'type' => 'smallint' , 'nullable' => false , 'default' => 7 , ] , [ 'fieldName' => 'estimatedDateOfArrival' , 'columnName' => 'estimated_date_of_arrival' , 'type' => 'datetime' , 'nullable' => true , ] , [ 'fieldName' => 'geocode' , 'columnName' => 'geocode' , 'type' => 'string' , 'length' => 16 , 'nullable' => true , ] , [ 'fieldName' => 'minimumOrderQuantity' , 'columnName' => 'minimum_order_quantity' , 'type' => 'decimal' , 'precision' => 10 , 'scale' => 3 , 'nullable' => false , 'default' => 1 , ] , [ 'fieldName' => 'quoteOnly' , 'columnName' => 'quote_only' , 'type' => 'boolean' , 'nullable' => false , 'default' => false , ] , [ 'fieldName' => 'endOfLife' , 'columnName' => 'end_of_life' , 'type' => 'boolean' , 'nullable' => false , 'default' => false , ] , ] ; }
8545	public function setGuaranteeClaimEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GuaranteeClaimEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
9379	protected function parse ( $ httpMethod , $ uri , $ route ) { $ matched = preg_match ( $ route [ 4 ] , $ uri , $ parameters ) ; if ( $ matched && ( $ httpMethod == $ route [ 0 ] || $ httpMethod == 'OPTIONS' ) ) { $ this -> allowed ( $ route [ 0 ] ) ; array_shift ( $ parameters ) ; return array ( $ route [ 2 ] , $ parameters , $ route [ 3 ] , $ route [ 5 ] ) ; } return null ; }
3761	private function getLegend ( PaletteInterface $ palette , $ legendName ) { if ( $ palette -> hasLegend ( $ legendName ) ) { return $ palette -> getLegend ( $ legendName ) ; } $ legend = new Legend ( $ legendName ) ; $ palette -> addLegend ( $ legend ) ; return $ legend ; }
9125	private function handleHeader ( & $ delimiterFound , & $ numBytes , & $ tmp ) { if ( $ tmp == "\r\n" ) { $ numBytes = $ this -> adjustNumbytes ( $ numBytes ) ; $ delimiterFound = true ; $ tmp = "" ; return ; } if ( substr ( $ tmp , - 2 , 2 ) == "\r\n" ) { $ this -> addParsedHeader ( $ tmp ) ; $ tmp = "" ; } }
8182	public function getDuration ( ) { if ( $ this -> isRoot ( ) && $ this -> profiles ) { $ duration = 0 ; foreach ( $ this -> profiles as $ profile ) { $ duration += $ profile -> getDuration ( ) ; } return $ duration ; } return isset ( $ this -> ends [ 'wt' ] ) && isset ( $ this -> starts [ 'wt' ] ) ? $ this -> ends [ 'wt' ] - $ this -> starts [ 'wt' ] : 0 ; }
88	public function equals ( Rule $ rule ) { if ( $ rule instanceof self ) { if ( $ this -> literal1 !== $ rule -> literal1 ) { return false ; } if ( $ this -> literal2 !== $ rule -> literal2 ) { return false ; } return true ; } $ literals = $ rule -> getLiterals ( ) ; if ( 2 != count ( $ literals ) ) { return false ; } if ( $ this -> literal1 !== $ literals [ 0 ] ) { return false ; } if ( $ this -> literal2 !== $ literals [ 1 ] ) { return false ; } return true ; }
12278	public function moveUser ( $ openId , $ groupId ) { $ params = [ 'openid' => $ openId , 'to_groupid' => $ groupId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_MEMBER_UPDATE , $ params ] ) ; }
9488	public function getPages ( ) { if ( $ this -> getPageRange ( ) > $ this -> getPagesCount ( ) ) { $ this -> setPageRange ( $ this -> getPagesCount ( ) ) ; } $ delta = ceil ( $ this -> getPageRange ( ) / 2 ) ; if ( $ this -> getCurrentPageNumber ( ) - $ delta > $ this -> getPagesCount ( ) - $ this -> getPageRange ( ) ) { $ pages = range ( $ this -> getPagesCount ( ) - $ this -> getPageRange ( ) + 1 , $ this -> getPagesCount ( ) ) ; } else { if ( $ this -> getCurrentPageNumber ( ) - $ delta < 0 ) { $ delta = $ this -> getCurrentPageNumber ( ) ; } $ offset = $ this -> getCurrentPageNumber ( ) - $ delta ; $ pages = range ( $ offset + 1 , $ offset + $ this -> getPageRange ( ) ) ; } return $ pages ; }
7124	protected function getMessageFromEvent ( ResourceEventInterface $ event ) { $ message = $ event -> getResource ( ) ; if ( ! $ message instanceof TicketMessageInterface ) { throw new UnexpectedValueException ( "Expected instance of " . TicketMessageInterface :: class ) ; } return $ message ; }
3083	public function getAssessmentItemRefByIdentifier ( \ tao_models_classes_service_StorageDirectory $ privateCompilationDirectory , $ identifier ) { $ compilationDataService = $ this -> getServiceLocator ( ) -> get ( CompilationDataService :: SERVICE_ID ) ; $ filename = "adaptive-assessment-item-ref-${identifier}" ; return $ compilationDataService -> readPhpCompilationData ( $ privateCompilationDirectory , "${filename}.php" , "${filename}" ) ; }
1845	public function getSearchablePages ( $ arrPages , $ intRoot = 0 , $ blnIsSitemap = false ) { $ arrRoot = array ( ) ; if ( $ intRoot > 0 ) { $ arrRoot = $ this -> Database -> getChildRecords ( $ intRoot , 'tl_page' ) ; } $ arrProcessed = array ( ) ; $ time = Date :: floorToMinute ( ) ; $ objCalendar = CalendarModel :: findByProtected ( '' ) ; if ( $ objCalendar !== null ) { while ( $ objCalendar -> next ( ) ) { if ( ! $ objCalendar -> jumpTo ) { continue ; } if ( ! empty ( $ arrRoot ) && ! \ in_array ( $ objCalendar -> jumpTo , $ arrRoot ) ) { continue ; } if ( ! isset ( $ arrProcessed [ $ objCalendar -> jumpTo ] ) ) { $ objParent = PageModel :: findWithDetails ( $ objCalendar -> jumpTo ) ; if ( $ objParent === null ) { continue ; } if ( ! $ objParent -> published || ( $ objParent -> start != '' && $ objParent -> start > $ time ) || ( $ objParent -> stop != '' && $ objParent -> stop <= ( $ time + 60 ) ) ) { continue ; } if ( $ blnIsSitemap ) { if ( $ objParent -> protected ) { continue ; } if ( $ objParent -> sitemap == 'map_never' ) { continue ; } } $ arrProcessed [ $ objCalendar -> jumpTo ] = $ objParent -> getAbsoluteUrl ( Config :: get ( 'useAutoItem' ) ? '/%s' : '/events/%s' ) ; } $ strUrl = $ arrProcessed [ $ objCalendar -> jumpTo ] ; $ objEvents = CalendarEventsModel :: findPublishedDefaultByPid ( $ objCalendar -> id ) ; if ( $ objEvents !== null ) { while ( $ objEvents -> next ( ) ) { $ arrPages [ ] = sprintf ( preg_replace ( '/%(?!s)/' , '%%' , $ strUrl ) , ( $ objEvents -> alias ? : $ objEvents -> id ) ) ; } } } } return $ arrPages ; }
8383	public function fetchAll ( ) { if ( $ this -> statement == null || $ this -> getErrorState ( ) != '00000' ) { return false ; } return $ this -> statement -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; }
970	public function setDomain ( string $ shopDomain ) { $ this -> fixLifetime ( ) ; Session :: put ( self :: DOMAIN , $ shopDomain ) ; }
615	protected function resolveDependencies ( $ dependencies , $ reflection = null ) { foreach ( $ dependencies as $ index => $ dependency ) { if ( $ dependency instanceof Instance ) { if ( $ dependency -> id !== null ) { $ dependencies [ $ index ] = $ this -> get ( $ dependency -> id ) ; } elseif ( $ reflection !== null ) { $ name = $ reflection -> getConstructor ( ) -> getParameters ( ) [ $ index ] -> getName ( ) ; $ class = $ reflection -> getName ( ) ; throw new InvalidConfigException ( "Missing required parameter \"$name\" when instantiating \"$class\"." ) ; } } } return $ dependencies ; }
4339	private function setOutputAs ( $ outputAs ) { if ( \ is_object ( $ this -> cfg [ 'outputAs' ] ) ) { $ this -> debug -> removePlugin ( $ this -> cfg [ 'outputAs' ] ) ; $ this -> cfg [ 'outputAs' ] = null ; } $ prop = null ; $ obj = null ; if ( \ is_string ( $ outputAs ) ) { $ prop = $ outputAs ; $ classname = __NAMESPACE__ . '\\Output\\' . \ ucfirst ( $ outputAs ) ; if ( \ property_exists ( $ this , $ prop ) ) { $ obj = $ this -> { $ prop } ; } elseif ( \ class_exists ( $ classname ) ) { $ obj = new $ classname ( $ this -> debug ) ; } } elseif ( $ outputAs instanceof OutputInterface ) { $ classname = \ get_class ( $ outputAs ) ; $ prefix = __NAMESPACE__ . '\\Output\\' ; if ( \ strpos ( $ classname , $ prefix ) == 0 ) { $ prop = \ substr ( $ classname , \ strlen ( $ prefix ) ) ; $ prop = \ lcfirst ( $ prop ) ; } $ obj = $ outputAs ; } if ( $ obj ) { $ this -> debug -> addPlugin ( $ obj ) ; $ this -> cfg [ 'outputAs' ] = $ obj ; if ( $ prop ) { $ this -> { $ prop } = $ obj ; } } }
4669	protected function beforeGeneration ( ) { $ this -> config -> getLogger ( ) -> startBreak ( 'XSD Parsing' ) ; $ this -> XSDMap = XSDMapGenerator :: buildXSDMap ( $ this -> config ) ; $ this -> config -> getLogger ( ) -> endBreak ( 'XSD Parsing' ) ; $ this -> config -> getLogger ( ) -> startBreak ( 'Generator Class Initialization' ) ; self :: _initializeClasses ( $ this -> config ) ; $ this -> autoloadMap = new AutoloaderTemplate ( $ this -> config ) ; $ this -> mapTemplate = new ParserMapTemplate ( $ this -> config ) ; $ this -> autoloadMap -> addEntry ( $ this -> mapTemplate -> getClassName ( ) , $ this -> mapTemplate -> getClassPath ( ) ) ; $ helperTemplate = new HelperTemplate ( $ this -> config ) ; $ helperTemplate -> writeToFile ( ) ; $ this -> autoloadMap -> addEntry ( $ helperTemplate -> getClassName ( ) , $ helperTemplate -> getClassPath ( ) ) ; $ this -> config -> getLogger ( ) -> endBreak ( 'Generator Class Initialization' ) ; }
2862	public function startRequest ( ) { foreach ( $ this -> files as $ logFile ) { $ logFilePath = $ this -> getLogFilePath ( $ logFile ) ; $ this -> ranges [ $ logFile ] = array ( 'start' => $ this -> getLastFilePosition ( $ logFilePath ) , 'end' => 0 ) ; } }
12956	public function remove ( $ id ) { if ( ! $ this -> has ( $ id ) ) { throw new NotFoundException ( sprintf ( '%s not found in %s' , $ id , __CLASS__ ) ) ; } unset ( $ this -> objects [ $ id ] ) ; }
1489	public function unless ( bool $ test , $ decodings ) : self { return $ this -> when ( true !== $ test , $ decodings ) ; }
1093	protected function getFreshInstance ( ) { if ( $ this -> areSoftDeletesEnabled ( ) ) return static :: withTrashed ( ) -> find ( $ this -> getKey ( ) ) ; return static :: find ( $ this -> getKey ( ) ) ; }
10747	protected function sendItems ( Response $ response , iterable $ items , ? Pagination $ pagination = null , ? int $ total = null ) : Response { $ items = is_array ( $ items ) ? $ items : ( $ items instanceof \ Traversable ? iterator_to_array ( $ items , false ) : [ ] ) ; $ total = $ total ?? count ( $ items ) ; $ start = $ pagination === null ? 0 : $ pagination -> getOffset ( ) ; $ max = $ pagination === null ? 0 : $ pagination -> getMax ( ) ; $ end = max ( min ( ( PHP_INT_MAX - $ max < $ start ? PHP_INT_MAX : $ start + $ max ) , $ total ) - 1 , 0 ) ; return $ this -> sendJson ( $ response -> withHeader ( 'Content-Range' , "items $start-$end/$total" ) , $ items ) ; }
7655	function AddAddress ( $ address , $ name = "" ) { $ cur = count ( $ this -> to ) ; $ this -> to [ $ cur ] [ 0 ] = trim ( $ address ) ; $ this -> to [ $ cur ] [ 1 ] = $ name ; }
6370	public static function forMap ( array $ map ) : callable { return function ( $ index ) use ( $ map ) { Preconditions :: checkArgument ( array_key_exists ( $ index , $ map ) , "The given key '%s' does not exist in the map" , $ index ) ; return $ map [ $ index ] ; } ; }
1949	public function showRelatedRecords ( $ data , $ row ) { Contao \ System :: loadLanguageFile ( 'tl_opt_in_related' ) ; Contao \ Controller :: loadDataContainer ( 'tl_opt_in_related' ) ; $ objRelated = $ this -> Database -> prepare ( "SELECT * FROM tl_opt_in_related WHERE pid=?" ) -> execute ( $ row [ 'id' ] ) ; while ( $ objRelated -> next ( ) ) { $ arrAdd = array ( ) ; $ arrRow = $ objRelated -> row ( ) ; foreach ( $ arrRow as $ k => $ v ) { $ label = \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ 'tl_opt_in_related' ] [ 'fields' ] [ $ k ] [ 'label' ] ) ? $ GLOBALS [ 'TL_DCA' ] [ 'tl_opt_in_related' ] [ 'fields' ] [ $ k ] [ 'label' ] [ 0 ] : $ GLOBALS [ 'TL_DCA' ] [ 'tl_opt_in_related' ] [ 'fields' ] [ $ k ] [ 'label' ] ; $ arrAdd [ $ label ] = $ v ; } $ data [ 'tl_opt_in_related' ] [ ] = $ arrAdd ; } return $ data ; }
10224	private function buildComplexIndexMenu ( $ modelName , $ modelId , ModelConfig $ config = null ) { $ model = $ this -> aujaConfigurator -> getModel ( $ modelName ) ; $ relations = $ this -> aujaConfigurator -> getRelationsForModel ( $ model ) ; $ associationRelations = array ( ) ; foreach ( $ relations as $ relation ) { if ( $ relation -> getType ( ) == Relation :: HAS_MANY || $ relation -> getType ( ) == Relation :: HAS_AND_BELONGS_TO ) { $ associationRelations [ ] = $ relation ; } } switch ( count ( $ associationRelations ) ) { case 0 : $ menu = $ this -> noAssociationsMenuFor ( $ modelName , $ config ) ; break ; case 1 : $ menu = $ this -> singleAssociationMenuFor ( $ modelName , $ modelId , $ associationRelations [ 0 ] , $ config ) ; break ; default : $ menu = $ this -> multipleAssociationsMenuFor ( $ modelName , $ modelId , $ associationRelations , $ config ) ; break ; } return $ menu ; }
11555	private function getBonusTotals ( $ dsBegin , $ dsEnd ) { $ query = $ this -> qbGetBonusTotals -> build ( ) ; $ conn = $ query -> getConnection ( ) ; $ bind = [ QBGetTotals :: BND_PERIOD_BEGIN => $ dsBegin , QBGetTotals :: BND_PERIOD_END => $ dsEnd ] ; $ rs = $ conn -> fetchAll ( $ query , $ bind ) ; $ result = [ ] ; foreach ( $ rs as $ one ) { $ accId = $ one [ QBGetTotals :: A_ACC_ID ] ; $ custId = $ one [ QBGetTotals :: A_CUST_ID ] ; $ total = $ one [ QBGetTotals :: A_TOTAL ] ; if ( $ custId ) { $ item = new DTotal ( ) ; $ item -> accountId = $ accId ; $ item -> customerId = $ custId ; $ item -> total = $ total ; $ result [ $ custId ] = $ item ; } } return $ result ; }
5630	public function getIdentity ( ) { if ( $ this -> username && $ this -> password ) { return $ this -> username . ':' . $ this -> password ; } return false ; }
4444	public function failedForGroup ( $ group , int $ start = 0 , int $ limit = 25 ) : array { $ results = json_decode ( $ this -> client -> failed ( $ group , $ start , $ limit ) , true ) ; if ( isset ( $ results [ 'jobs' ] ) && ! empty ( $ results [ 'jobs' ] ) ) { $ results [ 'jobs' ] = $ this -> multiget ( $ results [ 'jobs' ] ) ; } return is_array ( $ results ) ? $ results : [ ] ; }
8113	public function getReviewDate ( SiteTree $ page = null ) { if ( $ page === null ) { $ page = $ this -> owner ; } if ( $ page -> obj ( 'NextReviewDate' ) -> exists ( ) ) { return $ page -> obj ( 'NextReviewDate' ) ; } $ options = $ this -> owner -> getOptions ( ) ; if ( ! $ options ) { return false ; } if ( ! $ options -> ReviewPeriodDays ) { return false ; } $ nextReviewUnixSec = strtotime ( ' + ' . $ options -> ReviewPeriodDays . ' days' , DBDatetime :: now ( ) -> getTimestamp ( ) ) ; $ date = DBDate :: create ( 'NextReviewDate' ) ; $ date -> setValue ( $ nextReviewUnixSec ) ; return $ date ; }
10343	protected function extractRange ( $ definition , $ min = null , $ max = null ) { $ resultSet = array ( ) ; if ( substr ( $ definition , 0 , 1 ) === '*' ) { if ( $ min === null || $ max === null ) { return false ; } for ( $ i = $ min ; $ i <= $ max ; ++ $ i ) { $ resultSet [ ] = $ i ; } return $ resultSet ; } if ( ( $ position = strpos ( $ definition , '/' ) ) !== false ) { $ definition = substr ( $ definition , 0 , $ position ) ; } $ ranges = explode ( ',' , $ definition ) ; foreach ( $ ranges as $ range ) { $ entries = explode ( '-' , $ range ) ; if ( count ( $ entries ) === 1 ) { $ resultSet [ ] = ( int ) $ entries [ 0 ] ; } else { $ high = ( int ) max ( $ entries ) ; $ low = ( int ) min ( $ entries ) ; for ( $ i = $ low ; $ i <= $ high ; ++ $ i ) { $ resultSet [ ] = $ i ; } } } return $ resultSet ; }
8845	public function build ( ContainerBuilder $ container ) { $ container -> addCompilerPass ( new ThemeCompilerPass ( ) , PassConfig :: TYPE_BEFORE_OPTIMIZATION , - 10 ) ; $ container -> addCompilerPass ( new ThemeProviderPass ( ) ) ; }
6352	public static function paddedPartition ( Iterator $ iterator , int $ size ) : Iterator { Preconditions :: checkArgument ( 0 < $ size ) ; return new PartitionIterator ( $ iterator , $ size , true ) ; }
12284	public function head ( ) : string { $ property = static :: HEAD_ASSETS_NAME . static :: BLOCK_PROPERTY_SUFFIX ; return isset ( $ this -> $ property ) ? trim ( $ this -> make ( static :: HEAD_ASSETS_NAME ) ) . PHP_EOL : PHP_EOL ; }
4040	protected function generateOption ( $ val , $ index ) { $ checked = '' ; if ( is_array ( $ this -> varValue ) && in_array ( $ val [ 'value' ] , $ this -> varValue ) ) { $ checked = ' checked="checked"' ; } return sprintf ( '<span class="%1$s opt_%2$s">' . '<input type="checkbox" name="%8$s[]" id="opt_%3$s" class="checkbox" value="%4$s"%5$s%6$s ' . '<label id="lbl_%3$s" for="opt_%3$s">%7$s</label></span>' , $ this -> getClassForOption ( $ index ) , $ index , $ this -> strName . '_' . $ index , $ val [ 'value' ] , $ checked , $ this -> getAttributes ( ) . $ this -> strTagEnding , $ val [ 'label' ] , $ this -> strName ) ; }
3731	protected function fetchRows ( $ arrIds , $ arrAttrOnly = array ( ) ) { $ builder = $ this -> getConnection ( ) -> createQueryBuilder ( ) ; $ query = $ builder -> select ( '*' ) -> from ( $ this -> getTableName ( ) ) -> where ( $ builder -> expr ( ) -> in ( 'id' , ':values' ) ) -> setParameter ( 'values' , $ arrIds , Connection :: PARAM_STR_ARRAY ) -> orderBy ( 'FIELD(id, :values)' ) -> execute ( ) ; if ( $ arrAttrOnly ) { $ arrAttrOnly = array_merge ( $ this -> systemColumns , $ arrAttrOnly ) ; } $ result = [ ] ; while ( $ row = $ query -> fetch ( \ PDO :: FETCH_ASSOC ) ) { $ data = [ ] ; foreach ( $ row as $ attribute => $ value ) { if ( ( ! $ arrAttrOnly ) || ( in_array ( $ attribute , $ arrAttrOnly , true ) ) ) { $ data [ $ attribute ] = $ value ; } } $ result [ $ row [ 'id' ] ] = $ data ; } return $ result ; }
10566	protected function formatJsonp ( $ response ) { $ response -> getHeaders ( ) -> set ( 'Content-Type' , 'application/javascript; charset=UTF-8' ) ; if ( is_array ( $ response -> data ) && isset ( $ response -> data [ 'data' ] , $ response -> data [ 'callback' ] ) ) { $ response -> content = sprintf ( '%s(%s);' , $ response -> data [ 'callback' ] , Json :: htmlEncode ( $ response -> data [ 'data' ] ) ) ; } elseif ( $ response -> data !== null ) { $ response -> content = '' ; Yii :: warning ( "The 'jsonp' response requires that the data be an array consisting of both 'data' and 'callback' elements." , __METHOD__ ) ; } }
9506	public function listLogs ( Request $ request ) { $ this -> authorize ( LogViewerPolicy :: PERMISSION_LIST ) ; $ stats = $ this -> logViewer -> statsTable ( ) ; $ headers = $ stats -> header ( ) ; $ page = $ request -> get ( 'page' , 1 ) ; $ offset = ( $ page * $ this -> perPage ) - $ this -> perPage ; $ rows = new LengthAwarePaginator ( array_slice ( $ stats -> rows ( ) , $ offset , $ this -> perPage , true ) , count ( $ stats -> rows ( ) ) , $ this -> perPage , $ page ) ; $ rows -> setPath ( $ request -> url ( ) ) ; $ this -> setTitle ( $ title = trans ( 'foundation::log-viewer.titles.logs-list' ) ) ; $ this -> addBreadcrumb ( $ title ) ; return $ this -> view ( 'admin.system.log-viewer.list' , compact ( 'headers' , 'rows' , 'footer' ) ) ; }
1699	public function getFile ( $ strName ) { foreach ( $ this -> arrFiles as $ k => $ v ) { if ( $ strName == $ v [ 'file_name' ] ) { $ this -> intIndex = $ k ; return true ; } } return false ; }
10143	private function readTextObject ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( $ this -> readDataOnly ) { return ; } $ grbitOpts = self :: getUInt2d ( $ recordData , 0 ) ; $ rot = self :: getUInt2d ( $ recordData , 2 ) ; $ cchText = self :: getUInt2d ( $ recordData , 10 ) ; $ cbRuns = self :: getUInt2d ( $ recordData , 12 ) ; $ text = $ this -> getSplicedRecordData ( ) ; $ textByte = $ text [ 'spliceOffsets' ] [ 1 ] - $ text [ 'spliceOffsets' ] [ 0 ] - 1 ; $ textStr = substr ( $ text [ 'recordData' ] , $ text [ 'spliceOffsets' ] [ 0 ] + 1 , $ textByte ) ; $ is16Bit = ord ( $ text [ 'recordData' ] [ 0 ] ) ; if ( ( $ is16Bit & 0x01 ) === 0 ) { $ textStr = StringHelper :: ConvertEncoding ( $ textStr , 'UTF-8' , 'ISO-8859-1' ) ; } else { $ textStr = $ this -> decodeCodepage ( $ textStr ) ; } $ this -> textObjects [ $ this -> textObjRef ] = [ 'text' => $ textStr , 'format' => substr ( $ text [ 'recordData' ] , $ text [ 'spliceOffsets' ] [ 1 ] , $ cbRuns ) , 'alignment' => $ grbitOpts , 'rotation' => $ rot , ] ; }
3289	public function start ( ) : Promise { if ( $ this -> handle ) { throw new StatusError ( "Process has already been started." ) ; } return call ( function ( ) { $ this -> handle = $ this -> processRunner -> start ( $ this -> command , $ this -> cwd , $ this -> env , $ this -> options ) ; return $ this -> pid = yield $ this -> handle -> pidDeferred -> promise ( ) ; } ) ; }
7015	private function format_y ( & $ str ) { if ( strstr ( $ str , '%y' ) ) $ str = str_replace ( '%y' , substr ( $ this -> year , strlen ( $ this -> year ) - 2 , 2 ) , $ str ) ; }
7422	protected function renderAlertBlock ( ) { $ session = \ Yii :: $ app -> session ; $ flashes = $ session -> getAllFlashes ( ) ; $ alertContainerOptions = [ 'style' => 'max-width:400px' ] ; if ( count ( $ flashes ) === 0 ) { Html :: addCssStyle ( $ alertContainerOptions , 'display:none;' ) ; } $ out = Html :: beginTag ( 'div' , $ alertContainerOptions ) ; foreach ( $ flashes as $ type => $ message ) { if ( is_array ( $ message ) ) { $ message = implode ( '<br>' , $ message ) ; } $ alertWidgetOptions = [ ] ; $ alertWidgetOptions [ 'body' ] = $ message ; $ alertWidgetOptions [ 'options' ] = [ 'class' => [ 'alert' , 'alert-success' ] , 'style' => 'padding-left:10px;padding-right:10px;' ] ; $ out .= "\n" . Alert :: widget ( $ alertWidgetOptions ) ; $ session -> removeFlash ( $ type ) ; } $ out .= "\n</div>" ; return $ this -> alertBlockAddon . $ out ; }
7768	public function validate ( array $ data , $ rules = [ ] ) { $ this -> clearErrors ( ) ; $ this -> clearFieldAliases ( ) ; $ data = $ this -> extractFieldAliases ( $ data ) ; if ( empty ( $ rules ) ) { $ rules = $ this -> extractRules ( $ data ) ; $ data = $ this -> extractInput ( $ data ) ; } $ this -> input = $ data ; foreach ( $ this -> before as $ before ) { call_user_func_array ( $ before , [ $ this ] ) ; } foreach ( $ data as $ field => $ value ) { $ fieldRules = explode ( '|' , $ rules [ $ field ] ) ; foreach ( $ fieldRules as $ rule ) { $ continue = $ this -> validateAgainstRule ( $ field , $ value , $ this -> getRuleName ( $ rule ) , $ this -> getRuleArgs ( $ rule ) ) ; if ( ! $ continue ) { break ; } } } return $ this ; }
12720	public function callInstance ( $ instance , $ args = [ ] ) { $ args = ( is_array ( $ args ) ? $ args : array_slice ( func_get_args ( ) , 1 ) ) ; $ current = $ this -> make ( $ instance ) ; return call_user_func_array ( $ current , $ args ) ; }
10182	public function unsetWorksheetCells ( ) { if ( $ this -> currentCell !== null ) { $ this -> currentCell -> detach ( ) ; $ this -> currentCell = null ; $ this -> currentCoordinate = null ; } $ this -> __destruct ( ) ; $ this -> index = [ ] ; $ this -> parent = null ; }
6828	private function getSaleDeliveryAddress ( ShipmentInterface $ shipment ) { if ( null === $ sale = $ shipment -> getSale ( ) ) { throw new LogicException ( "Shipment's sale must be set at this point." ) ; } return $ sale -> isSameAddress ( ) ? $ sale -> getInvoiceAddress ( ) : $ sale -> getDeliveryAddress ( ) ; }
2190	public function isRegistered ( Model $ objModel ) { $ intObjectId = spl_object_hash ( $ objModel ) ; return isset ( $ this -> arrIdentities [ $ intObjectId ] ) ; }
8054	public function updateCalendarEvent ( $ id , array $ data ) { $ eventData = $ this -> calendarEventsEngine -> buildEventData ( $ data ) ; $ eventDates = $ this -> calendarEventsEngine -> buildEventDates ( $ data ) ; $ cache = $ this -> cache ; $ calendarEventRepeatDate = clone $ this -> calendarEventRepeatDate ; $ calendarEventRepeatDate -> where ( 'calendar_event_id' , $ id ) -> delete ( ) ; $ this -> calendarEvent -> where ( 'id' , $ id ) -> update ( $ eventData ) ; $ calendarEvent = $ this -> calendarEvent -> where ( 'id' , $ id ) -> firstOrFail ( ) ; $ this -> handleEventLocation ( $ data , $ calendarEvent ) ; foreach ( $ eventDates as $ date ) { $ calendarEventRepeatDate = clone $ this -> calendarEventRepeatDate ; $ calendarEventRepeatDate -> start = $ date [ 'start' ] ; $ calendarEventRepeatDate -> end = $ date [ 'end' ] ; $ calendarEventRepeatDate -> calendarEvent ( ) -> associate ( $ calendarEvent ) ; $ calendarEventRepeatDate -> save ( ) ; unset ( $ calendarEventRepeatDate ) ; } $ cache :: put ( self :: CACHE_KEY . $ calendarEvent -> id , $ calendarEvent , $ this -> cacheTimeToLive ) ; $ allEvents = $ this -> getAllEvents ( ) ; $ allEvents -> put ( $ calendarEvent -> id , $ calendarEvent ) ; $ cache :: put ( self :: ALL_EVENTS_KEY , $ allEvents , $ this -> cacheTimeToLive ) ; return true ; }
6563	public function carrier_data ( $ carrier = '' , $ field_output = '' ) { $ inputParams = array ( 'carrier' => $ carrier , 'field_output' => $ field_output ) ; $ field_output = strtolower ( $ field_output ) ; $ this -> debug -> info ( __FUNCTION__ , 'Input Params: ' , $ inputParams ) ; try { $ vnCarrierData = DataRepository :: getData ( 'vn_carrier_data' ) ; $ this -> debug -> debug ( __FUNCTION__ , 'VN Carrier All Data: ' , $ vnCarrierData ) ; if ( array_key_exists ( $ carrier , $ vnCarrierData ) ) { $ isCarrier = $ vnCarrierData [ $ carrier ] ; $ this -> debug -> debug ( __FUNCTION__ , 'Is Carrier Data: ' , $ isCarrier ) ; if ( array_key_exists ( $ field_output , $ isCarrier ) ) { $ result = $ isCarrier [ $ field_output ] ; $ this -> debug -> info ( __FUNCTION__ , 'Final Result get Field : ' . $ field_output , $ result ) ; return $ result ; } if ( $ field_output = 'full' ) { $ this -> debug -> info ( __FUNCTION__ , 'Final Result get Field : ' . $ field_output , $ isCarrier ) ; return $ isCarrier ; } } } catch ( \ Exception $ e ) { $ message = 'Error File: ' . $ e -> getFile ( ) . ' - Line: ' . $ e -> getLine ( ) . ' - Code: ' . $ e -> getCode ( ) . ' - Message: ' . $ e -> getMessage ( ) ; $ this -> debug -> error ( __FUNCTION__ , $ message ) ; return NULL ; } return NULL ; }
591	protected function compressCssFiles ( $ inputFiles , $ outputFile ) { if ( empty ( $ inputFiles ) ) { return ; } $ this -> stdout ( " Compressing CSS files...\n" ) ; if ( is_string ( $ this -> cssCompressor ) ) { $ tmpFile = $ outputFile . '.tmp' ; $ this -> combineCssFiles ( $ inputFiles , $ tmpFile ) ; $ this -> stdout ( shell_exec ( strtr ( $ this -> cssCompressor , [ '{from}' => escapeshellarg ( $ tmpFile ) , '{to}' => escapeshellarg ( $ outputFile ) , ] ) ) ) ; @ unlink ( $ tmpFile ) ; } else { call_user_func ( $ this -> cssCompressor , $ this , $ inputFiles , $ outputFile ) ; } if ( ! file_exists ( $ outputFile ) ) { throw new Exception ( "Unable to compress CSS files into '{$outputFile}'." ) ; } $ this -> stdout ( " CSS files compressed into '{$outputFile}'.\n" ) ; }
8488	public static function getLoad ( ) { $ wmi = Windows :: getInstance ( ) ; $ load = [ ] ; foreach ( $ wmi -> ExecQuery ( "SELECT LoadPercentage FROM Win32_Processor" ) as $ cpu ) { $ load [ ] = $ cpu -> LoadPercentage ; } return round ( array_sum ( $ load ) / count ( $ load ) , 2 ) . "%" ; }
10306	public function setLineStyleProperties ( $ line_width = null , $ compound_type = null , $ dash_type = null , $ cap_type = null , $ join_type = null , $ head_arrow_type = null , $ head_arrow_size = null , $ end_arrow_type = null , $ end_arrow_size = null ) { ( $ line_width !== null ) ? $ this -> lineStyleProperties [ 'width' ] = $ this -> getExcelPointsWidth ( ( float ) $ line_width ) : null ; ( $ compound_type !== null ) ? $ this -> lineStyleProperties [ 'compound' ] = ( string ) $ compound_type : null ; ( $ dash_type !== null ) ? $ this -> lineStyleProperties [ 'dash' ] = ( string ) $ dash_type : null ; ( $ cap_type !== null ) ? $ this -> lineStyleProperties [ 'cap' ] = ( string ) $ cap_type : null ; ( $ join_type !== null ) ? $ this -> lineStyleProperties [ 'join' ] = ( string ) $ join_type : null ; ( $ head_arrow_type !== null ) ? $ this -> lineStyleProperties [ 'arrow' ] [ 'head' ] [ 'type' ] = ( string ) $ head_arrow_type : null ; ( $ head_arrow_size !== null ) ? $ this -> lineStyleProperties [ 'arrow' ] [ 'head' ] [ 'size' ] = ( string ) $ head_arrow_size : null ; ( $ end_arrow_type !== null ) ? $ this -> lineStyleProperties [ 'arrow' ] [ 'end' ] [ 'type' ] = ( string ) $ end_arrow_type : null ; ( $ end_arrow_size !== null ) ? $ this -> lineStyleProperties [ 'arrow' ] [ 'end' ] [ 'size' ] = ( string ) $ end_arrow_size : null ; }
3051	protected function retrieveItemIndex ( ) { $ this -> itemIndex = new QtiTestCompilerIndex ( ) ; try { $ directories = $ this -> getCompilationDirectory ( ) ; $ data = $ directories [ 'private' ] -> read ( taoQtiTest_models_classes_QtiTestService :: TEST_COMPILED_INDEX ) ; if ( $ data ) { $ this -> itemIndex -> unserialize ( $ data ) ; } } catch ( \ Exception $ e ) { \ common_Logger :: d ( 'Ignoring file not found exception for Items Index' ) ; } }
10090	public function getUrl ( $ identifier , $ options = array ( ) ) { if ( ! $ identifier ) { $ identifier = null ; } else { $ identifier = $ this -> normalizeIdentifier ( $ identifier ) ; } $ options = $ this -> checkOptionsArray ( $ options ) ; $ https = $ this -> https ; if ( isset ( $ options [ 'https' ] ) ) { $ https = ( bool ) $ options [ 'https' ] ; } $ algorithm = $ this -> algorithm ; if ( isset ( $ options [ 'algorithm' ] ) ) { $ algorithm = $ this -> processAlgorithm ( $ options [ 'algorithm' ] ) ; } $ default = $ this -> default ; if ( isset ( $ options [ 'default' ] ) ) { $ default = $ this -> processDefault ( $ options [ 'default' ] ) ; } $ size = $ this -> size ; if ( isset ( $ options [ 'size' ] ) ) { $ size = $ this -> processSize ( $ options [ 'size' ] ) ; } $ identifierHash = $ this -> identifierHash ( $ identifier , $ algorithm ) ; $ domain = $ this -> domainGet ( $ identifier ) ; $ service = $ this -> srvGet ( $ domain , $ https ) ; $ protocol = $ https ? 'https' : 'http' ; $ params = array ( ) ; if ( $ size !== null ) { $ params [ 'size' ] = $ size ; } if ( $ default !== null ) { $ params [ 'default' ] = $ default ; } $ paramString = '' ; if ( count ( $ params ) > 0 ) { $ paramString = '?' . http_build_query ( $ params ) ; } $ url = $ protocol . '://' . $ service . '/avatar/' . $ identifierHash . $ paramString ; return $ url ; }
9925	private function handleCollections ( Parameters $ params , array $ permitted = array ( ) ) { if ( empty ( $ permitted ) ) { return ; } $ keys = $ params -> keys ( ) ; $ intKeys = $ keys -> select ( function ( $ value ) { return is_int ( $ value ) ; } ) ; if ( $ keys -> count ( ) === $ intKeys -> count ( ) ) { foreach ( $ keys as $ key ) { $ value = $ params [ $ key ] ; if ( $ value instanceof Parameters ) { $ this -> filter ( $ value , $ permitted ) ; } } } }
1216	public static function stableSort ( array $ data , callable $ sortFn ) { array_walk ( $ data , function ( & $ v , $ k ) { $ v = [ $ v , $ k ] ; } ) ; uasort ( $ data , function ( $ a , $ b ) use ( $ sortFn ) { return $ sortFn ( $ a [ 0 ] , $ b [ 0 ] ) ? : ( $ a [ 1 ] < $ b [ 1 ] ? - 1 : 1 ) ; } ) ; return array_map ( function ( $ v ) { return $ v [ 0 ] ; } , array_values ( $ data ) ) ; }
5990	public function addPropertyCriteria ( $ item ) { if ( ! ( $ item instanceof PropertyCriteria ) ) { if ( is_array ( $ item ) ) { try { $ item = new PropertyCriteria ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate PropertyCriteria. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "PropertyCriteria"!' , E_USER_WARNING ) ; } } $ this -> properties [ ] = $ item ; return $ this ; }
12923	public function getLocalDataItems ( ) { if ( ! isset ( $ this -> _localDataItems ) ) { $ this -> trigger ( self :: EVENT_LOAD_LOCAL_DATA_ITEMS ) ; } return $ this -> _localDataItems ; }
5879	protected static function createIndex ( $ fileName , $ width , $ height ) { $ relativePath = substr ( PathUtility :: dirname ( $ fileName ) , strlen ( PATH_site ) ) ; $ resourceFactory = \ TYPO3 \ CMS \ Core \ Resource \ ResourceFactory :: getInstance ( ) ; $ targetFolder = $ resourceFactory -> retrieveFileOrFolderObject ( $ relativePath ) ; $ targetFilename = PathUtility :: basename ( $ fileName ) ; $ storageConfiguration = $ targetFolder -> getStorage ( ) -> getConfiguration ( ) ; if ( ! isset ( $ storageConfiguration [ 'basePath' ] ) ) { return ; } $ basePath = rtrim ( $ storageConfiguration [ 'basePath' ] , '/' ) . '/' ; $ basePath = GeneralUtility :: getFileAbsFileName ( $ basePath ) ; $ identifier = substr ( $ fileName , strlen ( $ basePath ) - 1 ) ; $ driver = static :: accessProtectedProperty ( $ targetFolder -> getStorage ( ) , 'driver' ) ; $ fileInfo = $ driver -> getFileInfoByIdentifier ( $ identifier ) ; $ file = $ resourceFactory -> createFileObject ( $ fileInfo ) ; $ fileRepository = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Core \ Resource \ FileRepository :: class ) ; $ fileRepository -> addToIndex ( $ file ) ; }
2140	private function fetchHttpHeaders ( ) : void { $ this -> headers = array_merge ( $ this -> headers , $ this -> headerStorage -> all ( ) ) ; $ this -> headerStorage -> clear ( ) ; }
1641	protected function setupSessionTracking ( Client $ client , $ endpoint , $ events ) { $ client -> setAutoCaptureSessions ( true ) ; if ( ! is_null ( $ endpoint ) ) { $ client -> setSessionEndpoint ( $ endpoint ) ; } $ sessionTracker = $ client -> getSessionTracker ( ) ; $ sessionStorage = function ( $ session = null ) { if ( is_null ( $ session ) ) { return session ( 'bugsnag-session' , [ ] ) ; } else { session ( [ 'bugsnag-session' => $ session ] ) ; } } ; $ sessionTracker -> setSessionFunction ( $ sessionStorage ) ; $ cache = $ this -> app -> cache ; $ genericStorage = function ( $ key , $ value = null ) use ( $ cache ) { if ( is_null ( $ value ) ) { return $ cache -> get ( $ key , null ) ; } else { $ cache -> put ( $ key , $ value , 60 ) ; } } ; $ sessionTracker -> setStorageFunction ( $ genericStorage ) ; }
9452	public function query ( $ index , array $ filters = null , array $ queries = null , array $ fieldWeights = null , $ limit = 20 , $ offset = 0 ) { $ sphinxClient = $ this -> getSphinxClient ( ) ; $ sphinxClient -> SetLimits ( $ offset , $ limit ) ; if ( null !== $ filters ) { foreach ( $ filters as $ filter ) { if ( ! isset ( $ filter [ 'key' ] ) ) { } if ( array_key_exists ( 'min' , $ filter ) && array_key_exists ( 'max' , $ filter ) ) { $ sphinxClient -> SetFilterRange ( $ filter [ 'key' ] , ( integer ) $ filter [ 'min' ] , ( integer ) $ filter [ 'max' ] ) ; } else { if ( ! isset ( $ filter [ 'values' ] ) || ! is_array ( $ filter [ 'values' ] ) ) { } $ sphinxClient -> SetFilter ( $ filter [ 'key' ] , $ filter [ 'values' ] ) ; } } } if ( null !== $ queries ) { foreach ( $ queries as $ key => $ queryInfo ) { $ query = $ this -> implodeQueryValues ( $ queryInfo ) ; if ( array_key_exists ( 'countableAttributes' , $ queryInfo ) ) { $ array = $ queryInfo [ 'countableAttributes' ] ; if ( ! is_array ( $ array ) ) { $ array = [ $ array ] ; } $ sphinxClient -> addFacetedQuery ( $ query , $ index , $ array ) ; } else { $ sphinxClient -> AddQuery ( $ query , $ index ) ; } } } if ( null !== $ fieldWeights ) { $ sphinxClient -> SetFieldWeights ( $ fieldWeights ) ; } $ result = $ this -> getResult ( $ sphinxClient ) ; return $ result ; }
4138	public function postMedia ( $ call , $ filename ) { $ this -> resetCallState ( ) ; $ this -> call = $ call ; $ this -> method = 'POST' ; $ this -> withMedia = true ; $ mimeBoundary = sha1 ( $ call . microtime ( ) ) ; $ params = array ( 'post' => $ this -> buildMultipart ( $ mimeBoundary , $ filename ) , 'headers' => $ this -> buildUploadMediaHeader ( $ mimeBoundary ) , ) ; $ response = $ this -> curl -> send ( $ this -> getUrl ( ) , $ params ) ; $ obj = json_decode ( $ response [ 'body' ] ) ; if ( ! $ obj || ! isset ( $ obj -> token_type ) || $ obj -> token_type != 'bearer' ) { $ this -> findExceptions ( $ response ) ; } $ this -> headers = $ response [ 'headers' ] ; $ this -> withMedia = null ; unset ( $ call , $ filename , $ mimeBoundary , $ params , $ obj ) ; return $ this -> serializer -> format ( $ response [ 'body' ] ) ; }
11348	public function getField ( $ name ) { foreach ( $ this -> fields as $ field ) { if ( $ field -> getName ( ) == $ name ) return $ field ; } throw new FieldNotFoundException ( $ name ) ; }
4340	private function uncollapseErrors ( & $ log ) { $ groupStack = array ( ) ; for ( $ i = 0 , $ count = \ count ( $ log ) ; $ i < $ count ; $ i ++ ) { $ method = $ log [ $ i ] [ 0 ] ; if ( \ in_array ( $ method , array ( 'group' , 'groupCollapsed' ) ) ) { $ groupStack [ ] = $ i ; } elseif ( $ method == 'groupEnd' ) { \ array_pop ( $ groupStack ) ; } elseif ( \ in_array ( $ method , array ( 'error' , 'warn' ) ) ) { foreach ( $ groupStack as $ i2 ) { $ log [ $ i2 ] [ 0 ] = 'group' ; } } } }
12805	private static function getColumnName ( string $ name ) : ? string { $ class = self :: getStaticChildClass ( ) ; if ( self :: $ columnPropertiesCache === null || ! array_key_exists ( $ class , self :: $ columnPropertiesCache ) || self :: $ columnPropertiesCache [ $ class ] === null ) self :: buildColumnPropertiesCache ( ) ; if ( array_key_exists ( $ name , self :: $ columnPropertiesCache [ $ class ] ) ) return $ name ; foreach ( self :: $ columnPropertiesCache [ $ class ] as $ column => $ properties ) { if ( in_array ( $ name , $ properties ) ) return $ column ; } return null ; }
8565	private function _convertGetEligibleShippingServices ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetEligibleShippingServices' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetShipmentRequestDetails ( ) ) { $ ShipmentRequestDetailsGetEligibleShippingServicesRequest = $ request -> getShipmentRequestDetails ( ) ; foreach ( $ ShipmentRequestDetailsGetEligibleShippingServicesRequest -> getAmazonOrderId ( ) as $ AmazonOrderIdShipmentRequestDetailsIndex => $ AmazonOrderIdShipmentRequestDetails ) { $ parameters [ 'ShipmentRequestDetails' . '.' . 'AmazonOrderId' . '.' . ( $ AmazonOrderIdShipmentRequestDetailsIndex + 1 ) ] = $ AmazonOrderIdShipmentRequestDetails ; } } return $ parameters ; }
7267	public function has ( $ forClass , $ forColumn = null ) { $ refTable = static :: tableName ( ) ; $ forTable = $ forClass :: tableName ( ) ; $ refColumn = static :: $ idColumn ; $ forColumn = $ forColumn ? : strtolower ( static :: modelName ( ) ) . "_id" ; $ rows = Db :: query ( " select F.* from $refTable as R, $forTable as F where R.$refColumn = F.$forColumn and R.$refColumn = :id " , [ "id" => $ this -> $ refColumn ] , static :: getDbName ( ) ) ; if ( $ rows === false ) return false ; if ( empty ( $ rows ) ) return null ; $ forModel = new $ forClass ; foreach ( $ rows [ 0 ] as $ col => $ val ) $ forModel -> $ col = $ forModel -> decodeValue ( $ val , $ col ) ; return $ forModel ; }
4910	public function renderSummary ( SummaryFormInterface $ form ) { $ form -> prepare ( ) ; $ baseFieldset = $ form -> getBaseFieldset ( ) ; if ( ! isset ( $ baseFieldset ) ) { throw new \ InvalidArgumentException ( 'For the Form ' . get_class ( $ form ) . ' there is no Basefieldset' ) ; } $ dataAttributesMarkup = '' ; foreach ( $ form -> getAttributes ( ) as $ dataKey => $ dataValue ) { if ( preg_match ( '/^data-/' , $ dataKey ) ) { $ dataAttributesMarkup .= sprintf ( ' %s="%s"' , $ dataKey , $ dataValue ) ; } } $ markup = '<div class="panel panel-default" style="min-height: 100px;"' . $ dataAttributesMarkup . '> <div class="panel-body"><div class="sf-controls">%s</div>%s</div></div>' ; $ view = $ this -> getView ( ) ; $ buttonMarkup = false === $ form -> getOption ( 'editable' ) ? '' : '<button type="button" class="btn btn-default btn-xs sf-edit">' . '<span class="yk-icon yk-icon-edit"></span> ' . $ view -> translate ( 'Edit' ) . '</button>' ; if ( ( $ controlButtons = $ form -> getOption ( 'control_buttons' ) ) !== null ) { $ buttonMarkup .= PHP_EOL . implode ( PHP_EOL , array_map ( function ( array $ buttonSpec ) use ( $ view ) { return '<button type="button" class="btn btn-default btn-xs' . ( isset ( $ buttonSpec [ 'class' ] ) ? ' ' . $ buttonSpec [ 'class' ] : '' ) . '">' . ( isset ( $ buttonSpec [ 'icon' ] ) ? '<span class="yk-icon yk-icon-' . $ buttonSpec [ 'icon' ] . '"></span> ' : '' ) . $ view -> translate ( $ buttonSpec [ 'label' ] ) . '</button>' ; } , $ controlButtons ) ) ; } $ elementMarkup = $ this -> renderSummaryElement ( $ baseFieldset ) ; return sprintf ( $ markup , $ buttonMarkup , $ elementMarkup ) ; }
3595	public function registerCpUrlRules ( RegisterUrlRulesEvent $ event ) { if ( ! \ Craft :: $ app -> user -> identity ) return ; $ rules = [ 'settings/sitemap' => [ 'route' => 'sitemap/settings' , 'params' => [ 'source' => 'CpSettings' ] ] , 'settings/sitemap/save-sitemap' => [ 'route' => 'sitemap/settings/save-sitemap' , 'params' => [ 'source' => 'CpSettings' ] ] , ] ; $ event -> rules = array_merge ( $ event -> rules , $ rules ) ; }
1583	public function getRelations ( ) : Collection { return $ this -> getRelationships ( ) -> filter ( function ( array $ relation ) { return array_key_exists ( 'data' , $ relation ) ; } ) -> map ( function ( array $ relation ) { return $ relation [ 'data' ] ; } ) ; }
4128	protected function loadMetadata ( $ className ) { if ( class_exists ( $ className ) ) { return parent :: loadMetadata ( $ className ) ; } throw MappingException :: classNotFound ( $ className ) ; }
12570	public function previewNews ( $ message , $ to , $ by = self :: PREVIEW_BY_OPENID ) { return $ this -> preview ( self :: MSG_TYPE_NEWS , $ message , $ to , $ by ) ; }
1674	public function synchronize ( ) { if ( ! $ this -> isUnsynchronized ( ) ) { return ; } if ( ! file_exists ( $ this -> strRootDir . '/' . $ this -> strFolder . '/.nosync' ) ) { throw new \ RuntimeException ( sprintf ( 'Cannot synchronize the folder "%s" because one of its parent folders is unsynchronized' , $ this -> strFolder ) ) ; } ( new File ( $ this -> strFolder . '/.nosync' ) ) -> delete ( ) ; }
9694	public function canRead ( $ pFilename ) { try { $ this -> openFile ( $ pFilename ) ; } catch ( Exception $ e ) { return false ; } $ beginning = $ this -> readBeginning ( ) ; $ startWithTag = self :: startsWithTag ( $ beginning ) ; $ containsTags = self :: containsTags ( $ beginning ) ; $ endsWithTag = self :: endsWithTag ( $ this -> readEnding ( ) ) ; fclose ( $ this -> fileHandle ) ; return $ startWithTag && $ containsTags && $ endsWithTag ; }
1559	protected function fillAttributes ( $ record , Collection $ attributes ) { $ record -> fill ( $ this -> deserializeAttributes ( $ attributes , $ record ) ) ; }
11892	public function newAction ( Request $ request ) { $ entity = new CustomField ( ) ; $ cfGroupId = $ request -> query -> get ( 'customFieldsGroup' , null ) ; if ( $ cfGroupId !== null ) { $ cfGroup = $ this -> getDoctrine ( ) -> getManager ( ) -> getRepository ( 'ChillCustomFieldsBundle:CustomFieldsGroup' ) -> find ( $ cfGroupId ) ; if ( ! $ cfGroup ) { throw $ this -> createNotFoundException ( 'CustomFieldsGroup with id ' . $ cfGroupId . ' is not found !' ) ; } $ entity -> setCustomFieldsGroup ( $ cfGroup ) ; } $ form = $ this -> createCreateForm ( $ entity , $ request -> query -> get ( 'type' ) ) ; return $ this -> render ( 'ChillCustomFieldsBundle:CustomField:new.html.twig' , array ( 'entity' => $ entity , 'form' => $ form -> createView ( ) , ) ) ; }
123	public function binaryVersion ( ) { if ( ! self :: $ version ) { if ( 0 === $ this -> process -> execute ( 'svn --version' , $ output ) ) { if ( preg_match ( '{(\d+(?:\.\d+)+)}' , $ output , $ match ) ) { self :: $ version = $ match [ 1 ] ; } } } return self :: $ version ; }
7411	public function combine ( array $ keys ) : self { if ( count ( $ keys ) !== count ( $ this -> _container ) ) { throw new LengthException ( 'array counts do not match' ) ; } $ this -> _container = array_combine ( $ keys , $ this -> _container ) ; return $ this ; }
955	public function retrieve ( ) { $ path = null ; switch ( $ this -> type ) { case self :: CHARGE_CREDIT : $ path = 'application_credits' ; break ; case self :: CHARGE_ONETIME : $ path = 'application_charges' ; break ; default : $ path = 'recurring_application_charges' ; break ; } return $ this -> shop -> api ( ) -> rest ( 'GET' , "/admin/{$path}/{$this->charge_id}.json" ) -> body -> { substr ( $ path , 0 , - 1 ) } ; }
10742	public function get ( $ keys , $ default = null ) { $ result = $ this -> data ; foreach ( is_array ( $ keys ) ? $ keys : [ $ keys ] as $ key ) { if ( is_array ( $ result ) && isset ( $ result [ $ key ] ) ) { $ result = $ result [ $ key ] ; } else { $ result = $ default ; break ; } } return $ result ; }
2467	private function setImpersonatedLogout ( ) { $ token = System :: getContainer ( ) -> get ( 'security.token_storage' ) -> getToken ( ) ; if ( ! $ token instanceof TokenInterface ) { return ; } $ impersonatorUser = null ; foreach ( $ token -> getRoles ( ) as $ role ) { if ( $ role instanceof SwitchUserRole ) { $ impersonatorUser = $ role -> getSource ( ) -> getUsername ( ) ; break ; } } if ( ! $ impersonatorUser ) { return ; } $ request = System :: getContainer ( ) -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( $ request === null ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } $ firewallMap = System :: getContainer ( ) -> get ( 'security.firewall.map' ) ; if ( ( $ firewallConfig = $ firewallMap -> getFirewallConfig ( $ request ) ) === null || ( $ switchUserConfig = $ firewallConfig -> getSwitchUser ( ) ) === null ) { return ; } $ arrParams = array ( 'do' => 'user' , urlencode ( $ switchUserConfig [ 'parameter' ] ) => SwitchUserListener :: EXIT_VALUE ) ; $ this -> Template -> logout = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'switchBT' ] , $ impersonatorUser ) ; $ this -> Template -> logoutLink = System :: getContainer ( ) -> get ( 'router' ) -> generate ( 'contao_backend' , $ arrParams ) ; }
6771	protected function isDiscountUpdateNeeded ( SaleInterface $ sale ) { if ( $ this -> persistenceHelper -> isChanged ( $ sale , [ 'autoDiscount' ] ) ) { return true ; } if ( ( 0 == $ sale -> getPaidTotal ( ) ) && $ this -> persistenceHelper -> isChanged ( $ sale , [ 'customerGroup' , 'customer' ] ) ) { return true ; } return $ this -> didInvoiceCountryChanged ( $ sale ) ; }
3963	public static function isReserveColumnPostFix ( $ strColName ) { $ inputProvider = new InputProvider ( ) ; if ( ! $ inputProvider -> hasValue ( 'colname' ) || strtolower ( $ strColName ) !== strtolower ( $ inputProvider -> getValue ( 'colname' ) ) ) { return false ; } foreach ( self :: $ reservedColumnPostFix as $ postFix ) { if ( $ postFix !== strtolower ( substr ( $ strColName , - strlen ( $ postFix ) ) ) ) { continue ; } return true ; } return false ; }
10373	public static function unify ( $ id , $ params , $ minify = '' ) { self :: $ id = $ id ; self :: $ unify = $ params ; self :: $ minify = $ minify ; return true ; }
2945	public function removeRole ( $ role ) { if ( is_string ( $ role ) ) { return $ this -> roles ( ) -> detach ( Role :: where ( 'slug' , $ role ) -> first ( ) ) ; } return $ this -> roles ( ) -> detach ( $ role ) ; }
2814	public function getBlock ( $ blockName ) { if ( ! array_key_exists ( $ blockName , $ this -> blocks ) ) { throw new Exception ( 'Unable to find block with name ' . $ blockName ) ; } return $ this -> blocks [ $ blockName ] ; }
12495	public static function get ( Scope $ scope , $ connection , $ multiple , $ return = false ) { $ from = $ connection -> db ; if ( strpos ( $ from , '.' ) !== false ) { $ tmp = explode ( '.' , $ connection -> db ) ; $ from = end ( $ tmp ) ; } if ( ! is_null ( $ scope -> listWordsField ) ) { if ( $ scope -> listWordsField === '' ) { $ from = 'LIST_WORDS(' . $ from . ')' ; } else { $ from = 'LIST_WORDS(' . $ from . '.' . $ scope -> listWordsField . ')' ; } } if ( ! is_null ( $ scope -> alternativesField ) ) { if ( $ scope -> alternativesField === '' ) { $ from = 'ALTERNATIVES(' . $ from . ')' ; } else { $ from = 'ALTERNATIVES(' . $ from . '.' . $ scope -> alternativesField . ')' ; } } $ connection -> query = $ scope -> prepend . 'SELECT ' . $ scope -> select . ' FROM ' . $ from . ' ' ; if ( ! is_null ( $ scope -> join ) ) { $ connection -> query .= $ scope -> join . ' ' ; } if ( $ scope -> where != '' ) { $ connection -> query .= 'WHERE' . $ scope -> where ; } if ( count ( $ scope -> groupBy ) ) { $ connection -> query .= 'GROUP BY ' . implode ( ", " , $ scope -> groupBy ) . ' ' ; } if ( count ( $ scope -> orderBy ) ) { $ connection -> query .= 'ORDER BY ' . implode ( ", " , $ scope -> orderBy ) . ' ' ; } $ connection -> query .= 'LIMIT ' . $ scope -> offset . ', ' . $ scope -> limit ; if ( $ return ) { return $ connection -> query ; } $ connection -> method = 'POST' ; $ connection -> action = '/_query' ; $ connection -> multiple = $ multiple ; $ scope -> resetSelf ( ) ; return self :: sendQuery ( $ connection ) ; }
7476	public function getEntitiesByIds ( $ identifier , array $ values ) { $ accessor = PropertyAccess :: createPropertyAccessor ( ) ; return array_filter ( is_array ( $ this -> entities ) ? $ this -> entities : $ this -> entities -> toArray ( ) , function ( $ entity ) use ( $ identifier , $ values , $ accessor ) { return in_array ( $ accessor -> getValue ( $ entity , $ identifier ) , $ values ) ; } ) ; }
853	public function getNonEmptySibling ( $ index , $ direction ) { while ( true ) { $ index += $ direction ; if ( ! $ this -> offsetExists ( $ index ) ) { return null ; } if ( ! $ this -> isEmptyAt ( $ index ) ) { return $ index ; } } }
5017	public function logJobEnd ( ProcessJobEvent $ event ) : void { $ result = $ event -> getResult ( ) ; $ job = $ event -> getJob ( ) ; $ queue = $ event -> getQueue ( ) -> getName ( ) ; $ logger = $ this -> getLogger ( ) ; switch ( $ result ) { default : $ logger -> info ( sprintf ( $ this -> tmpl [ 'job' ] , $ queue , 'SUCCESS' , $ this -> formatJob ( $ job ) ) ) ; break ; case ProcessJobEvent :: JOB_STATUS_FAILURE_RECOVERABLE : $ logger -> warn ( sprintf ( $ this -> tmpl [ 'job' ] , $ queue , 'RECOVERABLE' , $ this -> formatJob ( $ job ) ) ) ; break ; case ProcessJobEvent :: JOB_STATUS_FAILURE : $ logger -> err ( sprintf ( $ this -> tmpl [ 'job' ] , $ queue , 'FAILURE' , $ this -> formatJob ( $ job ) ) ) ; break ; } }
10797	public function getCryptedPassword ( $ password ) { $ bcrypt = new Bcrypt ; $ bcrypt -> setCost ( $ this -> getOptions ( ) -> getPasswordCost ( ) ) ; return $ bcrypt -> create ( $ password ) ; }
6705	public function getWriterFactory ( ) { if ( ! $ this -> writerFactory ) { $ xmlFormatter = new Xml ( ) ; $ jsonFormatter = new Json ( ) ; $ this -> writerFactory = new WriterFactory ( [ 'xml' => $ xmlFormatter , 'text/xml' => $ xmlFormatter , 'application/xml' => $ xmlFormatter , 'json' => $ jsonFormatter , 'application/json' => $ jsonFormatter , ] ) ; } return $ this -> writerFactory ; }
2124	public function getFileUrls ( ) { $ return = array ( ) ; $ strTarget = substr ( $ this -> strMode , 1 ) ; foreach ( $ this -> arrFiles as $ arrFile ) { if ( $ arrFile [ 'extension' ] == self :: SCSS || $ arrFile [ 'extension' ] == self :: LESS ) { $ strPath = 'assets/' . $ strTarget . '/' . str_replace ( '/' , '_' , $ arrFile [ 'name' ] ) . $ this -> strMode ; if ( Config :: get ( 'debugMode' ) || ! file_exists ( $ this -> strRootDir . '/' . $ strPath ) ) { $ objFile = new File ( $ strPath ) ; $ objFile -> write ( $ this -> handleScssLess ( file_get_contents ( $ this -> strRootDir . '/' . $ arrFile [ 'name' ] ) , $ arrFile ) ) ; $ objFile -> close ( ) ; } $ return [ ] = $ strPath . '|' . $ arrFile [ 'version' ] ; } else { $ name = $ arrFile [ 'name' ] ; if ( strncmp ( $ name , $ this -> strWebDir . '/' , \ strlen ( $ this -> strWebDir ) + 1 ) === 0 ) { $ name = substr ( $ name , \ strlen ( $ this -> strWebDir ) + 1 ) ; } if ( $ this -> strMode == self :: CSS && $ arrFile [ 'media' ] != '' && $ arrFile [ 'media' ] != 'all' && ! $ this -> hasMediaTag ( $ arrFile [ 'name' ] ) ) { $ name .= '|' . $ arrFile [ 'media' ] ; } $ return [ ] = $ name . '|' . $ arrFile [ 'version' ] ; } } return $ return ; }
98	public function add ( $ prefix , $ paths , $ prepend = false ) { if ( ! $ prefix ) { if ( $ prepend ) { $ this -> fallbackDirsPsr0 = array_merge ( ( array ) $ paths , $ this -> fallbackDirsPsr0 ) ; } else { $ this -> fallbackDirsPsr0 = array_merge ( $ this -> fallbackDirsPsr0 , ( array ) $ paths ) ; } return ; } $ first = $ prefix [ 0 ] ; if ( ! isset ( $ this -> prefixesPsr0 [ $ first ] [ $ prefix ] ) ) { $ this -> prefixesPsr0 [ $ first ] [ $ prefix ] = ( array ) $ paths ; return ; } if ( $ prepend ) { $ this -> prefixesPsr0 [ $ first ] [ $ prefix ] = array_merge ( ( array ) $ paths , $ this -> prefixesPsr0 [ $ first ] [ $ prefix ] ) ; } else { $ this -> prefixesPsr0 [ $ first ] [ $ prefix ] = array_merge ( $ this -> prefixesPsr0 [ $ first ] [ $ prefix ] , ( array ) $ paths ) ; } }
5597	protected function createErrorQueue ( ) { $ context = SimpleTest :: getContext ( ) ; $ test = $ this -> getTestCase ( ) ; $ queue = $ context -> get ( 'SimpleErrorQueue' ) ; $ queue -> setTestCase ( $ test ) ; return $ queue ; }
965	public function dispatchScripttags ( ) { $ scripttags = Config :: get ( 'shopify-app.scripttags' ) ; if ( count ( $ scripttags ) > 0 ) { ScripttagInstaller :: dispatch ( $ this -> shop , $ scripttags ) -> onQueue ( Config :: get ( 'shopify-app.job_queues.scripttags' ) ) ; } }
11849	protected function getSettingsFromRealSource ( $ namespace ) { $ arraySettings = $ this -> getSettingsArray ( $ namespace ) ; $ namespaceOptions = $ this -> options -> getNamespaceOptions ( $ namespace ) ; $ entity = clone ( $ namespaceOptions -> getEntityPrototype ( ) ) ; if ( ! empty ( $ arraySettings ) ) { $ hydrator = $ this -> namespaceHydratorProvider -> getHydrator ( $ namespace ) ; $ entity = $ hydrator -> hydrate ( $ arraySettings , $ entity ) ; } return $ entity ; }
11608	public function actionConfirm ( $ id , $ code ) { $ user = $ this -> finder -> findUserById ( $ id ) ; if ( $ user === null || $ this -> module -> emailChangeStrategy == Module :: STRATEGY_INSECURE ) { throw new NotFoundHttpException ; } $ user -> attemptEmailChange ( $ code ) ; return $ this -> redirect ( [ 'account' ] ) ; }
12273	public static function cast ( $ date ) { return $ date instanceof self ? $ date : new self ( $ date -> format ( self :: ISO8601 ) , $ date -> getTimezone ( ) ) ; }
9564	protected function makeFatalErrorException ( ) { $ error = error_get_last ( ) ; if ( $ error !== null ) { return new FatalErrorException ( $ error [ 'message' ] , $ error [ 'type' ] , 0 , $ error [ 'file' ] , $ error [ 'line' ] ) ; } return null ; }
12572	public function previewImage ( $ message , $ to , $ by = self :: PREVIEW_BY_OPENID ) { return $ this -> preview ( self :: MSG_TYPE_IMAGE , $ message , $ to , $ by ) ; }
5016	public function logJobStart ( ProcessJobEvent $ event ) : void { $ queue = $ event -> getQueue ( ) ; $ job = $ event -> getJob ( ) ; $ logger = $ this -> getLogger ( ) ; $ logger -> info ( sprintf ( $ this -> tmpl [ 'job' ] , $ queue -> getName ( ) , 'START' , $ this -> formatJob ( $ job ) , '' ) ) ; $ this -> injectLoggerInObject ( $ job ) ; $ this -> injectLoggerInEvent ( $ event ) ; }
7601	protected function renderButtons ( array $ aButtons , $ bJustified = false ) { $ sMarkup = '' ; foreach ( $ aButtons as $ oButton ) { if ( is_array ( $ oButton ) || ( $ oButton instanceof Traversable && ! ( $ oButton instanceof ElementInterface ) ) ) { $ oFactory = new Factory ( ) ; $ oButton = $ oFactory -> create ( $ oButton ) ; } elseif ( ! ( $ oButton instanceof ElementInterface ) ) { throw new LogicException ( sprintf ( 'Button expects an instanceof Zend\Form\ElementInterface or an array / Traversable, "%s" given' , is_object ( $ oButton ) ? get_class ( $ oButton ) : gettype ( $ oButton ) ) ) ; } $ sButtonMarkup = $ this -> getFormElementHelper ( ) -> __invoke ( $ oButton ) ; $ sMarkup .= $ bJustified ? sprintf ( static :: $ buttonGroupJustifiedFormat , $ sButtonMarkup ) : $ sButtonMarkup ; } return $ sMarkup ; }
1766	public function onKernelResponse ( FilterResponseEvent $ event ) : void { if ( ! $ this -> scopeMatcher -> isContaoMasterRequest ( $ event ) ) { return ; } $ request = $ event -> getRequest ( ) ; if ( ! $ request -> isMethod ( Request :: METHOD_GET ) ) { return ; } $ response = $ event -> getResponse ( ) ; if ( 200 !== $ response -> getStatusCode ( ) ) { return ; } $ token = $ this -> tokenStorage -> getToken ( ) ; if ( null === $ token || $ this -> authenticationTrustResolver -> isAnonymous ( $ token ) ) { return ; } if ( $ this -> scopeMatcher -> isBackendRequest ( $ request ) ) { $ this -> storeBackendReferer ( $ request ) ; } else { $ this -> storeFrontendReferer ( $ request ) ; } }
9890	public static function xml ( $ response ) { $ body = self :: toString ( $ response ) ; $ errorMessage = null ; $ internalErrors = libxml_use_internal_errors ( true ) ; $ disableEntities = libxml_disable_entity_loader ( true ) ; libxml_clear_errors ( ) ; $ xml = null ; try { $ xml = new \ SimpleXMLElement ( ( string ) $ body ? : '<root />' , LIBXML_NONET ) ; } catch ( \ Exception $ e ) { $ errorMessage = $ e -> getMessage ( ) ; } libxml_clear_errors ( ) ; libxml_use_internal_errors ( $ internalErrors ) ; libxml_disable_entity_loader ( $ disableEntities ) ; if ( $ errorMessage !== null ) { throw new RuntimeException ( 'Unable to parse response body into XML: ' . $ errorMessage ) ; } return $ xml ; }
7341	protected function assertDeletable ( ResourceInterface $ resource ) { if ( $ resource instanceof Model \ SupplierOrderItemInterface ) { if ( null === $ stockUnit = $ resource -> getStockUnit ( ) ) { return ; } if ( 0 < $ stockUnit -> getShippedQuantity ( ) ) { throw new Exception \ IllegalOperationException ( "Supplier delivery can't be removed as at least one " . "of its items is linked to a shipped stock unit." ) ; } } elseif ( $ resource instanceof Model \ SupplierOrderInterface ) { foreach ( $ resource -> getItems ( ) as $ item ) { $ this -> assertDeletable ( $ item ) ; } } elseif ( $ resource instanceof Model \ SupplierDeliveryItemInterface ) { $ this -> assertDeletable ( $ resource -> getOrderItem ( ) ) ; } elseif ( $ resource instanceof Model \ SupplierDeliveryInterface ) { foreach ( $ resource -> getItems ( ) as $ item ) { $ this -> assertDeletable ( $ item ) ; } } else { throw new Exception \ InvalidArgumentException ( "Unexpected resource." ) ; } }
7866	protected function drawBorderTop ( $ isCore = false ) { $ crossroads = $ isCore ? static :: CROSSROADS_UP : static :: CROSSROADS ; $ this -> drawBorder ( static :: BORDER_NW , $ crossroads , static :: BORDER_NE ) ; $ this -> geometry -> increaseNesting ( ) ; }
9930	public function setFilterType ( $ pFilterType ) { if ( ! in_array ( $ pFilterType , self :: $ filterTypes ) ) { throw new PhpSpreadsheetException ( 'Invalid filter type for column AutoFilter.' ) ; } $ this -> filterType = $ pFilterType ; return $ this ; }
7824	public function getHalfWidth ( $ up = false ) { $ number = $ this -> getTotalWidth ( ) ; return $ this -> roundHalf ( $ number , $ up ) ; }
8106	protected function getEmailBody ( $ config , $ variables ) { $ template = SSViewer :: fromString ( $ config -> ReviewBody ) ; $ value = $ template -> process ( ArrayData :: create ( $ variables ) ) ; return DBField :: create_field ( 'HTMLText' , ( string ) $ value ) ; }
3225	function createFolder ( $ path ) { Path :: checkArgNonRoot ( "path" , $ path ) ; $ response = $ this -> doPost ( $ this -> apiHost , "1/fileops/create_folder" , array ( "root" => "auto" , "path" => $ path , ) ) ; if ( $ response -> statusCode === 403 ) return null ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; return RequestUtil :: parseResponseJson ( $ response -> body ) ; }
8065	protected function getNextFreeWorker ( ) { $ sec = 0 ; while ( TRUE ) { $ this -> collectWorkerResults ( $ sec ) ; $ freeProcess = $ this -> workerProcesses -> takeFreeProcess ( ) ; if ( $ freeProcess !== NULL ) { return $ freeProcess ; } $ sec = $ this -> child_timeout_sec ; if ( $ this -> workerPoolSize <= 0 ) { throw new WorkerPoolException ( 'All workers were gone.' ) ; } } return NULL ; }
11066	public function addMethods ( $ mixin , array $ methods ) { foreach ( $ methods as $ method ) { $ this -> method_map [ $ method ] = $ mixin ; } return $ this ; }
2426	protected static function isFileSyncExclude ( $ strPath ) { if ( Config :: get ( 'uploadPath' ) == 'templates' ) { return true ; } $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; while ( $ strPath != '.' && ! is_dir ( $ rootDir . '/' . $ strPath ) ) { $ strPath = \ dirname ( $ strPath ) ; } if ( $ strPath == '.' ) { return true ; } $ uploadPath = System :: getContainer ( ) -> getParameter ( 'contao.upload_path' ) ; if ( strncmp ( $ strPath . '/' , $ uploadPath . '/' , \ strlen ( $ uploadPath ) + 1 ) !== 0 ) { return true ; } return ( new Folder ( $ strPath ) ) -> isUnsynchronized ( ) ; }
10350	protected function validate ( ) { $ this -> validateArgSet ( $ this -> args ) ; if ( $ this -> success ) { $ this -> validateArgSet ( $ this -> successArgs ) ; } if ( ! $ this -> success ) { $ this -> validateArgSet ( $ this -> failureArgs ) ; } }
7252	protected function validatePaymentTermAndOutstandingLimit ( SaleInterface $ sale , Constraint $ constraint ) { if ( 0 >= $ sale -> getOutstandingLimit ( ) ) { return ; } if ( null === $ term = $ sale -> getPaymentTerm ( ) ) { if ( null !== $ customer = $ sale -> getCustomer ( ) ) { if ( $ customer -> hasParent ( ) ) { $ term = $ customer -> getParent ( ) -> getPaymentTerm ( ) ; } else { $ term = $ customer -> getPaymentTerm ( ) ; } } } if ( null === $ term ) { $ this -> context -> buildViolation ( $ constraint -> outstanding_limit_require_term ) -> atPath ( 'outstandingLimit' ) -> addViolation ( ) ; } }
5402	public function isExpired ( $ now ) { if ( ! $ this -> expiry ) { return true ; } if ( is_string ( $ now ) ) { $ now = strtotime ( $ now ) ; } return ( $ this -> expiry < $ now ) ; }
4197	public function onStart ( Event $ event ) { $ obj = $ event -> getSubject ( ) ; if ( $ obj instanceof \ DateTime || $ obj instanceof \ DateTimeImmutable ) { $ event [ 'stringified' ] = $ obj -> format ( \ DateTime :: ISO8601 ) ; } elseif ( $ obj instanceof \ mysqli && ( $ obj -> connect_errno || ! $ obj -> stat ) ) { $ event [ 'collectPropertyValues' ] = false ; } }
7722	function meth_Misc_Alert ( $ Src , $ Msg , $ NoErrMsg = false , $ SrcType = false ) { $ this -> ErrCount ++ ; if ( $ this -> NoErr || ( php_sapi_name === 'cli' ) ) { $ t = array ( '' , '' , '' , '' , '' ) ; } else { $ t = array ( '<br /><b>' , '</b>' , '<em>' , '</em>' , '<br />' ) ; $ Msg = htmlentities ( $ Msg ) ; } if ( ! is_string ( $ Src ) ) { if ( $ SrcType === false ) $ SrcType = 'in field' ; if ( isset ( $ Src -> PrmLst [ 'tbstype' ] ) ) { $ Msg = 'Column \'' . $ Src -> SubName . '\' is expected but missing in the current record.' ; $ Src = 'Parameter \'' . $ Src -> PrmLst [ 'tbstype' ] . '=' . $ Src -> SubName . '\'' ; $ NoErrMsg = false ; } else { $ Src = $ SrcType . ' ' . $ this -> _ChrOpen . $ Src -> FullName . '...' . $ this -> _ChrClose ; } } $ x = $ t [ 0 ] . 'TinyButStrong Error' . $ t [ 1 ] . ' ' . $ Src . ': ' . $ Msg ; if ( $ NoErrMsg ) $ x = $ x . ' ' . $ t [ 2 ] . 'This message can be cancelled using parameter \'noerr\'.' . $ t [ 3 ] ; $ x = $ x . $ t [ 4 ] . "\n" ; if ( $ this -> NoErr ) { $ this -> ErrMsg .= $ x ; } else { if ( php_sapi_name !== 'cli' ) { $ x = str_replace ( $ this -> _ChrOpen , $ this -> _ChrProtect , $ x ) ; } echo $ x ; } return false ; }
7062	protected function updateCustomerBalance ( PaymentInterface $ payment , $ amount = null ) { if ( null === $ customer = $ payment -> getSale ( ) -> getCustomer ( ) ) { return false ; } $ amount = $ amount ? : $ payment -> getAmount ( ) ; if ( $ this -> isAcceptedPayment ( $ payment ) ) { $ amount = - $ amount ; } if ( $ payment -> getMethod ( ) -> isCredit ( ) ) { return $ this -> updateCreditBalance ( $ customer , $ amount , true ) ; } elseif ( $ payment -> getMethod ( ) -> isOutstanding ( ) ) { return $ this -> updateOutstandingBalance ( $ customer , $ amount , true ) ; } return false ; }
4753	private function getContactFormMethod ( ) { $ method = self :: CONTACT_FORM_METHOD_DEFAULT ; if ( $ configMethod = \ OxidEsales \ Eshop \ Core \ Registry :: getConfig ( ) -> getConfigParam ( 'OeGdprOptinContactFormMethod' ) ) { $ method = $ configMethod ; } return $ method ; }
642	public function createIndex ( $ name , $ table , $ columns , $ unique = false ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> createIndex ( $ name , $ table , $ columns , $ unique ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
8352	public function handle ( int $ signal ) { if ( isset ( $ this -> handlers [ $ signal ] ) && $ this -> handlers [ $ signal ] === true ) { return new Failure ( new Exception ( 'Signal is already being processed.' ) ) ; } $ this -> handlers [ $ signal ] = true ; $ this -> dispatcher -> setIsRunning ( false ) ; $ fn = $ this -> signals [ $ signal ] ; $ result = $ this -> $ fn ( ) ; if ( $ result === true ) { unset ( $ this -> handlers [ $ signal ] ) ; return new Success ( $ result ) ; } $ deferred = new Deferred ; Loop :: repeat ( 1000 , function ( $ watcherId , $ callback ) use ( $ deferred , $ signal , $ result ) { if ( count ( $ this -> dispatcher -> getProcesses ( ) ) === 0 ) { Loop :: cancel ( $ watcherId ) ; unset ( $ this -> handlers [ $ signal ] ) ; return $ deferred -> resolve ( $ result ) ; } } ) ; return $ deferred -> promise ( ) ; }
6464	public function isJson ( HttpHeaders $ headers ) : bool { $ contentType = null ; $ headers -> tryGetFirst ( 'Content-Type' , $ contentType ) ; return preg_match ( "/application\/json/i" , $ contentType ) === 1 ; }
11410	public function update ( $ tagId , $ name ) { $ params = [ 'tag' => [ 'id' => $ tagId , 'name' => $ name , ] , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_UPDATE , $ params ] ) ; }
12469	protected function replaceNamespace ( $ path ) { $ search = [ 'namespace ' . $ this -> currentRoot . ';' , $ this -> currentRoot . '\\' ] ; $ replace = [ 'namespace ' . $ this -> argument ( 'name' ) . ';' , $ this -> argument ( 'name' ) . '\\' ] ; $ this -> replaceIn ( $ path , $ search , $ replace ) ; }
6376	public function sorted ( Comparator $ comparator ) : FluentIterable { $ array = $ this -> toArray ( ) ; Arrays :: sort ( $ array , $ comparator ) ; return self :: of ( $ array ) ; }
10290	protected function storeLastRun ( ) { if ( ! @ file_put_contents ( $ this -> lockDir . '/lastRun' , time ( ) ) ) { $ this -> logger -> log ( 'Failure storing last run time: ' . ( isset ( $ php_errormsg ) ? $ php_errormsg : 'Unknown error - enable the track_errors ini directive.' ) , Logger :: ERROR ) ; return ; } $ this -> logger -> log ( 'Stored last run time.' , Logger :: INFO ) ; }
9393	public function withStatus ( $ code , $ reason = '' ) { $ static = clone $ this ; $ static -> code = $ code ; $ static -> reason = $ reason ? : $ static -> codes [ $ code ] ; return $ static ; }
9868	private function writePrintOptions ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { $ objWriter -> startElement ( 'printOptions' ) ; $ objWriter -> writeAttribute ( 'gridLines' , ( $ pSheet -> getPrintGridlines ( ) ? 'true' : 'false' ) ) ; $ objWriter -> writeAttribute ( 'gridLinesSet' , 'true' ) ; if ( $ pSheet -> getPageSetup ( ) -> getHorizontalCentered ( ) ) { $ objWriter -> writeAttribute ( 'horizontalCentered' , 'true' ) ; } if ( $ pSheet -> getPageSetup ( ) -> getVerticalCentered ( ) ) { $ objWriter -> writeAttribute ( 'verticalCentered' , 'true' ) ; } $ objWriter -> endElement ( ) ; }
9139	public static function parse ( $ uri , $ serverVars = array ( ) , $ defaultController = 'Index' , $ defaultAction = 'index' ) { $ req = new self ( $ defaultController , $ defaultAction ) ; $ req -> origin = $ uri ; self :: parseRemoteHost ( $ req , $ serverVars ) ; self :: parseGetPostSessionCookie ( $ req ) ; $ savedRequestParams = array ( ) ; if ( strpos ( $ uri , '?' ) ) { parse_str ( substr ( $ uri , strpos ( $ uri , '?' ) + 1 ) , $ savedRequestParams ) ; $ uri = substr ( $ uri , 0 , strpos ( $ uri , '?' ) ) ; } self :: parseContextPrefix ( $ req , $ serverVars ) ; $ parts = self :: parseUri ( $ req , $ uri , $ defaultController , $ defaultAction ) ; $ numParts = count ( $ parts ) ; for ( $ i = 0 ; $ i < $ numParts ; $ i = $ i + 2 ) { $ paramName = trim ( $ parts [ $ i ] ) ; $ paramValue = isset ( $ parts [ $ i + 1 ] ) ? trim ( $ parts [ $ i + 1 ] ) : '' ; if ( $ paramName && $ paramValue ) { $ req -> params [ $ paramName ] = $ paramValue ; } } $ req -> params = array_merge ( $ req -> params , $ savedRequestParams ) ; self :: parseParameters ( $ req , $ serverVars ) ; return $ req ; }
9119	public function registerController ( $ controller , $ applicationName = 'default' ) { if ( ! $ controller instanceof \ Nkey \ Caribu \ Mvc \ Controller \ AbstractController ) { if ( ! class_exists ( $ controller ) ) { throw new ControllerException ( "No such controller class {controller} found" , array ( 'controller' => $ controller ) ) ; } $ c = new $ controller ( ) ; if ( ! ( $ c instanceof AbstractController ) ) { throw new ControllerException ( "Controller {controller} is not in application scope" , array ( 'controller' => $ controller ) ) ; } } else { $ c = $ controller ; } $ settings = $ c -> getControllerSettings ( ) ; $ this -> controllers [ $ applicationName ] [ $ settings -> getControllerSimpleName ( ) ] = $ settings ; return $ this ; }
6940	private function pop ( array & $ list , $ oid , StockUnitInterface $ unit ) { if ( false !== $ index = $ this -> find ( $ list , $ oid , $ unit ) ) { unset ( $ list [ $ oid ] [ $ index ] ) ; if ( empty ( $ list [ $ oid ] ) ) { unset ( $ list [ $ oid ] ) ; } } }
9958	public function unprotectCells ( $ pRange ) { $ pRange = strtoupper ( $ pRange ) ; if ( isset ( $ this -> protectedCells [ $ pRange ] ) ) { unset ( $ this -> protectedCells [ $ pRange ] ) ; } else { throw new Exception ( 'Cell range ' . $ pRange . ' not known as protected.' ) ; } return $ this ; }
2886	public function onActionPreDispatch ( Varien_Event_Observer $ observer ) { if ( ! $ this -> canCollect ( ) ) { return ; } $ action = $ observer -> getData ( 'controller_action' ) ; $ this -> getRequestInfo ( ) -> initController ( $ action ) ; }
6298	public function addToMain ( array $ item , $ name = 'default' , $ first = false ) { if ( ! array_key_exists ( $ name , $ this -> main ) ) { $ this -> main [ $ name ] = [ ] ; } if ( $ first ) { $ this -> main [ $ name ] = array_merge ( [ $ item ] , $ this -> main [ $ name ] ) ; } else { $ this -> main [ $ name ] [ ] = $ item ; } return $ this ; }
11931	protected function generateField ( $ fieldType , $ fieldId , array $ labels ) { $ field = new FieldType ( ) ; $ field -> setType ( $ fieldType ) ; $ field -> setFieldId ( $ fieldId ) ; $ field -> setDefaultValue ( null ) ; $ field -> setSearchable ( true ) ; $ field -> setLabels ( $ labels ) ; return $ field ; }
4272	public function stream_close ( ) { if ( ! $ this -> handle ) { return ; } self :: restorePrev ( ) ; \ fclose ( $ this -> handle ) ; $ this -> handle = null ; self :: register ( ) ; }
6256	public function searchPickupPointsByText ( $ query_text , $ service_provider = null , $ limit = 5 ) { if ( $ query_text == null || trim ( $ query_text ) == '' ) { return '[]' ; } $ post_params = array ( 'query' => ( string ) $ query_text , 'service_provider' => ( string ) $ service_provider , 'limit' => ( int ) $ limit ) ; return $ this -> doPost ( '/pickup-points/search' , $ post_params ) ; }
8279	public function onRequestFile ( & $ file ) { if ( $ this -> errorOccurred ) { $ file = $ this -> requestFile ; return ; } try { $ realUrl = ( $ this -> requestFile ) ? $ this -> requestUrl : $ this -> resolveRealUrl ( $ file ) ; if ( ! in_array ( $ realUrl , $ this -> alwaysAllowed , true ) ) { $ this -> triggerEvent ( 'denyAccessIfRestricted' , [ $ realUrl ] ) ; } } catch ( \ Exception $ e ) { $ realUrl = ( isset ( $ realUrl ) ) ? $ realUrl : "" ; $ this -> errorHandler ( $ e , $ realUrl ) ; } if ( $ this -> requestFile ) { $ file = $ this -> requestFile ; } else { switch ( $ this -> requestUrl ) { case 'login' : $ file = $ this -> pluginDir . '/content/login.md' ; break ; case 'logout' : $ file = $ this -> pluginDir . '/content/logout.md' ; break ; } } }
6341	final public static function init ( ) : void { $ className = static :: class ; self :: $ cache [ $ className ] = [ ] ; $ reflectionClass = self :: objectClass ( ) ; $ constructorParams = static :: constructorArgs ( ) ; $ ordinal = 0 ; foreach ( $ reflectionClass -> getProperties ( ReflectionProperty :: IS_STATIC ) as $ property ) { if ( $ property -> isPublic ( ) ) { $ name = $ property -> getName ( ) ; $ instance = self :: newInstance ( $ name , $ constructorParams ) ; $ property -> setValue ( $ instance ) ; self :: $ cache [ $ className ] [ $ name ] = $ instance ; self :: $ ordinals [ $ className ] [ $ name ] = $ ordinal ++ ; } } }
12722	protected function turnIntoResolvableClosure ( $ abstract , $ concrete ) { return function ( Container $ container , $ parameters = [ ] ) use ( $ abstract , $ concrete ) { return ( $ abstract == $ concrete ? $ container -> resolve ( $ abstract ) : $ container -> resolve ( $ concrete , $ parameters ) ) ; } ; }
6001	public function addImageTemplate ( $ item ) { if ( ! ( $ item instanceof ImageTemplate ) ) { if ( is_array ( $ item ) ) { try { $ item = new ImageTemplate ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate ImageTemplate. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "ImageTemplate"!' , E_USER_WARNING ) ; } } $ this -> imagetemplates [ ] = $ item ; return $ this ; }
2592	public static function createRequestCreator ( $ params , $ libIdentifier ) { $ params -> receivedFrom = self :: makeReceivedFrom ( $ params -> receivedFrom , $ libIdentifier ) ; $ theRequestCreator = new Base ( $ params ) ; return $ theRequestCreator ; }
9359	protected function finalize ( $ function ) { $ response = $ this -> container -> get ( self :: RESPONSE ) ; if ( is_string ( $ function ) === true ) { $ stream = $ response -> getBody ( ) ; $ stream -> write ( ( string ) $ function ) ; } $ instanceof = $ function instanceof ResponseInterface ; return $ instanceof ? $ function : $ response ; }
11753	public function close ( $ msgId , $ index ) { $ params = [ 'msg_data_id' => $ msgId , 'index' => $ index , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_CLOSE_COMMENT , $ params ] ) ; }
11298	public function getModelsFromCustomRelationship ( $ attributeName , $ objName , $ query = false , $ loadMap = false ) { $ repo = \ Cora \ RepositoryFactory :: make ( $ objName , false , false , false , $ this -> model_db ) ; if ( ! $ query ) $ query = $ this -> _getQueryObjectForRelation ( $ attributeName ) ; $ definingFunctionName = $ this -> model_attributes [ $ attributeName ] [ 'using' ] ; $ query = $ this -> $ definingFunctionName ( $ query ) ; return $ repo -> findAll ( $ query , false , $ loadMap ) ; }
9826	private function writeRelationship ( XMLWriter $ objWriter , $ pId , $ pType , $ pTarget , $ pTargetMode = '' ) { if ( $ pType != '' && $ pTarget != '' ) { $ objWriter -> startElement ( 'Relationship' ) ; $ objWriter -> writeAttribute ( 'Id' , 'rId' . $ pId ) ; $ objWriter -> writeAttribute ( 'Type' , $ pType ) ; $ objWriter -> writeAttribute ( 'Target' , $ pTarget ) ; if ( $ pTargetMode != '' ) { $ objWriter -> writeAttribute ( 'TargetMode' , $ pTargetMode ) ; } $ objWriter -> endElement ( ) ; } else { throw new WriterException ( 'Invalid parameters passed.' ) ; } }
5354	public function getAuthenticationData ( $ method ) { if ( ! $ this -> supportsAuthentication ( $ method ) ) { return null ; } $ authentication = $ this -> getSupportedAuthentication ( ) ; return $ authentication [ $ method ] ; }
6768	protected function handleContentChange ( SaleInterface $ sale ) { $ changed = $ this -> saleUpdater -> updateShipmentMethodAndAmount ( $ sale ) ; if ( $ this -> isShipmentTaxationUpdateNeeded ( $ sale ) ) { $ changed = $ this -> saleUpdater -> updateShipmentTaxation ( $ sale , true ) ; } $ changed |= $ this -> saleUpdater -> updateTotals ( $ sale ) ; $ changed |= $ this -> updateState ( $ sale ) ; $ changed |= $ this -> saleUpdater -> updateOutstandingDate ( $ sale ) ; return $ changed ; }
9776	function throw ( string $ className = '' ) : self { if ( ! is_callable ( $ this -> target ) ) throw new \ BadMethodCallException ( 'The function target is not callable.' ) ; $ exception = null ; try { call_user_func ( $ this -> target ) ; } catch ( \ Throwable $ e ) { $ exception = $ e ; } $ constraint = logicalNot ( isNull ( ) ) ; return $ this -> expect ( $ exception , mb_strlen ( $ className ) ? logicalAnd ( $ constraint , isInstanceOf ( $ className ) ) : $ constraint ) ; }
3347	public function __preparedRequest ( $ type , $ request_type = 'GET' , $ params = array ( ) , $ data = array ( ) , $ retry_throttled = null ) { $ retry_throttled = $ retry_throttled ? : $ this -> retry_throttled ; $ path = $ this -> __getPath ( $ type , $ params ) ; while ( true ) { try { return $ this -> request ( $ request_type , $ path , $ data ) ; } catch ( ThrottledRequestException $ exception ) { if ( $ retry_throttled > 0 ) { sleep ( $ exception -> getTimeout ( ) ) ; $ retry_throttled -- ; continue ; } else { throw $ exception ; } } } return null ; }
4358	protected function processSubstitutions ( $ args , & $ hasSubs ) { $ subRegex = '/%' . '(?:' . '[coO]|' . '[+-]?' . '(?:[ 0]|\'.{1})?' . '-?' . '\d*' . '(?:\.\d+)?' . '[difs]' . ')' . '/' ; if ( ! \ is_string ( $ args [ 0 ] ) ) { return $ args ; } $ index = 0 ; $ indexes = array ( 'c' => array ( ) , ) ; $ hasSubs = false ; $ args [ 0 ] = \ preg_replace_callback ( $ subRegex , function ( $ matches ) use ( & $ args , & $ hasSubs , & $ index , & $ indexes ) { $ hasSubs = true ; $ index ++ ; $ replacement = $ matches [ 0 ] ; $ type = \ substr ( $ matches [ 0 ] , - 1 ) ; if ( \ strpos ( 'difs' , $ type ) !== false ) { $ format = $ matches [ 0 ] ; $ sub = $ args [ $ index ] ; if ( $ type == 'i' ) { $ format = \ substr_replace ( $ format , 'd' , - 1 , 1 ) ; } elseif ( $ type === 's' ) { $ sub = $ this -> substitutionAsString ( $ sub ) ; } $ replacement = \ sprintf ( $ format , $ sub ) ; } elseif ( $ type === 'c' ) { $ asHtml = \ get_called_class ( ) == __NAMESPACE__ . '\\Html' ; if ( ! $ asHtml ) { return '' ; } $ replacement = '' ; if ( $ indexes [ 'c' ] ) { $ replacement = '</span>' ; } $ replacement .= '<span' . $ this -> debug -> utilities -> buildAttribString ( array ( 'style' => $ args [ $ index ] , ) ) . '>' ; $ indexes [ 'c' ] [ ] = $ index ; } elseif ( \ strpos ( 'oO' , $ type ) !== false ) { $ replacement = $ this -> dump ( $ args [ $ index ] ) ; } return $ replacement ; } , $ args [ 0 ] ) ; if ( $ indexes [ 'c' ] ) { $ args [ 0 ] .= '</span>' ; } if ( $ hasSubs ) { $ args = array ( $ args [ 0 ] ) ; } return $ args ; }
977	protected function getUrlFromName ( string $ name ) { if ( Str :: endsWith ( $ name , 'Job' ) ) { $ name = substr ( $ name , 0 , - 3 ) ; } return strtolower ( preg_replace ( '/(?<!^)[A-Z]/' , '-$0' , $ name ) ) ; }
12479	private function generateOptions ( $ folder , $ rootAlias ) { $ assetsPath = $ this -> configurationHandler -> uploadAssetsDir ( ) . '/' . $ folder ; if ( ! is_dir ( $ assetsPath ) ) { @ mkdir ( $ assetsPath ) ; } $ options = array ( 'locale' => '' , 'roots' => array ( array ( 'driver' => 'LocalFileSystem' , 'path' => $ assetsPath , 'URL' => $ this -> configurationHandler -> absoluteUploadAssetsDir ( ) . '/' . $ folder , 'accessControl' => 'access' , 'rootAlias' => $ rootAlias ) ) ) ; return $ options ; }
4736	public function process ( ContainerBuilder $ container ) { $ serviceId = 'simple_bus.asynchronous.publishes_predefined_messages_middleware' ; if ( ! $ container -> hasDefinition ( $ serviceId ) ) { return ; } $ names = array ( ) ; $ this -> collectServiceIds ( $ container , 'asynchronous_event_subscriber' , 'subscribes_to' , function ( $ key ) use ( & $ names ) { $ names [ ] = $ key ; } ) ; $ container -> getDefinition ( $ serviceId ) -> replaceArgument ( 2 , array_unique ( $ names ) ) ; }
5563	protected function load ( $ url , $ parameters ) { $ frame = $ url -> getTarget ( ) ; if ( ! $ frame || ! $ this -> page -> hasFrames ( ) || ( strtolower ( $ frame ) == '_top' ) ) { return $ this -> loadPage ( $ url , $ parameters ) ; } return $ this -> loadFrame ( array ( $ frame ) , $ url , $ parameters ) ; }
5833	protected function headerToArray ( $ header ) { $ tmp = explode ( "\r\n" , $ header ) ; $ headers = array ( ) ; foreach ( $ tmp as $ singleHeader ) { $ delimiter = strpos ( $ singleHeader , ': ' ) ; if ( $ delimiter !== false ) { $ key = substr ( $ singleHeader , 0 , $ delimiter ) ; $ val = substr ( $ singleHeader , $ delimiter + 2 ) ; $ headers [ $ key ] = $ val ; } else { $ delimiter = strpos ( $ singleHeader , ' ' ) ; if ( $ delimiter !== false ) { $ key = substr ( $ singleHeader , 0 , $ delimiter ) ; $ val = substr ( $ singleHeader , $ delimiter + 1 ) ; $ headers [ $ key ] = $ val ; } } } return $ headers ; }
133	public function getInstaller ( $ type ) { $ type = strtolower ( $ type ) ; if ( isset ( $ this -> cache [ $ type ] ) ) { return $ this -> cache [ $ type ] ; } foreach ( $ this -> installers as $ installer ) { if ( $ installer -> supports ( $ type ) ) { return $ this -> cache [ $ type ] = $ installer ; } } throw new \ InvalidArgumentException ( 'Unknown installer type: ' . $ type ) ; }
6536	protected function retrieve ( ) { if ( false === $ this -> retrieved ) { $ this -> updatedDatas = $ this -> getArray ( ) ; $ this -> retrieved = true ; } }
11940	public function getUrl ( string $ sCode , array $ aParams = array ( ) ) : string { if ( isset ( $ _SERVER ) && isset ( $ _SERVER [ 'HTTP_HOST' ] ) ) { foreach ( Config :: get ( 'route' ) as $ sHost => $ oHost ) { if ( ( ! strstr ( $ sHost , '/' ) && $ sHost == $ _SERVER [ 'HTTP_HOST' ] ) || ( strstr ( $ sHost , '/' ) && strstr ( $ _SERVER [ 'HTTP_HOST' ] . $ _SERVER [ 'REQUEST_URI' ] , $ sHost ) ) ) { if ( strstr ( $ sHost , '/' ) && strstr ( $ _SERVER [ 'HTTP_HOST' ] . $ _SERVER [ 'REQUEST_URI' ] , $ sHost ) ) { $ this -> _sBaseUri = preg_replace ( '#^[^/]+#' , '' , $ sHost ) ; } if ( isset ( $ oHost -> routes ) ) { foreach ( $ oHost -> routes as $ sKey => $ oRoute ) { if ( $ sKey === $ sCode ) { $ sRoute = $ this -> _sBaseUri . $ oRoute -> route ; if ( isset ( $ oRoute -> constraints ) ) { foreach ( $ oRoute -> constraints as $ sName => $ sType ) { if ( ! isset ( $ aParams [ $ sName ] ) ) { $ aParams [ $ sName ] = '' ; } if ( preg_match ( '#' . $ sType . '#' , $ aParams [ $ sName ] ) ) { if ( $ aParams [ $ sName ] ) { $ sRoute = str_replace ( '[/:' . $ sName . ']' , '/' . $ aParams [ $ sName ] , $ sRoute ) ; } else { $ sRoute = str_replace ( '[/:' . $ sName . ']' , '' , $ sRoute ) ; } $ sRoute = str_replace ( '[:' . $ sName . ']' , $ aParams [ $ sName ] , $ sRoute ) ; continue ; } else if ( isset ( $ oRoute -> defaults_constraints ) && isset ( $ oRoute -> defaults_constraints -> { $ sName } ) && preg_match ( '#' . $ sType . '#' , $ oRoute -> defaults_constraints -> { $ sName } ) ) { continue ; } throw new \ Exception ( 'For the route ' . $ sCode . ' the parameter ' . $ sName . ' is not good!' ) ; } } return $ sRoute ; } } } } } } }
288	protected function negotiateLanguage ( $ request ) { if ( ! empty ( $ this -> languageParam ) && ( $ language = $ request -> get ( $ this -> languageParam ) ) !== null ) { if ( is_array ( $ language ) ) { return reset ( $ this -> languages ) ; } if ( isset ( $ this -> languages [ $ language ] ) ) { return $ this -> languages [ $ language ] ; } foreach ( $ this -> languages as $ key => $ supported ) { if ( is_int ( $ key ) && $ this -> isLanguageSupported ( $ language , $ supported ) ) { return $ supported ; } } return reset ( $ this -> languages ) ; } foreach ( $ request -> getAcceptableLanguages ( ) as $ language ) { if ( isset ( $ this -> languages [ $ language ] ) ) { return $ this -> languages [ $ language ] ; } foreach ( $ this -> languages as $ key => $ supported ) { if ( is_int ( $ key ) && $ this -> isLanguageSupported ( $ language , $ supported ) ) { return $ supported ; } } } return reset ( $ this -> languages ) ; }
12840	static public function getMimeType ( $ filePath , $ default = 'application/octet-stream' ) { $ mimeType = finfo_file ( finfo_open ( FILEINFO_MIME_TYPE ) , $ filePath ) ; if ( $ mimeType === false ) { $ mimeType = $ default ; } return $ mimeType ; }
11068	public function sendMessage ( Message $ message ) { $ exceptions = [ ] ; foreach ( $ this -> gateways as $ gatewayName => $ gateway ) { try { $ gateway -> sendMessage ( $ message ) ; return ; } catch ( GatewayException $ e ) { $ exceptions [ $ gatewayName ] = $ e ; $ this -> logger -> warning ( sprintf ( '(Cascade gateway: %s) %s' , $ gatewayName , $ e -> getMessage ( ) ) , [ 'exception' => $ e ] ) ; } } throw new CascadeGatewayException ( $ exceptions ) ; }
9165	public function fields ( $ entity = array ( ) , $ action = 'all' , array $ params = array ( ) ) { $ fieldCollection = array ( ) ; $ entity = $ this -> entityFactory -> build ( $ entity ) ; if ( $ entity instanceof \ ElggEntity ) { $ params [ 'entity' ] = $ entity ; $ fields = ( array ) elgg_trigger_plugin_hook ( 'prototype' , $ action , $ params , array ( ) ) ; $ attribute_names = $ this -> entityFactory -> getAttributeNames ( $ entity ) ; if ( ! $ entity -> guid ) { $ fields [ 'type' ] = array ( 'type' => 'hidden' ) ; $ fields [ 'subtype' ] = array ( 'type' => 'hidden' ) ; $ fields [ 'owner_guid' ] = array ( 'type' => 'hidden' ) ; $ fields [ 'container_guid' ] = array ( 'type' => 'hidden' ) ; } else { $ fields [ 'guid' ] = array ( 'type' => 'hidden' ) ; } foreach ( $ fields as $ shortname => $ field ) { $ field [ 'entity_type' ] = $ entity -> getType ( ) ; $ field [ 'entity_subtype' ] = $ entity -> getSubtype ( ) ; if ( empty ( $ field [ 'shortname' ] ) ) { $ field [ 'shortname' ] = $ shortname ; } if ( in_array ( $ shortname , $ attribute_names ) ) { $ field [ 'data_type' ] = 'attribute' ; $ field [ 'class_name' ] = Elements \ AttributeField :: CLASSNAME ; } $ fieldObj = $ this -> fieldFactory -> build ( $ field ) ; if ( $ fieldObj instanceof Elements \ Field ) { $ fieldCollection [ ] = $ fieldObj ; } } } return new Elements \ FieldCollection ( $ fieldCollection ) ; }
4094	public function query ( array $ options = array ( ) ) { if ( ! ( $ this -> query instanceof Query ) ) $ this -> query = new Query ( $ options ) ; return $ this -> query ; }
383	public function getExceptionName ( $ exception ) { if ( $ exception instanceof \ yii \ base \ Exception || $ exception instanceof \ yii \ base \ InvalidCallException || $ exception instanceof \ yii \ base \ InvalidParamException || $ exception instanceof \ yii \ base \ UnknownMethodException ) { return $ exception -> getName ( ) ; } return null ; }
8159	public function getIsStatus ( ) { switch ( $ this -> status ) { case User :: STATUS_PENDING : return '<div class="text-center"><span class="text-primary">Pending</span></div>' ; case User :: STATUS_ACTIVE : return '<div class="text-center"><span class="text-success">Active</span></div>' ; case User :: STATUS_BLOCKED : return '<div class="text-center"><span class="text-danger">Blocked</span></div>' ; } return NULL ; }
4888	public function gotoAction ( Request $ r ) { return $ this -> redirect ( $ this -> get ( 'zicht_url.provider' ) -> url ( $ this -> getPageManager ( ) -> findForView ( $ r -> get ( 'id' ) ) ) ) ; }
5437	public function addPattern ( $ pattern , $ label = true ) { $ count = count ( $ this -> patterns ) ; $ this -> patterns [ $ count ] = $ pattern ; $ this -> labels [ $ count ] = $ label ; $ this -> regex = null ; }
530	public function actionSortChangelog ( array $ what ) { if ( \ count ( $ what ) > 1 ) { $ this -> stdout ( "Currently only one simultaneous release is supported.\n" ) ; return 1 ; } $ this -> validateWhat ( $ what , [ 'framework' , 'ext' ] , false ) ; $ version = $ this -> version ? : array_values ( $ this -> getNextVersions ( $ this -> getCurrentVersions ( $ what ) , self :: PATCH ) ) [ 0 ] ; $ this -> stdout ( 'sorting CHANGELOG of ' ) ; $ this -> stdout ( reset ( $ what ) , Console :: BOLD ) ; $ this -> stdout ( ' for version ' ) ; $ this -> stdout ( $ version , Console :: BOLD ) ; $ this -> stdout ( '...' ) ; $ this -> resortChangelogs ( $ what , $ version ) ; $ this -> stdout ( "done.\n" , Console :: BOLD , Console :: FG_GREEN ) ; }
7541	function setIndex ( $ index ) { if ( $ this -> parent ) { if ( $ index > $ this -> index ( ) ) { -- $ index ; } $ this -> delete ( ) ; $ this -> parent -> addChild ( $ this , $ index ) ; } }
6100	protected function delete ( $ endpoint , array $ parameters = [ ] , $ fireAndForget = false ) { return $ this -> call ( $ endpoint , $ parameters , self :: METHOD_DELETE , null , $ fireAndForget ) ; }
6083	public function uploadFile ( $ pathname , $ name , $ categoryId , $ progress = null , $ chunkSize = 10485760 ) { $ chunk = 0 ; $ chunksTotal = ceil ( filesize ( $ pathname ) / $ chunkSize ) ; $ fileId = sha1 ( uniqid ( 'upload' , true ) ) ; $ fp = fopen ( $ pathname , 'rb' ) ; if ( false === $ fp ) { throw new UploadException ( 'Could not open file "' . $ pathname . '" for reading.' ) ; } if ( $ chunkSize > 10485760 ) { $ this -> logger -> warning ( 'Using a chunk size larger then 10MB is not recommended. Uploading is not guaranteed to work properly.' ) ; } while ( $ chunkData = fread ( $ fp , $ chunkSize ) ) { $ result = $ this -> uploadFileChunked ( $ chunkData , $ name , $ chunk , $ chunksTotal , $ fileId , $ categoryId ) ; if ( is_callable ( $ progress ) ) { try { call_user_func ( $ progress , $ chunk + 1 , $ chunksTotal ) ; } catch ( \ Exception $ e ) { $ this -> logger -> warning ( 'Could not report progress due to callback error.' , [ 'message' => $ e -> getMessage ( ) ] ) ; } } $ this -> logger -> info ( 'Upload progress!' , [ 'part' => $ chunk + 1 , 'total' => $ chunksTotal ] ) ; if ( isset ( $ result [ 'mediaId' ] ) ) { return new MediaResponse ( $ result ) ; } if ( isset ( $ result [ 'success' ] ) && false == $ result [ 'success' ] ) { throw new UploadException ( $ result [ 'error' ] [ 'message' ] , $ result [ 'error' ] [ 'code' ] ) ; } if ( isset ( $ result [ 'fileId' ] ) ) { $ fileId = $ result [ 'fileId' ] ; } ++ $ chunk ; } if ( $ chunk == $ chunksTotal - 1 ) { throw new UploadException ( 'Uploaded all chunks, but something went wrong.' ) ; } if ( false === $ chunkData ) { throw new UploadException ( 'Could not read chunk ' . $ chunk . ' from file "' . $ pathname . '".' ) ; } throw new UploadException ( 'Unknown upload error!' ) ; }
9007	public function sort ( ) { $ this -> uasort ( function ( $ a , $ b ) { $ priority_a = ( int ) $ a -> get ( 'priority' ) ? : 500 ; $ priority_b = ( int ) $ b -> get ( 'priority' ) ? : 500 ; if ( $ priority_a == $ priority_b ) { return 0 ; } return ( $ priority_a < $ priority_b ) ? - 1 : 1 ; } ) ; return $ this ; }
11544	public function confirmPasswordReset ( $ token ) { $ user = $ this -> getMapper ( ) -> findOneBy ( [ 'registrationToken' => $ token ] ) ; if ( ! $ user instanceof UserInterface ) { return ; } $ eventManager = $ this -> getEventManager ( ) ; $ eventManager -> trigger ( __METHOD__ , $ this , $ user ) ; $ user -> setRegistrationToken ( $ this -> getRegistrationToken ( ) ) ; $ user -> setEmailConfirmed ( true ) ; $ password = $ this -> getPasswordGenerator ( ) -> generate ( ) ; $ passwordService = $ this -> getMapper ( ) -> getPasswordService ( ) ; $ user -> setPassword ( $ passwordService -> create ( $ password ) ) ; $ viewModel = new ViewModel ( compact ( 'user' , 'password' ) ) ; $ viewModel -> setTemplate ( 'mail-message/user-change-password-success' ) ; $ mailService = $ this -> getMailService ( ) ; $ message = $ mailService -> getMessage ( ) ; $ message -> setTo ( $ user -> getEmail ( ) , $ user -> getDisplayName ( ) ) ; $ subject = 'Your password has been changed!' ; if ( $ this -> getTranslator ( ) && $ this -> isTranslatorEnabled ( ) ) { $ subject = $ this -> getTranslator ( ) -> translate ( $ subject , $ this -> getTranslatorTextDomain ( ) ) ; } $ message -> setSubject ( $ subject ) ; $ mailService -> setBody ( $ viewModel ) -> sendMessage ( ) ; $ this -> getMapper ( ) -> update ( $ user ) -> save ( ) ; $ eventManager -> trigger ( __METHOD__ . '.post' , $ this , $ user ) ; return $ user ; }
2498	private function getLanguageFilter ( array $ languageCodes ) { $ languageFilters = array ( ) ; foreach ( $ languageCodes as $ languageCode ) { $ condition = new CustomField ( self :: FIELD_LANGUAGE , Operator :: EQ , $ languageCode ) ; $ excluded = $ this -> getExcludedLanguageCodes ( $ languageCodes , $ languageCode ) ; if ( ! empty ( $ excluded ) ) { $ condition = new LogicalAnd ( array ( $ condition , new LogicalNot ( new CustomField ( self :: FIELD_LANGUAGES , Operator :: IN , $ excluded ) ) , ) ) ; } $ languageFilters [ ] = $ condition ; } if ( count ( $ languageFilters ) > 1 ) { $ languageFilters = array ( new LogicalOr ( $ languageFilters ) ) ; } if ( $ this -> hasMainLanguagesEndpoint ) { $ languageFilters [ ] = new LogicalNot ( new CustomField ( self :: FIELD_IS_MAIN_LANGUAGES_INDEX , Operator :: EQ , true ) ) ; } if ( count ( $ languageFilters ) > 1 ) { return new LogicalAnd ( $ languageFilters ) ; } return reset ( $ languageFilters ) ; }
425	protected function addErrorClassIfNeeded ( & $ options ) { $ attributeName = Html :: getAttributeName ( $ this -> attribute ) ; if ( $ this -> model -> hasErrors ( $ attributeName ) ) { Html :: addCssClass ( $ options , $ this -> form -> errorCssClass ) ; } }
3698	private function getOrCreateDefinition ( ) { if ( $ this -> container -> hasDefinition ( Contao2BackendViewDefinitionInterface :: NAME ) ) { $ view = $ this -> container -> getDefinition ( Contao2BackendViewDefinitionInterface :: NAME ) ; if ( ! $ view instanceof Contao2BackendViewDefinitionInterface ) { throw new DcGeneralInvalidArgumentException ( 'Configured BackendViewDefinition does not implement Contao2BackendViewDefinitionInterface.' ) ; } return $ view ; } $ this -> container -> setDefinition ( Contao2BackendViewDefinitionInterface :: NAME , $ view = new Contao2BackendViewDefinition ( ) ) ; return $ view ; }
12778	public function getRefreshInstructions ( ) { $ i = [ ] ; $ i [ 'type' ] = 'widget' ; $ i [ 'systemId' ] = $ this -> collectorItem -> systemId ; $ i [ 'recreateParams' ] = $ this -> recreateParams ; if ( $ this -> section ) { $ i [ 'section' ] = $ this -> section -> systemId ; } return $ i ; }
8234	protected function isExpired ( array $ tokenData , $ tokenValidity = null ) { return time ( ) > $ tokenData [ 'time' ] + ( ( $ tokenValidity !== null ) ? $ tokenValidity : self :: TOKEN_VALIDITY ) ; }
10841	public function sayHello ( ) { $ text = $ this -> getHALLogo ( ) ; if ( $ this -> showText ) { $ text .= $ this -> getHelloDave ( ) ; } $ lines = explode ( "\n" , $ text ) ; $ spaces = '' ; if ( $ this -> center ) { $ max_length = 0 ; foreach ( $ lines as $ line ) { $ max_length = max ( $ max_length , Helper :: strlenWithoutDecoration ( $ this -> output -> getFormatter ( ) , $ line ) ) ; } $ numberOfSpaces = floor ( ( $ this -> screenSize [ 0 ] - $ max_length ) / 2 ) ; if ( $ numberOfSpaces > 0 ) { $ spaces = str_repeat ( ' ' , $ numberOfSpaces ) ; } } foreach ( $ lines as $ line ) { $ this -> output -> writeln ( $ spaces . $ line ) ; } }
11642	public function getTotalItems ( ) { if ( is_null ( $ this -> _totalItems ) ) { $ this -> _totalItems = $ this -> dataProvider -> totalItemCount ; } return $ this -> _totalItems ; }
12972	protected function createEntityManager ( ) { if ( $ cache = $ this -> getConfig ( 'cache_driver' , 'array' ) ) { $ cache = 'doctrine.cache.' . $ cache ; $ cache = DiC :: resolve ( $ cache ) ; } if ( $ this -> getConfig ( 'auto_config' , false ) ) { $ dev = $ this -> getConfig ( 'dev_mode' , \ Fuel :: $ env === \ Fuel :: DEVELOPMENT ) ; $ proxy_dir = $ this -> getConfig ( 'proxy_dir' ) ; $ config = Setup :: createConfiguration ( $ dev , $ proxy_dir , $ cache ) ; } else { $ config = new Configuration ; $ config -> setProxyDir ( $ this -> getConfig ( 'proxy_dir' ) ) ; $ config -> setProxyNamespace ( $ this -> getConfig ( 'proxy_namespace' ) ) ; $ config -> setAutoGenerateProxyClasses ( $ this -> getConfig ( 'auto_generate_proxy_classes' , false ) ) ; if ( $ cache ) { $ config -> setMetadataCacheImpl ( $ cache ) ; $ config -> setQueryCacheImpl ( $ cache ) ; $ config -> setResultCacheImpl ( $ cache ) ; } } $ config -> newDefaultAnnotationDriver ( array ( ) ) ; $ this -> registerMapping ( $ config ) ; $ conn = DiC :: multiton ( 'dbal' , $ this -> getConfig ( 'dbal' ) , [ $ this -> getConfig ( 'dbal' ) ] ) ; $ evm = $ conn -> getEventManager ( ) ; $ this -> registerBehaviors ( $ evm , $ config ) ; return $ this -> entityManager = EntityManager :: create ( $ conn , $ config , $ evm ) ; }
11290	protected function _getModels ( $ attributeName , $ relatedObjName = false , $ query = false , $ loadMap = false ) { $ def = $ this -> model_attributes [ $ attributeName ] ; $ result = [ ] ; if ( $ relatedObjName ) { if ( isset ( $ def [ 'via' ] ) ) { $ result = $ this -> _getModelsFromTableColumn ( $ attributeName , $ relatedObjName , $ def [ 'via' ] , $ query , $ loadMap ) ; } else if ( isset ( $ def [ 'using' ] ) ) { $ result = $ this -> getModelsFromCustomRelationship ( $ attributeName , $ relatedObjName , $ query , $ loadMap ) ; } else { $ result = $ this -> _getModelsFromRelationTable ( $ attributeName , $ relatedObjName , $ query , $ loadMap ) ; } } if ( $ result == null ) { $ this -> $ attributeName = new \ Cora \ Collection ( ) ; $ result = $ this -> model_data [ $ attributeName ] ; } return $ result ; }
5610	public function paintCaseStart ( $ message ) { parent :: paintCaseStart ( $ message ) ; $ node = new TreemapNode ( 'TestCase' , $ message ) ; $ this -> _stack -> push ( $ node ) ; }
7611	public function actionCreate ( ) { $ model = new User ; if ( $ model -> load ( $ _POST ) && $ model -> save ( ) ) { return $ this -> redirect ( [ 'view' , 'id' => $ model -> id ] ) ; } else { return $ this -> render ( 'create' , [ 'model' => $ model , ] ) ; } }
12028	function addExecuteAsyncMethod ( ) { $ body = $ this -> generateCreateFragment ( ) ; $ body .= 'return $this->dispatchAsync($request, $callable);' ; $ docBlock = new DocBlockGenerator ( 'Execute the operation asynchronously, passing the parsed response to the callback' , null ) ; $ tags [ ] = new GenericTag ( 'return' , '\Amp\Promise' ) ; $ docBlock -> setTags ( $ tags ) ; $ callableParamGenerator = new ParameterGenerator ( 'callable' , 'callable' ) ; $ methodGenerator = new MethodGenerator ( 'executeAsync' ) ; $ methodGenerator -> setBody ( $ body ) ; $ methodGenerator -> setDocBlock ( $ docBlock ) ; $ methodGenerator -> setParameters ( [ $ callableParamGenerator ] ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
9044	private function isRotationNeeded ( ) { clearstatcache ( ) ; if ( ! file_exists ( $ this -> file ) ) { return false ; } $ result = false ; $ attributes = stat ( $ this -> file ) ; if ( $ attributes == false || $ attributes [ 'size' ] >= $ this -> maxLogSize * 1024 * 1024 ) { $ result = true ; } return $ result ; }
2155	public function getSearchablePages ( $ arrPages , $ intRoot = 0 , $ blnIsSitemap = false ) { $ arrRoot = array ( ) ; if ( $ intRoot > 0 ) { $ arrRoot = $ this -> Database -> getChildRecords ( $ intRoot , 'tl_page' ) ; } $ arrProcessed = array ( ) ; $ time = Date :: floorToMinute ( ) ; $ objNewsletter = NewsletterChannelModel :: findAll ( ) ; if ( $ objNewsletter !== null ) { while ( $ objNewsletter -> next ( ) ) { if ( ! $ objNewsletter -> jumpTo ) { continue ; } if ( ! empty ( $ arrRoot ) && ! \ in_array ( $ objNewsletter -> jumpTo , $ arrRoot ) ) { continue ; } if ( ! isset ( $ arrProcessed [ $ objNewsletter -> jumpTo ] ) ) { $ objParent = PageModel :: findWithDetails ( $ objNewsletter -> jumpTo ) ; if ( $ objParent === null ) { continue ; } if ( ! $ objParent -> published || ( $ objParent -> start != '' && $ objParent -> start > $ time ) || ( $ objParent -> stop != '' && $ objParent -> stop <= ( $ time + 60 ) ) ) { continue ; } if ( $ blnIsSitemap ) { if ( $ objParent -> protected ) { continue ; } if ( $ objParent -> sitemap == 'map_never' ) { continue ; } } $ arrProcessed [ $ objNewsletter -> jumpTo ] = $ objParent -> getAbsoluteUrl ( Config :: get ( 'useAutoItem' ) ? '/%s' : '/items/%s' ) ; } $ strUrl = $ arrProcessed [ $ objNewsletter -> jumpTo ] ; $ objItem = NewsletterModel :: findSentByPid ( $ objNewsletter -> id ) ; if ( $ objItem !== null ) { while ( $ objItem -> next ( ) ) { $ arrPages [ ] = sprintf ( preg_replace ( '/%(?!s)/' , '%%' , $ strUrl ) , ( $ objItem -> alias ? : $ objItem -> id ) ) ; } } } } return $ arrPages ; }
5205	public function isActiveMatch ( $ string , $ output = "active" ) { if ( strpos ( $ this -> url -> current ( ) , $ string ) !== false ) { return $ output ; } return null ; }
7451	public function boot ( \ Neos \ Flow \ Core \ Bootstrap $ bootstrap ) { $ dispatcher = $ bootstrap -> getSignalSlotDispatcher ( ) ; $ dispatcher -> connect ( 'Neos\Flow\Configuration\ConfigurationManager' , 'configurationManagerReady' , function ( $ configurationManager ) { $ configurationManager -> registerConfigurationType ( 'Menus' ) ; } ) ; }
9416	public function max ( ) { $ float_max = 1 / ( $ this -> float_sigma * sqrt ( 2 * pi ( ) ) ) ; if ( $ this -> int_precision ) { return round ( $ float_max , $ this -> int_precision ) ; } return $ float_max ; }
10344	protected function extractStep ( $ definition ) { if ( ( $ position = strpos ( $ definition , '/' ) ) !== false ) { return ( int ) substr ( $ definition , $ position + 1 ) ; } return false ; }
3414	public function fill ( $ fields ) { if ( ! is_array ( $ fields ) ) { return ; } if ( isset ( $ fields [ 'ID' ] ) ) { $ this -> id = $ fields [ 'ID' ] ; } $ this -> fields = $ fields ; $ this -> fieldsAreFetched = true ; if ( method_exists ( $ this , 'afterFill' ) ) { $ this -> afterFill ( ) ; } $ this -> original = $ this -> fields ; }
9502	public function runPeridot ( InputInterface $ input , OutputInterface $ output ) { global $ argv ; $ command = $ this -> joinCommand ( $ argv ) ; $ process = new Process ( $ command ) ; $ process -> run ( function ( $ type , $ buffer ) use ( $ output ) { $ buffer = preg_replace ( '/\[([\d]{1,2})m/' , "\033[$1m" , $ buffer ) ; $ output -> write ( $ buffer ) ; } ) ; }
7913	protected function renderInput ( ) { return $ this -> hasModel ( ) ? Html :: activeCheckbox ( $ this -> model , $ this -> attribute , $ this -> options ) : Html :: checkbox ( $ this -> name , $ this -> checked , $ this -> options ) ; }
8562	public function createShipment ( $ request ) { if ( ! ( $ request instanceof MWSMerchantFulfillmentService_Model_CreateShipmentRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/CreateShipmentRequest.php' ) ; $ request = new MWSMerchantFulfillmentService_Model_CreateShipmentRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'CreateShipment' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/CreateShipmentResponse.php' ) ; $ response = MWSMerchantFulfillmentService_Model_CreateShipmentResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
771	public function actionConfig ( $ filePath ) { $ filePath = Yii :: getAlias ( $ filePath ) ; $ dir = dirname ( $ filePath ) ; if ( file_exists ( $ filePath ) ) { if ( ! $ this -> confirm ( "File '{$filePath}' already exists. Do you wish to overwrite it?" ) ) { return ExitCode :: OK ; } } $ array = VarDumper :: export ( $ this -> getOptionValues ( $ this -> action -> id ) ) ; $ content = <<<EOD<?php/** * Configuration file for 'yii {$this->id}/{$this->defaultAction}' command. * * This file is automatically generated by 'yii {$this->id}/{$this->action->id}' command. * It contains parameters for source code messages extraction. * You may modify this file to suit your needs. * * You can use 'yii {$this->id}/{$this->action->id}-template' command to create * template configuration file with detailed description for each parameter. */return $array;EOD ; if ( FileHelper :: createDirectory ( $ dir ) === false || file_put_contents ( $ filePath , $ content , LOCK_EX ) === false ) { $ this -> stdout ( "Configuration file was NOT created: '{$filePath}'.\n\n" , Console :: FG_RED ) ; return ExitCode :: UNSPECIFIED_ERROR ; } $ this -> stdout ( "Configuration file created: '{$filePath}'.\n\n" , Console :: FG_GREEN ) ; return ExitCode :: OK ; }
9140	public static function parseFromServerRequest ( $ serverVars , $ defaultController = 'Index' , $ defaultAction = 'index' ) { if ( ! isset ( $ serverVars [ 'REQUEST_URI' ] ) ) { throw new InvalidUrlException ( "No such uri provided" ) ; } return self :: parse ( $ serverVars [ 'REQUEST_URI' ] , $ serverVars , $ defaultController , $ defaultAction ) ; }
2717	public function render ( AbstractElement $ element ) { $ element -> unsScope ( ) -> unsCanUseWebsiteValue ( ) -> unsCanUseDefaultValue ( ) ; return parent :: render ( $ element ) ; }
1498	public function merge ( EncodingList $ encodings ) : self { $ copy = new self ( ) ; $ copy -> stack = collect ( $ this -> stack ) -> merge ( $ encodings -> stack ) -> all ( ) ; return $ copy ; }
12247	public function getNodeByName ( $ strXpath , $ strName ) { $ varResult = $ this -> xpath ( $ strXpath . "[@name='" . $ strName . "']" ) ; if ( $ varResult !== false ) { return reset ( $ varResult ) ; } else { return false ; } }
7997	public static function getSpecificationString ( $ reversed = false ) { $ reflection = new ReflectionClass ( get_class ( ) ) ; $ constants = $ reflection -> getConstants ( ) ; if ( $ reversed ) { $ constants = array_reverse ( $ constants ) ; } $ string = '' ; foreach ( $ constants as $ name => $ int_val ) { $ binary_val_string = base_convert ( ( string ) $ int_val , '10' , '2' ) ; $ string .= sprintf ( '0b%s : %s' , str_pad ( $ binary_val_string , 32 , '0' , STR_PAD_LEFT ) , $ name ) ; $ string .= PHP_EOL ; } return $ string ; }
5604	public function paintMethodStart ( $ method ) { $ this -> pass = false ; $ this -> fail = false ; $ this -> error = false ; $ this -> method = self :: escapeVal ( $ method ) ; }
11281	public function getFloat ( $ min , $ max ) { if ( $ min > $ max ) { throw new InvalidArgumentException ( 'Min cannot be greater than max' ) ; } $ random01 = \ mt_rand ( ) / \ mt_getrandmax ( ) ; return ( $ max - $ min ) * $ random01 + $ min ; }
12241	public function addClass ( $ class ) { if ( ! $ this -> hasClass ( $ class ) ) { $ current = ( string ) $ this [ 'class' ] ; if ( $ current !== '' && substr ( $ current , - 1 ) !== ' ' ) { $ this [ 'class' ] .= ' ' ; } $ this [ 'class' ] .= $ class ; } return $ this ; }
472	public function insert ( $ table , $ columns ) { $ time = $ this -> beginCommand ( "insert into $table" ) ; $ this -> db -> createCommand ( ) -> insert ( $ table , $ columns ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
9516	public function settings ( $ name = null , $ value = null ) { switch ( func_num_args ( ) ) { case 0 : return $ this -> info ( 'settings' ) ; break ; case 1 : return $ this -> info ( 'settings' , func_get_arg ( 0 ) ) ; break ; case 2 : $ update = false ; list ( $ name , $ value ) = func_get_args ( ) ; $ current = $ this -> info ( 'settings' , $ name ) ; if ( is_null ( $ value ) ) { if ( ! is_null ( $ current ) ) { unset ( $ this -> info [ 'settings' ] [ $ name ] ) ; $ update = true ; } } elseif ( $ current !== $ value ) { $ this -> info [ 'settings' ] [ $ name ] = $ value ; $ update = true ; } if ( $ update ) { $ this -> exec ( 'UPDATE config SET settings = ?' , serialize ( $ this -> info [ 'settings' ] ) ) ; } break ; } }
7566	protected function parse_single ( $ recursive = true ) { if ( ( $ c = $ this -> parse_conditions ( ) ) === false ) { return false ; } $ this -> parse_callback ( $ c , $ recursive , $ this -> search_root ) ; return true ; }
10824	public static function confirm ( $ question , $ allowShort , $ defaultValue = false ) { $ value = $ defaultValue ? 'yes' : 'no' ; $ value = self :: ask ( $ question . ' (yes/no)' , $ value ) ; return $ value == 'yes' || ( $ value == 'y' && $ allowShort ) ; }
12906	public function show ( $ id , FilterRequest $ request ) { $ id = $ this -> getRealId ( $ id ) ; $ request -> criteria [ ] = 'id,=,' . $ id ; $ resource = $ this -> repository -> filter ( $ request ) -> first ( ) ; if ( ! $ resource ) { } return $ this -> success ( $ resource ) ; }
606	private function tokenizeDelimitedString ( & $ length ) { $ isIdentifier = $ this -> isIdentifier ( $ length , $ content ) ; $ isStringLiteral = ! $ isIdentifier && $ this -> isStringLiteral ( $ length , $ content ) ; if ( ! $ isIdentifier && ! $ isStringLiteral ) { return false ; } $ this -> addTokenFromBuffer ( ) ; $ this -> _currentToken [ ] = new SqlToken ( [ 'type' => $ isIdentifier ? SqlToken :: TYPE_IDENTIFIER : SqlToken :: TYPE_STRING_LITERAL , 'content' => is_string ( $ content ) ? $ content : $ this -> substring ( $ length ) , 'startOffset' => $ this -> offset , 'endOffset' => $ this -> offset + $ length , ] ) ; return true ; }
8642	public function getReportRequestListByNextToken ( $ request ) { if ( ! $ request instanceof MarketplaceWebService_Model_GetReportRequestListByNextTokenRequest ) { $ request = new MarketplaceWebService_Model_GetReportRequestListByNextTokenRequest ( $ request ) ; } $ httpResponse = $ this -> invoke ( $ this -> convertGetReportRequestListByNextToken ( $ request ) ) ; $ response = MarketplaceWebService_Model_GetReportRequestListByNextTokenResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
6366	public function compound ( Comparator $ secondaryComparator ) : Ordering { return Ordering :: from ( Collections :: comparatorFrom ( function ( $ object1 , $ object2 ) use ( $ secondaryComparator ) { $ res = $ this -> compare ( $ object1 , $ object2 ) ; return $ res !== 0 ? $ res : $ secondaryComparator -> compare ( $ object1 , $ object2 ) ; } ) ) ; }
8684	public static function fromRecursive ( $ iterable ) { $ arr = static :: from ( $ iterable ) ; foreach ( $ arr as $ key => $ value ) { if ( $ value instanceof \ stdClass || \ is_iterable ( $ value ) ) { $ value = static :: fromRecursive ( $ value ) ; } $ arr [ $ key ] = $ value ; } return $ arr ; }
10319	function getBlocksCount ( $ fromDate = null , $ toDate = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ reasons = null , $ oldStatus = null , $ newStatus = null , $ excludeAnonymousBlocks = false ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , null , null ) ; if ( isset ( $ excludeAnonymousBlocks ) ) $ params [ 'exclude_anonymous_blocks' ] = ( $ excludeAnonymousBlocks == true ) ? "true" : "false" ; $ params = $ this -> appendArrayFields ( $ params , "reasons" , $ reasons ) ; if ( isset ( $ oldStatus ) ) $ params [ 'old_status' ] = $ oldStatus ; if ( isset ( $ newStatus ) ) $ params [ 'new_status' ] = $ newStatus ; return $ this -> get ( 'reports/blocks/count' , $ params ) ; }
8880	private function isValidFullPath ( string $ path ) : bool { $ valid = false ; if ( '/' === substr ( $ path , 0 , 1 ) && is_executable ( $ path ) ) { $ valid = true ; } return $ valid ; }
3744	protected function getMetaModel ( ) { if ( ! $ this -> metaModel ) { if ( $ this -> metaModel === null ) { throw new \ RuntimeException ( 'No MetaModel instance set for ' . $ this -> strTable ) ; } } return $ this -> metaModel ; }
6152	public function run ( ) { if ( ! empty ( $ this -> _fields ) ) { throw new InvalidCallException ( 'Each beginField() should have a matching endField() call.' ) ; } $ id = $ this -> options [ 'id' ] ; $ options = Json :: encode ( $ this -> getClientOptions ( ) ) ; $ attributes = Json :: encode ( $ this -> attributes ) ; $ view = $ this -> getView ( ) ; AdminUiActiveForm :: register ( $ view ) ; $ view -> registerJs ( "jQuery('#$id').yiiActiveForm($attributes, $options);" ) ; echo Html :: endForm ( ) ; }
11067	protected function compileMixins ( ) { $ sql = array ( ) ; foreach ( $ this -> mixins as $ mixin ) { $ compiled = $ this -> { $ mixin } -> compile ( ) ; if ( $ compiled !== "" ) { $ sql [ ] = $ compiled ; } } return $ sql ; }
6353	public static function tryFind ( Iterator $ iterator , callable $ predicate ) : Optional { return Optional :: ofNullable ( self :: find ( $ iterator , $ predicate ) ) ; }
3835	protected function prepareTemplate ( Template $ objTemplate , $ arrRowData , $ objSettings ) { $ objTemplate -> setData ( array ( 'attribute' => $ this , 'settings' => $ objSettings , 'row' => $ arrRowData , 'raw' => $ arrRowData [ $ this -> getColName ( ) ] , 'additional_class' => $ objSettings -> get ( 'additional_class' ) ? ' ' . $ objSettings -> get ( 'additional_class' ) : '' ) ) ; }
1868	public function maintenanceCheck ( ) { $ this -> import ( BackendUser :: class , 'User' ) ; if ( ! $ this -> User -> hasAccess ( 'maintenance' , 'modules' ) ) { return '' ; } try { if ( System :: getContainer ( ) -> get ( 'lexik_maintenance.driver.factory' ) -> getDriver ( ) -> isExists ( ) ) { return '<p class="tl_error">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'maintenanceEnabled' ] . '</p>' ; } } catch ( \ Exception $ e ) { } return '' ; }
9286	public function create ( ) { $ adapter = $ this -> dbAdapter ; $ ddl = new Ddl \ CreateTable ( ) ; $ ddl -> setTable ( self :: TABLE_NAME ) -> addColumn ( new Column \ Integer ( 'id' , false , null , array ( 'autoincrement' => true ) ) ) -> addColumn ( new Column \ Varchar ( 'code' , 55 ) ) -> addColumn ( new Column \ Varchar ( 'status' , 55 ) ) -> addColumn ( new Column \ Text ( 'error_msg' ) ) -> addColumn ( new Column \ Text ( 'stack_trace' ) ) -> addColumn ( new Column \ Varchar ( 'created' , 255 ) ) -> addColumn ( new Column \ Varchar ( 'scheduled' , 255 ) ) -> addColumn ( new Column \ Varchar ( 'executed' , 255 ) ) -> addColumn ( new Column \ Varchar ( 'finished' , 255 ) ) -> addConstraint ( new Constraint \ PrimaryKey ( 'id' ) ) ; $ sql = ( new Sql ( $ adapter ) ) -> getSqlStringForSqlObject ( $ ddl ) ; $ adapter -> query ( $ sql , $ adapter :: QUERY_MODE_EXECUTE ) ; }
9562	protected function matchesTypehint ( $ handler , Exception $ exception ) { if ( $ handler instanceof ErrorHandlerInterface ) { return true ; } if ( is_array ( $ handler ) ) { $ reflection = ( new ReflectionMethod ( $ handler [ 0 ] , $ handler [ 1 ] ) ) ; } else { $ reflection = ( new ReflectionFunction ( $ handler ) ) ; } $ params = $ reflection -> getParameters ( ) ; if ( empty ( $ params ) ) { return true ; } $ handlerHint = $ params [ 0 ] -> getClass ( ) ; if ( ! $ handlerHint ) { return true ; } return $ handlerHint -> isInstance ( $ exception ) ; }
962	public function buildAuthUrl ( $ mode = null ) { return $ this -> api -> getAuthUrl ( Config :: get ( 'shopify-app.api_scopes' ) , URL :: secure ( Config :: get ( 'shopify-app.api_redirect' ) ) , $ mode ?? 'offline' ) ; }
5150	protected function getEmailRecipients ( $ email ) { $ recipients = $ email -> Headers -> to . ' ' . $ email -> Headers -> cc ; if ( $ email -> Headers -> bcc != NULL ) { $ recipients .= ' ' . $ email -> Headers -> bcc ; } return $ recipients ; }
1483	public function register ( AbstractProvider $ provider ) { $ this -> resolver -> attach ( $ provider -> getResolver ( ) ) ; $ this -> errors = array_replace ( $ provider -> getErrors ( ) , $ this -> errors ) ; }
8498	public function listAllFulfillmentOrdersByNextToken ( $ request ) { if ( ! ( $ request instanceof FBAOutboundServiceMWS_Model_ListAllFulfillmentOrdersByNextTokenRequest ) ) { $ request = new FBAOutboundServiceMWS_Model_ListAllFulfillmentOrdersByNextTokenRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListAllFulfillmentOrdersByNextToken' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAOutboundServiceMWS_Model_ListAllFulfillmentOrdersByNextTokenResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
9145	private static function resetLocaleTo ( $ localeSaved ) { $ localeData = explode ( ';' , $ localeSaved ) ; foreach ( $ localeData as $ identifier ) { if ( ! strchr ( $ identifier , '=' ) ) { continue ; } $ type = $ value = null ; sscanf ( $ identifier , "%s=%s" , $ type , $ value ) ; switch ( $ type ) { case 'LC_ALL' : setlocale ( LC_ALL , $ value ) ; break ; case 'LC_COLLATE' : setlocale ( LC_COLLATE , $ value ) ; break ; case 'LC_CTYPE' : setlocale ( LC_CTYPE , $ value ) ; break ; case 'LC_MONETARY' : setlocale ( LC_MONETARY , $ value ) ; break ; case 'LC_NUMERIC' : setlocale ( LC_NUMERIC , $ value ) ; break ; case 'LC_TIME' : setlocale ( LC_TIME , $ value ) ; break ; case 'LC_MESSAGES' : setlocale ( LC_MESSAGES , $ value ) ; break ; default : ; break ; } } }
2149	public function createNewUser ( $ intUser , $ arrData ) { $ arrNewsletters = StringUtil :: deserialize ( $ arrData [ 'newsletter' ] , true ) ; if ( ! \ is_array ( $ arrNewsletters ) ) { return ; } $ time = time ( ) ; foreach ( $ arrNewsletters as $ intNewsletter ) { $ intNewsletter = ( int ) $ intNewsletter ; if ( $ intNewsletter < 1 ) { continue ; } $ objRecipient = $ this -> Database -> prepare ( "SELECT COUNT(*) AS count FROM tl_newsletter_recipients WHERE pid=? AND email=?" ) -> execute ( $ intNewsletter , $ arrData [ 'email' ] ) ; if ( $ objRecipient -> count < 1 ) { $ this -> Database -> prepare ( "INSERT INTO tl_newsletter_recipients SET pid=?, tstamp=$time, email=?, addedOn=$time" ) -> execute ( $ intNewsletter , $ arrData [ 'email' ] ) ; } } }
7038	public function getShipments ( $ filter = null ) { if ( null === $ filter ) { return $ this -> shipments ; } return $ this -> shipments -> filter ( function ( ShipmentInterface $ shipment ) use ( $ filter ) { return $ filter xor $ shipment -> isReturn ( ) ; } ) ; }
12539	public static function dasherize ( $ str , $ replacement = '_' ) { return preg_replace_callback ( '/([A-Z0-9-\s]+)/' , function ( $ match ) use ( $ replacement ) { return $ replacement . strtolower ( $ match [ 1 ] ) ; } , lcfirst ( $ str ) ) ; }
5265	public function getNotCachedAttributes ( $ key , array $ attributes = [ '*' ] ) { if ( ! $ this -> has ( $ key ) ) { return $ attributes ; } $ cachedAttributes = $ this -> cache [ $ key ] [ 'attributes' ] ; return $ cachedAttributes == [ '*' ] ? [ ] : array_diff ( $ attributes , $ cachedAttributes ) ; }
3885	private function collectRulesFor ( $ parentSetting , $ filterSettings ) { $ childInformation = $ this -> database -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel_filtersetting' ) -> where ( 'pid=:pid' ) -> andWhere ( 'enabled=1' ) -> orderBy ( 'sorting' , 'ASC' ) -> setParameter ( 'pid' , $ parentSetting -> get ( 'id' ) ) -> execute ( ) ; foreach ( $ childInformation -> fetchAll ( \ PDO :: FETCH_ASSOC ) as $ item ) { $ childSetting = $ this -> createSetting ( $ item , $ filterSettings ) ; if ( $ childSetting ) { $ parentSetting -> addChild ( $ childSetting ) ; } } }
11164	protected function getPublishedFormat ( array $ config ) { if ( isset ( $ config [ 'publishedFormat' ] ) ) { if ( ! is_string ( $ config [ 'publishedFormat' ] ) ) { throw new \ DomainException ( 'publishedFormat must reference a string' , self :: ERR_INVALID_PUBLISHEDFORMAT ) ; } return $ config [ 'publishedFormat' ] ; } return 'n/j/y g:i A' ; }
850	public function getTokenOfKindSibling ( $ index , $ direction , array $ tokens = [ ] , $ caseSensitive = true ) { if ( ! self :: isLegacyMode ( ) ) { $ tokens = array_filter ( $ tokens , function ( $ token ) { return $ this -> isTokenKindFound ( $ this -> extractTokenKind ( $ token ) ) ; } ) ; } if ( ! \ count ( $ tokens ) ) { return null ; } while ( true ) { $ index += $ direction ; if ( ! $ this -> offsetExists ( $ index ) ) { return null ; } $ token = $ this [ $ index ] ; if ( $ token -> equalsAny ( $ tokens , $ caseSensitive ) ) { return $ index ; } } }
83	private function copyFiles ( $ files , $ source , $ target , $ roles , $ vars ) { foreach ( $ files as $ file ) { $ from = $ this -> combine ( $ source , $ file [ 'from' ] ) ; $ to = $ this -> combine ( $ target , $ roles [ $ file [ 'role' ] ] ) ; $ to = $ this -> combine ( $ to , $ file [ 'to' ] ) ; $ tasks = $ file [ 'tasks' ] ; $ this -> copyFile ( $ from , $ to , $ tasks , $ vars ) ; } }
7619	public function setPermissionSet ( $ value = array ( ) ) { foreach ( $ value as $ url ) { if ( strpos ( $ url , $ this -> accountName ) === false ) { throw new Exception ( 'The permission set can only contain URLs for the account name specified in the Credentials_SharedAccessSignature instance.' ) ; } } $ this -> permissionSet = $ value ; }
10232	private function writeLine ( $ pFileHandle , array $ pValues ) { $ writeDelimiter = false ; $ line = '' ; foreach ( $ pValues as $ element ) { $ element = str_replace ( $ this -> enclosure , $ this -> enclosure . $ this -> enclosure , $ element ) ; if ( $ writeDelimiter ) { $ line .= $ this -> delimiter ; } else { $ writeDelimiter = true ; } $ line .= $ this -> enclosure . $ element . $ this -> enclosure ; } $ line .= $ this -> lineEnding ; fwrite ( $ pFileHandle , $ line ) ; }
7057	public function hasData ( $ key = null ) { if ( ! is_null ( $ key ) ) { return isset ( $ this -> data [ $ key ] ) ; } return ! empty ( $ this -> data ) ; }
8843	public function save ( ) { if ( ! isset ( $ this -> name ) ) { return false ; } if ( class_exists ( '\Tilmeld\Tilmeld' ) && ! \ Tilmeld \ Tilmeld :: gatekeeper ( 'umailphp/admin' ) ) { return false ; } return parent :: save ( ) ; }
8013	protected function getBasicOptions ( ) { $ options = array ( ) ; $ options [ ] = '-encoding UTF-8' ; if ( $ this -> _asHtml ) { $ options [ ] = '-html' ; } if ( $ this -> _toConsole ) { $ options [ ] = '-console' ; } return join ( ' ' , $ options ) ; }
10375	protected static function validate ( $ type , $ data , $ admin ) { $ place = ( isset ( $ data [ 'place' ] ) ) ? $ data [ 'place' ] : 'front' ; $ place = $ admin && 'admin' == $ place || ! $ admin && 'front' == $ place ; if ( ! $ place || self :: set_params ( $ type , $ data ) === false ) { return false ; } return true ; }
2446	public function checkPermission ( ) { switch ( Contao \ Input :: get ( 'act' ) ) { case 'select' : case 'show' : break ; case 'edit' : case 'delete' : case 'toggle' : $ objComment = $ this -> Database -> prepare ( "SELECT id, parent, source FROM tl_comments WHERE id=?" ) -> limit ( 1 ) -> execute ( Contao \ Input :: get ( 'id' ) ) ; if ( $ objComment -> numRows < 1 ) { throw new Contao \ CoreBundle \ Exception \ AccessDeniedException ( 'Invalid comment ID ' . Contao \ Input :: get ( 'id' ) . '.' ) ; } if ( ! $ this -> isAllowedToEditComment ( $ objComment -> parent , $ objComment -> source ) ) { throw new Contao \ CoreBundle \ Exception \ AccessDeniedException ( 'Not enough permissions to ' . Contao \ Input :: get ( 'act' ) . ' comment ID ' . Contao \ Input :: get ( 'id' ) . ' (parent element: ' . $ objComment -> source . ' ID ' . $ objComment -> parent . ').' ) ; } break ; case 'editAll' : case 'deleteAll' : case 'overrideAll' : $ objSession = Contao \ System :: getContainer ( ) -> get ( 'session' ) ; $ session = $ objSession -> all ( ) ; if ( empty ( $ session [ 'CURRENT' ] [ 'IDS' ] ) || ! \ is_array ( $ session [ 'CURRENT' ] [ 'IDS' ] ) ) { break ; } $ objComment = $ this -> Database -> execute ( "SELECT id, parent, source FROM tl_comments WHERE id IN(" . implode ( ',' , array_map ( '\intval' , $ session [ 'CURRENT' ] [ 'IDS' ] ) ) . ")" ) ; while ( $ objComment -> next ( ) ) { if ( ! $ this -> isAllowedToEditComment ( $ objComment -> parent , $ objComment -> source ) && ( $ key = array_search ( $ objComment -> id , $ session [ 'CURRENT' ] [ 'IDS' ] ) ) !== false ) { unset ( $ session [ 'CURRENT' ] [ 'IDS' ] [ $ key ] ) ; } } $ session [ 'CURRENT' ] [ 'IDS' ] = array_values ( $ session [ 'CURRENT' ] [ 'IDS' ] ) ; $ objSession -> replace ( $ session ) ; break ; default : if ( \ strlen ( Contao \ Input :: get ( 'act' ) ) ) { throw new Contao \ CoreBundle \ Exception \ AccessDeniedException ( 'Invalid command "' . Contao \ Input :: get ( 'act' ) . '.' ) ; } break ; } }
9617	public function registerSubscriber ( $ class , callable $ callback ) { $ service_id = "event." . strtolower ( str_replace ( "\\" , "." , $ class ) ) ; $ this [ $ service_id ] = $ callback ; $ this [ "dispatcher" ] -> addSubscriberService ( $ service_id , $ class ) ; }
2755	public function onImport ( ImportEvent $ event ) { $ uuids = [ '0bd5c257-2231-450f-b4c2-ab156af7b78d' , '36b2e2b2-3df0-43eb-a282-d792b0999c07' , '94ad928b-3ec8-4bcb-b617-ab1607bf69cb' , 'bbb1ee17-15f8-46bd-9df5-21c58040d741' , ] ; foreach ( $ event -> getImportedEntities ( ) as $ entity ) { if ( in_array ( $ entity -> uuid ( ) , $ uuids ) ) { $ entity -> moderation_state -> value = 'published' ; $ entity -> save ( ) ; } } }
1847	protected function parseArticles ( $ objArticles , $ blnAddArchive = false ) { $ limit = $ objArticles -> count ( ) ; if ( $ limit < 1 ) { return array ( ) ; } $ count = 0 ; $ arrArticles = array ( ) ; while ( $ objArticles -> next ( ) ) { $ objArticle = $ objArticles -> current ( ) ; $ arrArticles [ ] = $ this -> parseArticle ( $ objArticle , $ blnAddArchive , ( ( ++ $ count == 1 ) ? ' first' : '' ) . ( ( $ count == $ limit ) ? ' last' : '' ) . ( ( ( $ count % 2 ) == 0 ) ? ' odd' : ' even' ) , $ count ) ; } return $ arrArticles ; }
1380	protected function validateToOne ( $ value , ? string $ field = null ) : bool { if ( is_null ( $ value ) ) { return true ; } $ dataPath = $ field ? "/data/relationships/{$field}" : "/" ; $ identifierPath = $ field ? "/data/relationships/{$field}" : "/data" ; if ( ! $ this -> validateIdentifier ( $ value , $ dataPath ) ) { return false ; } if ( ! $ this -> store -> exists ( new ResourceIdentifier ( $ value ) ) ) { $ this -> resourceDoesNotExist ( $ identifierPath ) ; return false ; } return true ; }
5657	private function createEmptyForm ( $ node ) { return new SimpleForm ( $ this -> tags ( ) -> createTag ( $ node -> name , ( array ) $ node -> attribute ) , $ this -> page ) ; }
6723	protected function validateAuthParams ( ) { if ( empty ( $ this -> authUrl ) || filter_var ( $ this -> authUrl , FILTER_VALIDATE_URL ) === false ) { throw new Oauth2ClientException ( sprintf ( self :: INVALID_AUTH_URL , $ this -> authUrl ) ) ; } if ( empty ( $ this -> clientId ) ) { throw new Oauth2ClientException ( self :: INVALID_CLIENT_ID ) ; } if ( empty ( $ this -> clientSecret ) ) { throw new Oauth2ClientException ( self :: INVALID_CLIENT_SECRET ) ; } return true ; }
3973	public function encodeAttributeValue ( EncodePropertyValueFromWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ metaModel = $ this -> getMetaModel ( $ event -> getEnvironment ( ) ) ; $ value = $ event -> getValue ( ) ; if ( ! ( $ metaModel && $ value ) ) { return ; } $ value = substr ( $ value , \ strlen ( $ metaModel -> getTableName ( ) . '_' ) ) ; $ attribute = $ metaModel -> getAttribute ( $ value ) ; if ( $ attribute ) { $ event -> setValue ( $ attribute -> get ( 'id' ) ) ; } }
7615	private function encodeBearer ( $ consumer_key , $ consumer_secret ) { $ consumer_key = rawurlencode ( $ consumer_key ) ; $ consumer_secret = rawurlencode ( $ consumer_secret ) ; return base64_encode ( $ consumer_key . ':' . $ consumer_secret ) ; }
3757	public function decodeValue ( DecodePropertyValueForWidgetEvent $ event ) { if ( ! ( $ this -> wantToHandle ( $ event ) && \ in_array ( $ event -> getProperty ( ) , [ 'name' , 'description' ] ) ) ) { return ; } $ metaModel = $ this -> getMetaModelByModelPid ( $ event -> getModel ( ) ) ; $ values = Helper :: decodeLangArray ( $ event -> getValue ( ) , $ metaModel ) ; $ event -> setValue ( unserialize ( $ values , [ 'allowed_classes' => false ] ) ) ; }
7929	public function setDefaultGroup ( $ defaultGroup ) { list ( $ defaultGroup ) = $ this -> fireEvent ( 'default-group.set' , [ $ defaultGroup ] ) ; $ this -> defaultGroup = $ defaultGroup ; return $ this ; }
9423	public function getSize ( ) { if ( is_null ( $ this -> size ) === true ) { $ stats = fstat ( $ this -> stream ) ; $ this -> size = $ stats [ 'size' ] ; } return $ this -> size ; }
6168	protected function writeAssertionFailure ( $ assertionFailure ) { $ this -> writeNewLine ( ) ; foreach ( explode ( "\n" , $ assertionFailure ) as $ line ) { $ this -> writeWithColor ( 'fg-red' , $ line ) ; } }
4022	protected function getHelpForWidget ( $ widget ) { if ( $ GLOBALS [ 'TL_CONFIG' ] [ 'showHelp' ] && $ widget -> description ) { return sprintf ( '<p class="tl_help tl_tip%s">%s</p>' , $ widget -> tl_class , $ widget -> description ) ; } return '' ; }
12597	public function getCacheAdapter ( $ namespace ) { if ( ! $ this -> isCacheable ( $ namespace ) ) { return null ; } if ( is_array ( $ this -> cacheOptions -> getAdapter ( ) ) ) { if ( ! isset ( $ this -> cacheOptions -> getAdapter ( ) [ $ namespace ] ) ) { return null ; } $ adapter = $ this -> cacheOptions -> getAdapter ( ) [ $ namespace ] ; } else { $ adapter = $ this -> cacheOptions -> getAdapter ( ) ; } if ( is_object ( $ adapter ) ) { return $ adapter ; } if ( $ this -> getServiceLocator ( ) -> has ( $ adapter ) ) { return $ this -> getServiceLocator ( ) -> get ( $ adapter ) ; } return new $ adapter ; }
2379	public static function deserialize ( $ varValue , $ blnForceArray = false ) { if ( \ is_array ( $ varValue ) ) { return $ varValue ; } if ( $ varValue === null ) { return $ blnForceArray ? array ( ) : null ; } if ( ! \ is_string ( $ varValue ) ) { return $ blnForceArray ? array ( $ varValue ) : $ varValue ; } if ( trim ( $ varValue ) == '' ) { return $ blnForceArray ? array ( ) : '' ; } if ( strncmp ( $ varValue , 'a:' , 2 ) !== 0 ) { return $ blnForceArray ? array ( $ varValue ) : $ varValue ; } if ( preg_match ( '/[OoC]:\+?[0-9]+:"/' , $ varValue ) ) { trigger_error ( 'StringUtil::deserialize() does not allow serialized objects' , E_USER_WARNING ) ; return $ blnForceArray ? array ( $ varValue ) : $ varValue ; } $ varUnserialized = @ unserialize ( $ varValue , array ( 'allowed_classes' => false ) ) ; if ( \ is_array ( $ varUnserialized ) ) { $ varValue = $ varUnserialized ; } elseif ( $ blnForceArray ) { $ varValue = array ( $ varValue ) ; } return $ varValue ; }
6576	public function stop ( ) : void { if ( $ this -> isStarted ( ) ) { $ this -> getHandler ( ) -> destroy ( $ this -> getDataHolder ( ) -> getId ( ) ) ; $ this -> dataHolder = null ; } }
8849	public function category ( ) { $ category = $ this -> getCurrentCategory ( ) ; if ( $ category ) { $ this -> blogPosts = $ category -> BlogPosts ( ) ; return $ this -> render ( ) ; } return $ this -> httpError ( 404 , "Not Found" ) ; }
403	public function overrideDefaultSettings ( $ action ) { if ( isset ( $ this -> actions [ $ action -> id ] ) ) { $ actionParams = $ this -> actions [ $ action -> id ] ; $ actionParamsKeys = array_keys ( $ actionParams ) ; foreach ( $ this -> cors as $ headerField => $ headerValue ) { if ( in_array ( $ headerField , $ actionParamsKeys ) ) { $ this -> cors [ $ headerField ] = $ actionParams [ $ headerField ] ; } } } }
3692	protected function breadcrumb ( EnvironmentInterface $ environment ) { $ event = new GetBreadcrumbEvent ( $ environment ) ; $ environment -> getEventDispatcher ( ) -> dispatch ( $ event :: NAME , $ event ) ; $ arrReturn = $ event -> getElements ( ) ; if ( ! is_array ( $ arrReturn ) || count ( $ arrReturn ) == 0 ) { return null ; } $ GLOBALS [ 'TL_CSS' ] [ ] = 'bundles/ccadcgeneral/css/generalBreadcrumb.css' ; $ objTemplate = new ContaoBackendViewTemplate ( 'dcbe_general_breadcrumb' ) ; $ objTemplate -> elements = $ arrReturn ; return $ objTemplate -> parse ( ) ; }
4380	protected function visualWhiteSpace ( $ str ) { $ str = \ preg_replace_callback ( '/(\r\n|\r|\n)/' , array ( $ this , 'visualWhiteSpaceCallback' ) , $ str ) ; $ str = \ preg_replace ( '#(<br />)?\n$#' , '' , $ str ) ; $ str = \ str_replace ( "\t" , '<span class="ws_t">' . "\t" . '</span>' , $ str ) ; return $ str ; }
2427	public function onBuild ( MenuEvent $ event ) : void { if ( null === $ this -> managerPath || ! $ this -> isAdminUser ( ) ) { return ; } $ categoryNode = $ event -> getTree ( ) -> getChild ( 'system' ) ; if ( null === $ categoryNode ) { return ; } $ item = $ event -> getFactory ( ) -> createItem ( 'contao_manager' , [ 'label' => 'Contao Manager' , 'attributes' => [ 'title' => 'Contao Manager' , 'href' => '/' . $ this -> managerPath , 'class' => 'navigation contao_manager' , ] , ] ) ; $ categoryNode -> addChild ( $ item ) ; }
11700	public function getCachePool ( $ name ) { if ( array_key_exists ( $ name , $ this -> cachePools ) ) { return $ this -> cachePools [ $ name ] ; } throw new KeyNotFoundInSetException ( $ name , array_keys ( $ this -> cachePools ) , 'cache pools' ) ; }
11200	public function checkIfSingleton ( $ name , $ item ) { if ( isset ( $ this -> signaturesToSingletons -> $ name ) and $ this -> signaturesToSingletons -> $ name ) { $ this -> $ name = $ item ; $ this -> signaturesToSingletons = false ; } }
6137	public function searchtotal ( Search $ search ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'search' => $ search ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/search/total' , $ parameters ) ; return $ result ; }
2568	protected function checkAllIntegers ( ) { $ foundNonInt = false ; $ args = func_get_args ( ) ; foreach ( $ args as $ arg ) { if ( ! is_int ( $ arg ) ) { $ foundNonInt = true ; break ; } } return ! $ foundNonInt ; }
10820	public static function warning ( $ messages , $ linebreak = true , $ length = 0 ) { $ separator = $ linebreak ? "\n" : '' ; self :: write ( $ messages , 'warning' , $ length , $ separator ) ; }
7098	private function findStockUnits ( StockSubjectInterface $ subject ) { $ repository = $ this -> entityManager -> getRepository ( $ subject :: getStockUnitClass ( ) ) ; $ stockUnits = array_merge ( $ repository -> findNotClosedBySubject ( $ subject ) , $ repository -> findLatestClosedBySubject ( $ subject ) ) ; usort ( $ stockUnits , function ( StockUnitInterface $ a , StockUnitInterface $ b ) { if ( $ a -> getState ( ) === StockUnitStates :: STATE_CLOSED && $ b -> getState ( ) !== StockUnitStates :: STATE_CLOSED ) { return 1 ; } if ( $ a -> getState ( ) !== StockUnitStates :: STATE_CLOSED && $ b -> getState ( ) === StockUnitStates :: STATE_CLOSED ) { return - 1 ; } if ( $ a -> getState ( ) === StockUnitStates :: STATE_CLOSED && $ b -> getState ( ) === StockUnitStates :: STATE_CLOSED ) { $ aDate = $ a -> getClosedAt ( ) -> getTimestamp ( ) ; $ bDate = $ b -> getClosedAt ( ) -> getTimestamp ( ) ; if ( $ aDate > $ bDate ) { return - 1 ; } if ( $ aDate < $ bDate ) { return 1 ; } } $ aDate = $ a -> getCreatedAt ( ) -> getTimestamp ( ) ; $ bDate = $ b -> getCreatedAt ( ) -> getTimestamp ( ) ; if ( $ aDate > $ bDate ) { return - 1 ; } if ( $ aDate < $ bDate ) { return 1 ; } return 0 ; } ) ; return $ stockUnits ; }
494	public function flush ( $ final = false ) { $ messages = $ this -> messages ; $ this -> messages = [ ] ; if ( $ this -> dispatcher instanceof Dispatcher ) { $ this -> dispatcher -> dispatch ( $ messages , $ final ) ; } }
5272	protected function translateOrderBy ( ) { $ build = array ( ) ; foreach ( $ this -> statements [ 'orders' ] as $ column => $ direction ) { if ( is_array ( $ direction ) ) { list ( $ column , $ direction ) = $ direction ; } if ( ! is_null ( $ direction ) ) { $ column .= ' ' . $ direction ; } $ build [ ] = $ column ; } return 'order by ' . join ( ', ' , $ build ) ; }
10104	private function writeWindow2 ( ) { $ record = 0x023E ; $ length = 0x0012 ; $ grbit = 0x00B6 ; $ rwTop = 0x0000 ; $ colLeft = 0x0000 ; $ fDspFmla = 0 ; $ fDspGrid = $ this -> phpSheet -> getShowGridlines ( ) ? 1 : 0 ; $ fDspRwCol = $ this -> phpSheet -> getShowRowColHeaders ( ) ? 1 : 0 ; $ fFrozen = $ this -> phpSheet -> getFreezePane ( ) ? 1 : 0 ; $ fDspZeros = 1 ; $ fDefaultHdr = 1 ; $ fArabic = $ this -> phpSheet -> getRightToLeft ( ) ? 1 : 0 ; $ fDspGuts = $ this -> outlineOn ; $ fFrozenNoSplit = 0 ; $ fSelected = ( $ this -> phpSheet === $ this -> phpSheet -> getParent ( ) -> getActiveSheet ( ) ) ? 1 : 0 ; $ fPaged = 1 ; $ fPageBreakPreview = $ this -> phpSheet -> getSheetView ( ) -> getView ( ) === SheetView :: SHEETVIEW_PAGE_BREAK_PREVIEW ; $ grbit = $ fDspFmla ; $ grbit |= $ fDspGrid << 1 ; $ grbit |= $ fDspRwCol << 2 ; $ grbit |= $ fFrozen << 3 ; $ grbit |= $ fDspZeros << 4 ; $ grbit |= $ fDefaultHdr << 5 ; $ grbit |= $ fArabic << 6 ; $ grbit |= $ fDspGuts << 7 ; $ grbit |= $ fFrozenNoSplit << 8 ; $ grbit |= $ fSelected << 9 ; $ grbit |= $ fPaged << 10 ; $ grbit |= $ fPageBreakPreview << 11 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vvv' , $ grbit , $ rwTop , $ colLeft ) ; $ rgbHdr = 0x0040 ; $ zoom_factor_page_break = ( $ fPageBreakPreview ? $ this -> phpSheet -> getSheetView ( ) -> getZoomScale ( ) : 0x0000 ) ; $ zoom_factor_normal = $ this -> phpSheet -> getSheetView ( ) -> getZoomScaleNormal ( ) ; $ data .= pack ( 'vvvvV' , $ rgbHdr , 0x0000 , $ zoom_factor_page_break , $ zoom_factor_normal , 0x00000000 ) ; $ this -> append ( $ header . $ data ) ; }
3338	public static function dateTimeString ( $ datetime ) { if ( $ datetime === null ) { return null ; } if ( is_object ( $ datetime ) && ! ( $ datetime instanceof \ DateTime ) ) { throw new \ Exception ( 'Only \DateTime objects allowed' ) ; } if ( is_string ( $ datetime ) ) { $ datetime = new \ DateTime ( $ datetime ) ; } return $ datetime -> format ( "Y-m-d\TH:i:s.uP" ) ; }
6382	public function readQuestions ( $ quizId ) { $ quizSlots = $ this -> readStoreRecords ( 'quiz_slots' , [ 'quizid' => $ quizId ] ) ; $ questions = [ ] ; foreach ( $ quizSlots as $ index => $ quizSlot ) { try { $ question = $ this -> readStoreRecord ( 'question' , [ 'id' => $ quizSlot -> questionid ] ) ; $ question -> answers = $ this -> readStoreRecords ( 'question_answers' , [ 'question' => $ question -> id ] ) ; $ question -> url = $ this -> cfg -> wwwroot . '/mod/question/question.php?id=' . $ question -> id ; if ( $ question -> qtype == 'numerical' ) { $ question -> numerical = ( object ) [ 'answers' => $ this -> readStoreRecords ( 'question_numerical' , [ 'question' => $ question -> id ] ) , 'options' => $ this -> readStoreRecord ( 'question_numerical_options' , [ 'question' => $ question -> id ] ) , 'units' => $ this -> readStoreRecords ( 'question_numerical_units' , [ 'question' => $ question -> id ] ) ] ; } else if ( $ question -> qtype == 'match' ) { $ question -> match = ( object ) [ 'options' => $ this -> readStoreRecord ( 'qtype_match_options' , [ 'questionid' => $ question -> id ] ) , 'subquestions' => $ this -> readStoreRecords ( 'qtype_match_subquestions' , [ 'questionid' => $ question -> id ] ) ] ; } else if ( strpos ( $ question -> qtype , 'calculated' ) === 0 ) { $ question -> calculated = ( object ) [ 'answers' => $ this -> readStoreRecords ( 'question_calculated' , [ 'question' => $ question -> id ] ) , 'options' => $ this -> readStoreRecord ( 'question_calculated_options' , [ 'question' => $ question -> id ] ) ] ; } else if ( $ question -> qtype == 'shortanswer' ) { $ question -> shortanswer = ( object ) [ 'options' => $ this -> readStoreRecord ( 'qtype_shortanswer_options' , [ 'questionid' => $ question -> id ] ) ] ; } $ questions [ $ question -> id ] = $ question ; } catch ( \ Exception $ e ) { } } return $ questions ; }
10484	public static function createSpamComplaint ( $ recipientEmailAddress , $ listExternalId , $ recipientExternalId = null , $ ipAddress = '127.0.0.1' ) { if ( $ recipientExternalId == null ) { $ recipientExternalId = rand ( 1 , 99999 ) ; } return ( new Payload ( ) ) -> setIpAddress ( $ ipAddress ) -> setAction ( Type :: SPAM_COMPLAINT ) -> setCampaignId ( rand ( 1 , 99999 ) ) -> setListExternalId ( $ listExternalId ) -> setReason ( Type :: REASON_USER_REQUEST ) -> setRecipientEmailAddress ( $ recipientEmailAddress ) -> setHash ( md5 ( $ recipientEmailAddress ) ) -> setRecipientExternalId ( $ recipientExternalId ) -> setTriggerDate ( new \ DateTime ( ) ) -> setType ( Type :: SPAM_COMPLAINT ) ; }
4946	public function build ( ) { $ view = $ change = array ( ) ; foreach ( $ this -> assigned as $ resourceId => $ spec ) { if ( isset ( $ spec [ 'permission' ] ) ) { $ spec = array ( $ spec [ 'permission' ] => $ spec [ 'users' ] ) ; $ this -> assigned [ $ resourceId ] = $ spec ; } foreach ( $ spec as $ perm => $ userIds ) { if ( self :: PERMISSION_ALL == $ perm || self :: PERMISSION_CHANGE == $ perm ) { $ change = array_merge ( $ change , $ userIds ) ; } $ view = array_merge ( $ view , $ userIds ) ; } } $ this -> change = array_unique ( $ change ) ; $ this -> view = array_unique ( $ view ) ; return $ this ; }
3206	private function parse_response_headers ( $ headers ) { $ head = array ( ) ; foreach ( $ headers as $ key => $ value ) { $ tag = explode ( ':' , $ value , 2 ) ; if ( isset ( $ tag [ 1 ] ) ) { $ head [ trim ( $ tag [ 0 ] ) ] = trim ( $ tag [ 1 ] ) ; } else { $ head [ ] = $ value ; if ( preg_match ( '`HTTP/[0-9\.]+\s+([0-9]+)`' , $ value , $ out ) ) { $ head [ 'response_code' ] = intval ( $ out [ 1 ] ) ; } } } return $ head ; }
10951	private function validateCsrfTokenInternal ( $ token , $ trueToken ) { $ token = base64_decode ( str_replace ( '.' , '+' , $ token ) ) ; $ n = StringHelper :: byteLength ( $ token ) ; if ( $ n <= static :: CSRF_MASK_LENGTH ) { return false ; } $ mask = StringHelper :: byteSubstr ( $ token , 0 , static :: CSRF_MASK_LENGTH ) ; $ token = StringHelper :: byteSubstr ( $ token , static :: CSRF_MASK_LENGTH , $ n - static :: CSRF_MASK_LENGTH ) ; $ token = $ this -> xorTokens ( $ mask , $ token ) ; return $ token === $ trueToken ; }
6164	public function setData ( $ data ) { if ( is_array ( $ data ) ) { $ this -> data = $ data ; return $ this ; } $ this -> data = json_decode ( $ data , true ) ; if ( null === $ this -> data ) { $ this -> data = $ data ; } return $ this ; }
6120	public function serverStart ( $ sid ) { if ( $ sid == $ this -> serverSelectedId ( ) ) { $ this -> serverDeselect ( ) ; } $ this -> execute ( "serverstart" , array ( "sid" => $ sid ) ) ; $ this -> serverListReset ( ) ; Signal :: getInstance ( ) -> emit ( "notifyServerstarted" , $ this , $ sid ) ; }
1639	protected function setupCallbacks ( Client $ client , Container $ app , array $ config ) { if ( ! isset ( $ config [ 'callbacks' ] ) || $ config [ 'callbacks' ] ) { $ client -> registerDefaultCallbacks ( ) ; $ client -> registerCallback ( function ( Report $ report ) use ( $ app ) { $ tracker = $ app -> make ( Tracker :: class ) ; if ( $ context = $ tracker -> context ( ) ) { $ report -> setContext ( $ context ) ; } if ( $ job = $ tracker -> get ( ) ) { $ report -> setMetaData ( [ 'job' => $ job ] ) ; } } ) ; } if ( ! isset ( $ config [ 'user' ] ) || $ config [ 'user' ] ) { $ client -> registerCallback ( new CustomUser ( function ( ) use ( $ app ) { if ( $ user = $ app -> auth -> user ( ) ) { if ( method_exists ( $ user , 'attributesToArray' ) && is_callable ( [ $ user , 'attributesToArray' ] ) ) { return $ user -> attributesToArray ( ) ; } if ( $ user instanceof GenericUser ) { $ reflection = new ReflectionClass ( $ user ) ; $ property = $ reflection -> getProperty ( 'attributes' ) ; $ property -> setAccessible ( true ) ; return $ property -> getValue ( $ user ) ; } } } ) ) ; } }
7061	private function setClasses ( array $ classes ) { if ( ! empty ( $ classes ) ) { $ this -> vars [ 'attr' ] [ 'class' ] = ' ' . trim ( implode ( ' ' , $ classes ) ) ; } else { unset ( $ this -> vars [ 'attr' ] [ 'class' ] ) ; } }
2360	public static function findPublishedById ( $ intId , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.id=?" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.disable=''" ; } return static :: findOneBy ( $ arrColumns , $ intId , $ arrOptions ) ; }
12008	public function getMessages ( $ domain = 'default' , $ locale = null ) { if ( $ locale === null ) { $ locale = $ this -> getLocale ( ) ; } if ( ! isset ( $ this -> messages [ $ domain ] [ $ locale ] ) ) { $ this -> loadMessages ( $ domain , $ locale ) ; } return $ this -> messages [ $ domain ] [ $ locale ] ; }
5689	public function getFormById ( $ id ) { for ( $ i = 0 ; $ i < count ( $ this -> forms ) ; $ i ++ ) { if ( $ this -> forms [ $ i ] -> getId ( ) == $ id ) { return $ this -> forms [ $ i ] ; } } return ; }
16	public static function getContentHash ( $ composerFileContents ) { $ content = json_decode ( $ composerFileContents , true ) ; $ relevantKeys = array ( 'name' , 'version' , 'require' , 'require-dev' , 'conflict' , 'replace' , 'provide' , 'minimum-stability' , 'prefer-stable' , 'repositories' , 'extra' , ) ; $ relevantContent = array ( ) ; foreach ( array_intersect ( $ relevantKeys , array_keys ( $ content ) ) as $ key ) { $ relevantContent [ $ key ] = $ content [ $ key ] ; } if ( isset ( $ content [ 'config' ] [ 'platform' ] ) ) { $ relevantContent [ 'config' ] [ 'platform' ] = $ content [ 'config' ] [ 'platform' ] ; } ksort ( $ relevantContent ) ; return md5 ( json_encode ( $ relevantContent ) ) ; }
3527	private function fetch ( ) { $ data = FortniteClient :: sendFortnitePostRequest ( FortniteClient :: FORTNITE_API . 'game/v2/profile/' . $ this -> account_id . '/client/QueryProfile?profileId=athena&rvn=-1' , $ this -> access_token , new \ StdClass ( ) ) ; return $ data -> profileChanges [ 0 ] -> profile ; }
7542	function typeIndex ( ) { if ( ! $ this -> parent ) { return - 1 ; } else { $ index = - 1 ; foreach ( array_keys ( $ this -> parent -> children ) as $ k ) { if ( strcasecmp ( $ this -> tag , $ this -> parent -> children [ $ k ] -> tag ) === 0 ) { ++ $ index ; } if ( $ this -> parent -> children [ $ k ] === $ this ) { return $ index ; } } return - 1 ; } }
9244	private function __loadConfigFiles ( ) { $ additionalConfigs = $ this -> config ( 'additionalConfigFiles' ) ; foreach ( $ additionalConfigs as $ additionalConfig ) { Configure :: load ( $ additionalConfig ) ; } }
11517	protected function GenerateIOSPinicon ( SiteConfig $ config , SiteTree $ owner , & $ metadata , Image $ IOSPinicon ) { $ metadata .= $ this -> owner -> MarkupComment ( 'iOS Pinned Icon' ) ; if ( $ config -> fetchPiniconTitle ( ) ) { $ metadata .= $ owner -> MarkupMeta ( 'apple-mobile-web-app-title' , $ config -> fetchPiniconTitle ( ) ) ; } $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 57 , 57 ) -> getAbsoluteURL ( ) , 'image/png' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 60 , 60 ) -> getAbsoluteURL ( ) , 'image/png' , '60x60' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 72 , 72 ) -> getAbsoluteURL ( ) , 'image/png' , '72x72' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 76 , 76 ) -> getAbsoluteURL ( ) , 'image/png' , '76x76' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 114 , 114 ) -> getAbsoluteURL ( ) , 'image/png' , '114x114' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 120 , 120 ) -> getAbsoluteURL ( ) , 'image/png' , '120x120' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 144 , 144 ) -> getAbsoluteURL ( ) , 'image/png' , '144x144' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 152 , 152 ) -> getAbsoluteURL ( ) , 'image/png' , '152x152' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 180 , 180 ) -> getAbsoluteURL ( ) , 'image/png' , '180x180' ) ; }
9513	public function setMatchModeByModeName ( $ modeName ) { $ modes = [ 'all' => 0 , 'any' => 1 , 'phrase' => 2 , 'boolean' => 3 , 'extended' => 4 , 'fullscan' => 5 , ] ; if ( array_key_exists ( $ modeName , $ modes ) ) { $ mode = $ modes [ $ modeName ] ; $ this -> SetMatchMode ( $ mode ) ; } else { throw new \ LogicException ( 'Wrong Mode' ) ; } }
9090	function isMultipart ( ) { foreach ( $ this -> fields as $ field ) { if ( ! $ field instanceof Field ) { continue ; } if ( $ field -> getType ( ) == 'file' || $ field -> getValueType ( ) == 'file' || $ field -> getDataType ( ) ) { return true ; } } return false ; }
79	public function createRepository ( $ type , $ config , $ name = null ) { if ( ! isset ( $ this -> repositoryClasses [ $ type ] ) ) { throw new \ InvalidArgumentException ( 'Repository type is not registered: ' . $ type ) ; } if ( isset ( $ config [ 'packagist' ] ) && false === $ config [ 'packagist' ] ) { $ this -> io -> writeError ( '<warning>Repository "' . $ name . '" (' . json_encode ( $ config ) . ') has a packagist key which should be in its own repository definition</warning>' ) ; } $ class = $ this -> repositoryClasses [ $ type ] ; $ reflMethod = new \ ReflectionMethod ( $ class , '__construct' ) ; $ params = $ reflMethod -> getParameters ( ) ; if ( isset ( $ params [ 4 ] ) && $ params [ 4 ] -> getClass ( ) && $ params [ 4 ] -> getClass ( ) -> getName ( ) === 'Composer\Util\RemoteFilesystem' ) { return new $ class ( $ config , $ this -> io , $ this -> config , $ this -> eventDispatcher , $ this -> rfs ) ; } return new $ class ( $ config , $ this -> io , $ this -> config , $ this -> eventDispatcher ) ; }
10881	public function checkPaths ( ) { if ( $ this -> path_checked ) return true ; foreach ( array ( 'root' , 'webroot' ) as $ type ) { $ path = $ this -> $ type ; if ( ! file_exists ( $ path ) || ! is_dir ( $ path ) ) throw new IOException ( "Path '$type' does not exist: " . $ path ) ; if ( ! is_readable ( $ path ) ) throw new PermissionError ( $ path , "Path '$type' cannot be read" ) ; } if ( ! is_dir ( $ this -> config ) || is_readable ( $ this -> config ) ) $ this -> config = null ; foreach ( array ( 'var' , 'cache' , 'log' , 'uploads' ) as $ write_dir ) { $ path = $ this -> $ write_dir ; if ( ! is_dir ( $ path ) ) { $ dn = dirname ( $ path ) ; if ( ! file_exists ( $ path ) && $ dn === $ this -> var ) { Path :: mkdir ( $ path ) ; } else { if ( file_exists ( $ path ) ) throw new IOException ( "Path '$write_dir' exists but is not a directory: " . $ path ) ; $ this -> $ write_dir = null ; continue ; } } if ( ! is_writable ( $ path ) ) { try { Path :: makeWritable ( $ path ) ; } catch ( PermissionError $ e ) { $ this -> $ write_dir = null ; if ( $ this -> cli ) WF :: debug ( "Failed to get write access to: %s" , $ e -> getMessage ( ) ) ; } } } $ this -> path_checked = true ; return true ; }
8454	protected function downloadMediaFileFromURL ( $ fileUri , $ tempFileName ) { $ curl = curl_init ( ) ; curl_setopt ( $ curl , CURLOPT_URL , "$fileUri" ) ; curl_setopt ( $ curl , CURLOPT_USERAGENT , "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.11) Gecko/20071127 Firefox/2.0.0.11" ) ; curl_setopt ( $ curl , CURLOPT_RETURNTRANSFER , true ) ; curl_setopt ( $ curl , CURLOPT_HEADER , false ) ; curl_setopt ( $ curl , CURLOPT_NOBODY , false ) ; curl_setopt ( $ curl , CURLOPT_BUFFERSIZE , 1024 ) ; curl_setopt ( $ curl , CURLOPT_FILE , $ tempFileName ) ; curl_exec ( $ curl ) ; curl_close ( $ curl ) ; }
7407	public function serialize ( ) : string { return serialize ( [ '_type' => $ this -> _type , '_arrayOptions' => $ this -> _arrayOptions , '_jsonOptions' => $ this -> _jsonOptions , '_container' => $ this -> _container , ] ) ; }
700	public function actionExt ( $ extension , $ repo = null ) { $ base = \ dirname ( \ dirname ( __DIR__ ) ) ; $ extensionDir = "$base/extensions/$extension" ; if ( ! file_exists ( $ extensionDir ) ) { if ( empty ( $ repo ) ) { if ( isset ( $ this -> extensions [ $ extension ] ) ) { $ repo = $ this -> extensions [ $ extension ] ; if ( $ this -> useHttp ) { $ repo = str_replace ( 'git@github.com:' , 'https://github.com/' , $ repo ) ; } } else { $ this -> stderr ( "Repo argument is required for extension '$extension'.\n" , Console :: FG_RED ) ; return 1 ; } } $ this -> stdout ( "cloning extension repo '$extension' from '$repo'...\n" , Console :: BOLD ) ; passthru ( 'git clone ' . escapeshellarg ( $ repo ) . ' ' . $ extensionDir ) ; $ this -> stdout ( "done.\n" , Console :: BOLD , Console :: FG_GREEN ) ; } $ this -> stdout ( "cleaning up extension '$extension' vendor directory...\n" , Console :: BOLD ) ; $ this -> cleanupVendorDir ( $ extensionDir ) ; $ this -> stdout ( "done.\n" , Console :: BOLD , Console :: FG_GREEN ) ; $ this -> stdout ( "updating composer for extension '$extension'...\n" , Console :: BOLD ) ; chdir ( $ extensionDir ) ; $ command = 'composer update --prefer-dist' ; if ( $ this -> composerNoProgress ) { $ command .= ' --no-progress' ; } passthru ( $ command ) ; $ this -> stdout ( "done.\n" , Console :: BOLD , Console :: FG_GREEN ) ; $ this -> stdout ( "linking framework and extensions to '$extension' vendor dir...\n" , Console :: BOLD ) ; $ this -> linkFrameworkAndExtensions ( $ extensionDir , $ base ) ; $ this -> stdout ( "done.\n" , Console :: BOLD , Console :: FG_GREEN ) ; return 0 ; }
6958	public function setForcedRedirect ( $ url ) { $ data = $ this -> getData ( true ) ; $ data [ static :: $ forcedRedirectKey ] = $ url ; return $ this -> setData ( $ data ) ; }
8740	public function i18nQuery ( ) { $ query = $ this -> getModel ( ) -> newQueryWithoutScopes ( ) -> getQuery ( ) ; $ query -> from ( $ this -> model -> getI18nTable ( ) ) ; return $ query ; }
7486	public function indexOf ( $ string , $ offset = null ) { $ string = static :: convertString ( $ string , $ this -> encoding ) ; $ offset = $ offset !== null ? ( int ) $ offset : null ; if ( $ offset !== null && ( $ offset < 0 || $ offset >= $ this -> length ( ) ) ) { throw new \ OutOfBoundsException ( ) ; } return mb_strpos ( $ this -> string , $ string , $ offset , $ this -> encoding ) ; }
9276	public function validateFields ( Request $ request , Repository $ repository , $ data ) { $ config = [ ] ; $ validation = [ ] ; foreach ( $ this -> versions as $ version ) { foreach ( $ version [ 'endpoints' ] as $ endpoint ) { if ( $ endpoint [ 'repository' ] == $ request -> attributes -> get ( 'repository' ) ) { $ config = $ endpoint ; break ; } } if ( $ config != [ ] ) { break ; } } if ( ! $ config [ 'allow_extra_fields' ] || $ config [ 'allow_fields' ] ) { $ mapping = $ this -> manager -> getMetadataCollector ( ) -> getMapping ( $ repository -> getClassName ( ) ) ; $ forbiddenFields = $ mapping [ 'properties' ] ; if ( $ config [ 'allow_fields' ] ) { foreach ( $ config [ 'allow_fields' ] as $ field ) { unset ( $ forbiddenFields [ $ field ] ) ; } } foreach ( $ data as $ parameter => $ value ) { if ( ! array_key_exists ( $ parameter , $ mapping [ 'properties' ] ) && $ parameter != '_id' ) { $ validation [ 'message' ] = sprintf ( 'Property `%s` does not exist in the mapping of `%s`.' , $ parameter , $ repository -> getType ( ) ) ; return $ validation ; } if ( $ config [ 'allow_fields' ] && array_key_exists ( $ parameter , $ forbiddenFields ) ) { $ validation [ 'message' ] = sprintf ( 'You are not allowed to insert or modify the field `%s` in `%s`' , $ parameter , $ repository -> getType ( ) ) ; return $ validation ; } } } return $ validation ; }
251	public function removeFlash ( $ key ) { $ counters = $ this -> get ( $ this -> flashParam , [ ] ) ; $ value = isset ( $ _SESSION [ $ key ] , $ counters [ $ key ] ) ? $ _SESSION [ $ key ] : null ; unset ( $ counters [ $ key ] , $ _SESSION [ $ key ] ) ; $ _SESSION [ $ this -> flashParam ] = $ counters ; return $ value ; }
2061	public function generateAlias ( $ varValue , Contao \ DataContainer $ dc ) { $ objPage = Contao \ PageModel :: findWithDetails ( $ dc -> id ) ; $ aliasExists = function ( string $ alias ) use ( $ dc , $ objPage ) : bool { $ objAliasIds = $ this -> Database -> prepare ( "SELECT id FROM tl_page WHERE alias=? AND id!=?" ) -> execute ( $ alias , $ dc -> id ) ; if ( ! $ objAliasIds -> numRows ) { return false ; } $ strCurrentDomain = $ objPage -> domain ; $ strCurrentLanguage = $ objPage -> rootLanguage ; if ( $ objPage -> type == 'root' ) { $ strCurrentDomain = Contao \ Input :: post ( 'dns' ) ; $ strCurrentLanguage = Contao \ Input :: post ( 'language' ) ; } while ( $ objAliasIds -> next ( ) ) { $ objAliasPage = Contao \ PageModel :: findWithDetails ( $ objAliasIds -> id ) ; if ( $ objAliasPage -> domain != $ strCurrentDomain ) { continue ; } if ( Contao \ Config :: get ( 'addLanguageToUrl' ) && $ objAliasPage -> rootLanguage != $ strCurrentLanguage ) { continue ; } return true ; } return false ; } ; if ( $ varValue == '' ) { $ varValue = Contao \ System :: getContainer ( ) -> get ( 'contao.slug' ) -> generate ( $ dc -> activeRecord -> title , $ dc -> activeRecord -> id , function ( $ alias ) use ( $ objPage , $ aliasExists ) { return $ aliasExists ( ( Contao \ Config :: get ( 'folderUrl' ) ? $ objPage -> folderUrl : '' ) . $ alias ) ; } ) ; if ( Contao \ Config :: get ( 'folderUrl' ) && $ objPage -> folderUrl != '' ) { $ varValue = $ objPage -> folderUrl . $ varValue ; } } elseif ( $ aliasExists ( $ varValue ) ) { throw new Exception ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'aliasExists' ] , $ varValue ) ) ; } return $ varValue ; }
12981	public function preDispatch ( ) { $ error = null ; $ request = $ this -> getRequest ( ) ; if ( ! $ request -> isGet ( ) && ! $ request -> isHead ( ) ) { $ this -> _input = json_decode ( $ request -> getRawBody ( ) ) ; if ( JSON_ERROR_NONE === json_last_error ( ) ) { return ; } $ this -> getResponse ( ) -> setHttpResponseCode ( 400 ) -> setHeader ( 'Content-Type' , 'text/plain; charset=utf-8' , true ) -> setBody ( json_last_error_msg ( ) ) -> sendResponse ( ) ; exit ( 400 ) ; } }
12535	public function fetchByApplyId ( $ applyId , $ lastSeen , $ count ) { $ params = [ 'type' => 3 , 'apply_id' => intval ( $ applyId ) , 'last_seen' => intval ( $ lastSeen ) , 'count' => intval ( $ count ) , ] ; return $ this -> fetch ( $ params ) ; }
6669	public function set_movie_params ( ) { $ post_id = get_the_ID ( ) ; $ is_active = $ this -> get_rating_state ( $ post_id ) ; $ options = $ this -> model -> get_theme_options ( ) ; $ params = [ 'postID' => $ post_id , 'dark' => $ options [ 'enable-dark' ] , 'imdb_button' => __ ( 'TOTAL' , 'extensions-for-grifus-rating' ) , 'is_active' => $ is_active , ] ; return $ params ; }
9644	protected function mapParams ( array $ params ) : array { unset ( $ params [ 0 ] ) ; foreach ( $ params as $ name => $ value ) { if ( ! is_string ( $ name ) ) { unset ( $ params [ $ name ] ) ; } else { $ params [ $ name ] = urldecode ( $ value [ 0 ] ) ; } } return $ params ; }
7810	public function getPackageVersion ( ) { $ package_config = file_get_contents ( dirname ( __FILE__ ) . "./../composer.json" ) ; if ( $ package_config ) { $ package_config_object = json_decode ( $ package_config ) ; if ( is_object ( $ package_config_object ) && isset ( $ package_config_object -> version ) ) { return $ package_config_object -> version ; } } return null ; }
1161	private function fakeRequiredIfData ( $ data , $ rule , $ parameters ) { if ( $ rule !== 'RequiredIf' ) { return ; } $ newData = $ data ; $ newData [ $ parameters [ 0 ] ] = $ parameters [ 1 ] ; $ this -> validator -> setData ( $ newData ) ; }
511	protected function formatOptionHelp ( $ name , $ required , $ type , $ defaultValue , $ comment ) { $ comment = trim ( $ comment ) ; $ type = trim ( $ type ) ; if ( strncmp ( $ type , 'bool' , 4 ) === 0 ) { $ type = 'boolean, 0 or 1' ; } if ( $ defaultValue !== null && ! is_array ( $ defaultValue ) ) { if ( $ type === null ) { $ type = gettype ( $ defaultValue ) ; } if ( is_bool ( $ defaultValue ) ) { $ defaultValue = ( int ) $ defaultValue ; } if ( is_string ( $ defaultValue ) ) { $ defaultValue = "'" . $ defaultValue . "'" ; } else { $ defaultValue = var_export ( $ defaultValue , true ) ; } $ doc = "$type (defaults to $defaultValue)" ; } else { $ doc = $ type ; } if ( $ doc === '' ) { $ doc = $ comment ; } elseif ( $ comment !== '' ) { $ doc .= "\n" . preg_replace ( '/^/m' , ' ' , $ comment ) ; } $ name = $ required ? "$name (required)" : $ name ; return $ doc === '' ? $ name : "$name: $doc" ; }
459	public function getColumnType ( $ type ) { if ( $ type instanceof ColumnSchemaBuilder ) { $ type = $ type -> __toString ( ) ; } if ( isset ( $ this -> typeMap [ $ type ] ) ) { return $ this -> typeMap [ $ type ] ; } elseif ( preg_match ( '/^(\w+)\((.+?)\)(.*)$/' , $ type , $ matches ) ) { if ( isset ( $ this -> typeMap [ $ matches [ 1 ] ] ) ) { return preg_replace ( '/\(.+\)/' , '(' . $ matches [ 2 ] . ')' , $ this -> typeMap [ $ matches [ 1 ] ] ) . $ matches [ 3 ] ; } } elseif ( preg_match ( '/^(\w+)\s+/' , $ type , $ matches ) ) { if ( isset ( $ this -> typeMap [ $ matches [ 1 ] ] ) ) { return preg_replace ( '/^\w+/' , $ this -> typeMap [ $ matches [ 1 ] ] , $ type ) ; } } return $ type ; }
9345	public function getRow ( $ int = 0 ) { if ( ! isset ( $ this -> arr [ $ int ] ) ) { throw new \ OutOfRangeException ( 'There is no line having this index.' ) ; } return $ this -> arr [ $ int ] ; }
11184	protected function generateActions ( ) { $ parser = new Parser ( ) ; $ parser -> setPath ( $ this -> getApplicationPath ( ) ) ; $ parser -> setNameSpace ( $ this -> getApplicationNameSpace ( ) ) ; $ list = $ parser -> run ( ) ; return $ list ; }
6726	public function get_movie_votes ( $ post_id ) { $ votes = get_post_meta ( $ post_id , 'imdbTotalVotes' , true ) ; if ( ! empty ( $ votes ) ) { return json_decode ( $ votes , true ) ; } return false ; }
5550	public function getRequestData ( ) { if ( is_integer ( $ this -> focus ) ) { return $ this -> frames [ $ this -> focus ] -> getRequestData ( ) ; } return $ this -> frameset -> getRequestData ( ) ; }
7647	public function stream_open ( $ path , $ mode , $ options , & $ opened_path ) { $ this -> fileName = $ path ; $ this -> temporaryFileName = tempnam ( sys_get_temp_dir ( ) , 'azure' ) ; $ fh = @ fopen ( $ this -> temporaryFileName , $ mode ) ; if ( $ fh === false ) { return false ; } fclose ( $ fh ) ; if ( strpbrk ( $ mode , 'wax+' ) ) { $ this -> writeMode = true ; } else { $ this -> writeMode = false ; } if ( ! $ this -> writeMode || strpbrk ( $ mode , 'ra+' ) ) { $ this -> getStorageClient ( $ this -> fileName ) -> getBlob ( $ this -> getContainerName ( $ this -> fileName ) , $ this -> getFileName ( $ this -> fileName ) , $ this -> temporaryFileName ) ; } $ this -> temporaryFileHandle = fopen ( $ this -> temporaryFileName , $ mode ) ; return true ; }
8569	public function setSKUPrepInstructions ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'SKUPrepInstructions' ] [ 'FieldValue' ] = $ value ; return $ this ; }
6045	protected function renderItems ( $ items ) { $ lines = [ ] ; foreach ( $ items as $ i => $ item ) { if ( isset ( $ item [ 'visible' ] ) && ! $ item [ 'visible' ] ) { unset ( $ items [ $ i ] ) ; continue ; } if ( is_string ( $ item ) ) { $ lines [ ] = $ item ; continue ; } $ options = ArrayHelper :: getValue ( $ item , 'options' , [ ] ) ; if ( isset ( $ item [ 'divider' ] ) ) { Html :: addCssClass ( $ options , 'divider' ) ; $ lines [ ] = Html :: tag ( 'li' , '' , $ options ) ; continue ; } if ( ! isset ( $ item [ 'label' ] ) ) { throw new InvalidConfigException ( "The 'label' option is required." ) ; } $ label = $ this -> encodeLabels ? Html :: encode ( $ item [ 'label' ] ) : $ item [ 'label' ] ; $ linkOptions = ArrayHelper :: getValue ( $ item , 'linkOptions' , [ ] ) ; $ linkOptions [ 'tabindex' ] = '-1' ; $ badgeOptions = ArrayHelper :: getValue ( $ item , 'badgeOptions' , [ ] ) ; $ label = Html :: tag ( 'i' , '' , $ linkOptions ) . Html :: tag ( 'span' , $ label ) ; $ label .= $ this -> renderBadge ( $ badgeOptions ) ; $ content = Html :: a ( $ label , ArrayHelper :: getValue ( $ item , 'url' , '#' ) ) ; if ( ! empty ( $ item [ 'items' ] ) ) { $ content .= $ this -> renderItems ( $ item [ 'items' ] ) ; Html :: addCssClass ( $ options , 'dropdown-submenu' ) ; } $ lines [ ] = Html :: tag ( 'li' , $ content , $ options ) ; } return Html :: tag ( 'ul' , implode ( "\n" , $ lines ) , $ this -> options ) ; }
2790	public static function getMutation ( array & $ tokens , $ index ) { $ num = ( float ) $ tokens [ $ index ] [ 1 ] ; if ( $ num == 0 ) { $ replace = 1.0 ; } elseif ( $ num == 1 ) { $ replace = 0.0 ; } elseif ( $ num < 2 ) { $ replace = $ num + 1 ; } else { $ replace = 1.0 ; } $ tokens [ $ index ] = [ T_DNUMBER , sprintf ( "%.2f" , $ replace ) ] ; }
6068	public function listVersions ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/media/' . $ id . '/versions' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new MediaVersion ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
6685	public function sendFailResponse ( $ data , $ httpStatusCode = 500 ) { \ Yii :: $ app -> response -> format = Response :: FORMAT_JSON ; \ Yii :: $ app -> response -> setStatusCode ( $ httpStatusCode , $ this -> httpStatuses -> getReasonPhrase ( $ httpStatusCode ) ) ; return [ 'status' => 'fail' , 'data' => $ data ] ; }
490	protected function findPrimaryKeys ( $ table ) { $ result = [ ] ; foreach ( $ this -> findTableConstraints ( $ table , 'PRIMARY KEY' ) as $ row ) { $ result [ ] = $ row [ 'field_name' ] ; } $ table -> primaryKey = $ result ; }
5778	public function set ( string $ sql , array $ args ) { $ this -> sql = $ sql ; $ this -> args = $ args ; }
9296	private function update ( $ documents , $ repository , $ commitSize ) { if ( count ( $ documents ) > $ commitSize && $ commitSize > 1 ) { $ esResponse = [ ] ; $ i = 1 ; foreach ( $ documents as $ document ) { $ id = $ document [ '_id' ] ; unset ( $ document [ '_id' ] ) ; $ this -> crud -> update ( $ repository , $ id , $ document ) ; if ( $ i ++ % ( $ commitSize - 1 ) == 0 ) { $ esResponse [ ] = $ this -> crud -> commit ( $ repository ) ; } } } else { foreach ( $ documents as $ document ) { $ id = $ document [ '_id' ] ; unset ( $ document [ '_id' ] ) ; $ this -> crud -> update ( $ repository , $ id , $ document ) ; } $ esResponse = $ this -> crud -> commit ( $ repository ) ; } return json_encode ( $ esResponse ) ; }
783	public function actionReport ( $ sourcePath , $ translationPath , $ title = 'Translation report' ) { $ sourcePath = trim ( $ sourcePath , '/\\' ) ; $ translationPath = trim ( $ translationPath , '/\\' ) ; $ results = [ ] ; $ dir = new DirectoryIterator ( $ sourcePath ) ; foreach ( $ dir as $ fileinfo ) { if ( ! $ fileinfo -> isDot ( ) && ! $ fileinfo -> isDir ( ) ) { $ translatedFilePath = $ translationPath . '/' . $ fileinfo -> getFilename ( ) ; $ sourceFilePath = $ sourcePath . '/' . $ fileinfo -> getFilename ( ) ; $ errors = $ this -> checkFiles ( $ translatedFilePath ) ; $ diff = empty ( $ errors ) ? $ this -> getDiff ( $ translatedFilePath , $ sourceFilePath ) : '' ; if ( ! empty ( $ diff ) ) { $ errors [ ] = 'Translation outdated.' ; } $ result = [ 'errors' => $ errors , 'diff' => $ diff , ] ; $ results [ $ fileinfo -> getFilename ( ) ] = $ result ; } } $ dir = new DirectoryIterator ( $ translationPath ) ; foreach ( $ dir as $ fileinfo ) { if ( ! $ fileinfo -> isDot ( ) && ! $ fileinfo -> isDir ( ) ) { $ translatedFilePath = $ translationPath . '/' . $ fileinfo -> getFilename ( ) ; $ errors = $ this -> checkFiles ( null , $ translatedFilePath ) ; if ( ! empty ( $ errors ) ) { $ results [ $ fileinfo -> getFilename ( ) ] [ 'errors' ] = $ errors ; } } } echo $ this -> renderFile ( __DIR__ . '/views/translation/report_html.php' , [ 'results' => $ results , 'sourcePath' => $ sourcePath , 'translationPath' => $ translationPath , 'title' => $ title , ] ) ; }
7483	public function startsWith ( $ string ) { $ string = static :: convertString ( $ string , $ this -> encoding ) ; return $ string === $ this -> substring ( 0 , ( mb_strlen ( $ string , $ this -> encoding ) - 1 ) ) -> __toString ( ) ; }
10843	protected function refreshProductVariantSellPrice ( VariantInterface $ variant ) { $ product = $ variant -> getProduct ( ) ; $ sellPrice = $ product -> getSellPrice ( ) ; $ grossAmount = $ this -> calculateAttributePrice ( $ variant , $ sellPrice -> getGrossAmount ( ) ) ; $ discountedGrossAmount = $ this -> calculateAttributePrice ( $ variant , $ sellPrice -> getDiscountedGrossAmount ( ) ) ; $ taxRate = $ product -> getSellPriceTax ( ) -> getValue ( ) ; $ netAmount = TaxHelper :: calculateNetPrice ( $ grossAmount , $ taxRate ) ; $ discountedNetAmount = TaxHelper :: calculateNetPrice ( $ discountedGrossAmount , $ taxRate ) ; $ productAttributeSellPrice = $ variant -> getSellPrice ( ) ; $ productAttributeSellPrice -> setTaxRate ( $ taxRate ) ; $ productAttributeSellPrice -> setTaxAmount ( $ grossAmount - $ netAmount ) ; $ productAttributeSellPrice -> setGrossAmount ( $ grossAmount ) ; $ productAttributeSellPrice -> setNetAmount ( $ netAmount ) ; $ productAttributeSellPrice -> setDiscountedGrossAmount ( $ discountedGrossAmount ) ; $ productAttributeSellPrice -> setDiscountedTaxAmount ( $ discountedGrossAmount - $ discountedNetAmount ) ; $ productAttributeSellPrice -> setDiscountedNetAmount ( $ discountedNetAmount ) ; $ productAttributeSellPrice -> setValidFrom ( $ sellPrice -> getValidFrom ( ) ) ; $ productAttributeSellPrice -> setValidTo ( $ sellPrice -> getValidTo ( ) ) ; $ productAttributeSellPrice -> setCurrency ( $ sellPrice -> getCurrency ( ) ) ; }
3682	private function getFilterFactory ( ) : IFilterSettingFactory { if ( null === $ this -> filterFactory ) { return $ this -> filterFactory = System :: getContainer ( ) -> get ( 'metamodels.filter_setting_factory' ) ; } return $ this -> filterFactory ; }
7958	public function isIpv6Enabled ( $ forceReload = false ) { if ( ! $ this -> properties || $ forceReload ) $ this -> getProperties ( ) ; return $ this -> properties -> ipv6Enabled ; }
4782	public function removeWidgetConfig ( string $ widgetId , array $ config = [ ] ) { foreach ( $ config as $ id => $ content ) { if ( isset ( $ this -> config [ $ widgetId ] [ $ id ] ) ) { unset ( $ this -> config [ $ widgetId ] [ $ id ] ) ; } } return $ this ; }
6186	public function renderInclude ( $ name , $ path = null ) { $ twigConfig = Config :: load ( 'twig' ) ; $ pathFile = pathFile ( $ name ) ; $ folder = $ pathFile [ 0 ] ; $ name = $ pathFile [ 1 ] ; $ path = $ twigConfig -> get ( 'setTemplateDir' ) . DIRECTORY_SEPARATOR . $ folder . $ name . $ twigConfig -> get ( 'fileExtension' , '.twig' ) ; try { if ( ! is_file ( $ path ) ) { throw new ViewException ( 'Can not open template ' . $ name . ' in: ' . $ path ) ; } $ renderInclude = $ this -> twig -> render ( $ name , $ this -> assign ) ; } catch ( ViewException $ e ) { echo $ e -> getMessage ( ) . '<br /> File: ' . $ e -> getFile ( ) . '<br /> Code line: ' . $ e -> getLine ( ) . '<br /> Trace: ' . $ e -> getTraceAsString ( ) ; exit ( ) ; } return $ renderInclude ; }
11636	public function getDeviceByPageId ( $ pageId , $ begin , $ count ) { $ params = [ 'type' => 2 , 'page_id' => intval ( $ pageId ) , 'begin' => intval ( $ begin ) , 'count' => intval ( $ count ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_RELATION_SEARCH , $ params ] ) ; }
4384	protected function dumpArray ( $ array ) { $ isNested = $ this -> valDepth > 0 ; $ this -> valDepth ++ ; $ array = parent :: dumpArray ( $ array ) ; $ str = \ trim ( \ print_r ( $ array , true ) ) ; $ str = \ preg_replace ( '#^Array\n\(#' , 'array(' , $ str ) ; $ str = \ preg_replace ( '#^array\s*\(\s+\)#' , 'array()' , $ str ) ; if ( $ isNested ) { $ str = \ str_replace ( "\n" , "\n " , $ str ) ; } return $ str ; }
2125	protected function getDebugMarkup ( ) { $ return = $ this -> getFileUrls ( ) ; foreach ( $ return as $ k => $ v ) { $ options = StringUtil :: resolveFlaggedUrl ( $ v ) ; $ return [ $ k ] = $ v ; if ( $ options -> mtime ) { $ return [ $ k ] .= '?v=' . substr ( md5 ( $ options -> mtime ) , 0 , 8 ) ; } if ( $ options -> media ) { $ return [ $ k ] .= '" media="' . $ options -> media ; } } if ( $ this -> strMode == self :: JS ) { return implode ( '"></script><script src="' , $ return ) ; } return implode ( '"><link rel="stylesheet" href="' , $ return ) ; }
10040	public function load ( $ pFilename ) { $ spreadsheet = new Spreadsheet ( ) ; $ spreadsheet -> removeSheetByIndex ( 0 ) ; return $ this -> loadIntoExisting ( $ pFilename , $ spreadsheet ) ; }
3908	public function setAcceptedExtensions ( $ acceptedExtensions ) { $ allowedDownload = StringUtil :: trimsplit ( ',' , $ GLOBALS [ 'TL_CONFIG' ] [ 'allowedDownload' ] ) ; if ( ! is_array ( $ acceptedExtensions ) ) { $ acceptedExtensions = StringUtil :: trimsplit ( ',' , $ acceptedExtensions ) ; } $ this -> acceptedExtensions = array_map ( 'strtolower' , array_intersect ( $ allowedDownload , $ acceptedExtensions ) ) ; }
12806	public static function select ( ) : Collection { $ pdo = Database :: connect ( ) ; $ class = self :: getStaticChildClass ( ) ; $ tableName = self :: getTableName ( ) ; $ sql = "SELECT * FROM \"$tableName\"" ; $ results = $ pdo -> query ( $ sql ) -> fetchAll ( ) ; $ collection = new Collection ( $ class , [ ] ) ; foreach ( $ results as $ result ) { $ object = new $ class ( $ result ) ; $ collection -> push ( $ object ) ; } return $ collection ; }
249	public function regenerateID ( $ deleteOldSession = false ) { if ( $ this -> getIsActive ( ) ) { if ( YII_DEBUG && ! headers_sent ( ) ) { session_regenerate_id ( $ deleteOldSession ) ; } else { @ session_regenerate_id ( $ deleteOldSession ) ; } } }
343	protected function renderSortLinks ( ) { $ attributes = empty ( $ this -> attributes ) ? array_keys ( $ this -> sort -> attributes ) : $ this -> attributes ; $ links = [ ] ; foreach ( $ attributes as $ name ) { $ links [ ] = $ this -> sort -> link ( $ name , $ this -> linkOptions ) ; } return Html :: ul ( $ links , array_merge ( $ this -> options , [ 'encode' => false ] ) ) ; }
11146	public function move ( Neuron_GameServer_Map_MapObject $ object , Neuron_GameServer_Map_Location $ location , Neuron_GameServer_Map_Date $ start , Neuron_GameServer_Map_Date $ end ) { throw new Neuron_Exceptions_NotImplemented ( "The move method is not implemented in this map." ) ; }
5291	public static function simpleDetect ( $ text ) { $ detections = self :: detect ( $ text ) ; if ( count ( $ detections ) > 0 ) return $ detections [ 0 ] -> language ; else return null ; }
947	protected function scripttagExists ( array $ shopScripttags , array $ scripttag ) { foreach ( $ shopScripttags as $ shopScripttag ) { if ( $ shopScripttag -> src === $ scripttag [ 'src' ] ) { return true ; } } return false ; }
6923	private function buildKey ( TaxGroupInterface $ taxGroup , CountryInterface $ country , $ business = false ) { return sprintf ( '%s-%s-%s' , $ taxGroup -> getId ( ) , $ country -> getId ( ) , ( int ) $ business ) ; }
1308	private static function urlParameter ( $ url ) { $ start = strpos ( $ url , '{' ) + 1 ; $ length = strpos ( $ url , '}' ) - $ start ; return substr ( $ url , $ start , $ length ) ; }
6585	protected function perform ( callable $ callback , ... $ params ) { $ result = $ callback ( $ this -> curl , ... $ params ) ; if ( curl_errno ( $ this -> curl ) !== CURLE_OK ) throw new CurlException ( $ this -> curl ) ; if ( $ result === false ) throw new CurlException ( "Unable to perform $callback - unknown error." ) ; return $ result ; }
7436	protected function prepareProductMediaGalleryValueToEntityAttributes ( ) { return $ this -> initializeEntity ( array ( MemberNames :: VALUE_ID => $ this -> valueId , MemberNames :: ROW_ID => $ this -> parentId ) ) ; }
5298	public function addGlyph ( $ char , $ path , $ name = null , $ width = null ) { $ glyph = $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> addChild ( 'glyph' ) ; $ glyph -> addAttribute ( 'unicode' , $ char ) ; if ( $ name !== null ) { $ glyph -> addAttribute ( 'glyph-name' , $ name ) ; } if ( $ width !== null ) { $ glyph -> addAttribute ( 'horiz-adv-x' , $ width ) ; } $ glyph -> addAttribute ( 'd' , $ path ) ; }
1748	protected function listSingleRecord ( $ id ) { if ( ! \ strlen ( $ this -> list_info_layout ) ) { $ this -> list_info_layout = 'info_default' ; } $ this -> Template = new FrontendTemplate ( $ this -> list_info_layout ) ; $ this -> Template -> record = array ( ) ; $ this -> Template -> referer = 'javascript:history.go(-1)' ; $ this -> Template -> back = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'goBack' ] ; $ this -> list_info = StringUtil :: deserialize ( $ this -> list_info ) ; $ this -> list_info_where = $ this -> replaceInsertTags ( $ this -> list_info_where , false ) ; $ objRecord = $ this -> Database -> prepare ( "SELECT " . implode ( ', ' , array_map ( 'Database::quoteIdentifier' , trimsplit ( ',' , $ this -> list_info ) ) ) . " FROM " . $ this -> list_table . " WHERE " . ( ( $ this -> list_info_where != '' ) ? "(" . $ this -> list_info_where . ") AND " : "" ) . Database :: quoteIdentifier ( $ this -> strPk ) . "=?" ) -> limit ( 1 ) -> execute ( $ id ) ; if ( $ objRecord -> numRows < 1 ) { return ; } $ arrFields = array ( ) ; $ arrRow = $ objRecord -> row ( ) ; $ limit = \ count ( $ arrRow ) ; $ count = - 1 ; foreach ( $ arrRow as $ k => $ v ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> list_table ] [ 'fields' ] [ $ k ] [ 'inputType' ] == 'password' ) { -- $ limit ; continue ; } $ class = 'row_' . ++ $ count . ( ( $ count == 0 ) ? ' row_first' : '' ) . ( ( $ count >= ( $ limit - 1 ) ) ? ' row_last' : '' ) . ( ( ( $ count % 2 ) == 0 ) ? ' even' : ' odd' ) ; $ arrFields [ $ k ] = array ( 'raw' => $ v , 'label' => ( \ strlen ( $ label = $ GLOBALS [ 'TL_DCA' ] [ $ this -> list_table ] [ 'fields' ] [ $ k ] [ 'label' ] [ 0 ] ) ? $ label : $ k ) , 'content' => $ this -> formatValue ( $ k , $ v , true ) , 'class' => $ class ) ; } $ this -> Template -> record = $ arrFields ; }
11891	private function createCreateForm ( CustomField $ entity , $ type ) { $ form = $ this -> createForm ( 'custom_field_choice' , $ entity , array ( 'action' => $ this -> generateUrl ( 'customfield_create' , array ( 'type' => $ type ) ) , 'method' => 'POST' , 'type' => $ type , 'group_widget' => ( $ entity -> getCustomFieldsGroup ( ) ) ? 'hidden' : 'entity' ) ) ; $ form -> add ( 'submit' , 'submit' , array ( 'label' => 'Create' ) ) ; return $ form ; }
10363	public function __isset ( $ childName ) { foreach ( $ this -> nodes as $ node ) { if ( isset ( $ node -> $ childName ) ) { return true ; } } return false ; }
12839	static public function generateFilename ( $ directory , $ extension , $ length = 16 ) { do { $ name = \ Extlib \ Generator :: generate ( $ length ) ; $ filepath = rtrim ( $ directory , DIRECTORY_SEPARATOR ) . DIRECTORY_SEPARATOR . sprintf ( '%s.%s' , $ name , $ extension ) ; } while ( file_exists ( $ filepath ) ) ; return $ name ; }
11145	protected function scanDir ( $ dir ) { $ result = array ( ) ; $ list = $ this -> scanDirExec ( $ dir ) ; foreach ( $ list as $ element ) { $ elementPath = $ dir . DIRECTORY_SEPARATOR . $ element ; if ( is_file ( $ elementPath ) ) { $ fileInfo = pathinfo ( $ element ) ; if ( in_array ( $ fileInfo [ 'extension' ] , $ this -> getAllowedFileExtensions ( ) ) ) { $ result [ ] = $ this -> getNameSpace ( ) . "\\" . $ fileInfo [ 'filename' ] ; } } } return $ result ; }
7793	public function getStatements ( $ text ) { if ( ! $ this -> parsers ) { $ this -> addParsers ( $ this -> getDefaultParsers ( ) ) ; } foreach ( $ this -> parsers as $ class ) { $ parser = new $ class ( $ this ) ; if ( $ parser -> accept ( $ text ) ) { return $ parser -> parse ( $ text ) ; } } throw new \ RuntimeException ( 'No suitable parser found.' ) ; }
3964	private function getJsonFile ( $ filename ) { if ( ! is_readable ( $ filename ) ) { return [ ] ; } $ contents = json_decode ( file_get_contents ( $ filename ) , true ) ; return $ contents ? : [ ] ; }
10496	public function exp ( $ value ) { $ value = Cast :: Float ( $ value ) ; if ( $ this -> value === null ) { return new FloatType ( $ this -> value ) ; } return new FloatType ( pow ( $ this -> value , $ value ) ) ; }
2424	public static function getFolderHash ( $ strPath ) { $ strPath = str_replace ( array ( '\\' , '%' , '_' ) , array ( '\\\\' , '\\%' , '\\_' ) , $ strPath ) ; $ arrHash = array ( ) ; $ objChildren = Database :: getInstance ( ) -> prepare ( "SELECT hash, name FROM tl_files WHERE path LIKE ? AND path NOT LIKE ? ORDER BY name" ) -> execute ( $ strPath . '/%' , $ strPath . '/%/%' ) ; if ( $ objChildren !== null ) { while ( $ objChildren -> next ( ) ) { $ arrHash [ ] = $ objChildren -> hash . $ objChildren -> name ; } } return md5 ( implode ( "\0" , $ arrHash ) ) ; }
5652	public function render ( ) { $ tab_stop = $ this -> longestFlag ( $ this -> flag_sets ) + 4 ; $ text = $ this -> overview . "\n" ; $ numberOfFlags = count ( $ this -> flag_sets ) ; for ( $ i = 0 ; $ i < $ numberOfFlags ; $ i ++ ) { $ text .= $ this -> renderFlagSet ( $ this -> flag_sets [ $ i ] , $ this -> explanations [ $ i ] , $ tab_stop ) ; } return $ this -> noDuplicateNewLines ( $ text ) ; }
2625	protected function _toHtml ( ) { if ( $ this -> config -> isGeoIpEnabled ( ) == false || $ this -> config -> isFastlyEnabled ( ) == false ) { return parent :: _toHtml ( ) ; } $ actionUrl = $ this -> getUrl ( 'fastlyCdn/geoip/getaction' ) ; $ header = $ this -> response -> getHeader ( 'x-esi' ) ; if ( empty ( $ header ) ) { $ this -> response -> setHeader ( "x-esi" , "1" ) ; } return sprintf ( '<esi:include src=\'%s\' />' , preg_replace ( "/^https/" , "http" , $ actionUrl ) ) ; }
8550	public function setRentalTransactionEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'RentalTransactionEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
10286	public static function stringFromColumnIndex ( $ columnIndex ) { static $ indexCache = [ ] ; if ( ! isset ( $ indexCache [ $ columnIndex ] ) ) { $ indexValue = $ columnIndex ; $ base26 = null ; do { $ characterValue = ( $ indexValue % 26 ) ? : 26 ; $ indexValue = ( $ indexValue - $ characterValue ) / 26 ; $ base26 = chr ( $ characterValue + 64 ) . ( $ base26 ? : '' ) ; } while ( $ indexValue > 0 ) ; $ indexCache [ $ columnIndex ] = $ base26 ; } return $ indexCache [ $ columnIndex ] ; }
4332	private static function buildAttribArrayVal ( $ key , $ value = array ( ) ) { if ( $ key == 'class' ) { if ( ! \ is_array ( $ value ) ) { $ value = \ explode ( ' ' , $ value ) ; } $ value = \ array_filter ( \ array_unique ( $ value ) ) ; \ sort ( $ value ) ; $ value = \ implode ( ' ' , $ value ) ; } elseif ( $ key == 'style' ) { $ keyValues = array ( ) ; foreach ( $ value as $ k => $ v ) { $ keyValues [ ] = $ k . ':' . $ v . ';' ; } \ sort ( $ keyValues ) ; $ value = \ implode ( '' , $ keyValues ) ; } else { $ value = null ; } return $ value ; }
8005	public static function calculatePayloadOffset ( $ negotiate_flags ) { $ offset = 0 ; $ offset += strlen ( static :: SIGNATURE ) ; $ offset += 4 ; $ offset += 4 ; $ offset += 8 ; $ offset += 8 ; return $ offset ; }
5385	public function isId ( $ id ) { for ( $ i = 0 , $ count = count ( $ this -> widgets ) ; $ i < $ count ; $ i ++ ) { if ( $ this -> widgets [ $ i ] -> isId ( $ id ) ) { return true ; } } return false ; }
7999	public function identifyTargetName ( $ username , $ nt_domain , ServerChallenge $ server_challenge ) { $ target_name = $ nt_domain ? : $ server_challenge -> getTargetName ( ) ; if ( false !== strpos ( $ username , static :: USER_PRINCIPAL_NAME_SEPARATOR ) ) { $ target_name = '' ; } return $ target_name ; }
86	public function archive ( PackageInterface $ package , $ format , $ targetDir , $ fileName = null , $ ignoreFilters = false ) { if ( empty ( $ format ) ) { throw new \ InvalidArgumentException ( 'Format must be specified' ) ; } $ usableArchiver = null ; foreach ( $ this -> archivers as $ archiver ) { if ( $ archiver -> supports ( $ format , $ package -> getSourceType ( ) ) ) { $ usableArchiver = $ archiver ; break ; } } if ( null === $ usableArchiver ) { throw new \ RuntimeException ( sprintf ( 'No archiver found to support %s format' , $ format ) ) ; } $ filesystem = new Filesystem ( ) ; if ( null === $ fileName ) { $ packageName = $ this -> getPackageFilename ( $ package ) ; } else { $ packageName = $ fileName ; } $ filesystem -> ensureDirectoryExists ( $ targetDir ) ; $ target = realpath ( $ targetDir ) . '/' . $ packageName . '.' . $ format ; $ filesystem -> ensureDirectoryExists ( dirname ( $ target ) ) ; if ( ! $ this -> overwriteFiles && file_exists ( $ target ) ) { return $ target ; } if ( $ package instanceof RootPackageInterface ) { $ sourcePath = realpath ( '.' ) ; } else { $ sourcePath = sys_get_temp_dir ( ) . '/composer_archive' . uniqid ( ) ; $ filesystem -> ensureDirectoryExists ( $ sourcePath ) ; try { $ this -> downloadManager -> download ( $ package , $ sourcePath ) ; } catch ( \ Exception $ e ) { $ filesystem -> removeDirectory ( $ sourcePath ) ; throw $ e ; } if ( file_exists ( $ composerJsonPath = $ sourcePath . '/composer.json' ) ) { $ jsonFile = new JsonFile ( $ composerJsonPath ) ; $ jsonData = $ jsonFile -> read ( ) ; if ( ! empty ( $ jsonData [ 'archive' ] [ 'exclude' ] ) ) { $ package -> setArchiveExcludes ( $ jsonData [ 'archive' ] [ 'exclude' ] ) ; } } } $ tempTarget = sys_get_temp_dir ( ) . '/composer_archive' . uniqid ( ) . '.' . $ format ; $ filesystem -> ensureDirectoryExists ( dirname ( $ tempTarget ) ) ; $ archivePath = $ usableArchiver -> archive ( $ sourcePath , $ tempTarget , $ format , $ package -> getArchiveExcludes ( ) , $ ignoreFilters ) ; $ filesystem -> rename ( $ archivePath , $ target ) ; if ( ! $ package instanceof RootPackageInterface ) { $ filesystem -> removeDirectory ( $ sourcePath ) ; } $ filesystem -> remove ( $ tempTarget ) ; return $ target ; }
2585	protected function loadReferences ( $ params ) { if ( $ this -> checkAnyNotEmpty ( $ params -> passengers , $ params -> segments ) ) { $ this -> psaInformation = new PsaInformation ( ) ; foreach ( $ params -> passengers as $ passenger ) { $ this -> psaInformation -> refDetails [ ] = new RefDetails ( $ passenger , RefDetails :: QUAL_PASSENGER ) ; } foreach ( $ params -> segments as $ segment ) { $ this -> psaInformation -> refDetails [ ] = new RefDetails ( $ segment , RefDetails :: QUAL_SEGMENT_REFERENCE ) ; } } }
2913	public function formatMemorySize ( $ size , $ precision = 2 ) { $ sizes = array ( " Bytes" , " KB" , " MB" , " GB" , " TB" , " PB" , " EB" , " ZB" , " YB" ) ; if ( $ size == 0 ) { return $ this -> __ ( 'n/a' ) ; } else { $ value = round ( $ size / pow ( 1000 , ( $ i = floor ( log ( $ size , 1000 ) ) ) ) , $ precision ) ; $ unitIndex = ( int ) $ i ; return $ this -> __ ( '%s%s' , $ this -> formatNumber ( $ value , $ precision ) , $ sizes [ $ unitIndex ] ) ; } }
8659	private function convertGetFeedSubmissionCount ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetFeedSubmissionCount' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetFeedTypeList ( ) ) { $ feedTypeList = $ request -> getFeedTypeList ( ) ; foreach ( $ feedTypeList -> getType ( ) as $ typeIndex => $ type ) { $ parameters [ 'FeedTypeList' . '.' . 'Type' . '.' . ( $ typeIndex + 1 ) ] = $ type ; } } if ( $ request -> isSetFeedProcessingStatusList ( ) ) { $ feedProcessingStatusList = $ request -> getFeedProcessingStatusList ( ) ; foreach ( $ feedProcessingStatusList -> getStatus ( ) as $ statusIndex => $ status ) { $ parameters [ 'FeedProcessingStatusList' . '.' . 'Status' . '.' . ( $ statusIndex + 1 ) ] = $ status ; } } if ( $ request -> isSetSubmittedFromDate ( ) ) { $ parameters [ 'SubmittedFromDate' ] = $ this -> getFormattedTimestamp ( $ request -> getSubmittedFromDate ( ) ) ; } if ( $ request -> isSetSubmittedToDate ( ) ) { $ parameters [ 'SubmittedToDate' ] = $ this -> getFormattedTimestamp ( $ request -> getSubmittedToDate ( ) ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
264	protected function escapeColumnName ( $ columnName , & $ params = [ ] ) { if ( $ columnName instanceof Query ) { list ( $ sql , $ params ) = $ this -> queryBuilder -> build ( $ columnName , $ params ) ; return "($sql)" ; } elseif ( $ columnName instanceof ExpressionInterface ) { return $ this -> queryBuilder -> buildExpression ( $ columnName , $ params ) ; } elseif ( strpos ( $ columnName , '(' ) === false ) { return $ this -> queryBuilder -> db -> quoteColumnName ( $ columnName ) ; } return $ columnName ; }
6673	public function update_rating ( $ post_id , $ post , $ update ) { App :: setCurrentID ( 'EFG' ) ; if ( App :: main ( ) -> is_after_update_post ( $ post , $ update ) ) { if ( isset ( $ _POST [ 'efg-update-rating' ] ) ) { for ( $ i = 1 ; $ i <= 10 ; $ i ++ ) { if ( ! isset ( $ _POST [ "efg-rating-$i" ] ) ) { return false ; } $ votes [ "$i" ] = ( int ) $ _POST [ "efg-rating-$i" ] ; } $ this -> set_rating_and_votes ( $ post_id , $ votes ) ; } } return true ; }
9627	protected function matchParams ( Route $ route , array $ params ) : bool { $ matchers = $ route -> getMatchers ( ) ; foreach ( $ params as $ name => $ value ) { if ( ! isset ( $ matchers [ $ name ] ) ) { continue ; } $ valueMatchers = $ matchers [ $ name ] ; foreach ( $ valueMatchers as $ matcher ) { if ( ! $ matcher ( $ value ) ) { $ this -> logger -> debug ( sprintf ( 'Value "%s" for param "%s" did not match criteria of matcher "%s"' , $ value , $ name , get_class ( $ matcher ) ) ) ; return false ; } } } return true ; }
4623	public function execute ( Command $ command ) { $ response = $ this -> getActiveNode ( ) -> execute ( $ command , $ this -> api ) ; if ( empty ( $ response ) && count ( $ this -> nodes ) > 1 && $ this -> attempts < $ this -> getConfigValue ( 'max_connect_attempts' ) ) { $ response = $ this -> pickNewNode ( ) -> execute ( $ command ) ; } elseif ( empty ( $ response ) && $ this -> attempts >= $ this -> getConfigValue ( 'max_connect_attempts' ) ) { throw new Exception ( 'Nodes unreachable. Error Msg: ' . $ this -> api -> getError ( ) ) ; } elseif ( $ response == false ) { throw new Exception ( 'Command failed to execute against Riak. Error Msg: ' . $ this -> api -> getError ( ) ) ; } return $ response ; }
1496	public function prepend ( Encoding ... $ encodings ) : self { $ copy = clone $ this ; array_unshift ( $ copy -> stack , ... $ encodings ) ; return $ copy ; }
6249	protected function prepareForPresentation ( ) { if ( $ this -> prepared ) { return ; } $ this -> permissionGroups = new Collection ; $ this -> ungroupedPermissions = [ ] ; $ this -> groupedPermissionIndex = [ ] ; $ this -> loadPermissionsFromModules ( ) -> loadCustomPermissions ( ) -> loadCustomPermissionGroups ( ) -> addUngroupedPermissionGroup ( ) -> filterEmptyGroups ( ) ; }
687	protected function getChildrenRecursive ( $ name , $ childrenList , & $ result ) { if ( isset ( $ childrenList [ $ name ] ) ) { foreach ( $ childrenList [ $ name ] as $ child ) { $ result [ $ child ] = true ; $ this -> getChildrenRecursive ( $ child , $ childrenList , $ result ) ; } } }
4532	public function setFirstResult ( ? int $ firstResult ) { $ this -> firstResult = $ firstResult ; $ this -> _firstResult = null !== $ firstResult ; return $ this ; }
9136	public function clearTag ( $ name ) { if ( isset ( $ this -> tags [ $ name ] ) ) { unset ( $ this -> tags [ $ name ] ) ; } return $ this ; }
3899	public function setDataFor ( $ arrValues ) { $ strTable = $ this -> getMetaModel ( ) -> getTableName ( ) ; $ strColName = $ this -> getColName ( ) ; foreach ( $ arrValues as $ intId => $ varData ) { if ( is_array ( $ varData ) ) { $ varData = serialize ( $ varData ) ; } $ this -> connection -> update ( $ strTable , [ $ strColName => $ varData ] , [ 'id' => $ intId ] ) ; } }
1626	public static function buildKey ( $ key ) { if ( is_numeric ( $ key ) ) { return $ key ; } elseif ( is_string ( $ key ) ) { return ctype_alnum ( $ key ) && StringHelper :: byteLength ( $ key ) <= 32 ? $ key : md5 ( $ key ) ; } elseif ( is_array ( $ key ) ) { if ( count ( $ key ) == 1 ) { return self :: buildKey ( reset ( $ key ) ) ; } ksort ( $ key ) ; $ isNumeric = true ; foreach ( $ key as $ value ) { if ( ! is_numeric ( $ value ) ) { $ isNumeric = false ; } } if ( $ isNumeric ) { return implode ( '-' , $ key ) ; } } return md5 ( json_encode ( $ key , JSON_NUMERIC_CHECK ) ) ; }
8195	protected function checkConstantExpression ( Twig_NodeInterface $ node ) { if ( ! ( $ node instanceof Twig_Node_Expression_Constant || $ node instanceof Twig_Node_Expression_Array || $ node instanceof Twig_Node_Expression_Unary_Neg || $ node instanceof Twig_Node_Expression_Unary_Pos ) ) { return false ; } foreach ( $ node as $ n ) { if ( ! $ this -> checkConstantExpression ( $ n ) ) { return false ; } } return true ; }
1500	public function unless ( bool $ test , $ encodings ) : self { return $ this -> when ( true !== $ test , $ encodings ) ; }
3931	private function getOrCreateProperty ( PropertiesDefinitionInterface $ definition , $ propName ) { if ( $ definition -> hasProperty ( $ propName ) ) { return $ definition -> getProperty ( $ propName ) ; } $ property = new DefaultProperty ( $ propName ) ; $ definition -> addProperty ( $ property ) ; return $ property ; }
12154	public function getRequiredRoles ( ) { $ roles = [ ] ; foreach ( Yii :: $ app -> collectors [ 'roles' ] -> getAll ( ) as $ roleItem ) { $ test = false ; switch ( $ roleItem -> systemId ) { case 'owner' : $ test = $ this -> isOwnable ; break ; } if ( $ test ) { $ roles [ ] = $ roleItem -> object -> primaryKey ; } } return $ roles ; }
10757	public function totals ( $ locale = null ) { $ this -> setLocale ( $ locale ) ; $ totals = Collection :: make ( ) ; foreach ( Arr :: except ( $ this -> footer ( ) , 'all' ) as $ level => $ count ) { $ totals -> put ( $ level , [ 'label' => trans ( 'dashboard::logs.' . $ level ) , 'value' => $ count , 'color' => $ this -> color ( $ level ) , 'highlight' => $ this -> color ( $ level ) , ] ) ; } return $ totals ; }
4171	public function askPackageKey ( $ summary , $ message = 'Please provide an id' ) { $ this -> table ( [ 'id' , 'name' ] , $ summary ) ; $ selected = $ this -> ask ( $ message ) ; $ key = collect ( $ summary ) -> pluck ( 'id' ) -> search ( $ selected ) ; if ( $ key === false ) { $ this -> warn ( 'Invalid package name or id given.' ) ; return $ this -> askPackageKey ( $ summary , 'Please provide a valid id' ) ; } return $ key ; }
6533	protected function getConnectionFactory ( $ type ) { if ( false === isset ( $ this -> connectionFactories [ $ type ] ) ) { throw new \ InvalidArgumentException ( "Missing connection factory \"$type\"" ) ; } return $ this -> connectionFactories [ $ type ] ; }
117	protected function getCommand ( $ cmd , $ url , $ path = null ) { $ cmd = sprintf ( '%s %s%s %s' , $ cmd , '--non-interactive ' , $ this -> getCredentialString ( ) , ProcessExecutor :: escape ( $ url ) ) ; if ( $ path ) { $ cmd .= ' ' . ProcessExecutor :: escape ( $ path ) ; } return $ cmd ; }
7938	public function getBackupFTPaccessBlock ( $ domain , $ ipBlock ) { $ domain = ( string ) $ domain ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; if ( ! $ ipBlock ) throw new BadMethodCallException ( 'Parameter $ipBlock is missing.' ) ; try { $ r = $ this -> get ( 'dedicated/server/' . $ domain . '/features/backupFTP/access/' . urlencode ( $ ipBlock ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new ServerException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
4497	private function getAndroidJsonInner ( ? string $ text ) : array { $ data = [ ] ; if ( null !== $ text ) { $ data [ 'message' ] = $ text ; } if ( null !== $ this -> localizedKey ) { $ data [ 'message-loc-key' ] = $ this -> localizedKey ; if ( $ this -> localizedArguments ) { $ data [ 'message-loc-args' ] = $ this -> localizedArguments ; } } return $ data ; }
8870	public function detach ( Runner $ runner ) { if ( ! $ this -> runners -> contains ( $ runner ) ) { throw new LogicException ( 'Can\'t detach not attached runner.' ) ; } $ this -> runners -> detach ( $ runner ) ; return $ this ; }
7518	function parse_comment ( ) { $ this -> pos += 3 ; if ( $ this -> next_pos ( ' , false ) !== self :: TOK_UNKNOWN ) { $ this -> status [ 'comment' ] = $ this -> getTokenString ( 1 , - 1 ) ; -- $ this -> pos ; } else { $ this -> status [ 'comment' ] = $ this -> getTokenString ( 1 , - 1 ) ; $ this -> pos += 2 ; } $ this -> status [ 'last_pos' ] = $ this -> pos ; return true ; }
1286	private function createIdChunks ( array $ resourceIds ) : array { $ chunks = [ ] ; $ chunkId = - 1 ; $ resourceIds = \ array_values ( $ resourceIds ) ; foreach ( $ resourceIds as $ index => $ resourceId ) { if ( 0 === $ index % 30 ) { ++ $ chunkId ; $ chunks [ $ chunkId ] = [ ] ; } $ chunks [ $ chunkId ] [ ] = $ resourceId ; } return $ chunks ; }
10208	public function delete ( $ resourcePath , $ queryParameters = array ( ) , $ mimeType = 'application/vnd.maileon.api+xml' , $ deserializationType = null ) { $ curlSession = $ this -> prepareSession ( $ resourcePath , $ queryParameters , $ mimeType ) ; curl_setopt ( $ curlSession , CURLOPT_CUSTOMREQUEST , "DELETE" ) ; return $ this -> performRequest ( $ curlSession , $ deserializationType ) ; }
2454	public function showAll ( ) { $ return = '' ; $ this -> limit = '' ; $ objSession = System :: getContainer ( ) -> get ( 'session' ) ; $ undoPeriod = ( int ) Config :: get ( 'undoPeriod' ) ; $ logPeriod = ( int ) Config :: get ( 'logPeriod' ) ; if ( $ this -> strTable == 'tl_undo' && $ undoPeriod > 0 ) { $ this -> Database -> prepare ( "DELETE FROM tl_undo WHERE tstamp<?" ) -> execute ( time ( ) - $ undoPeriod ) ; } elseif ( $ this -> strTable == 'tl_log' && $ logPeriod > 0 ) { $ this -> Database -> prepare ( "DELETE FROM tl_log WHERE tstamp<?" ) -> execute ( time ( ) - $ logPeriod ) ; } $ this -> reviseTable ( ) ; if ( Input :: get ( 'act' ) == 'paste' ) { $ arrClipboard = $ objSession -> get ( 'CLIPBOARD' ) ; $ arrClipboard [ $ this -> strTable ] = array ( 'id' => Input :: get ( 'id' ) , 'childs' => Input :: get ( 'childs' ) , 'mode' => Input :: get ( 'mode' ) ) ; $ objSession -> set ( 'CLIPBOARD' , $ arrClipboard ) ; } if ( ! empty ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'filter' ] ) && \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'filter' ] ) ) { foreach ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'filter' ] as $ filter ) { $ this -> procedure [ ] = $ filter [ 0 ] ; $ this -> values [ ] = $ filter [ 1 ] ; } } if ( $ this -> treeView ) { $ return .= $ this -> panel ( ) ; $ return .= $ this -> treeView ( ) ; } else { if ( Input :: get ( 'table' ) && $ this -> ptable && $ this -> Database -> fieldExists ( 'pid' , $ this -> strTable ) ) { $ this -> procedure [ ] = 'pid=?' ; $ this -> values [ ] = CURRENT_ID ; } $ return .= $ this -> panel ( ) ; $ return .= ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'mode' ] == 4 ) ? $ this -> parentView ( ) : $ this -> listView ( ) ; if ( strpos ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'panelLayout' ] , 'limit' ) !== false ) { $ return .= $ this -> paginationMenu ( ) ; } } return $ return ; }
10422	public function addToInsertList ( $ key , $ value , $ isString = true ) { $ this -> sqlInsertList [ $ key ] = [ 'value' => $ value , 'string' => $ isString , ] ; }
3627	protected function getDeviceNetworkInfo ( $ serial_number = NULL ) { $ this -> prepareForGet ( ) ; $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ connection_info = $ this -> last_status -> track -> { $ serial_number } ; return ( object ) array ( 'online' => $ connection_info -> online , 'last_connection' => date ( DATETIME_FORMAT , $ connection_info -> last_connection / 1000 ) , 'last_connection_UTC' => gmdate ( DATETIME_FORMAT , $ connection_info -> last_connection / 1000 ) , 'wan_ip' => @ $ connection_info -> last_ip , 'local_ip' => $ this -> last_status -> device -> { $ serial_number } -> local_ip , 'mac_address' => $ this -> last_status -> device -> { $ serial_number } -> mac_address ) ; }
5700	protected function getDefaultButtonList ( $ config ) { $ new = ( $ this -> owner -> ID == 0 ) ; $ list = $ new ? Config :: inst ( ) -> get ( $ config , $ this -> checkVersioned ( ) ? "versioned_create" : "create" ) : Config :: inst ( ) -> get ( $ config , $ this -> checkVersioned ( ) ? "versioned_edit" : "edit" ) ; return $ list ? : array ( ) ; }
6773	protected function isTaxationUpdateNeeded ( SaleInterface $ sale ) { if ( $ this -> persistenceHelper -> isChanged ( $ sale , [ 'taxExempt' , 'customer' , 'vatValid' ] ) ) { return true ; } return $ this -> didDeliveryCountryChanged ( $ sale ) ; }
7040	protected function hasDifferentCurrencies ( PaymentSubjectInterface $ subject ) { $ currency = $ subject -> getCurrency ( ) -> getCode ( ) ; foreach ( $ subject -> getPayments ( ) as $ payment ) { if ( $ payment -> getCurrency ( ) -> getCode ( ) !== $ currency ) { return true ; } } return false ; }
10985	public static function checkPhpVersion ( ) { $ version = null ; if ( \ defined ( 'PHP_VERSION' ) ) { $ version = PHP_VERSION ; } else { $ version = phpversion ( '' ) ; } if ( strpos ( $ version , '-' ) !== false ) { $ version = substr ( $ version , 0 , strpos ( $ version , '-' ) ) ; } return $ version ; }
4587	public function setStaffUuid ( ? string $ staffUuid ) { $ this -> staffUuid = $ staffUuid ; $ this -> _staffUuid = true ; return $ this ; }
4457	public function detach ( string $ eventName , $ handler ) : void { if ( is_object ( $ handler ) == false && is_callable ( $ handler ) == false ) { throw new InvalidArgumentException ( sprintf ( 'Event handler must be either an object or a callable %s given.' , gettype ( $ handler ) ) ) ; } if ( isset ( $ this -> events [ $ eventName ] ) == false ) { return ; } $ priorityQueue = $ this -> events [ $ eventName ] ; $ priorityQueue -> setExtractFlags ( SplPriorityQueue :: EXTR_BOTH ) ; $ priorityQueue -> top ( ) ; $ newPriorityQueue = $ this -> createQueue ( ) ; while ( $ priorityQueue -> valid ( ) ) { $ data = $ priorityQueue -> current ( ) ; $ priorityQueue -> next ( ) ; if ( $ data [ 'data' ] !== $ handler ) { $ newPriorityQueue -> insert ( $ data [ 'data' ] , $ data [ 'priority' ] ) ; } } $ this -> events [ $ eventName ] = $ newPriorityQueue ; }
3408	public function getLockFactory ( ) : Factory { if ( $ this -> lockFactory !== null ) { return $ this -> lockFactory ; } if ( ! is_dir ( $ this -> lockPath ) ) { ( new Filesystem ( ) ) -> mkdir ( $ this -> lockPath ) ; } $ store = new FlockStore ( $ this -> lockPath ) ; return $ this -> setLockStore ( $ store ) ; }
5111	protected function appendPart ( $ part , $ sql , $ bind = false ) { if ( ! is_array ( $ sql ) ) $ sql = [ $ sql ] ; if ( ! $ this -> parts [ $ part ] ) { $ this -> parts [ $ part ] = $ sql ; } else { $ this -> parts [ $ part ] = array_merge ( $ this -> parts [ $ part ] , $ sql ) ; } return $ this -> appendBind ( $ part , $ bind ) ; }
11601	private static function getBaseUrl ( ) : ? string { $ serverName = filter_input ( \ INPUT_SERVER , 'SERVER_NAME' , \ FILTER_SANITIZE_STRING ) ; if ( ! empty ( $ serverName ) ) { $ https = filter_input ( \ INPUT_SERVER , 'HTTPS' , \ FILTER_SANITIZE_STRING ) ; $ protocol = ! empty ( $ https ) && strtolower ( $ https ) === 'on' ? 'https' : 'http' ; return $ protocol . '://' . $ serverName ; } return null ; }
11986	function read ( $ length ) { $ l = $ this -> pos + $ length < strlen ( $ this -> data ) ? $ length : strlen ( $ this -> data ) - $ this -> pos ; $ result = substr ( $ this -> data , $ this -> pos , $ l ) ; $ this -> pos += $ l ; return $ result ; }
4821	public function getAsArray ( $ fieldName ) { if ( ! array_key_exists ( $ fieldName , $ this -> row ) ) { return [ ] ; } $ result = $ this -> row [ $ fieldName ] ; if ( empty ( $ result ) ) { return [ ] ; } return ( array ) $ result ; }
11352	public function getErrors ( ) { $ errors = [ ] ; foreach ( $ this -> fields as $ field ) { if ( ! $ field -> isValid ( ) ) { $ errors [ ] = [ 'field' => $ field -> getLabel ( ) , 'message' => $ field -> getError ( ) ] ; } } return $ errors ; }
4307	public function timeEnd ( $ label = null , $ returnOrTemplate = false , $ precision = 4 ) { $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'label' => null , 'returnOrTemplate' => false , 'precision' => 4 , ) ) ; \ extract ( $ args ) ; if ( \ is_bool ( $ label ) || \ strpos ( $ label , '%time' ) !== false ) { if ( \ is_numeric ( $ returnOrTemplate ) ) { $ precision = $ returnOrTemplate ; } $ returnOrTemplate = $ label ; $ label = null ; } $ ret = $ this -> timeGet ( $ label , true , null ) ; if ( isset ( $ label ) ) { if ( isset ( $ this -> data [ 'timers' ] [ 'labels' ] [ $ label ] ) ) { $ this -> data [ 'timers' ] [ 'labels' ] [ $ label ] = array ( $ ret , null , ) ; } } else { $ label = 'time' ; \ array_pop ( $ this -> data [ 'timers' ] [ 'stack' ] ) ; } if ( \ is_int ( $ precision ) ) { $ ret = \ number_format ( $ ret , $ precision , '.' , '' ) ; } $ this -> doTime ( $ ret , $ returnOrTemplate , $ label , $ meta ) ; return $ ret ; }
9515	private function _initLoggerCascade ( $ configFile , $ loggerName ) { $ err = '' ; try { $ fs = $ this -> _obm -> get ( Filesystem :: class ) ; if ( $ fs -> isAbsolutePath ( $ configFile ) ) { $ fileName = $ configFile ; } else { $ fileName = BP . '/' . $ configFile ; } $ realPath = realpath ( $ fileName ) ; if ( $ realPath ) { Cascade :: fileConfig ( $ realPath ) ; $ this -> _logger = Cascade :: getLogger ( $ loggerName ) ; } else { $ err = "Cannot open logging configuration file '$fileName'. Default Magento logger is used." ; } } catch ( \ Exception $ e ) { $ err = $ e -> getMessage ( ) ; } finally { if ( is_null ( $ this -> _logger ) ) { $ this -> _logger = $ this -> _obm -> get ( \ Magento \ Framework \ Logger \ Monolog :: class ) ; $ this -> warning ( $ err ) ; } } }
5674	protected function isMatchingKeys ( $ first , $ second , $ identical ) { $ first_keys = array_keys ( $ first ) ; $ second_keys = array_keys ( $ second ) ; if ( $ identical ) { return ( $ first_keys === $ second_keys ) ; } sort ( $ first_keys ) ; sort ( $ second_keys ) ; return ( $ first_keys == $ second_keys ) ; }
1627	public function useFiles ( $ path , $ level = 'debug' ) { foreach ( $ this -> loggers as $ logger ) { if ( $ logger instanceof Log ) { $ logger -> useFiles ( $ path , $ level ) ; } } }
5869	protected static function getVirtualFileObject ( $ fileName , array $ metadata ) { $ resourceFactory = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Core \ Resource \ ResourceFactory :: class ) ; $ recordData = [ 'uid' => 0 , 'pid' => 0 , 'name' => 'Temporary Upload Storage' , 'description' => 'Internal storage, mounting the temporary PHP upload directory.' , 'driver' => 'Local' , 'processingfolder' => '' , 'configuration' => '' , 'is_online' => true , 'is_browsable' => false , 'is_public' => false , 'is_writable' => false , 'is_default' => false , ] ; $ storageConfiguration = [ 'basePath' => PathUtility :: dirname ( $ fileName ) , 'pathType' => 'absolute' ] ; $ virtualStorage = $ resourceFactory -> createStorageObject ( $ recordData , $ storageConfiguration ) ; $ name = PathUtility :: basename ( $ fileName ) ; $ extension = strtolower ( substr ( $ name , strrpos ( $ name , '.' ) + 1 ) ) ; $ virtualFileObject = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Core \ Resource \ File :: class , [ 'identifier' => '/' . $ name , 'name' => $ name , 'extension' => $ extension , ] , $ virtualStorage , $ metadata ) ; return $ virtualFileObject ; }
9434	public function rho ( $ float_min , $ float_max ) { self :: checkOrder ( $ float_min , $ float_max ) ; if ( $ float_min < 0 || $ float_max < 0 ) { throw new \ InvalidArgumentException ( 'Rho value must be a positive number!' ) ; } if ( $ this -> r || $ this -> i ) { throw new \ RuntimeException ( 'You cannot set rho value, because algebraic form is in use.' ) ; } $ this -> rho = new \ stdClass ( ) ; $ this -> rho -> min = $ float_min ; $ this -> rho -> max = $ float_max ; return $ this ; }
11851	public function show ( ) { $ response = new \ Venus \ lib \ Response ( ) ; $ response -> setContent ( '<html><body><h1>Hello world!</h1></body></html>' ) ; $ response -> setStatusCode ( \ Venus \ lib \ Response :: HTTP_OK ) ; $ response -> headers -> set ( 'Content-Type' , 'text/html' ) ; $ response -> send ( ) ; }
12706	public static function getAllCommands ( ) : array { $ commands = [ ] ; foreach ( get_declared_classes ( ) as $ class ) { if ( is_subclass_of ( $ class , 'Senhung\CLI\Command' ) ) { $ commandObject = new $ class ; $ command = $ commandObject -> getCommand ( ) ; $ commands [ $ command ] = $ class ; } } return $ commands ; }
4313	protected function autoloader ( $ className ) { $ className = \ ltrim ( $ className , '\\' ) ; if ( ! \ strpos ( $ className , '\\' ) ) { return ; } $ psr4Map = array ( 'bdk\\Debug\\' => __DIR__ , 'bdk\\PubSub\\' => __DIR__ . '/../PubSub' , 'bdk\\ErrorHandler\\' => __DIR__ . '/../ErrorHandler' , ) ; foreach ( $ psr4Map as $ namespace => $ dir ) { if ( \ strpos ( $ className , $ namespace ) === 0 ) { $ rel = \ substr ( $ className , \ strlen ( $ namespace ) ) ; $ rel = \ str_replace ( '\\' , '/' , $ rel ) ; require $ dir . '/' . $ rel . '.php' ; return ; } } $ classMap = array ( 'bdk\\ErrorHandler' => __DIR__ . '/../ErrorHandler/ErrorHandler.php' , ) ; if ( isset ( $ classMap [ $ className ] ) ) { require $ classMap [ $ className ] ; } }
5681	protected function linkIsAbsolute ( $ url ) { $ parsed = new SimpleUrl ( $ url ) ; return ( boolean ) ( $ parsed -> getScheme ( ) && $ parsed -> getHost ( ) ) ; }
1477	public function update ( $ resourceType , $ id , array $ queryParams = [ ] ) { return $ this -> resource ( RouteName :: update ( $ resourceType ) , $ id , $ queryParams ) ; }
1019	public static function createLocatedError ( $ error , $ nodes = null , $ path = null ) { if ( $ error instanceof self ) { if ( $ error -> path && $ error -> nodes ) { return $ error ; } $ nodes = $ nodes ? : $ error -> nodes ; $ path = $ path ? : $ error -> path ; } $ source = $ positions = $ originalError = null ; $ extensions = [ ] ; if ( $ error instanceof self ) { $ message = $ error -> getMessage ( ) ; $ originalError = $ error ; $ nodes = $ error -> nodes ? : $ nodes ; $ source = $ error -> source ; $ positions = $ error -> positions ; $ extensions = $ error -> extensions ; } elseif ( $ error instanceof Exception || $ error instanceof Throwable ) { $ message = $ error -> getMessage ( ) ; $ originalError = $ error ; } else { $ message = ( string ) $ error ; } return new static ( $ message ? : 'An unknown error occurred.' , $ nodes , $ source , $ positions , $ path , $ originalError , $ extensions ) ; }
4882	public function getPermissions ( ) { if ( ! $ this -> permissions ) { $ perms = new Permissions ( ) ; if ( $ this -> user instanceof UserInterface ) { $ perms -> grant ( $ this -> user , PermissionsInterface :: PERMISSION_ALL ) ; } $ this -> setPermissions ( $ perms ) ; } return $ this -> permissions ; }
5677	protected function stringDiffersAt ( $ first , $ second ) { if ( ! $ first || ! $ second ) { return 0 ; } if ( strlen ( $ first ) < strlen ( $ second ) ) { list ( $ first , $ second ) = array ( $ second , $ first ) ; } $ position = 0 ; $ step = strlen ( $ first ) ; while ( $ step > 1 ) { $ step = ( integer ) ( ( $ step + 1 ) / 2 ) ; if ( strncmp ( $ first , $ second , $ position + $ step ) == 0 ) { $ position += $ step ; } } return $ position ; }
1823	public function listImageSize ( $ row ) { $ html = '<div class="tl_content_left">' ; $ html .= $ row [ 'name' ] ; if ( $ row [ 'width' ] || $ row [ 'height' ] ) { $ html .= ' <span style="color:#999;padding-left:3px">' . $ row [ 'width' ] . 'x' . $ row [ 'height' ] . '</span>' ; } if ( $ row [ 'zoom' ] ) { $ html .= ' <span style="color:#999;padding-left:3px">(' . ( int ) $ row [ 'zoom' ] . '%)</span>' ; } $ html .= "</div>\n" ; return $ html ; }
12292	public function findOneLastPost ( $ site ) { $ qb = $ this -> getQueryBuilder ( ) -> select ( 'p.id, p.title, p.description, p.slug, p.published, i.path as image_path' ) -> leftJoin ( 'p.images' , 'i' ) -> andWhere ( 'p.highlighted=1' ) -> setMaxResults ( 1 ) -> orderBy ( 'p.published' , 'DESC' ) ; return $ qb -> getQuery ( ) -> getOneOrNullResult ( \ Doctrine \ ORM \ Query :: HYDRATE_ARRAY ) ; }
2948	public function release ( $ version ) { $ package = 'upyun/sdk' ; $ name = 'php-sdk' ; $ collection = $ this -> collectionBuilder ( ) ; $ workingPath = __DIR__ . DIRECTORY_SEPARATOR . $ collection -> workDir ( "release" ) ; $ collection -> taskExec ( "composer create-project {$package} {$name} {$version}" ) -> dir ( $ workingPath ) -> arg ( '--prefer-dist' ) -> arg ( '--no-dev' ) -> arg ( '-vvv' ) -> taskExec ( 'composer dump-autoload --optimize' ) -> dir ( $ workingPath . DIRECTORY_SEPARATOR . $ name ) -> arg ( '-vvv' ) ; $ collection -> run ( ) ; $ zipFile = "release/{$name}-{$version}.zip" ; $ this -> _remove ( $ zipFile ) ; $ this -> taskPack ( $ zipFile ) -> addDir ( "php-sdk" , __DIR__ . "/release/php-sdk" ) -> run ( ) ; $ this -> _deleteDir ( "release/$name" ) ; }
669	protected function generateDependencyData ( $ cache ) { $ db = Instance :: ensure ( $ this -> db , Connection :: className ( ) ) ; if ( $ this -> sql === null ) { throw new InvalidConfigException ( 'DbDependency::sql must be set.' ) ; } if ( $ db -> enableQueryCache ) { $ db -> enableQueryCache = false ; $ result = $ db -> createCommand ( $ this -> sql , $ this -> params ) -> queryOne ( ) ; $ db -> enableQueryCache = true ; } else { $ result = $ db -> createCommand ( $ this -> sql , $ this -> params ) -> queryOne ( ) ; } return $ result ; }
11433	public function query ( $ keyword , $ categories , array $ other = [ ] ) { $ params = [ 'query' => $ keyword , 'category' => implode ( ',' , ( array ) $ categories ) , 'appid' => $ this -> getAccessToken ( ) -> getAppId ( ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_SEARCH , array_merge ( $ params , $ other ) ] ) ; }
10119	private function writeMarginRight ( ) { $ record = 0x0027 ; $ length = 0x0008 ; $ margin = $ this -> phpSheet -> getPageMargins ( ) -> getRight ( ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'd' , $ margin ) ; if ( self :: getByteOrder ( ) ) { $ data = strrev ( $ data ) ; } $ this -> append ( $ header . $ data ) ; }
10016	public function addExternalSheet ( Worksheet $ pSheet , $ iSheetIndex = null ) { if ( $ this -> sheetNameExists ( $ pSheet -> getTitle ( ) ) ) { throw new Exception ( "Workbook already contains a worksheet named '{$pSheet->getTitle()}'. Rename the external sheet first." ) ; } $ countCellXfs = count ( $ this -> cellXfCollection ) ; foreach ( $ pSheet -> getParent ( ) -> getCellXfCollection ( ) as $ cellXf ) { $ this -> addCellXf ( clone $ cellXf ) ; } $ pSheet -> rebindParent ( $ this ) ; foreach ( $ pSheet -> getCoordinates ( false ) as $ coordinate ) { $ cell = $ pSheet -> getCell ( $ coordinate ) ; $ cell -> setXfIndex ( $ cell -> getXfIndex ( ) + $ countCellXfs ) ; } return $ this -> addSheet ( $ pSheet , $ iSheetIndex ) ; }
2782	public function renderShadowMark ( $ count , $ current , $ eolInterval = 60 ) { $ this -> progressCount ++ ; $ this -> write ( '<fg=blue;options=bold>S</fg=blue;options=bold>' , false ) ; if ( ( $ this -> progressCount % $ eolInterval ) == 0 ) { $ counter = str_pad ( $ this -> progressCount , 5 , ' ' , STR_PAD_LEFT ) ; $ this -> write ( ' |' . $ counter . ' (' . str_pad ( $ current , strlen ( $ count ) , ' ' , STR_PAD_LEFT ) . '/' . $ count . ')' . PHP_EOL , false ) ; } }
9467	protected function initializer ( string $ key , array $ storage ) : void { $ this -> _name = $ key ; $ this -> attached ( $ storage ) ; }
34	protected function jobToText ( $ job ) { $ packageName = $ job [ 'packageName' ] ; $ constraint = $ job [ 'constraint' ] ; switch ( $ job [ 'cmd' ] ) { case 'install' : $ packages = $ this -> pool -> whatProvides ( $ packageName , $ constraint ) ; if ( ! $ packages ) { return 'No package found to satisfy install request for ' . $ packageName . $ this -> constraintToText ( $ constraint ) ; } return 'Installation request for ' . $ packageName . $ this -> constraintToText ( $ constraint ) . ' -> satisfiable by ' . $ this -> getPackageList ( $ packages ) . '.' ; case 'update' : return 'Update request for ' . $ packageName . $ this -> constraintToText ( $ constraint ) . '.' ; case 'remove' : return 'Removal request for ' . $ packageName . $ this -> constraintToText ( $ constraint ) . '' ; } if ( isset ( $ constraint ) ) { $ packages = $ this -> pool -> whatProvides ( $ packageName , $ constraint ) ; } else { $ packages = array ( ) ; } return 'Job(cmd=' . $ job [ 'cmd' ] . ', target=' . $ packageName . ', packages=[' . $ this -> getPackageList ( $ packages ) . '])' ; }
12713	protected function resolve ( $ instance , $ parameters = [ ] ) { if ( $ this -> isInterface ( $ instance ) ) { return $ this -> getConcreteFromInterface ( $ instance ) ; } try { return $ this -> getResolvedSingleton ( $ instance ) ; } catch ( \ Exception $ e ) { } $ concrete = $ this -> getConcrete ( $ instance ) ; if ( ! is_null ( $ concrete ) ) { $ object = $ this -> build ( $ instance , $ concrete instanceof \ Closure ? $ concrete ( $ this ) : $ concrete ) ; if ( $ this -> isShared ( $ instance ) ) { $ this -> markAsResolved ( $ instance , $ object , 'singleton' ) ; } else { $ this -> markAsResolved ( $ instance , $ object ) ; } } else { $ object = $ this -> build ( $ instance , $ parameters ) ; } return $ object ; }
11564	protected function processWeakWord ( $ word ) { $ index = 0 ; $ text = ' ' . $ this -> text . ' ' ; while ( TRUE ) { $ index = mb_strpos ( $ text , ' ' . $ word . ' ' ) ; if ( $ index !== FALSE ) { $ text = mb_substr ( $ text , 0 , $ index + 1 ) . $ word . '&nbsp;' . mb_substr ( $ text , $ index + 1 + mb_strlen ( $ word ) + 1 ) ; $ index += 1 + mb_strlen ( $ word ) + 6 ; } else { break ; } } $ this -> text = mb_substr ( $ text , 1 , mb_strlen ( $ text ) - 2 ) ; }
8535	public function setId ( $ id ) { if ( ! $ this -> isNumericArray ( $ id ) ) { $ id = array ( $ id ) ; } $ this -> fields [ 'Id' ] [ 'FieldValue' ] = $ id ; return $ this ; }
2510	public function analyze ( SendResult $ response ) { $ analyzeResponse = new Result ( $ response ) ; $ domXpath = $ this -> makeDomXpath ( $ response -> responseXml ) ; $ errorCodeNodeList = $ domXpath -> query ( self :: Q_G_ERR ) ; if ( $ errorCodeNodeList -> length > 0 ) { $ errorCatNode = $ domXpath -> query ( self :: Q_G_CAT ) -> item ( 0 ) ; $ analyzeResponse -> setStatus ( $ this -> makeStatusForPotentiallyNonExistent ( $ errorCatNode ) ) ; $ code = $ errorCodeNodeList -> item ( 0 ) -> nodeValue ; $ errorTextNodeList = $ domXpath -> query ( self :: Q_G_MSG ) ; $ message = $ this -> makeMessageFromMessagesNodeList ( $ errorTextNodeList ) ; $ analyzeResponse -> messages [ ] = new Result \ NotOk ( $ code , trim ( $ message ) , 'general' ) ; } $ errorCodeNodeList = $ domXpath -> query ( self :: Q_D_ERR ) ; if ( $ errorCodeNodeList -> length > 0 ) { $ errorCatNode = $ domXpath -> query ( self :: Q_D_CAT ) -> item ( 0 ) ; $ analyzeResponse -> setStatus ( $ this -> makeStatusForPotentiallyNonExistent ( $ errorCatNode ) ) ; $ code = $ errorCodeNodeList -> item ( 0 ) -> nodeValue ; $ errorTextNodeList = $ domXpath -> query ( self :: Q_D_MSG ) ; $ message = $ this -> makeMessageFromMessagesNodeList ( $ errorTextNodeList ) ; $ analyzeResponse -> messages [ ] = new Result \ NotOk ( $ code , trim ( $ message ) , 'deficient_fop' ) ; } return $ analyzeResponse ; }
11533	public static function readFile ( $ file ) { if ( ! file_exists ( $ file ) ) { return null ; } $ handle = fopen ( $ file , 'r' ) ; if ( ! self :: lockFile ( $ handle , LOCK_SH | LOCK_NB ) ) { $ exception = array ( "message" => 'exception_file_cannot_be_locked_for_reading' , "parameters" => array ( "%file%" => basename ( $ file ) , ) ) ; throw new RuntimeException ( json_encode ( $ exception ) ) ; } $ contents = file_get_contents ( $ file ) ; self :: unlockFile ( $ handle ) ; return $ contents ; }
9771	function most ( $ value ) : self { $ target = $ this -> hasFlag ( 'length' ) ? $ this -> getLength ( $ this -> target ) : $ this -> target ; return $ this -> expect ( $ target , lessThanOrEqual ( $ value ) ) ; }
6184	public function display ( $ type = 'all' , $ print = false ) { $ messages = '' ; $ data = '' ; if ( in_array ( $ type , $ this -> msgTypes ) ) { $ flashMessages = $ this -> driver -> get ( 'flash_messages' ) ; foreach ( $ flashMessages [ $ type ] as $ msg ) { $ messages .= $ msg ; } $ data .= $ messages ; $ this -> clear ( $ type ) ; } elseif ( $ type === 'all' ) { $ flashMessages = $ this -> driver -> get ( 'flash_messages' ) ; foreach ( $ flashMessages as $ type => $ msgArray ) { $ messages = '' ; foreach ( $ msgArray as $ msg ) { $ messages .= $ msg ; } $ data .= $ messages ; } $ this -> clear ( ) ; } else { return false ; } if ( $ print ) { echo $ data ; return null ; } return $ data ; }
8269	public function read ( ) { $ this -> open ( ) ; $ data = file_get_contents ( $ this -> filePath ) ; if ( $ data === false ) { throw new \ RuntimeException ( "Could not read from file " . $ this -> filePath ) ; } return $ data ; }
6303	protected function active ( array $ nav ) { foreach ( $ nav as $ key => $ value ) { if ( isset ( $ value [ 'slug' ] ) ) { if ( $ this -> request -> is ( $ value [ 'slug' ] ) || $ this -> request -> is ( $ value [ 'slug' ] . '/*' ) ) { $ nav [ $ key ] [ 'active' ] = true ; } else { $ nav [ $ key ] [ 'active' ] = false ; } } else { $ nav [ $ key ] [ 'active' ] = false ; } } return $ nav ; }
8228	protected function assertLimits ( ) { if ( $ this -> storage -> getUsersCount ( ) >= $ this -> config [ "maxUsers" ] ) { $ this -> session -> addFlash ( "error" , "New registrations are currently disabled." ) ; $ this -> picoAuth -> redirectToPage ( "register" ) ; } }
11327	public function getLocations ( ) { if ( is_null ( $ this -> _locations ) ) { $ this -> _locations = $ this -> determineLocations ( ) ; } return $ this -> _locations ; }
11703	public function getForm ( ) { $ oForm = $ this -> getFormInObject ( ) ; $ sFormContent = $ oForm -> start ; foreach ( $ oForm -> form as $ sValue ) { $ sFormContent .= $ sValue . $ this -> _sSeparator ; } $ sFormContent .= $ oForm -> end ; $ oContainer = new Container ; $ oContainer -> setView ( $ sFormContent ) -> setForm ( $ this ) ; return $ oContainer ; }
8144	public function tokenize ( $ source , $ name = null ) { if ( ! $ source instanceof Twig_Source ) { @ trigger_error ( sprintf ( 'Passing a string as the $source argument of %s() is deprecated since version 1.27. Pass a Twig_Source instance instead.' , __METHOD__ ) , E_USER_DEPRECATED ) ; $ source = new Twig_Source ( $ source , $ name ) ; } if ( null === $ this -> lexer ) { $ this -> lexer = new Twig_Lexer ( $ this ) ; } return $ this -> lexer -> tokenize ( $ source ) ; }
1900	private function createImportantPart ( ImageInterface $ image ) : ? ImportantPart { $ filesModel = $ this -> framework -> getAdapter ( FilesModel :: class ) ; $ file = $ filesModel -> findByPath ( $ image -> getPath ( ) ) ; if ( null === $ file || ! $ file -> importantPartWidth || ! $ file -> importantPartHeight ) { return null ; } $ imageSize = $ image -> getDimensions ( ) -> getSize ( ) ; if ( $ file -> importantPartX + $ file -> importantPartWidth > $ imageSize -> getWidth ( ) || $ file -> importantPartY + $ file -> importantPartHeight > $ imageSize -> getHeight ( ) ) { return null ; } return new ImportantPart ( new Point ( ( int ) $ file -> importantPartX , ( int ) $ file -> importantPartY ) , new Box ( ( int ) $ file -> importantPartWidth , ( int ) $ file -> importantPartHeight ) ) ; }
2887	public function onLayoutGenerate ( Varien_Event_Observer $ observer ) { if ( ! $ this -> canCollect ( ) ) { return ; } $ layout = $ observer -> getData ( 'layout' ) ; $ requestInfo = $ this -> getRequestInfo ( ) ; $ layoutBlocks = $ layout -> getAllBlocks ( ) ; foreach ( $ layoutBlocks as $ block ) { if ( ! $ this -> canCaptureBlock ( $ block ) ) { continue ; } $ requestInfo -> addBlock ( $ block ) ; } $ design = Mage :: getSingleton ( 'core/design_package' ) ; $ requestInfo -> addLayout ( $ layout , $ design ) ; $ this -> saveProfiling ( ) ; }
10284	public static function getRangeBoundaries ( $ pRange ) { if ( empty ( $ pRange ) ) { $ pRange = self :: DEFAULT_RANGE ; } $ pRange = strtoupper ( $ pRange ) ; if ( strpos ( $ pRange , ':' ) === false ) { $ rangeA = $ rangeB = $ pRange ; } else { list ( $ rangeA , $ rangeB ) = explode ( ':' , $ pRange ) ; } return [ self :: coordinateFromString ( $ rangeA ) , self :: coordinateFromString ( $ rangeB ) ] ; }
10431	protected function getShopId ( ContainerBuilder $ container , $ shop , $ name ) { $ shops = $ container -> getParameter ( 'ongr_connections.shops' ) ; if ( ! isset ( $ shops [ $ shop ] ) ) { throw new \ InvalidArgumentException ( 'Non existing shop provided for pipeline ' . $ name ) ; } return $ shops [ $ shop ] [ 'shop_id' ] ; }
10614	public function createMigrateRepository ( array $ args ) { $ db = $ this -> app -> db ; $ repo = new Repository ( $ db ) ; $ resolver = $ this -> app -> resolver -> getResolver ( "migrations" ) ; $ mods = [ ] ; foreach ( $ resolver -> getSearchPath ( ) as $ name => $ path ) { $ module = new Module ( $ name , $ path , $ db ) ; if ( $ name === "wedeto.db" ) array_unshift ( $ mods , $ module ) ; else array_push ( $ mods , $ module ) ; } foreach ( $ mods as $ module ) $ repo -> addModule ( $ module ) ; return $ repo ; }
6599	protected function getReturnType ( array $ lines ) { foreach ( $ lines as $ line ) { if ( strpos ( $ line , '@return' ) === 0 ) { $ type = trim ( str_replace ( '@return' , '' , $ line ) ) ; $ type = str_replace ( '$this' , 'self' , $ type ) ; $ type = explode ( '|' , $ type ) ; return $ type ; } } return [ ] ; }
7455	protected function getTaxonomies ( string $ post_type ) : array { $ return = [ ] ; $ taxes = \ get_object_taxonomies ( $ post_type , 'objects' ) ; foreach ( $ taxes as $ tax_slug => $ tax_object ) { if ( \ is_taxonomy_hierarchical ( $ tax_slug ) ) { $ return [ ] = $ tax_slug ; } } return $ return ; }
1407	protected function getModelAttributes ( Model $ model ) { $ attributes = [ ] ; foreach ( $ this -> attributeKeys ( $ model ) as $ modelKey => $ field ) { if ( is_numeric ( $ modelKey ) ) { $ modelKey = $ field ; $ field = $ this -> fieldForAttribute ( $ field ) ; } $ attributes [ $ field ] = $ this -> extractAttribute ( $ model , $ modelKey , $ field ) ; } return $ attributes ; }
10409	protected function getUrlsByDocumentParameter ( ) { if ( count ( $ this -> documentParamCache ) < 1 ) { return [ ] ; } $ urls = [ ] ; $ query = new Query ( ) ; $ queryTerms = [ ] ; foreach ( $ this -> documentParamCache as $ param ) { $ queryTerms [ $ param [ 0 ] ] [ ] = $ param [ 1 ] ; } foreach ( $ queryTerms as $ field => $ values ) { $ termQuery = new TermQuery ( $ field , $ values ) ; $ query -> addQuery ( $ termQuery , 'should' ) ; } $ limitFilter = new LimitFilter ( count ( $ this -> documentParamCache ) ) ; $ repository = $ this -> manager -> getRepository ( 'MultiModel' ) ; $ search = $ repository -> createSearch ( ) -> addQuery ( $ query ) -> addFilter ( $ limitFilter ) ; $ documents = $ repository -> execute ( $ search ) ; foreach ( $ documents as $ document ) { if ( is_array ( $ document -> url ) ) { foreach ( $ document -> url as $ url ) { $ urls [ ] = $ url [ 'url' ] ; } } } array_walk ( $ urls , [ $ this , 'addWildcard' ] ) ; $ this -> addUrls ( $ urls ) ; return $ urls ; }
12921	public function getRemaining ( ) { if ( is_null ( $ this -> _countRemaining ) ) { $ this -> _countRemaining = $ this -> total ; } return $ this -> _countRemaining ; }
3475	public function getGateway ( ) { $ gateway = $ this -> gateway ; try { $ response = $ this -> guzzle -> get ( 'https://discordapp.com/api/gateway' , [ 'headers' => [ 'Authorization' => 'Bot ' . $ this -> token , ] , ] ) ; $ gateway = Arr :: get ( json_decode ( $ response -> getBody ( ) , true ) , 'url' , $ gateway ) ; } catch ( Exception $ e ) { $ this -> warn ( "Could not get a websocket gateway address, defaulting to '{$gateway}'." ) ; } return $ gateway ; }
7176	public static function extract ( $ array , array $ paths , $ default = null ) { $ found = array ( ) ; foreach ( $ paths as $ path ) { static :: set_path ( $ found , $ path , static :: path ( $ array , $ path , $ default ) ) ; } return $ found ; }
10321	function getUnsubscribersCount ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ source = null ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , $ source ) ; return $ this -> get ( 'reports/unsubscriptions/count' , $ params ) ; }
3496	private function doSend ( Receiver $ receiver , Notification $ notification , bool $ sandbox ) : void { $ payloadEncoded = $ this -> payloadEncoder -> encode ( $ notification -> getPayload ( ) ) ; $ uri = $ this -> uriFactory -> create ( $ receiver -> getToken ( ) , $ sandbox ) ; $ request = new Request ( $ uri , $ payloadEncoded ) ; $ headers = [ 'content-type' => 'application/json' , 'accept' => 'application/json' , 'apns-topic' => $ receiver -> getTopic ( ) , ] ; $ request = $ request -> withHeaders ( $ headers ) ; $ request = $ this -> authenticator -> authenticate ( $ request ) ; $ request = $ this -> visitor -> visit ( $ notification , $ request ) ; $ response = $ this -> httpSender -> send ( $ request ) ; if ( $ response -> getStatusCode ( ) !== 200 ) { throw $ this -> exceptionFactory -> create ( $ response ) ; } }
444	public function trigger ( $ name , Event $ event = null ) { $ this -> ensureBehaviors ( ) ; $ eventHandlers = [ ] ; foreach ( $ this -> _eventWildcards as $ wildcard => $ handlers ) { if ( StringHelper :: matchWildcard ( $ wildcard , $ name ) ) { $ eventHandlers = array_merge ( $ eventHandlers , $ handlers ) ; } } if ( ! empty ( $ this -> _events [ $ name ] ) ) { $ eventHandlers = array_merge ( $ eventHandlers , $ this -> _events [ $ name ] ) ; } if ( ! empty ( $ eventHandlers ) ) { if ( $ event === null ) { $ event = new Event ( ) ; } if ( $ event -> sender === null ) { $ event -> sender = $ this ; } $ event -> handled = false ; $ event -> name = $ name ; foreach ( $ eventHandlers as $ handler ) { $ event -> data = $ handler [ 1 ] ; call_user_func ( $ handler [ 0 ] , $ event ) ; if ( $ event -> handled ) { return ; } } } Event :: trigger ( $ this , $ name , $ event ) ; }
719	public function time ( $ precision = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_TIME , $ precision ) ; }
11089	public static function isCzechHoliday ( $ date ) { if ( ! $ date instanceof DateTime ) { if ( \ is_int ( $ date ) ) { $ date = new DateTime ( '@' . $ date ) ; } elseif ( \ is_string ( $ date ) ) { $ date = new DateTime ( $ date ) ; } else { throw new RuntimeException ( self :: poorManTranslate ( 'fts-shared' , 'Invalid date format' ) ) ; } } $ holidays = [ '01-01' , '05-01' , '05-08' , '07-05' , '07-06' , '09-28' , '10-28' , '11-17' , '12-24' , '12-25' , '12-26' ] ; if ( \ in_array ( $ date -> format ( 'm-d' ) , $ holidays , true ) ) { return true ; } $ easterDays = easter_days ( $ date -> format ( 'Y' ) ) ; $ easter = new DateTime ( $ date -> format ( 'Y' ) . '-03-21' ) ; $ easter -> add ( new \ DateInterval ( 'P' . $ easterDays . 'D' ) ) ; $ easter -> sub ( new \ DateInterval ( 'P2D' ) ) ; if ( $ date -> format ( 'Y-m-d' ) === $ easter -> format ( 'Y-m-d' ) ) { return true ; } $ easter -> add ( new \ DateInterval ( 'P3D' ) ) ; return ( $ easter -> format ( 'Y-m-d' ) === $ date -> format ( 'Y-m-d' ) ) ; }
12759	public static function parse ( & $ string ) { $ media = array ( "objects" => array ( ) , "hashes" => array ( ) , "links" => array ( ) , ) ; preg_match_all ( '#@([\\d\\w]+)#' , $ string , $ mentions ) ; preg_match_all ( '/#([\\d\\w]+)/' , $ string , $ hashTags ) ; preg_match_all ( '/((http|https|ftp|ftps)\:\/\/)([a-z0-9+!*(),;?&=\$_.-]+(\:[a-z0-9+!*(),;?&=\$_.-]+)?@)?([a-zA-Z0-9\-\.]+)\.([a-zA-Z]{2,3})(\:[0-9]{2,5})?(\/([a-z0-9+\$_-]\.?)+)*\/?/' , $ data , $ openLinks ) ; return $ media ; }
12599	public function get ( $ key , $ default = null ) { return array_key_exists ( $ key , $ this -> configs ) ? $ this -> configs [ $ key ] : $ default ; }
12031	function addCreateAndExecuteMethod ( ) { $ methodGenerator = new MethodGenerator ( 'createAndExecute' ) ; $ body = '' ; $ body .= $ this -> generateCreateFragment ( ) ; $ body .= $ this -> generateExecuteFragment ( ) ; $ body .= PHP_EOL ; $ body .= 'return $response;' . PHP_EOL ; ; $ docBlock = new DocBlockGenerator ( 'Create and execute the operation, returning the raw response from the server.' , null ) ; $ tags [ ] = new GenericTag ( 'return' , '\Amp\Artax\Response' ) ; $ docBlock -> setTags ( $ tags ) ; $ methodGenerator -> setBody ( $ body ) ; $ methodGenerator -> setDocBlock ( $ docBlock ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
1078	public static function executeQuery ( SchemaType $ schema , $ source , $ rootValue = null , $ context = null , $ variableValues = null , ? string $ operationName = null , ? callable $ fieldResolver = null , ? array $ validationRules = null ) : ExecutionResult { $ promiseAdapter = new SyncPromiseAdapter ( ) ; $ promise = self :: promiseToExecute ( $ promiseAdapter , $ schema , $ source , $ rootValue , $ context , $ variableValues , $ operationName , $ fieldResolver , $ validationRules ) ; return $ promiseAdapter -> wait ( $ promise ) ; }
3165	public function switchClientStoreId ( RunnerServiceContext $ context , $ receivedStoreId ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ session = $ context -> getTestSession ( ) ; $ sessionId = $ session -> getSessionId ( ) ; $ stateService = $ this -> getServiceManager ( ) -> get ( ExtendedStateService :: SERVICE_ID ) ; $ lastStoreId = $ stateService -> getStoreId ( $ sessionId ) ; if ( $ lastStoreId == false || $ lastStoreId != $ receivedStoreId ) { $ stateService -> setStoreId ( $ sessionId , $ receivedStoreId ) ; } return $ lastStoreId ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'switchClientStoreId' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } }
6106	private function getGridClass ( ) { $ class = [ ] ; foreach ( $ this -> grid as $ grid ) { if ( ! isset ( $ grid [ 'type' ] ) || ! isset ( $ grid [ 'size' ] ) ) { throw new InvalidConfigException ( get_called_class ( ) . ' must have type and size.' ) ; } if ( ! isset ( $ grid [ 'positiontype' ] ) ) $ class [ ] = $ grid [ 'type' ] . $ grid [ 'size' ] ; else $ class [ ] = $ grid [ 'type' ] . $ grid [ 'positiontype' ] . '-' . $ grid [ 'size' ] ; } return implode ( ' ' , $ class ) ; }
6378	protected function readStoreRecord ( $ type , array $ query ) { $ model = $ this -> store -> get_record ( $ type , $ query ) ; if ( $ model === false ) { throw new Exception ( 'Record not found.' ) ; } return $ model ; }
2164	public static function convertSingleField ( $ table , $ field ) { $ objDatabase = Database :: getInstance ( ) ; $ objRow = $ objDatabase -> query ( "SELECT id, $field FROM $table WHERE $field!=''" ) ; $ objDesc = $ objDatabase -> query ( "DESC $table $field" ) ; if ( $ objDesc -> Type != 'binary(16)' ) { $ objDatabase -> query ( "ALTER TABLE `$table` CHANGE `$field` `$field` binary(16) NULL" ) ; $ objDatabase -> query ( "UPDATE `$table` SET `$field`=NULL WHERE `$field`='' OR `$field`=0" ) ; } while ( $ objRow -> next ( ) ) { $ objHelper = static :: generateHelperObject ( $ objRow -> $ field ) ; if ( $ objHelper -> isUuid ) { continue ; } if ( $ objHelper -> isNumeric ) { $ objFile = FilesModel :: findByPk ( $ objHelper -> value ) ; $ objDatabase -> prepare ( "UPDATE $table SET $field=? WHERE id=?" ) -> execute ( $ objFile -> uuid , $ objRow -> id ) ; } else { $ objFile = FilesModel :: findByPath ( $ objHelper -> value ) ; $ objDatabase -> prepare ( "UPDATE $table SET $field=? WHERE id=?" ) -> execute ( $ objFile -> uuid , $ objRow -> id ) ; } } }
10548	public function setTemplate ( Template $ template ) { $ this -> template = $ template ; $ this -> setVariable ( 'template' , $ template ) ; $ this -> setVariable ( 'tpl' , $ template ) ; return $ this ; }
12646	public function setTrue ( $ obData = null ) { $ this -> bStatus = true ; $ this -> obData = $ obData ; return $ this ; }
11793	public function setCc ( $ mail = '' , $ name = null ) { $ this -> cc = Helper :: deduplicate ( array_merge ( $ this -> cc , call_user_func_array ( array ( '\MimeMailer\Helper' , 'checkPeopleArgs' ) , func_get_args ( ) ) ) ) ; return $ this ; }
5414	public function getRequestLine ( $ method ) { $ url = $ this -> getUrl ( ) ; $ scheme = $ url -> getScheme ( ) ? $ url -> getScheme ( ) : 'http' ; $ port = $ url -> getPort ( ) ? ':' . $ url -> getPort ( ) : '' ; return $ method . ' ' . $ scheme . '://' . $ url -> getHost ( ) . $ port . $ url -> getPath ( ) . $ url -> getEncodedRequest ( ) . ' HTTP/1.0' ; }
3836	private function setLanguageStrings ( ) { if ( empty ( $ GLOBALS [ 'TL_LANG' ] [ $ this -> getMetaModel ( ) -> getTableName ( ) ] [ $ this -> getColName ( ) ] ) ) { $ GLOBALS [ 'TL_LANG' ] [ $ this -> getMetaModel ( ) -> getTableName ( ) ] [ $ this -> getColName ( ) ] = array ( $ this -> getLangValue ( $ this -> get ( 'name' ) ) , $ this -> getLangValue ( $ this -> get ( 'description' ) ) , ) ; } }
11219	protected static function invokeObject ( $ callback , $ matched = null ) { $ last = explode ( '/' , $ callback ) ; $ last = end ( $ last ) ; $ segments = explode ( '@' , $ last ) ; $ class = $ segments [ 0 ] ; $ method = $ segments [ 1 ] ; $ matched = $ matched ? $ matched : [ ] ; if ( method_exists ( $ class , self :: $ singleton ) ) { $ instance = call_user_func ( [ $ class , self :: $ singleton ] ) ; return call_user_func_array ( [ $ instance , $ method ] , $ matched ) ; } if ( class_exists ( $ class ) ) { $ instance = new $ class ; return call_user_func_array ( [ $ instance , $ method ] , $ matched ) ; } return false ; }
12636	protected function getSandboxSignKey ( ) { if ( $ this -> sandboxSignKey ) { return $ this -> sandboxSignKey ; } $ cacheKey = 'sandbox_signkey.' . $ this -> merchant -> merchant_id . $ this -> merchant -> sub_merchant_id ; $ cache = $ this -> getCache ( ) ; $ this -> sandboxSignKey = $ cache -> fetch ( $ cacheKey ) ; if ( ! $ this -> sandboxSignKey ) { $ result = $ this -> request ( self :: API_SANDBOX_SIGN_KEY , [ ] ) ; if ( $ result -> return_code === 'SUCCESS' ) { $ cache -> save ( $ cacheKey , $ result -> sandbox_signkey , 24 * 3600 ) ; return $ this -> sandboxSignKey = $ result -> sandbox_signkey ; } throw new Exception ( $ result -> return_msg ) ; } return $ this -> sandboxSignKey ; }
9688	public function det ( ) { if ( $ this -> m == $ this -> n ) { $ d = $ this -> pivsign ; for ( $ j = 0 ; $ j < $ this -> n ; ++ $ j ) { $ d *= $ this -> LU [ $ j ] [ $ j ] ; } return $ d ; } throw new CalculationException ( Matrix :: MATRIX_DIMENSION_EXCEPTION ) ; }
7924	public function extract ( $ zipFile , $ targetPath ) { $ zipArchive = $ this -> openZipFile ( $ zipFile ) ; $ targetPath = $ this -> fixPath ( $ targetPath ) ; $ filenames = $ this -> extractFilenames ( $ zipArchive ) ; if ( $ zipArchive -> extractTo ( $ targetPath , $ filenames ) === false ) { throw new \ Exception ( $ this -> getError ( $ zipArchive -> status ) ) ; } $ zipArchive -> close ( ) ; return $ filenames ; }
567	private function parseDateValueFormat ( $ value , $ format ) { if ( is_array ( $ value ) ) { return false ; } if ( strncmp ( $ format , 'php:' , 4 ) === 0 ) { $ format = substr ( $ format , 4 ) ; } else { if ( extension_loaded ( 'intl' ) ) { return $ this -> parseDateValueIntl ( $ value , $ format ) ; } $ format = FormatConverter :: convertDateIcuToPhp ( $ format , 'date' ) ; } return $ this -> parseDateValuePHP ( $ value , $ format ) ; }
10486	protected function retrieveMapping ( $ table ) { $ result = $ this -> connection -> fetchAll ( 'SELECT COLUMN_NAME, ORDINAL_POSITION FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = ?' , [ $ table ] ) ; if ( empty ( $ result ) ) { return false ; } $ columns = [ ] ; foreach ( $ result as $ column ) { $ columns [ $ column [ 'ORDINAL_POSITION' ] ] = $ column [ 'COLUMN_NAME' ] ; } return $ columns ; }
12286	public function inset ( string $ block , array $ vars = null ) : string { return trim ( $ this -> make ( $ block , $ vars ) ) . PHP_EOL ; }
9400	public function export ( ) { foreach ( $ this -> messages as $ message ) { list ( $ msg , $ level , $ catagory , $ timestamp , $ traces ) = $ message ; $ errStr = '' ; $ options = [ 'level' => yii \ log \ Logger :: getLevelName ( $ level ) , 'extra' => [ ] , ] ; $ templateData = null ; if ( is_array ( $ msg ) ) { $ errStr = isset ( $ msg [ 'msg' ] ) ? $ msg [ 'msg' ] : '' ; if ( isset ( $ msg [ 'data' ] ) ) $ options [ 'extra' ] = $ msg [ 'data' ] ; } else { $ errStr = $ msg ; } $ traces = array_map ( function ( $ v ) { return "{$v['file']}" . PHP_EOL . "{$v['class']}::{$v['function']} [{$v['line']}]" ; } , $ traces ) ; if ( ! empty ( $ traces ) ) $ options [ 'extra' ] [ 'traces' ] = $ traces ; $ this -> client -> captureMessage ( $ errStr , array ( ) , $ options , false ) ; } }
481	public function addPrimaryKey ( $ name , $ table , $ columns ) { $ time = $ this -> beginCommand ( "add primary key $name on $table (" . ( is_array ( $ columns ) ? implode ( ',' , $ columns ) : $ columns ) . ')' ) ; $ this -> db -> createCommand ( ) -> addPrimaryKey ( $ name , $ table , $ columns ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
7185	public static function build ( StockUnitInterface $ unit , SaleInterface $ sale ) { $ releasable = 0 ; $ map = [ ] ; foreach ( $ unit -> getStockAssignments ( ) as $ a ) { if ( $ sale === $ s = $ a -> getSaleItem ( ) -> getSale ( ) ) { continue ; } if ( $ s -> getShipmentState ( ) === ShipmentStates :: STATE_PREPARATION ) { continue ; } if ( 0 < $ d = $ a -> getSoldQuantity ( ) - $ a -> getShippedQuantity ( ) ) { $ releasable += $ d ; $ map [ $ a -> getId ( ) ] = $ d ; } } arsort ( $ map , \ SORT_NUMERIC ) ; $ candidate = new static ; $ candidate -> unit = $ unit ; $ candidate -> shippable = $ unit -> getShippableQuantity ( ) ; $ candidate -> reservable = $ unit -> getReservableQuantity ( ) ; $ candidate -> releasable = $ releasable ; $ candidate -> map = $ map ; return $ candidate ; }
9299	public function postAction ( Request $ request ) { try { $ data = $ this -> get ( 'ongr_api.batch_request_handler' ) -> handleRequest ( $ request , $ repository = $ this -> getRequestRepository ( $ request ) , 'create' ) ; return $ this -> renderRest ( $ request , $ data , Response :: HTTP_OK ) ; } catch ( \ Exception $ e ) { return $ this -> renderError ( $ request , $ e -> getMessage ( ) , Response :: HTTP_BAD_REQUEST ) ; } }
11640	public function getData ( ) { if ( is_null ( $ this -> _currentData ) ) { $ this -> _currentDataRaw = $ this -> dataProvider -> getData ( ) ; $ this -> _currentData = [ ] ; $ itemNumber = $ this -> dataProvider -> pagination -> offset ; $ row = 0 ; foreach ( $ this -> _currentDataRaw as $ r ) { $ p = [ 'itemNumber' => $ itemNumber , 'id' => $ r -> primaryKey , 'values' => [ ] ] ; foreach ( $ this -> columns as $ key => $ c ) { $ p [ 'values' ] [ $ key ] = $ c -> getDataValue ( $ row , $ r , false ) ; } $ p [ 'acl' ] = [ ] ; if ( $ this -> owner -> instanceSettings [ 'whoAmI' ] === 'parent' and isset ( $ r -> childObject ) and $ r -> childObject -> hasBehavior ( 'Access' ) ) { $ p [ 'acl' ] = $ r -> childObject -> aclSummary ( ) ; } elseif ( $ this -> owner -> instanceSettings [ 'whoAmI' ] === 'child' and isset ( $ r -> parentObject ) and $ r -> parentObject -> hasBehavior ( 'Access' ) ) { $ p [ 'acl' ] = $ r -> parentObject -> aclSummary ( ) ; } elseif ( $ r -> hasBehavior ( 'Access' ) ) { $ p [ 'acl' ] = $ r -> aclSummary ( ) ; } $ this -> _currentData [ 'item-' . $ itemNumber ] = $ p ; $ row ++ ; $ itemNumber ++ ; } } return $ this -> _currentData ; }
10885	protected function makeRequest ( $ data ) { $ url = 'https://www.errorstream.com/api/1.0/errors/create?' . http_build_query ( [ 'api_token' => $ this -> api_token , 'project_token' => $ this -> project_token ] ) ; try { $ ch = curl_init ( ) ; curl_setopt ( $ ch , CURLOPT_URL , $ url ) ; curl_setopt ( $ ch , CURLOPT_POST , true ) ; curl_setopt ( $ ch , CURLOPT_POSTFIELDS , json_encode ( $ data ) ) ; curl_setopt ( $ ch , CURLOPT_HTTPHEADER , array ( 'Content-Type:application/json' ) ) ; curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , true ) ; $ result = curl_exec ( $ ch ) ; curl_close ( $ ch ) ; return $ result ; } catch ( \ Exception $ ex ) { return $ ex -> getMessage ( ) ; } }
11828	public function setUri ( $ uri ) { if ( ! empty ( $ uri ) && ! is_file ( $ uri ) ) { throw new \ Exception ( sprintf ( 'File %s not found.' , $ uri ) ) ; } $ this -> uri = $ uri ; return $ this ; }
9927	private function cleanUnwanted ( Parameters $ params , $ permitted ) { foreach ( $ params -> toArray ( ) as $ key => $ value ) { if ( is_array ( $ value ) && ! is_int ( $ key ) ) { if ( ! array_key_exists ( $ key , $ permitted ) ) { $ this -> handleUnpermittedParam ( $ key , $ params ) ; } } elseif ( ! is_int ( $ key ) && ! in_array ( $ key , $ permitted ) && ! array_key_exists ( $ key , $ permitted ) ) { $ this -> handleUnpermittedParam ( $ key , $ params ) ; } } }
4943	protected function addBaseFieldset ( ) { if ( null === $ this -> baseFieldset ) { return ; } $ fs = $ this -> baseFieldset ; if ( ! is_array ( $ fs ) ) { $ fs = array ( 'type' => $ fs , ) ; } if ( ! isset ( $ fs [ 'options' ] [ 'use_as_base_fieldset' ] ) ) { $ fs [ 'options' ] [ 'use_as_base_fieldset' ] = true ; } $ this -> add ( $ fs ) ; }
3537	public function getGroupsAssignedInLdap ( ) { if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: beginProfile ( 'getGroupsAssignedInLdap' , static :: YII2_PROFILE_NAME . 'getGroupsAssignedInLdap' ) ; } $ ldapUser = $ this -> queryLdapUserObject ( ) ; $ ldapGroupsConverted = [ ] ; if ( $ ldapUser != null ) { if ( static :: getGroupAssigmentOptions ( 'SEARCH_NESTED_GROUPS' , $ this -> individualGroupAssignmentOptions ) == true ) { $ ldapGroups = static :: getAdldapProvider ( ) -> search ( ) -> rawFilter ( '(member:1.2.840.113556.1.4.1941:=' . $ ldapUser -> getDn ( ) . ')' ) -> select ( 'cn' ) -> raw ( ) -> get ( ) ; if ( $ ldapGroups == null ) { $ ldapGroups = [ ] ; } foreach ( $ ldapGroups as $ groupDn ) { if ( is_array ( $ groupDn ) && array_key_exists ( 'cn' , $ groupDn ) ) { array_push ( $ ldapGroupsConverted , $ groupDn [ 'cn' ] [ 0 ] ) ; } } } else { $ ldapGroups = $ ldapUser -> getAttribute ( 'memberof' ) ; if ( $ ldapGroups == null ) { $ ldapGroups = [ ] ; } foreach ( $ ldapGroups as $ groupDn ) { $ n = Utilities :: explodeDn ( $ groupDn ) [ 0 ] ; array_push ( $ ldapGroupsConverted , $ n ) ; } } } if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: endProfile ( 'getGroupsAssignedInLdap' , static :: YII2_PROFILE_NAME . 'getGroupsAssignedInLdap' ) ; } return $ ldapGroupsConverted ; }
6891	protected function createAssignmentsForQuantity ( SaleItemInterface $ item , $ quantity ) { if ( 0 >= $ quantity ) { return ; } $ stockUnits = $ this -> sortStockUnits ( $ this -> unitResolver -> findAssignable ( $ item ) ) ; foreach ( $ stockUnits as $ stockUnit ) { $ assignment = $ this -> saleFactory -> createStockAssignmentForItem ( $ item ) ; $ assignment -> setSaleItem ( $ item ) -> setStockUnit ( $ stockUnit ) ; $ quantity -= $ this -> assignmentUpdater -> updateSold ( $ assignment , $ quantity ) ; if ( 0 == $ quantity ) { return ; } } if ( 0 < $ quantity ) { $ stockUnit = $ this -> unitResolver -> createBySubjectRelative ( $ item ) ; $ assignment = $ this -> saleFactory -> createStockAssignmentForItem ( $ item ) ; $ assignment -> setSaleItem ( $ item ) -> setStockUnit ( $ stockUnit ) ; $ quantity -= $ this -> assignmentUpdater -> updateSold ( $ assignment , $ quantity ) ; } if ( 0 < $ quantity ) { throw new StockLogicException ( sprintf ( 'Failed to create assignments for item "%s".' , $ item -> getDesignation ( ) ) ) ; } }
7220	public static function json ( $ content , $ code = 200 ) { if ( is_a ( $ content , "SnooPHP\Model\Collection" ) ) $ content = $ content -> array ( ) ; return new static ( to_json ( $ content ) , $ code , [ "Content-Type" => "application/json; charset=utf-8" ] ) ; }
9429	public function getFontIconClassNames ( ) { $ classes = [ ] ; if ( $ this -> owner -> FontIcon ) { if ( $ this -> owner -> FontIconListItem ) { $ classes [ ] = $ this -> backend -> getClassName ( 'list-item' ) ; } if ( $ this -> owner -> FontIconFixedWidth ) { $ classes [ ] = $ this -> backend -> getClassName ( 'fixed-width' ) ; } $ classes [ ] = $ this -> backend -> getClassName ( 'icon' , [ $ this -> owner -> FontIcon ] ) ; } return $ classes ; }
9779	private function expect ( $ target , Constraint $ constraint ) : self { assertThat ( $ target , $ this -> hasFlag ( 'negate' ) ? logicalNot ( $ constraint ) : $ constraint , $ this -> message ) ; return $ this ; }
3020	public function getBlogInfo ( $ blogName ) { $ path = $ this -> blogPath ( $ blogName , '/info' ) ; return $ this -> getRequest ( $ path , null , true ) ; }
2637	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ dictionaryId = $ this -> getRequest ( ) -> getParam ( 'dictionary_id' ) ; $ value = $ this -> getRequest ( ) -> getParam ( 'item_value' ) ; $ key = $ this -> getRequest ( ) -> getParam ( 'item_key' ) ; $ this -> api -> upsertDictionaryItem ( $ dictionaryId , $ key , $ value ) ; return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
6595	protected function getMethodComment ( \ ReflectionMethod $ method ) { $ lines = preg_split ( "/((\r?\n)|(\r\n?))/" , $ method -> getDocComment ( ) ) ; $ count = count ( $ lines ) ; foreach ( $ lines as $ i => $ line ) { $ line = preg_replace ( '/^\s*(\/\*\*|\*\/?)\s*/' , '' , $ line ) ; $ line = trim ( $ line ) ; $ lines [ $ i ] = $ line ; if ( ! $ line && ( $ i == 0 || $ i == $ count - 1 ) ) { unset ( $ lines [ $ i ] ) ; } } return array_values ( $ lines ) ; }
8661	private function convertGetFeedSubmissionResult ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetFeedSubmissionResult' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetFeedSubmissionId ( ) ) { $ parameters [ 'FeedSubmissionId' ] = $ request -> getFeedSubmissionId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
660	public function createCommand ( $ sql = null , $ params = [ ] ) { $ driver = $ this -> getDriverName ( ) ; $ config = [ 'class' => 'yii\db\Command' ] ; if ( $ this -> commandClass !== $ config [ 'class' ] ) { $ config [ 'class' ] = $ this -> commandClass ; } elseif ( isset ( $ this -> commandMap [ $ driver ] ) ) { $ config = ! is_array ( $ this -> commandMap [ $ driver ] ) ? [ 'class' => $ this -> commandMap [ $ driver ] ] : $ this -> commandMap [ $ driver ] ; } $ config [ 'db' ] = $ this ; $ config [ 'sql' ] = $ sql ; $ command = Yii :: createObject ( $ config ) ; return $ command -> bindValues ( $ params ) ; }
7171	protected function resolveTaxRule ( CountryInterface $ country , $ business = false ) : ? TaxRuleInterface { if ( $ business ) { return $ this -> taxRuleRepository -> findOneByCountryForBusiness ( $ country ) ; } return $ this -> taxRuleRepository -> findOneByCountryForCustomer ( $ country ) ; }
5182	private function fillSource ( $ source , $ photo ) : string { if ( ! empty ( $ source ) ) { return $ this -> filterUriInstance ( $ source ) ; } return ( string ) $ photo ; }
4918	public function setParam ( $ key , $ value ) { if ( $ this -> has ( $ key ) ) { $ this -> get ( $ key ) -> setValue ( $ value ) ; } else { $ this -> add ( [ 'type' => 'hidden' , 'name' => $ key , 'attributes' => [ 'value' => $ value ] ] ) ; } return $ this ; }
6506	public function serializeReturnValue ( $ type , $ value ) { $ jobType = $ this -> registry -> get ( $ type ) ; return $ this -> serializer -> serialize ( $ value , 'json' , $ this -> getResponseSerializationContext ( $ jobType ) ) ; }
2420	public static function moveResource ( $ strSource , $ strDestination ) { $ objFile = FilesModel :: findByPath ( $ strSource ) ; if ( $ objFile === null ) { $ objFile = static :: addResource ( $ strDestination ) ; } $ strFolder = \ dirname ( $ strDestination ) ; if ( $ strFolder == Config :: get ( 'uploadPath' ) ) { $ objFile -> pid = null ; } else { $ objFolder = FilesModel :: findByPath ( $ strFolder ) ; if ( $ objFolder === null ) { $ objFolder = static :: addResource ( $ strFolder ) ; } $ objFile -> pid = $ objFolder -> uuid ; } $ objFile -> path = $ strDestination ; $ objFile -> name = basename ( $ strDestination ) ; $ objFile -> save ( ) ; if ( $ objFile -> type == 'folder' ) { $ objFiles = FilesModel :: findMultipleByBasepath ( $ strSource . '/' ) ; if ( $ objFiles !== null ) { while ( $ objFiles -> next ( ) ) { $ objFiles -> path = preg_replace ( '@^' . preg_quote ( $ strSource , '@' ) . '/@' , $ strDestination . '/' , $ objFiles -> path ) ; $ objFiles -> save ( ) ; } } } if ( ( $ strPath = \ dirname ( $ strSource ) ) != Config :: get ( 'uploadPath' ) ) { static :: updateFolderHashes ( $ strPath ) ; } if ( ( $ strPath = \ dirname ( $ strDestination ) ) != Config :: get ( 'uploadPath' ) ) { static :: updateFolderHashes ( $ strPath ) ; } return $ objFile ; }
4523	protected function loadDefinition ( $ id ) { $ filename = $ this -> definitionPath . $ id . '.json' ; $ definition = @ file_get_contents ( $ filename ) ; if ( empty ( $ definition ) ) { throw new UnknownZoneException ( $ id ) ; } $ definition = json_decode ( $ definition , true ) ; $ definition [ 'id' ] = $ id ; return $ definition ; }
10581	public function handleRequest ( ServerRequestInterface $ serverRequest , ResponseInterface $ response ) : ResponseInterface { $ response = $ response -> withProtocolVersion ( $ serverRequest -> getProtocolVersion ( ) ) ; try { try { $ APIRequest = $ this -> requestFactory -> create ( $ serverRequest ) ; } catch ( UnableToCreateRequestException $ exception ) { return $ this -> handleRequestFactoryException ( $ exception , $ response ) ; } try { $ APIResponse = $ this -> server -> handleRequest ( $ APIRequest ) ; } catch ( UnableToHandleRequestException $ exception ) { return $ this -> handleServerException ( $ exception , $ response ) ; } return $ this -> buildResponse ( $ APIResponse , $ response ) ; } catch ( \ Throwable $ e ) { $ this -> logCaughtThrowableResultingInHTTPCode ( 500 , $ e , LogLevel :: CRITICAL ) ; return $ response -> withStatus ( 500 , "Internal Server Error" ) ; } }
4207	private function getPropCommentInfo ( \ ReflectionProperty $ reflectionProperty ) { $ name = $ reflectionProperty -> name ; $ phpDoc = $ this -> phpDoc -> getParsed ( $ reflectionProperty ) ; $ info = array ( 'type' => null , 'desc' => $ phpDoc [ 'summary' ] ? $ phpDoc [ 'summary' ] : null , ) ; if ( isset ( $ phpDoc [ 'var' ] ) ) { if ( \ count ( $ phpDoc [ 'var' ] ) == 1 ) { $ var = $ phpDoc [ 'var' ] [ 0 ] ; } else { foreach ( $ phpDoc [ 'var' ] as $ var ) { if ( $ var [ 'name' ] == $ name ) { break ; } } } $ info [ 'type' ] = $ var [ 'type' ] ; if ( ! $ info [ 'desc' ] ) { $ info [ 'desc' ] = $ var [ 'desc' ] ; } elseif ( $ var [ 'desc' ] ) { $ info [ 'desc' ] = $ info [ 'desc' ] . ': ' . $ var [ 'desc' ] ; } } return $ info ; }
2452	private function getLocale ( Request $ request ) : string { if ( null !== $ request -> attributes -> get ( '_locale' ) ) { return $ this -> formatLocaleId ( $ request -> attributes -> get ( '_locale' ) ) ; } return $ request -> getPreferredLanguage ( $ this -> availableLocales ) ; }
11953	public function deleteFromDB ( ) { if ( ! $ this -> isValid ( ) ) { return false ; } if ( count ( $ this -> key_properties ) == 0 ) { return false ; } $ where_part = '' ; foreach ( $ this -> key_properties as $ key ) { if ( $ where_part ) { $ where_part .= ' AND ' ; } if ( $ this -> { $ key } instanceof Web2All_Table_SQLOperation ) { trigger_error ( 'Web2All_Table_SaveObjectTrait->deleteFromDB(): using Web2All_Table_SQLOperation object for key value ' . $ key , E_USER_NOTICE ) ; $ where_part .= $ this -> obj_to_db_trans [ $ key ] . '=' . $ this -> { $ key } -> toSQLString ( ) ; } else if ( $ this -> { $ key } instanceof Web2All_Table_SQLOperationList ) { throw new Exception ( "Web2All_Table_SaveObjectTrait: can't delete using a Web2All_Table_SQLOperationList for key value " . $ key ) ; } else { $ where_part .= $ this -> obj_to_db_trans [ $ key ] . '=' . $ this -> db -> Quote ( $ this -> { $ key } ) ; } } $ this -> db -> Execute ( 'DELETE FROM ' . $ this -> quote ( $ this -> tablename ) . ' WHERE ' . $ where_part . ' ' ) ; return true ; }
8777	public function assets ( $ data = null , $ secure = false ) { $ data = ( ! is_null ( $ data ) ) ? $ this -> url . '/' . ASSETS_FOLDER . '/' . $ data : $ this -> url . '/' . ASSETS_FOLDER . '/' ; return $ this -> getUrl ( $ data , $ secure ) ; }
1439	protected function getStub ( ) { if ( $ this -> isIndependent ) { return $ this -> getStubFor ( 'independent' ) ; } if ( $ this -> isEloquent ( ) ) { return $ this -> getStubFor ( 'eloquent' ) ; } return $ this -> getStubFor ( 'abstract' ) ; }
1880	protected function isMounted ( $ strFolder ) { if ( $ strFolder == '' ) { return false ; } if ( empty ( $ this -> arrFilemounts ) ) { return true ; } $ path = $ strFolder ; while ( \ is_array ( $ this -> arrFilemounts ) && substr_count ( $ path , '/' ) > 0 ) { if ( \ in_array ( $ path , $ this -> arrFilemounts ) ) { return true ; } $ path = \ dirname ( $ path ) ; } return false ; }
11491	public function getAll ( ) : array { $ res = [ ] ; foreach ( $ this -> getKeys ( ) as $ key ) { $ res [ $ key ] = $ this -> get ( $ key ) ; } return $ res ; }
1269	public function getSubscription ( $ name = null , $ beginDateTime = null , $ endDateTime = null , $ fileName = null , $ bookmark = null ) { if ( null !== $ beginDateTime ) { $ beginDateTime = $ this -> formatDateTime ( $ beginDateTime ) ; } if ( null !== $ endDateTime ) { $ endDateTime = $ this -> formatDateTime ( $ endDateTime ) ; } if ( null !== $ beginDateTime && null === $ endDateTime ) { $ endDateTime = $ this -> formatDateTime ( time ( ) ) ; } $ this -> name = $ name ; $ this -> beginDateTime = $ beginDateTime ; $ this -> endDateTime = $ endDateTime ; $ this -> fileName = $ fileName ; $ this -> bookmark = $ bookmark ; $ access = $ this -> createAccess ( ) ; $ request = $ this -> createRequest ( ) ; $ this -> response = $ this -> getRequest ( ) -> request ( $ access , $ request , $ this -> compileEndpointUrl ( self :: ENDPOINT ) ) ; $ response = $ this -> response -> getResponse ( ) ; if ( null === $ response ) { throw new Exception ( 'Failure (0): Unknown error' , 0 ) ; } if ( $ response -> Response -> ResponseStatusCode == 0 ) { throw new Exception ( "Failure ({$response->Response->Error->ErrorSeverity}): {$response->Response->Error->ErrorDescription}" , ( int ) $ response -> Response -> Error -> ErrorCode ) ; } else { if ( isset ( $ response -> Bookmark ) ) { $ this -> setBookmark ( ( string ) $ response -> Bookmark ) ; } else { $ this -> setBookmark ( null ) ; } return $ this -> formatResponse ( $ response ) ; } }
7328	private function configureVatNumberSubjectMapping ( LoadClassMetadataEventArgs $ eventArgs ) { $ metadata = $ eventArgs -> getClassMetadata ( ) ; $ class = $ metadata -> getName ( ) ; if ( ! is_subclass_of ( $ class , Pricing \ Model \ VatNumberSubjectInterface :: class ) ) { return ; } if ( in_array ( $ class , $ this -> vatNumberSubjectClassCache ) ) { return ; } $ this -> addMappings ( $ metadata , $ this -> getVatNumberSubjectMappings ( ) ) ; $ this -> vatNumberSubjectClassCache [ ] = $ class ; }
597	public function one ( $ db = null ) { $ row = parent :: one ( $ db ) ; if ( $ row !== false ) { $ models = $ this -> populate ( [ $ row ] ) ; return reset ( $ models ) ? : null ; } return null ; }
6664	public function instantiate ( $ profile , $ provider ) { $ this -> provider = $ provider ; switch ( $ provider ) { case 'facebook' : $ this -> info = $ this -> parseFb ( $ profile ) ; break ; case 'twitter' : $ this -> info = $ this -> parseTwt ( $ profile ) ; break ; } return $ this ; }
3099	public function getItems ( RunnerServiceContext $ serviceContext ) { $ this -> getRunnerService ( ) -> assertQtiRunnerServiceContext ( $ serviceContext ) ; $ runnerService = $ this -> getRunnerService ( ) ; $ testMap = $ runnerService -> getTestMap ( $ serviceContext ) ; $ items = [ ] ; foreach ( $ this -> getItemIdentifiersFromTestMap ( $ testMap ) as $ itemIdentifier ) { $ itemRef = $ runnerService -> getItemHref ( $ serviceContext , $ itemIdentifier ) ; $ items [ $ itemIdentifier ] = [ 'baseUrl' => $ runnerService -> getItemPublicUrl ( $ serviceContext , $ itemRef ) , 'itemData' => $ this -> getItemData ( $ serviceContext , $ itemRef ) , 'itemState' => $ runnerService -> getItemState ( $ serviceContext , $ itemIdentifier ) , 'itemIdentifier' => $ itemIdentifier , 'portableElements' => $ runnerService -> getItemPortableElements ( $ serviceContext , $ itemRef ) , ] ; } return $ items ; }
7068	static function getUnits ( ) { return [ static :: PIECE , static :: METER , static :: CENTIMETER , static :: MILLIMETER , static :: INCH , static :: FOOT , static :: KILOGRAM , static :: GRAM , static :: CUBIC_METER , static :: LITER , static :: MILLILITER , static :: DAY , static :: HOUR , static :: MINUTE , static :: SECOND , ] ; }
2836	public function getLayoutUpdates ( ) { if ( $ this -> uncompressedLayoutUpdates === null ) { $ this -> uncompressedLayoutUpdates = $ this -> layoutUpdates ? json_decode ( gzuncompress ( $ this -> layoutUpdates ) , true ) : array ( ) ; } return $ this -> uncompressedLayoutUpdates ; }
5122	private function setAuthorizationHeader ( string $ accessToken ) : self { $ this -> accessToken = $ accessToken ; $ this -> options -> set ( 'default_headers' , array_merge ( $ this -> options -> get ( 'default_headers' ) , [ 'Authorization' => 'Bearer ' . $ accessToken , ] ) ) ; return $ this ; }
11924	public function onPermalinkChanged ( PermalinkChangedEvent $ event ) { $ previousPermalink = $ event -> getOriginalText ( ) ; $ newPermalink = $ event -> getChangedText ( ) ; $ this -> updatePermalinkOnBlocks ( $ previousPermalink , $ newPermalink ) ; $ this -> updateHomepagePermalink ( $ previousPermalink , $ newPermalink ) ; }
7689	function OpenXML_CTypesPrepareExt ( $ FileOrExt , $ ct = '' ) { $ ext = $ this -> Misc_FileExt ( $ FileOrExt ) ; $ this -> OpenXML_CTypesInit ( ) ; $ lst = & $ this -> OpenXmlCTypes [ 'Extension' ] ; if ( isset ( $ lst [ $ ext ] ) && ( $ lst [ $ ext ] !== '' ) ) return ; if ( ( $ ct === '' ) && isset ( $ this -> ExtInfo [ 'pic_ext' ] [ $ ext ] ) ) $ ct = 'image/' . $ this -> ExtInfo [ 'pic_ext' ] [ $ ext ] ; $ lst [ $ ext ] = $ ct ; }
12133	public function createService ( ServiceLocatorInterface $ serviceLocator ) { $ options = $ serviceLocator -> get ( 'HtSettingsModule\Options\ModuleOptions' ) ; $ settingsService = new SettingsService ( $ options , $ serviceLocator -> get ( 'HtSettingsModule_SettingsMapper' ) , $ serviceLocator -> get ( 'HtSettingsModule\Service\NamespaceHydratorProvider' ) ) ; if ( $ options -> getCacheOptions ( ) -> isEnabled ( ) ) { $ settingsService -> setCacheManager ( $ serviceLocator -> get ( 'HtSettingsModule\Service\CacheManager' ) ) ; } return $ settingsService ; }
10206	public function setReadOrder ( $ pValue ) { if ( $ pValue < 0 || $ pValue > 2 ) { $ pValue = 0 ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'readOrder' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> readOrder = $ pValue ; } return $ this ; }
8	public function fix ( $ packageName , ConstraintInterface $ constraint = null ) { $ this -> addJob ( $ packageName , 'install' , $ constraint , true ) ; }
9231	public function actionIndex ( $ format = false , $ arraymap = false , $ term = false , $ category = false , $ time = false ) { $ searchModel = new PostSearch ( ) ; $ req = Yii :: $ app -> request -> queryParams ; if ( $ term ) { $ req [ basename ( str_replace ( "\\" , "/" , get_class ( $ searchModel ) ) ) ] [ "term" ] = $ term ; } if ( $ category ) { $ req [ basename ( str_replace ( "\\" , "/" , get_class ( $ searchModel ) ) ) ] [ "category" ] = $ category ; } if ( $ time ) { $ req [ basename ( str_replace ( "\\" , "/" , get_class ( $ searchModel ) ) ) ] [ "time" ] = $ time ; } $ dataProvider = $ searchModel -> search ( $ req ) ; $ query = $ dataProvider -> query ; $ query -> andWhere ( [ 'status' => [ 1 ] ] ) ; if ( $ format == 'json' ) { $ model = [ ] ; foreach ( $ dataProvider -> getModels ( ) as $ d ) { $ obj = $ d -> attributes ; if ( $ arraymap ) { $ map = explode ( "," , $ arraymap ) ; if ( count ( $ map ) == 1 ) { $ obj = ( isset ( $ d [ $ arraymap ] ) ? $ d [ $ arraymap ] : null ) ; } else { $ obj = [ ] ; foreach ( $ map as $ a ) { $ k = explode ( ":" , $ a ) ; $ v = ( count ( $ k ) > 1 ? $ k [ 1 ] : $ k [ 0 ] ) ; $ obj [ $ k [ 0 ] ] = ( $ v == "Obj" ? json_encode ( $ d -> attributes ) : ( isset ( $ d -> $ v ) ? $ d -> $ v : null ) ) ; } } } if ( $ term ) { if ( ! in_array ( $ obj , $ model ) ) { array_push ( $ model , $ obj ) ; } } else { array_push ( $ model , $ obj ) ; } } header ( "Access-Control-Allow-Origin: *" ) ; header ( "Access-Control-Expose-Headers: X-Pagination-Per-Page,X-Pagination-Current-Page,X-Pagination-Page-Count,X-Pagination-Total-Count,Content-Type,Location" ) ; return \ yii \ helpers \ Json :: encode ( $ model ) ; } else { return $ this -> render ( 'index' , [ 'searchModel' => $ searchModel , 'dataProvider' => $ dataProvider , ] ) ; } }
7240	private function resolveClassAndCreateObject ( $ type , $ subject ) { foreach ( $ this -> classes [ $ type ] as $ source => $ target ) { if ( $ subject instanceof $ source ) { return new $ target ; } } throw new InvalidArgumentException ( 'Unsupported object class.' ) ; }
12339	private function getColoredMsg ( string $ msg , ? string $ fontColor , ? string $ bgColor ) : string { $ res = '' ; if ( ! is_null ( $ fontColor ) ) { $ res .= "\033[{$fontColor}m" ; } if ( ! is_null ( $ bgColor ) ) { $ res .= "\033[{$bgColor}m" ; } if ( ! is_null ( $ fontColor ) || ! is_null ( $ bgColor ) ) { return "{$res}{$msg}\033[0m" ; } return $ msg ; }
6580	public static function fromPolar ( $ length , $ ap , $ av ) { return new static ( $ length * cos ( $ ap ) * cos ( $ av ) , $ length * sin ( $ ap ) * cos ( $ av ) , $ length * sin ( $ av ) ) ; }
2115	private function getFieldValue ( ? PageModel $ page ) : string { if ( null === $ page ) { return '' ; } return ( string ) $ page -> { $ this -> field } ; }
9727	public function logRead ( $ format , $ path , $ callStartTime ) { $ callEndTime = microtime ( true ) ; $ callTime = $ callEndTime - $ callStartTime ; $ message = "Read {$format} format from <code>{$path}</code> in " . sprintf ( '%.4f' , $ callTime ) . ' seconds' ; $ this -> log ( $ message ) ; }
1330	public function queryToMany ( $ relation , EncodingParametersInterface $ parameters ) { return $ this -> queryAllOrOne ( $ relation -> newQuery ( ) , $ this -> getQueryParameters ( $ parameters ) ) ; }
8316	public function startPasswordResetSession ( $ user ) { $ this -> session -> migrate ( true ) ; $ this -> session -> set ( "pwreset" , array ( 'user' => $ user , 'validity' => time ( ) + $ this -> config [ "resetTimeout" ] ) ) ; }
5815	public function onBeforeWrite ( ) { parent :: onBeforeWrite ( ) ; $ types = $ this -> Types ? explode ( ',' , $ this -> Types ) : array ( ) ; if ( is_string ( $ this -> TagTypes ) ) { $ types = array_merge ( $ types , array_keys ( unserialize ( $ this -> TagTypes ) ) ) ; } if ( ! empty ( $ types ) ) { sort ( $ types ) ; $ formatted = array ( ) ; $ existing = $ this -> service -> getFusionTagTypes ( ) ; foreach ( $ types as $ type ) { if ( isset ( $ existing [ $ type ] ) ) { $ formatted [ $ type ] = $ type ; } } $ this -> TagTypes = ! empty ( $ formatted ) ? serialize ( $ formatted ) : null ; $ this -> Types = implode ( ',' , $ formatted ) ; } }
1695	public function checkStyleSheetName ( $ strName ) { $ objStyleSheet = $ this -> Database -> prepare ( "SELECT COUNT(*) AS count FROM tl_style_sheet WHERE name=?" ) -> limit ( 1 ) -> execute ( $ strName ) ; if ( $ objStyleSheet -> count < 1 ) { return $ strName ; } $ chunks = explode ( '-' , $ strName ) ; $ i = ( \ count ( $ chunks ) > 1 ) ? array_pop ( $ chunks ) : 0 ; $ strName = implode ( '-' , $ chunks ) . '-' . ( ( int ) $ i + 1 ) ; return $ this -> checkStyleSheetName ( $ strName ) ; }
9555	public function getHandler ( ) { if ( $ this -> namer === null ) { $ this -> namer = new GenericNamer ( ) ; } if ( $ this -> filesystem === null ) { throw new \ LogicException ( sprintf ( 'You should set a filesystem for the builder.' ) ) ; } $ handler = new UploadHandler ( $ this -> filesystem , $ this -> namer , $ this -> overwrite ) ; $ validator = $ handler -> getValidator ( ) ; foreach ( $ this -> constraints as $ constraint ) { $ validator -> addConstraint ( $ constraint ) ; } return $ handler ; }
7809	public static function toDebugReport ( ) { $ report = 'PHP SDK (zipMoney) Debug Report:' . PHP_EOL ; $ report .= ' OS: ' . php_uname ( ) . PHP_EOL ; $ report .= ' PHP Version: ' . phpversion ( ) . PHP_EOL ; $ report .= ' OpenAPI Spec Version: 2017-03-01' . PHP_EOL ; $ report .= ' Temp Folder Path: ' . self :: getDefaultConfiguration ( ) -> getTempFolderPath ( ) . PHP_EOL ; return $ report ; }
6446	public function completeLogin ( $ extrainputs = array ( ) ) { $ linkedin = $ this -> getClient ( ) ; $ this -> token = $ linkedin -> getAccessToken ( $ extrainputs [ 'code' ] ) ; return $ this -> getUserProfile ( ) ; }
12424	public function getAuthorizationInfo ( $ authCode = null ) { $ params = [ 'component_appid' => $ this -> getAppId ( ) , 'authorization_code' => $ authCode ? : $ this -> request -> get ( 'auth_code' ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: GET_AUTH_INFO , $ params ] ) ; }
5924	public function setFilterItems ( array $ filterItems ) { $ this -> filterItems = [ ] ; foreach ( $ filterItems as $ item ) { $ this -> addFilterItem ( $ item ) ; } return $ this ; }
8143	public function getLexer ( ) { @ trigger_error ( sprintf ( 'The %s() method is deprecated since version 1.25 and will be removed in 2.0.' , __FUNCTION__ ) , E_USER_DEPRECATED ) ; if ( null === $ this -> lexer ) { $ this -> lexer = new Twig_Lexer ( $ this ) ; } return $ this -> lexer ; }
230	public function getLastInsertID ( $ sequenceName = '' ) { if ( $ this -> db -> isActive ) { return $ this -> db -> pdo -> lastInsertId ( $ sequenceName === '' ? null : $ this -> quoteTableName ( $ sequenceName ) ) ; } throw new InvalidCallException ( 'DB Connection is not active.' ) ; }
9740	public function getPrintArea ( $ index = 0 ) { if ( $ index == 0 ) { return $ this -> printArea ; } $ printAreas = explode ( ',' , $ this -> printArea ) ; if ( isset ( $ printAreas [ $ index - 1 ] ) ) { return $ printAreas [ $ index - 1 ] ; } throw new PhpSpreadsheetException ( 'Requested Print Area does not exist' ) ; }
378	protected function renderException ( $ exception ) { if ( Yii :: $ app -> has ( 'response' ) ) { $ response = Yii :: $ app -> getResponse ( ) ; $ response -> isSent = false ; $ response -> stream = null ; $ response -> data = null ; $ response -> content = null ; } else { $ response = new Response ( ) ; } $ response -> setStatusCodeByException ( $ exception ) ; $ useErrorView = $ response -> format === Response :: FORMAT_HTML && ( ! YII_DEBUG || $ exception instanceof UserException ) ; if ( $ useErrorView && $ this -> errorAction !== null ) { $ result = Yii :: $ app -> runAction ( $ this -> errorAction ) ; if ( $ result instanceof Response ) { $ response = $ result ; } else { $ response -> data = $ result ; } } elseif ( $ response -> format === Response :: FORMAT_HTML ) { if ( $ this -> shouldRenderSimpleHtml ( ) ) { $ response -> data = '<pre>' . $ this -> htmlEncode ( static :: convertExceptionToString ( $ exception ) ) . '</pre>' ; } else { if ( YII_DEBUG ) { ini_set ( 'display_errors' , 1 ) ; } $ file = $ useErrorView ? $ this -> errorView : $ this -> exceptionView ; $ response -> data = $ this -> renderFile ( $ file , [ 'exception' => $ exception , ] ) ; } } elseif ( $ response -> format === Response :: FORMAT_RAW ) { $ response -> data = static :: convertExceptionToString ( $ exception ) ; } else { $ response -> data = $ this -> convertExceptionToArray ( $ exception ) ; } $ response -> send ( ) ; }
12265	public function findInSourceDirs ( Finder $ finder ) { foreach ( $ this -> sourceDirs as $ dir ) { $ finder -> in ( $ dir ) ; } return $ finder ; }
1698	private function loadFrontendUser ( string $ username , BackendUser $ backendUser ) : ? FrontendUser { try { $ frontendUser = $ this -> userProvider -> loadUserByUsername ( $ username ) ; if ( ! $ frontendUser instanceof FrontendUser ) { throw new UsernameNotFoundException ( 'User is not a front end user' ) ; } } catch ( UsernameNotFoundException $ e ) { if ( null !== $ this -> logger ) { $ this -> logger -> info ( sprintf ( 'Could not find a front end user with the username "%s"' , $ username ) , [ 'contao' => new ContaoContext ( __METHOD__ , ContaoContext :: ACCESS , '' ) ] ) ; } return null ; } $ allowedGroups = StringUtil :: deserialize ( $ backendUser -> amg , true ) ; $ frontendGroups = StringUtil :: deserialize ( $ frontendUser -> groups , true ) ; if ( ! $ backendUser -> isAdmin && ! \ count ( array_intersect ( $ frontendGroups , $ allowedGroups ) ) ) { return null ; } return $ frontendUser ; }
8943	public function diffUploadChangeset ( $ xml , $ id ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'changeset/' . $ id . '/upload' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ header [ 'Content-Type' ] = 'text/xml' ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'POST' , $ parameters , $ xml , $ header ) ; $ xmlString = simplexml_load_string ( $ response -> body ) ; return $ xmlString -> diffResult ; }
3725	private function buildPickerService ( ContainerBuilder $ container ) { $ pickerService = $ container -> getDefinition ( 'metamodels.controller.picker' ) ; $ configs = $ pickerService -> getArgument ( 2 ) ; $ configs [ 'PALETTE_STYLE_PICKER' ] [ ] = [ 'cssclass' => 'w50' ] ; $ configs [ 'PALETTE_STYLE_PICKER' ] [ ] = [ 'cssclass' => 'w50x' ] ; $ configs [ 'PALETTE_STYLE_PICKER' ] [ ] = [ 'cssclass' => 'clr' ] ; $ configs [ 'PALETTE_STYLE_PICKER' ] [ ] = [ 'cssclass' => 'clx' ] ; $ configs [ 'PALETTE_STYLE_PICKER' ] [ ] = [ 'cssclass' => 'long' ] ; $ configs [ 'PALETTE_STYLE_PICKER' ] [ ] = [ 'cssclass' => 'wizard' ] ; $ configs [ 'PALETTE_STYLE_PICKER' ] [ ] = [ 'cssclass' => 'm12' ] ; $ configs [ 'PALETTE_PANEL_PICKER' ] [ ] = [ 'cssclass' => 'search' ] ; $ configs [ 'PALETTE_PANEL_PICKER' ] [ ] = [ 'cssclass' => 'sort' ] ; $ configs [ 'PALETTE_PANEL_PICKER' ] [ ] = [ 'cssclass' => 'filter' ] ; $ configs [ 'PALETTE_PANEL_PICKER' ] [ ] = [ 'cssclass' => 'limit' ] ; $ pickerService -> setArgument ( 2 , $ configs ) ; }
3012	public function unfollow ( $ blogName ) { $ options = array ( 'url' => $ this -> blogUrl ( $ blogName ) ) ; return $ this -> postRequest ( 'v2/user/unfollow' , $ options , false ) ; }
10425	private function headers ( ResponseInterface $ response ) : void { if ( ! headers_sent ( ) ) { foreach ( $ response -> getHeaders ( ) as $ name => $ values ) { $ cookie = stripos ( $ name , 'Set-Cookie' ) === 0 ? false : true ; foreach ( $ values as $ value ) { header ( sprintf ( '%s: %s' , $ name , $ value ) , $ cookie ) ; $ cookie = false ; } } header ( sprintf ( 'HTTP/%s %s %s' , $ response -> getProtocolVersion ( ) , $ response -> getStatusCode ( ) , $ response -> getReasonPhrase ( ) ) , true , $ response -> getStatusCode ( ) ) ; } }
10895	public function addCollection ( UriCollection $ collection ) { foreach ( $ collection -> all ( ) as $ name => $ uri ) { unset ( $ this -> uris [ $ name ] ) ; $ this -> uris [ $ name ] = $ uri ; } $ this -> resources = array_merge ( $ this -> resources , $ collection -> getResources ( ) ) ; }
10762	public function setAlternativeAccount ( $ iban1 , $ swift1 = null , $ iban2 = null , $ swift2 = null ) { if ( $ swift1 !== null ) { $ iban1 .= '+' . $ swift1 ; } if ( $ iban2 !== null ) { if ( $ swift2 !== null ) { $ iban2 .= '+' . $ swift2 ; } $ iban1 .= ',' . $ iban2 ; } return $ this -> add ( 'ALT-ACC' , $ iban1 ) ; }
4668	public function generate ( ) { $ this -> beforeGeneration ( ) ; $ this -> config -> getLogger ( ) -> startBreak ( 'Class Generation' ) ; foreach ( $ this -> XSDMap as $ fhirElementName => $ mapEntry ) { $ this -> config -> getLogger ( ) -> debug ( "Generating class for element {$fhirElementName}..." ) ; $ classTemplate = ClassGenerator :: buildFHIRElementClassTemplate ( $ this -> config , $ this -> XSDMap , $ mapEntry ) ; FileUtils :: createDirsFromNS ( $ classTemplate -> getNamespace ( ) , $ this -> config ) ; MethodGenerator :: implementConstructor ( $ this -> config , $ classTemplate ) ; $ classTemplate -> writeToFile ( $ this -> config -> getOutputPath ( ) ) ; $ this -> mapTemplate -> addEntry ( $ classTemplate ) ; $ this -> autoloadMap -> addPHPFHIRClassEntry ( $ classTemplate ) ; $ this -> config -> getLogger ( ) -> debug ( "{$fhirElementName} completed." ) ; } $ this -> config -> getLogger ( ) -> endBreak ( 'Class Generation' ) ; $ this -> afterGeneration ( ) ; }
5520	protected function checkExpectations ( $ method , $ args , $ timing ) { $ test = $ this -> getCurrentTestCase ( ) ; if ( isset ( $ this -> max_counts [ $ method ] ) ) { if ( ! $ this -> max_counts [ $ method ] -> test ( $ timing + 1 ) ) { $ test -> assert ( $ this -> max_counts [ $ method ] , $ timing + 1 ) ; } } if ( isset ( $ this -> expected_args_at [ $ timing ] [ $ method ] ) ) { $ test -> assert ( $ this -> expected_args_at [ $ timing ] [ $ method ] , $ args , "Mock method [$method] at [$timing] -> %s" ) ; } elseif ( isset ( $ this -> expected_args [ $ method ] ) ) { $ test -> assert ( $ this -> expected_args [ $ method ] , $ args , "Mock method [$method] -> %s" ) ; } }
4199	public function addConstants ( Event $ abs ) { if ( ! $ this -> abstracter -> getCfg ( 'collectConstants' ) ) { return ; } $ reflector = $ abs [ 'reflector' ] ; $ constants = $ reflector -> getConstants ( ) ; while ( $ reflector = $ reflector -> getParentClass ( ) ) { $ constants = \ array_merge ( $ reflector -> getConstants ( ) , $ constants ) ; } if ( $ this -> abstracter -> getCfg ( 'objectSort' ) == 'name' ) { \ ksort ( $ constants ) ; } $ abs [ 'constants' ] = $ constants ; }
11365	public static function listAddresses ( $ list = array ( ) , $ type = 'to' ) { if ( empty ( $ list ) ) { return ; } $ str = ucfirst ( strtolower ( $ type ) ) . ': ' . self :: mailListTagger ( $ list ) ; return ( trim ( $ str , Mailer :: $ ADDERSSES_SEPARATOR ) . Mailer :: $ LINE_ENDING ) ; }
3021	public function getBlogAvatar ( $ blogName , $ size = null ) { $ path = $ this -> blogPath ( $ blogName , '/avatar' ) ; if ( $ size ) { $ path .= "/$size" ; } return $ this -> getRedirect ( $ path , null , true ) ; }
1819	public function extractYouTubeId ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ dc -> activeRecord -> youtube != $ varValue ) { $ matches = array ( ) ; if ( preg_match ( '%(?:youtube(?:-nocookie)?\.com/(?:[^/]+/.+/|(?:v|e(?:mbed)?)/|.*[?&]v=)|youtu\.be/)([^"&?/ ]{11})%i' , $ varValue , $ matches ) ) { $ varValue = $ matches [ 1 ] ; } } return $ varValue ; }
3378	private function showLink ( $ link ) { if ( ! $ link [ 'show_menu' ] ) return false ; $ user = \ Auth :: guard ( 'panel' ) -> user ( ) ; return $ user -> hasRole ( 'super' ) || $ user -> hasPermission ( '/' . $ link [ 'url' ] . '/all' ) ; }
11186	public function setPrivateChatUpdateRead ( Neuron_GameServer_Player $ from , Neuron_GameServer_Player $ target ) { $ db = Neuron_DB_Database :: getInstance ( ) ; $ db -> query ( " UPDATE n_privatechat_updates SET pu_read = '1' WHERE pu_to = {$target->getId ()} AND pu_from = {$from->getId ()} " ) ; }
5799	public function selectArrayWithRolesString ( string $ columns = "*" , array $ whereColumnsInfo = null ) : array { $ administrators = [ ] ; $ results = $ this -> selectArray ( $ columns , $ whereColumnsInfo ) ; foreach ( $ results as $ index => $ administrator ) { $ administrators [ $ index ] = $ administrator ; $ administrators [ $ index ] [ 'roles' ] = implode ( ", " , $ administrators [ $ index ] [ 'roles' ] ) ; } return $ administrators ; }
10448	private function callIfExistsAndEnabled ( $ method , array $ parameters = [ ] ) { if ( ! $ this -> isEnabled ( ) ) return ; if ( method_exists ( $ this , $ method ) && $ this -> { "{$method}IsEnabled" } ( ) ) { $ this -> container -> call ( [ $ this , $ method ] , $ parameters ) ; } }
1504	protected function bindApi ( string $ namespace , string $ host ) : Api { $ repository = $ this -> container -> make ( Repository :: class ) ; $ api = $ repository -> createApi ( $ namespace , $ host ) ; $ this -> container -> instance ( Api :: class , $ api ) ; $ this -> container -> alias ( Api :: class , 'json-api.inbound' ) ; return $ api ; }
9872	private function writeSheetData ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet , array $ pStringTable ) { $ aFlippedStringTable = $ this -> getParentWriter ( ) -> getWriterPart ( 'stringtable' ) -> flipStringTable ( $ pStringTable ) ; $ objWriter -> startElement ( 'sheetData' ) ; $ colCount = Coordinate :: columnIndexFromString ( $ pSheet -> getHighestColumn ( ) ) ; $ highestRow = $ pSheet -> getHighestRow ( ) ; $ cellsByRow = [ ] ; foreach ( $ pSheet -> getCoordinates ( ) as $ coordinate ) { $ cellAddress = Coordinate :: coordinateFromString ( $ coordinate ) ; $ cellsByRow [ $ cellAddress [ 1 ] ] [ ] = $ coordinate ; } $ currentRow = 0 ; while ( $ currentRow ++ < $ highestRow ) { $ rowDimension = $ pSheet -> getRowDimension ( $ currentRow ) ; $ writeCurrentRow = isset ( $ cellsByRow [ $ currentRow ] ) || $ rowDimension -> getRowHeight ( ) >= 0 || $ rowDimension -> getVisible ( ) == false || $ rowDimension -> getCollapsed ( ) == true || $ rowDimension -> getOutlineLevel ( ) > 0 || $ rowDimension -> getXfIndex ( ) !== null ; if ( $ writeCurrentRow ) { $ objWriter -> startElement ( 'row' ) ; $ objWriter -> writeAttribute ( 'r' , $ currentRow ) ; $ objWriter -> writeAttribute ( 'spans' , '1:' . $ colCount ) ; if ( $ rowDimension -> getRowHeight ( ) >= 0 ) { $ objWriter -> writeAttribute ( 'customHeight' , '1' ) ; $ objWriter -> writeAttribute ( 'ht' , StringHelper :: formatNumber ( $ rowDimension -> getRowHeight ( ) ) ) ; } if ( $ rowDimension -> getVisible ( ) == false ) { $ objWriter -> writeAttribute ( 'hidden' , 'true' ) ; } if ( $ rowDimension -> getCollapsed ( ) == true ) { $ objWriter -> writeAttribute ( 'collapsed' , 'true' ) ; } if ( $ rowDimension -> getOutlineLevel ( ) > 0 ) { $ objWriter -> writeAttribute ( 'outlineLevel' , $ rowDimension -> getOutlineLevel ( ) ) ; } if ( $ rowDimension -> getXfIndex ( ) !== null ) { $ objWriter -> writeAttribute ( 's' , $ rowDimension -> getXfIndex ( ) ) ; $ objWriter -> writeAttribute ( 'customFormat' , '1' ) ; } if ( isset ( $ cellsByRow [ $ currentRow ] ) ) { foreach ( $ cellsByRow [ $ currentRow ] as $ cellAddress ) { $ this -> writeCell ( $ objWriter , $ pSheet , $ cellAddress , $ aFlippedStringTable ) ; } } $ objWriter -> endElement ( ) ; } } $ objWriter -> endElement ( ) ; }
68	public function junction ( $ target , $ junction ) { if ( ! Platform :: isWindows ( ) ) { throw new \ LogicException ( sprintf ( 'Function %s is not available on non-Windows platform' , __CLASS__ ) ) ; } if ( ! is_dir ( $ target ) ) { throw new IOException ( sprintf ( 'Cannot junction to "%s" as it is not a directory.' , $ target ) , 0 , null , $ target ) ; } $ cmd = sprintf ( 'mklink /J %s %s' , ProcessExecutor :: escape ( str_replace ( '/' , DIRECTORY_SEPARATOR , $ junction ) ) , ProcessExecutor :: escape ( realpath ( $ target ) ) ) ; if ( $ this -> getProcess ( ) -> execute ( $ cmd , $ output ) !== 0 ) { throw new IOException ( sprintf ( 'Failed to create junction to "%s" at "%s".' , $ target , $ junction ) , 0 , null , $ target ) ; } clearstatcache ( true , $ junction ) ; }
9339	public function get ( $ key , $ default = null ) { $ keys = array_filter ( explode ( '.' , $ key ) ) ; $ length = count ( $ keys ) ; $ data = $ this -> data ; for ( $ i = 0 ; $ i < $ length ; $ i ++ ) { $ index = $ keys [ $ i ] ; $ data = & $ data [ $ index ] ; } return $ data !== null ? $ data : $ default ; }
11115	public function reset ( ) : void { $ migrations = array_reverse ( $ this -> repository -> getRan ( ) ) ; if ( count ( $ migrations ) === 0 ) { $ this -> notify -> note ( '<info>Nothing to rollback.</info>' ) ; return ; } $ this -> rollbackMigrations ( $ migrations ) ; }
164	public static function create ( $ from ) { return new self ( [ 'where' => $ from -> where , 'limit' => $ from -> limit , 'offset' => $ from -> offset , 'orderBy' => $ from -> orderBy , 'indexBy' => $ from -> indexBy , 'select' => $ from -> select , 'selectOption' => $ from -> selectOption , 'distinct' => $ from -> distinct , 'from' => $ from -> from , 'groupBy' => $ from -> groupBy , 'join' => $ from -> join , 'having' => $ from -> having , 'union' => $ from -> union , 'params' => $ from -> params , ] ) ; }
7959	public function getPairsNumber ( $ forceReload = false ) { if ( ! $ this -> properties || $ forceReload ) $ this -> getProperties ( ) ; return $ this -> properties -> pairsNumber ; }
5743	protected function parseContentType ( $ contentType ) { if ( false === stripos ( $ contentType , ';' ) ) { throw new ParserException ( 'ContentType does not contain a \';\'' ) ; } list ( $ mime , $ boundary ) = explode ( ';' , $ contentType , 2 ) ; list ( $ key , $ boundaryValue ) = explode ( '=' , trim ( $ boundary ) , 2 ) ; if ( 'boundary' != $ key ) { throw new ParserException ( 'Boundary does not start with \'boundary=\'' ) ; } return [ strtolower ( trim ( $ mime ) ) , $ boundaryValue ] ; }
8801	public function set ( $ key , $ value ) { if ( is_array ( $ key ) ) { foreach ( $ key as $ k => $ v ) { $ _SESSION [ $ k ] = $ v ; } } else { $ _SESSION [ $ key ] = $ value ; } return ; }
2908	public function decodeSubject ( $ subject ) { if ( $ this -> hasQueue ( ) && $ queue = $ this -> getQueue ( ) ) { return $ queue -> getMessageParameters ( 'subject' ) ; } return base64_decode ( substr ( $ subject , strlen ( '=?utf-8?B?' ) , - 1 * strlen ( '?=' ) ) ) ; }
12700	public function createServiceWithName ( ServiceLocatorInterface $ serviceLocator , $ name , $ requestedName ) { $ config = $ serviceLocator -> get ( 'config' ) ; if ( isset ( $ config [ 'rznviewcomponent' ] [ 'cache_adapter' ] ) ) { $ config = $ config [ 'rznviewcomponent' ] [ 'cache_adapter' ] ; } else $ config = array ( 'name' => 'filesystem' , 'options' => array ( 'ttl' => 3600 , 'dirLevel' => 2 , 'file_locking' => false , 'cacheDir' => 'data/cache' , 'dirPermission' => 0755 , 'filePermission' => 0666 , ) , ) ; return \ Zend \ Cache \ StorageFactory :: factory ( array ( 'adapter' => $ config , 'plugins' => array ( 'serializer' ) , ) ) ; }
3604	public function handleJsonRequest ( $ jsonRequest ) { if ( \ is_array ( $ jsonRequest ) ) { $ jsonResponse = [ ] ; foreach ( $ jsonRequest as $ request ) { $ jsonResponse [ ] = $ this -> handleJsonRequest ( $ request ) ; } return $ jsonResponse ; } if ( $ this -> stopwatch ) { $ this -> stopwatch -> start ( 'rpc.execute' ) ; } try { $ this -> dispatch ( Event \ JsonRequestEvent :: EVENT , new Event \ JsonRequestEvent ( $ jsonRequest ) ) ; $ metadata = $ this -> getMethod ( $ jsonRequest ) ; $ isCache = $ this -> isCacheSupport ( $ jsonRequest ) ; $ cacheId = $ jsonRequest -> getHash ( ) ; $ jsonResponse = new JsonResponse ( $ jsonRequest ) ; if ( true === $ isCache && true === $ this -> getCache ( ) -> contains ( $ cacheId ) ) { $ jsonResponse -> setResult ( $ this -> getCache ( ) -> fetch ( $ cacheId ) ) ; $ isCache = false ; } $ result = $ jsonResponse -> getResult ( ) ; if ( null === $ result ) { $ result = $ this -> executeJsonRequest ( $ metadata , $ jsonRequest ) ; } if ( $ result instanceof JsonResponse ) { $ jsonResponse = $ result ; $ jsonResponse -> setRequest ( $ jsonRequest ) ; } else { $ jsonResponse -> setResult ( $ this -> serialize ( $ result ) ) ; } $ isCache && $ this -> cache -> save ( $ cacheId , $ jsonResponse -> getResult ( ) , $ metadata -> getCache ( ) ) ; $ this -> dispatch ( Event \ JsonResponseEvent :: EVENT , new Event \ JsonResponseEvent ( $ jsonResponse ) ) ; } catch ( \ Exception $ exception ) { $ jsonResponse = $ this -> createJsonResponseFromException ( $ exception , $ jsonRequest ) ; } if ( $ this -> stopwatch ) { $ this -> stopwatch -> stop ( 'rpc.execute' ) ; } return $ jsonResponse ; }
7368	protected function checkShipmentIntegrity ( SaleItemInterface $ item , SaleItem $ constraint ) { $ sale = $ item -> getSale ( ) ; if ( ! $ sale instanceof Shipment \ ShipmentSubjectInterface ) { return ; } if ( empty ( $ sale -> getShipments ( ) -> toArray ( ) ) ) { return ; } $ min = $ this -> shipmentCalculator -> calculateShippedQuantity ( $ item ) ; if ( 1 === bccomp ( $ min , 0 , 3 ) && 1 === bccomp ( $ min , $ item -> getTotalQuantity ( ) , 3 ) ) { $ this -> context -> buildViolation ( $ constraint -> quantity_is_lower_than_shipped , [ '%min%' => $ min , ] ) -> setInvalidValue ( $ item -> getQuantity ( ) ) -> atPath ( 'quantity' ) -> addViolation ( ) ; throw new ValidationFailedException ( ) ; } }
6952	private function isSaleItemCovered ( Common \ SaleItemInterface $ saleItem , array $ coveredIds ) { if ( $ saleItem -> isCompound ( ) && ! $ saleItem -> hasPrivateChildren ( ) ) { return true ; } if ( ! in_array ( $ saleItem -> getId ( ) , $ coveredIds , true ) ) { return false ; } foreach ( $ saleItem -> getChildren ( ) as $ child ) { if ( ! $ this -> isSaleItemCovered ( $ child , $ coveredIds ) ) { return false ; } } return true ; }
3629	protected static function secureTouch ( $ fname ) { if ( file_exists ( $ fname ) ) { return ; } $ temp = tempnam ( sys_get_temp_dir ( ) , 'NEST' ) ; rename ( $ temp , $ fname ) ; }
8434	private function write ( array $ mapping , string $ mappingName , string $ name , array $ up = [ ] , array $ down = [ ] , array $ import = [ ] ) { $ path = rtrim ( $ mapping [ 'config' ] [ 'migrations' ] [ 'path' ] , DIRECTORY_SEPARATOR ) . DIRECTORY_SEPARATOR ; $ path .= $ name . DIRECTORY_SEPARATOR ; if ( file_exists ( $ path . $ name . '.php' ) === true ) { echo 'A migration with this name already exists. Do you want to overwrite it ? [y/n] : ' ; if ( fgetc ( STDIN ) != 'y' ) { return false ; } } if ( is_dir ( $ path ) === false ) { if ( mkdir ( $ path ) === false ) { throw new FileNotWritable ( 'can\'t mkdir "' . $ path . '"' ) ; } } $ path .= $ name . '.php' ; $ file = fopen ( $ path , 'w+' ) ; if ( $ file === false ) { throw new FileNotWritable ( 'can\'t open "' . $ path . '" with write permission' ) ; } $ content = "<?php\n\nnamespace " . ltrim ( rtrim ( $ mapping [ 'config' ] [ 'migrations' ] [ 'namespace' ] , '\\' ) , '\\' ) . '\\' . $ name . ";\n\nuse " . ltrim ( rtrim ( $ mapping [ 'config' ] [ 'provider' ] , '\\' ) , '\\' ) . '\\Migration;' . PHP_EOL ; if ( count ( $ import ) >= 1 ) { $ content .= 'use ' . ltrim ( rtrim ( $ mapping [ 'config' ] [ 'provider' ] , '\\' ) , '\\' ) . '\\Mutation\\{' ; $ content .= implode ( ', ' , $ import ) . "};\n" ; } $ up = implode ( '' , array_map ( function ( string $ a ) { return ' ' . $ a . '->execute();' . PHP_EOL ; } , $ up ) ) ; $ down = implode ( '' , array_map ( function ( string $ a ) { return ' ' . $ a . '->execute();' . PHP_EOL ; } , $ down ) ) ; var_dump ( $ up ) ; $ content .= "\nclass " . $ name . " extends Migration\n{\n" ; $ content .= ' const NAME = \'' . $ name . "';\n\n" ; $ content .= " public function getMappingName() : string\n {\n return '" . $ mappingName . "';\n }\n\n" ; $ content .= " public function up()\n {\n" . $ up . " }\n\n" ; $ content .= " public function down()\n {\n" . $ down . " }\n" ; $ content .= "}" ; if ( fwrite ( $ file , $ content ) === false ) { throw new FileNotWritable ( 'can\'t write in "' . $ path . '"' ) ; } fclose ( $ file ) ; return true ; }
12067	public function fetchProjects ( ) { $ response = $ this -> getResponse ( 'get' , 'v2/projects' ) ; $ projects = array ( ) ; if ( is_array ( $ response ) ) { foreach ( $ response as $ data ) { $ projects [ ] = $ this -> hydrator -> hydrate ( new Project ( ) , $ data ) ; } } return $ projects ; }
2921	public function save ( $ filePath ) { $ this -> ensureFileIsWritable ( $ filePath ) ; file_put_contents ( $ filePath , $ this -> buffer ) ; return $ this ; }
9386	public function retrieve ( $ httpMethod , $ uri ) { $ route = array ( $ httpMethod , $ uri ) ; $ routes = array_map ( function ( $ route ) { return array ( $ route [ 0 ] , $ route [ 1 ] ) ; } , $ this -> routes ) ; $ key = array_search ( $ route , $ routes ) ; return $ key !== false ? $ this -> routes [ $ key ] : null ; }
1784	protected function fetchItems ( $ newsArchives , $ blnFeatured , $ limit , $ offset ) { if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'newsListFetchItems' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'newsListFetchItems' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'newsListFetchItems' ] as $ callback ) { if ( ( $ objCollection = System :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ newsArchives , $ blnFeatured , $ limit , $ offset , $ this ) ) === false ) { continue ; } if ( $ objCollection === null || $ objCollection instanceof Collection ) { return $ objCollection ; } } } $ t = NewsModel :: getTable ( ) ; $ arrOptions = array ( ) ; switch ( $ this -> news_order ) { case 'order_headline_asc' : $ arrOptions [ 'order' ] = "$t.headline" ; break ; case 'order_headline_desc' : $ arrOptions [ 'order' ] = "$t.headline DESC" ; break ; case 'order_random' : $ arrOptions [ 'order' ] = "RAND()" ; break ; case 'order_date_asc' : $ arrOptions [ 'order' ] = "$t.date" ; break ; default : $ arrOptions [ 'order' ] = "$t.date DESC" ; } return NewsModel :: findPublishedByPids ( $ newsArchives , $ blnFeatured , $ limit , $ offset , $ arrOptions ) ; }
12682	private function registerProfilerConfiguration ( array $ config , XmlFileLoader $ loader ) { if ( $ config [ 'enabled' ] && $ config [ 'collect' ] && class_exists ( 'Symfony\Component\Debug\Debug' ) ) { $ loader -> load ( 'block_debug.xml' ) ; $ loader -> load ( 'collectors.xml' ) ; } }
2272	public static function quoteIdentifier ( $ strName ) { static $ strQuoteCharacter = null ; if ( $ strQuoteCharacter === null ) { $ strQuoteCharacter = System :: getContainer ( ) -> get ( 'database_connection' ) -> getDatabasePlatform ( ) -> getIdentifierQuoteCharacter ( ) ; } if ( strncmp ( $ strName , $ strQuoteCharacter , 1 ) === 0 ) { return $ strName ; } if ( ! preg_match ( '/^[A-Za-z0-9_$.]+$/' , $ strName ) ) { return $ strName ; } return System :: getContainer ( ) -> get ( 'database_connection' ) -> quoteIdentifier ( $ strName ) ; }
6640	private function getContainerRoute ( array $ routes , $ name ) { foreach ( $ routes as $ route => $ names ) { if ( in_array ( $ name , $ names , false ) ) { return $ route ; } } throw new Exception ( "Unknown configuration class name '{$name}'" ) ; }
1485	public function prepend ( Decoding ... $ decodings ) : self { $ copy = clone $ this ; array_unshift ( $ copy -> stack , ... $ decodings ) ; return $ copy ; }
2466	protected function welcomeScreen ( ) { System :: loadLanguageFile ( 'explain' ) ; $ objTemplate = new BackendTemplate ( 'be_welcome' ) ; $ objTemplate -> messages = Message :: generateUnwrapped ( ) . Backend :: getSystemMessages ( ) ; $ objTemplate -> loginMsg = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'firstLogin' ] ; if ( $ this -> User -> lastLogin > 0 ) { $ formatter = new DateTimeFormatter ( System :: getContainer ( ) -> get ( 'translator' ) ) ; $ diff = $ formatter -> formatDiff ( new \ DateTime ( date ( 'Y-m-d H:i:s' , $ this -> User -> lastLogin ) ) , new \ DateTime ( ) ) ; $ objTemplate -> loginMsg = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'lastLogin' ] [ 1 ] , '<time title="' . Date :: parse ( Config :: get ( 'datimFormat' ) , $ this -> User -> lastLogin ) . '">' . $ diff . '</time>' ) ; } Versions :: addToTemplate ( $ objTemplate ) ; $ objTemplate -> showDifferences = StringUtil :: specialchars ( str_replace ( "'" , "\\'" , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'showDifferences' ] ) ) ; $ objTemplate -> recordOfTable = StringUtil :: specialchars ( str_replace ( "'" , "\\'" , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'recordOfTable' ] ) ) ; $ objTemplate -> systemMessages = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'systemMessages' ] ; $ objTemplate -> shortcuts = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'shortcuts' ] [ 0 ] ; $ objTemplate -> shortcutsLink = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'shortcuts' ] [ 1 ] ; $ objTemplate -> editElement = StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'editElement' ] ) ; return $ objTemplate -> parse ( ) ; }
12208	public function getSingleWidget ( ) { if ( is_null ( $ this -> _singleWidget ) ) { $ this -> _singleWidget = false ; $ widgets = $ this -> collectorItem -> getAll ( ) ; if ( ! empty ( $ widgets ) ) { $ widget = array_shift ( $ widgets ) ; $ this -> _singleWidget = Yii :: $ app -> collectors [ 'widgets' ] -> build ( $ this , $ widget -> object ) ; } } return $ this -> _singleWidget ; }
11748	public function page ( ) { if ( is_null ( $ this -> page ) ) { $ this -> page = new Page ( $ this -> accessToken ) ; } return $ this -> page ; }
12767	public function set ( string $ key , $ value ) : self { $ this -> store [ $ key ] = $ value ; return self :: $ instance ; }
7279	public function file ( $ name = null ) { return ! $ name ? $ this -> files : ( $ this -> files [ $ name ] ?? null ) ; }
11735	private function updateOv ( $ dwnl ) { $ entity = new EBonDwnl ( ) ; foreach ( $ dwnl as $ one ) { $ ov = $ one -> getOv ( ) ; $ calcId = $ one -> getCalculationRef ( ) ; $ custId = $ one -> getCustomerRef ( ) ; $ entity -> setOv ( $ ov ) ; $ id = [ EBonDwnl :: A_CALC_REF => $ calcId , EBonDwnl :: A_CUST_REF => $ custId ] ; $ this -> daoBonDwnl -> updateById ( $ id , $ entity ) ; } }
6206	public function onShutdown ( ) { if ( self :: $ instance == null ) { return ; } self :: $ instance = null ; if ( ! $ error = error_get_last ( ) ) { return ; } if ( ! $ this -> shouldNotifyError ( $ error [ 'type' ] , $ error [ 'message' ] , $ error [ 'file' ] , $ error [ 'line' ] ) ) { return ; } $ backtrace = array ( array ( 'file' => $ error [ 'file' ] , 'line' => $ error [ 'line' ] , 'function' => '' , 'args' => array ( ) , ) ) ; $ this -> airbrakeClient -> notifyOnError ( '[Improper Shutdown] ' . $ error [ 'message' ] , $ backtrace ) ; }
7784	public function addParser ( $ name , $ class , $ before = null ) { if ( $ before === null ) { $ this -> parsers [ $ name ] = $ class ; return $ this ; } if ( ( $ offset = array_search ( $ before , array_keys ( $ this -> parsers ) ) ) !== false ) { $ this -> parsers = array_slice ( $ this -> parsers , 0 , $ offset , true ) + array ( $ name => $ class ) + array_slice ( $ this -> parsers , $ offset , null , true ) ; return $ this ; } throw new \ RuntimeException ( sprintf ( 'Parser "%s" does not exist.' , $ before ) ) ; }
617	private function parseArray ( $ value , & $ i = 0 ) { $ result = [ ] ; $ len = strlen ( $ value ) ; for ( ++ $ i ; $ i < $ len ; ++ $ i ) { switch ( $ value [ $ i ] ) { case '{' : $ result [ ] = $ this -> parseArray ( $ value , $ i ) ; break ; case '}' : break 2 ; case $ this -> delimiter : if ( empty ( $ result ) ) { $ result [ ] = null ; } if ( in_array ( $ value [ $ i + 1 ] , [ $ this -> delimiter , '}' ] , true ) ) { $ result [ ] = null ; } break ; default : $ result [ ] = $ this -> parseString ( $ value , $ i ) ; } } return $ result ; }
9188	public function connect ( ) { if ( ! is_resource ( $ this -> handle ) ) { throw new SocketException ( "Socket is not available" ) ; } if ( ! @ socket_connect ( $ this -> handle , $ this -> endpoint -> getAddress ( ) , $ this -> endpoint -> getPort ( ) ) ) { $ code = socket_last_error ( $ this -> handle ) ; throw new SocketException ( socket_strerror ( $ code ) , array ( ) , $ code ) ; } $ this -> conntected = true ; }
2725	private function canPurgeObject ( \ Magento \ Framework \ DataObject \ IdentityInterface $ object ) { if ( $ object instanceof \ Magento \ Catalog \ Model \ Category && ! $ this -> config -> canPurgeCatalogCategory ( ) ) { return false ; } if ( $ object instanceof \ Magento \ Catalog \ Model \ Product && ! $ this -> config -> canPurgeCatalogProduct ( ) ) { return false ; } if ( $ object instanceof \ Magento \ Cms \ Model \ Page && ! $ this -> config -> canPurgeCmsPage ( ) ) { return false ; } return true ; }
8509	public function getPrepInstructionsForSKU ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_GetPrepInstructionsForSKURequest ) ) { $ request = new FBAInboundServiceMWS_Model_GetPrepInstructionsForSKURequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetPrepInstructionsForSKU' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_GetPrepInstructionsForSKUResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
9972	public function setCodeName ( $ pValue , $ validate = true ) { if ( $ this -> getCodeName ( ) == $ pValue ) { return $ this ; } if ( $ validate ) { $ pValue = str_replace ( ' ' , '_' , $ pValue ) ; self :: checkSheetCodeName ( $ pValue ) ; if ( $ this -> getParent ( ) ) { if ( $ this -> getParent ( ) -> sheetCodeNameExists ( $ pValue ) ) { if ( Shared \ StringHelper :: countCharacters ( $ pValue ) > 29 ) { $ pValue = Shared \ StringHelper :: substring ( $ pValue , 0 , 29 ) ; } $ i = 1 ; while ( $ this -> getParent ( ) -> sheetCodeNameExists ( $ pValue . '_' . $ i ) ) { ++ $ i ; if ( $ i == 10 ) { if ( Shared \ StringHelper :: countCharacters ( $ pValue ) > 28 ) { $ pValue = Shared \ StringHelper :: substring ( $ pValue , 0 , 28 ) ; } } elseif ( $ i == 100 ) { if ( Shared \ StringHelper :: countCharacters ( $ pValue ) > 27 ) { $ pValue = Shared \ StringHelper :: substring ( $ pValue , 0 , 27 ) ; } } } $ pValue = $ pValue . '_' . $ i ; } } } $ this -> codeName = $ pValue ; return $ this ; }
10009	public function createSheet ( $ sheetIndex = null ) { $ newSheet = new Worksheet ( $ this ) ; $ this -> addSheet ( $ newSheet , $ sheetIndex ) ; return $ newSheet ; }
3781	private function determineFilterValue ( $ filterValues , $ valueName ) { if ( ! isset ( $ filterValues [ $ valueName ] ) && $ this -> get ( 'defaultid' ) ) { return $ this -> get ( 'defaultid' ) ; } return $ filterValues [ $ valueName ] ; }
10934	protected function is_php ( $ version ) { static $ _is_php ; $ version = ( string ) $ version ; if ( ! isset ( $ _is_php [ $ version ] ) ) { $ _is_php [ $ version ] = version_compare ( PHP_VERSION , $ version , '>=' ) ; } return $ _is_php [ $ version ] ; }
4801	public function injectSpecialBindings ( string $ sql , array $ bindings ) : string { foreach ( self :: SPECIAL_BINDINGS as $ special ) { $ specialPlaceholder = ":" . $ special ; if ( ! array_key_exists ( $ special , $ bindings ) ) { continue ; } $ replacement = $ this -> escapeSpecialBinding ( $ bindings [ $ special ] , $ special ) ; $ sql = str_replace ( $ specialPlaceholder , $ replacement , $ sql ) ; unset ( $ bindings [ $ special ] ) ; } foreach ( $ bindings as $ key => $ value ) { if ( is_array ( $ value ) ) { $ inString = "" ; foreach ( $ value as $ i => $ innerValue ) { $ newKey = $ key . "__" . $ i ; $ keyParamString = ":$newKey" ; $ inString .= "$keyParamString, " ; } $ inString = rtrim ( $ inString , " ," ) ; $ sql = str_replace ( ":$key" , $ inString , $ sql ) ; } } return $ sql ; }
6361	public function toDateInterval ( float $ duration ) : DateInterval { Preconditions :: checkState ( $ this -> dateIntervalFormat !== null , '[%s] does not support toDateInterval()' , $ this ) ; return new DateInterval ( sprintf ( $ this -> dateIntervalFormat , $ duration ) ) ; }
7058	protected function getStockAdjustmentFromEvent ( ResourceEventInterface $ event ) { $ stockAdjustment = $ event -> getResource ( ) ; if ( ! $ stockAdjustment instanceof StockAdjustmentInterface ) { throw new InvalidArgumentException ( "Expected instance of " . StockAdjustmentInterface :: class ) ; } return $ stockAdjustment ; }
5451	public function parse ( $ response ) { $ this -> tags = array ( ) ; $ this -> page = $ this -> createPage ( $ response ) ; $ parser = $ this -> createParser ( $ this ) ; $ parser -> parse ( $ response -> getContent ( ) ) ; $ this -> acceptPageEnd ( ) ; $ page = $ this -> page ; $ this -> free ( ) ; return $ page ; }
7371	public function editAction ( ) { $ user = $ this -> getUser ( ) ; $ form = $ this -> createForm ( ProfileType :: class , $ user ) ; return array ( 'form' => $ form -> createView ( ) , ) ; }
545	protected function rotateFiles ( ) { $ file = $ this -> logFile ; for ( $ i = $ this -> maxLogFiles ; $ i >= 0 ; -- $ i ) { $ rotateFile = $ file . ( $ i === 0 ? '' : '.' . $ i ) ; if ( is_file ( $ rotateFile ) ) { if ( $ i === $ this -> maxLogFiles ) { @ unlink ( $ rotateFile ) ; continue ; } $ newFile = $ this -> logFile . '.' . ( $ i + 1 ) ; $ this -> rotateByCopy ? $ this -> rotateByCopy ( $ rotateFile , $ newFile ) : $ this -> rotateByRename ( $ rotateFile , $ newFile ) ; if ( $ i === 0 ) { $ this -> clearLogFile ( $ rotateFile ) ; } } } }
8857	private function _relativeSymlinkWithFallback ( string $ originDir , string $ targetDir ) : string { try { $ this -> _symlink ( $ originDir , $ targetDir , true ) ; $ method = AssetsInstallCommand :: METHOD_RELATIVE_SYMLINK ; } catch ( IOException $ e ) { $ method = $ this -> _absoluteSymlinkWithFallback ( $ originDir , $ targetDir ) ; } return $ method ; }
12793	public function create ( $ params = array ( ) ) { $ serverConfig = array_merge ( $ this -> defaults , $ params ) ; try { $ response = $ this -> client -> request -> post ( $ this -> apiEndpoint . "/droplets" , [ 'json' => $ serverConfig ] ) ; if ( 202 != $ this -> client -> getStatus ( $ response ) ) { throw new Exception ( 'Unable to create server.' ) ; } } catch ( Exception $ e ) { echo 'Unable to create server because ' . $ e -> getMessage ( ) ; } return $ this -> client -> getBody ( $ response ) ; }
9224	public function setupToken ( $ token ) { if ( ! empty ( $ token ) ) { $ this -> headers [ 'Authorization' ] = "Bearer $token" ; return true ; } else { if ( $ this -> throw_exceptions ) { throw new CanvasPest_Exception ( 'API authorization token must be a non-zero-length string' , CanvasPest_Exception :: INVALID_TOKEN ) ; } return false ; } }
11137	protected function calculateDELETE ( ) { $ this -> query .= 'DELETE FROM ' ; $ this -> queryStringFromArray ( 'tables' , '' , ', ' ) ; $ this -> conditionStringFromArray ( 'wheres' , ' WHERE ' , ' AND ' ) ; $ this -> queryStringFromArray ( 'orderBys' , ' ORDER BY ' , ', ' , false ) ; if ( $ this -> limit ) { $ this -> query .= ' LIMIT ' . $ this -> limit ; } }
7573	public function validateRequiredFields ( $ postVars ) { $ requiredFields = $ this -> getRequiredFields ( $ postVars [ 'id' ] ) ; $ missingKeys = array ( ) ; foreach ( $ requiredFields as $ human => $ keys ) { if ( ! $ this -> hasRequiredValue ( $ postVars , $ keys ) ) { $ missingKeys [ ] = $ human ; } } if ( ! empty ( $ missingKeys ) ) { throw new GreenhouseApplicationException ( 'Submission missing required answers for: ' . implode ( ', ' , $ missingKeys ) ) ; } return true ; }
1673	public function isUnprotected ( ) { $ path = $ this -> strFolder ; do { if ( file_exists ( $ this -> strRootDir . '/' . $ path . '/.public' ) ) { return true ; } $ path = \ dirname ( $ path ) ; } while ( $ path != '.' ) ; return false ; }
1383	protected function dataGet ( $ key , $ default = null ) { if ( ! isset ( $ this -> document -> data ) ) { return $ default ; } return data_get ( $ this -> document -> data , $ key , $ default ) ; }
11161	protected function getReplacements ( $ entry ) { $ link = 'https://youtu.be/' . $ entry -> id ; $ title = $ entry -> snippet -> title ; $ author = $ entry -> snippet -> channelTitle ; $ published = date ( $ this -> publishedFormat , strtotime ( $ entry -> snippet -> publishedAt ) ) ; $ views = number_format ( $ entry -> statistics -> viewCount , 0 ) ; $ likes = number_format ( $ entry -> statistics -> likeCount , 0 ) ; $ dislikes = number_format ( $ entry -> statistics -> dislikeCount , 0 ) ; $ favorites = number_format ( $ entry -> statistics -> favoriteCount , 0 ) ; $ comments = number_format ( $ entry -> statistics -> commentCount , 0 ) ; $ durationInterval = new \ DateInterval ( $ entry -> contentDetails -> duration ) ; $ duration = $ durationInterval -> format ( $ this -> durationFormat ) ; return array ( '%link%' => $ link , '%title%' => $ title , '%author%' => $ author , '%published%' => $ published , '%views%' => $ views , '%likes%' => $ likes , '%dislikes%' => $ dislikes , '%favorites%' => $ favorites , '%comments%' => $ comments , '%duration%' => $ duration , ) ; }
6103	public function request ( $ cmd , $ throw = true ) { $ query = StringHelper :: factory ( $ cmd ) -> section ( TeamSpeak3 :: SEPARATOR_CELL ) ; if ( strstr ( $ cmd , "\r" ) || strstr ( $ cmd , "\n" ) ) { throw new Ts3Exception ( "illegal characters in command '" . $ query . "'" ) ; } elseif ( in_array ( $ query , $ this -> block ) ) { throw new Ts3Exception ( "command not found" , 0x100 ) ; } Signal :: getInstance ( ) -> emit ( "serverqueryCommandStarted" , $ cmd ) ; $ this -> getProfiler ( ) -> start ( ) ; $ this -> getTransport ( ) -> sendLine ( $ cmd ) ; $ this -> timer = time ( ) ; $ this -> count ++ ; $ rpl = array ( ) ; do { $ str = $ this -> getTransport ( ) -> readLine ( ) ; $ rpl [ ] = $ str ; } while ( $ str instanceof StringHelper && $ str -> section ( TeamSpeak3 :: SEPARATOR_CELL ) != TeamSpeak3 :: ERROR ) ; $ this -> getProfiler ( ) -> stop ( ) ; $ reply = new Reply ( $ rpl , $ cmd , $ this -> getHost ( ) , $ throw ) ; Signal :: getInstance ( ) -> emit ( "serverqueryCommandFinished" , $ cmd , $ reply ) ; return $ reply ; }
632	public function update ( $ table , $ columns , $ condition = '' , $ params = [ ] ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> update ( $ table , $ columns , $ condition , $ params ) ; return $ this -> setSql ( $ sql ) -> bindValues ( $ params ) ; }
10077	public static function sanitizeUTF8 ( $ value ) { if ( self :: getIsIconvEnabled ( ) ) { $ value = @ iconv ( 'UTF-8' , 'UTF-8' , $ value ) ; return $ value ; } $ value = mb_convert_encoding ( $ value , 'UTF-8' , 'UTF-8' ) ; return $ value ; }
2628	protected function getOptions ( $ label = false ) { $ options = [ ] ; foreach ( $ this -> _storeManager -> getStores ( ) as $ store ) { $ options [ ] = [ 'value' => $ store -> getId ( ) , 'label' => $ store -> getName ( ) ] ; } if ( $ label ) { array_unshift ( $ options , [ 'value' => '' , 'label' => $ label ] ) ; } return $ options ; }
4793	function order ( $ columns ) { $ this -> rows = null ; if ( $ columns != "" ) { foreach ( func_get_args ( ) as $ columns ) { if ( $ this -> union ) { $ this -> unionOrder [ ] = $ columns ; } else { $ this -> order [ ] = $ columns ; } } } elseif ( $ this -> union ) { $ this -> unionOrder = array ( ) ; } else { $ this -> order = array ( ) ; } return $ this ; }
4010	public function getMaxPaginationLinks ( ) { if ( null === $ this -> maxPaginationLinks ) { $ this -> setMaxPaginationLinks ( \ Config :: get ( 'maxPaginationLinks' ) ) ; } return $ this -> maxPaginationLinks ; }
7937	public function createBackupFTPAccess ( $ domain , $ ipBlock ) { if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; if ( ! $ ipBlock ) throw new BadMethodCallException ( 'Parameter $ipBlock is missing.' ) ; $ payload = array ( 'ftp' => ( 1 == 1 ) , 'ipBlock' => $ ipBlock , 'nfs' => ( 1 == 0 ) , 'cifs' => ( 1 == 0 ) ) ; try { $ r = $ this -> post ( 'dedicated/server/' . $ domain . '/features/backupFTP/access' , array ( 'Content-Type' => 'application/json;charset=UTF-8' ) , json_encode ( $ payload ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new ServerException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
8080	public function & getReports ( $ channel = null ) { $ channel = $ this -> namespaceChannel ( $ channel ) ; if ( ! isset ( $ this -> console [ 'reports' ] [ $ channel ] ) ) { $ this -> console [ 'reports' ] [ $ channel ] = array ( ) ; } return $ this -> console [ 'reports' ] [ $ channel ] ; }
5468	public function addHeaders ( $ request , $ url ) { if ( $ url -> getUsername ( ) && $ url -> getPassword ( ) ) { $ username = $ url -> getUsername ( ) ; $ password = $ url -> getPassword ( ) ; } elseif ( $ realm = $ this -> findRealmFromUrl ( $ url ) ) { $ username = $ realm -> getUsername ( ) ; $ password = $ realm -> getPassword ( ) ; } else { return ; } $ this -> addBasicHeaders ( $ request , $ username , $ password ) ; }
10690	public static function handleException ( \ Throwable $ e ) { $ app = self :: getInstance ( ) ; if ( $ app -> request === null ) $ app -> request = Request :: createFromGlobals ( ) ; $ req = $ app -> request ; try { if ( ! Request :: cli ( ) ) { $ mgr = $ app -> resolver ; $ res = $ mgr -> getResolver ( 'template' ) ; $ assets = $ mgr -> getResolver ( 'assets' ) ; $ amgr = new AssetManager ( $ assets ) ; $ tpl = new Template ( $ res , $ amgr , $ req ) ; $ tpl -> setExceptionTemplate ( $ e ) ; $ tpl -> assign ( 'exception' , $ e ) ; $ tpl -> assign ( 'request' , $ req ) ; $ tpl -> assign ( 'dev' , $ app -> dev ) ; $ app -> i18n ; $ response = $ tpl -> renderReturn ( ) ; $ responder = new \ Wedeto \ HTTP \ Responder ( ) ; $ result = new \ Wedeto \ HTTP \ Result ( ) ; $ result -> setResponse ( $ response ) ; $ responder -> setRequest ( $ req ) ; $ responder -> setResult ( $ result ) ; $ params = new Dictionary ( [ 'responder' => $ responder , 'mime' => 'text/html' ] ) ; $ amgr -> executeHook ( $ params ) ; $ responder -> respond ( ) ; } } catch ( \ Throwable $ e2 ) { echo "<h1>Error while showing error template:</h1>\n\n" ; echo "<pre>" . WF :: html ( $ e2 ) . "</pre>\n" ; } if ( Request :: cli ( ) ) { fprintf ( STDERR , \ Wedeto \ Application \ CLI \ ANSI :: bright ( "An uncaught exception has occurred:" ) . "\n\n" ) ; WF :: debug ( WF :: str ( $ e ) ) ; } else { echo "<h2>Original error:</h2>\n\n" ; echo "<pre>" . WF :: html ( $ e ) . "</pre>\n" ; } }
5173	public static function createArticle ( String $ title , string $ body , string $ source , string $ uniqueId , int $ typeId , int $ categoryId , string $ reporter , string $ lead , string $ tags , string $ publishedAt , int $ identifier ) : Article { return new Article ( $ title , $ body , $ source , $ uniqueId , $ typeId , $ categoryId , $ reporter , $ lead , $ tags , $ publishedAt , $ identifier ) ; }
9425	public function f ( ) { if ( is_null ( $ this -> arr_f ) ) { $ arr = $ this -> frequency ( ) ; array_walk ( $ arr , function ( & $ v , $ k , $ n ) { $ v = $ v / $ n ; } , count ( $ this ) ) ; $ this -> arr_f = $ arr ; } return $ this -> arr_f ; }
6541	public function fetchOne ( $ tableName , array $ identifier , $ shardingKey = null , $ forceFromMaster = true ) { return $ this -> fetch ( $ tableName , $ identifier , $ shardingKey , array ( '*' ) , false , $ forceFromMaster ) ; }
9273	public function filter ( $ text ) { $ text = str_replace ( "\r" , '' , $ text ) ; $ text = str_replace ( ' ' , ' &nbsp;' , $ text ) ; $ this -> _parseBbcodeNobbcode ( $ text ) ; $ this -> _parseBbcodeCode ( $ text ) ; $ this -> _parseBbcodeQuote ( $ text ) ; $ this -> _parseBbcodeList ( $ text ) ; $ this -> _parseSimpleBbcode ( 'i' , '<em>$1</em>' , $ text ) ; $ this -> _parseSimpleBbcode ( 'u' , '<u>$1</u>' , $ text ) ; $ this -> _parseSimpleBbcode ( 'b' , '<strong>$1</strong>' , $ text ) ; $ this -> _parseSimpleBbcode ( 'del' , '<del>$1</del>' , $ text ) ; $ this -> _parseSimpleBbcode ( 'strike' , '<del>$1</del>' , $ text ) ; $ this -> _parseParamBbcode ( 'color' , '([a-zA-Z]*|\#?[0-9a-fA-F]{6})' , '<span style="color: $1">$2</span>' , $ text ) ; $ this -> _parseParamBbcode ( 'bgcolor' , '([a-zA-Z]*|\#?[0-9a-fA-F]{6})' , '<span style="background-color: $1">$2</span>' , $ text ) ; $ this -> _parseParamBbcode ( 'align' , '(center|left|right|justify){1}' , '<div style="text-alignement: $1">$2</div>' , $ text ) ; $ this -> _parseParamBbcode ( 'size' , '([0-9].*)' , '<span style="font-size: $1">$2</span>' , $ text ) ; $ this -> _parseBbcodeEmail ( $ text ) ; $ this -> _parseBbcodeUrl ( $ text ) ; $ this -> _parseBbcodeImg ( $ text ) ; $ this -> _parseBbcodeSpoiler ( $ text ) ; $ this -> _parseScriptTags ( $ text ) ; $ this -> _parseSmiley ( $ text ) ; $ this -> _parseBbcodeBr ( $ text ) ; return $ text ; }
7229	public static function create ( $ method , $ url , $ data = "" , array $ headers = [ ] , array $ options = [ ] , $ initOnly = false ) { $ curl = null ; if ( ! strcasecmp ( $ method , "GET" ) ) $ curl = new static ( $ url , $ options + [ CURLOPT_CUSTOMREQUEST => "GET" , CURLOPT_RETURNTRANSFER => true ] , $ headers , $ initOnly ) ; else if ( ! strcasecmp ( $ method , "POST" ) ) $ curl = new static ( $ url , $ options + [ CURLOPT_CUSTOMREQUEST => "POST" , CURLOPT_POSTFIELDS => $ data , CURLOPT_RETURNTRANSFER => true ] , $ headers , $ initOnly ) ; else if ( ! strcasecmp ( $ method , "PUT" ) ) $ curl = new static ( $ url , $ options + [ CURLOPT_CUSTOMREQUEST => "PUT" , CURLOPT_POSTFIELDS => $ data , CURLOPT_RETURNTRANSFER => true ] , $ headers , $ initOnly ) ; else if ( ! strcasecmp ( $ method , "DELETE" ) ) $ curl = new static ( $ url , $ options + [ CURLOPT_CUSTOMREQUEST => "DELETE" , CURLOPT_RETURNTRANSFER => true ] , $ headers , $ initOnly ) ; return $ curl ; }
3136	public function setItemState ( RunnerServiceContext $ context , $ itemRef , $ state ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ serviceService = $ this -> getServiceManager ( ) -> get ( StorageManager :: SERVICE_ID ) ; $ userUri = \ common_session_SessionManager :: getSession ( ) -> getUserUri ( ) ; $ stateId = $ this -> getStateId ( $ context , $ itemRef ) ; if ( ! isset ( $ state ) ) { $ state = '' ; } return is_null ( $ userUri ) ? false : $ serviceService -> set ( $ userUri , $ stateId , json_encode ( $ state ) ) ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'setItemState' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } }
48	protected function getListeners ( Event $ event ) { $ scriptListeners = $ this -> getScriptListeners ( $ event ) ; if ( ! isset ( $ this -> listeners [ $ event -> getName ( ) ] [ 0 ] ) ) { $ this -> listeners [ $ event -> getName ( ) ] [ 0 ] = array ( ) ; } krsort ( $ this -> listeners [ $ event -> getName ( ) ] ) ; $ listeners = $ this -> listeners ; $ listeners [ $ event -> getName ( ) ] [ 0 ] = array_merge ( $ listeners [ $ event -> getName ( ) ] [ 0 ] , $ scriptListeners ) ; return call_user_func_array ( 'array_merge' , $ listeners [ $ event -> getName ( ) ] ) ; }
12380	public static function fromReflectionParam ( ReflectionParameter $ param , ReflectionFunctionAbstract $ func = null , Exception $ previous = null , $ afterMessage = null ) { $ message = static :: makeMessage ( $ param , $ func ) ; if ( $ previous ) { $ message .= ' - ' . $ previous -> getMessage ( ) ; } if ( $ afterMessage ) { $ message .= ' - ' . $ afterMessage ; } return new static ( $ message , 0 , $ previous ) ; }
9984	function fromXML ( $ xmlElement ) { if ( isset ( $ xmlElement -> id ) ) $ this -> id = $ xmlElement -> id ; if ( isset ( $ xmlElement -> name ) ) $ this -> name = $ xmlElement -> name ; if ( isset ( $ xmlElement -> entries ) ) { $ this -> entries = array ( ) ; foreach ( $ xmlElement -> entries -> children ( ) as $ entry ) { $ this -> entries [ ] = $ entry ; } } }
3227	function buildUrlForGetOrPut ( $ host , $ path , $ params = null ) { return RequestUtil :: buildUrlForGetOrPut ( $ this -> userLocale , $ host , $ path , $ params ) ; }
11488	public function setName ( string $ name ) : void { if ( ! empty ( $ name ) ) { if ( ! is_numeric ( $ name ) ) { @ session_name ( $ name ) ; } else { throw new Exception ( 'The session name can\'t consist only of digits, ' . 'at least one letter must be presented.' ) ; } } else { throw new Exception ( 'Empty session name value was passed.' ) ; } }
5508	public function returnsByReference ( $ method , & $ reference , $ args = false ) { $ this -> dieOnNoMethod ( $ method , 'set return reference' ) ; $ this -> actions -> register ( $ method , $ args , new SimpleByReference ( $ reference ) ) ; }
4073	public function getUser ( ) { static $ authenticated ; if ( ! isset ( $ authenticated ) ) { $ authenticated = true ; $ this -> authenticateUser ( ) ; } return $ this -> user ; }
5019	public function getFieldOptions ( $ field ) { if ( ! $ this -> hasField ( $ field ) ) { return [ ] ; } if ( ! isset ( $ this -> fields [ $ field ] [ '__options__' ] ) ) { $ this -> fields [ $ field ] [ '__options__' ] = $ this -> copyArrayValues ( $ this -> fields [ $ field ] , [ 'attributes' , 'options' , 'label' => 'options' , 'required' => [ 'key' => [ 'attributes' , '*' ] , 'value' => 'required' , 'if' => true ] , 'type' , ] ) ; } return $ this -> fields [ $ field ] [ '__options__' ] ; }
1128	public function isSelfOrAncestorOf ( $ other ) { return ( $ this -> getLeft ( ) <= $ other -> getLeft ( ) && $ this -> getRight ( ) > $ other -> getLeft ( ) && $ this -> inSameScope ( $ other ) ) ; }
11590	public static function title ( $ title , $ pad = '=' ) { $ rest = ( int ) ( 78 - mb_strlen ( $ title ) ) / 2 ; $ result = "\n\n" ; $ result .= str_repeat ( $ pad , $ rest ) ; $ result .= ' ' . $ title . ' ' ; $ result .= str_repeat ( $ pad , $ rest ) ; $ result .= "\n\n" ; return $ result ; }
9338	public function isSupplementary ( Angle $ angle ) { $ out = new self ( $ this -> float_rad + $ angle -> rad ) ; return $ out -> isStraight ( ) ; }
2960	public function sendMessage ( $ str , $ waitForReply = 0.1 ) { $ this -> _buffer .= $ str ; if ( $ this -> autoFlush === true ) { $ this -> serialflush ( ) ; } usleep ( ( int ) ( $ waitForReply * 1000000 ) ) ; }
11883	public function getTicketCacheKey ( ) { if ( is_null ( $ this -> ticketCacheKey ) ) { return $ this -> ticketCachePrefix . $ this -> getAccessToken ( ) -> getAppId ( ) ; } return $ this -> ticketCacheKey ; }
8575	public function setItemChargeList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ItemChargeList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
1942	public function listRecipient ( $ row ) { $ label = Contao \ Idna :: decodeEmail ( $ row [ 'email' ] ) ; if ( $ row [ 'addedOn' ] ) { $ label .= ' <span style="color:#999;padding-left:3px">(' . sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_newsletter_recipients' ] [ 'subscribed' ] , Contao \ Date :: parse ( Contao \ Config :: get ( 'datimFormat' ) , $ row [ 'addedOn' ] ) ) . ')</span>' ; } else { $ label .= ' <span style="color:#999;padding-left:3px">(' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_newsletter_recipients' ] [ 'manually' ] . ')</span>' ; } return sprintf ( '<div class="tl_content_left"><div class="list_icon" style="background-image:url(\'%ssystem/themes/%s/icons/%s.svg\')" data-icon="member.svg" data-icon-disabled="member_.svg">%s</div></div>' , Contao \ System :: getContainer ( ) -> get ( 'contao.assets.assets_context' ) -> getStaticUrl ( ) , Contao \ Backend :: getTheme ( ) , ( $ row [ 'active' ] ? 'member' : 'member_' ) , $ label ) . "\n" ; }
4706	public function each ( callable $ callable ) { foreach ( $ this -> objects as $ key => $ value ) { if ( false === call_user_func_array ( $ callable , array ( $ value , $ key ) ) ) { break ; } } return $ this ; }
4062	private static function isEmptyArrayEquivalent ( $ expected , $ actual ) { return ( gettype ( $ expected ) == 'string' ) && ( ( gettype ( $ actual ) == 'array' ) || ( gettype ( $ actual ) == 'NULL' ) ) && empty ( $ actual ) && empty ( $ expected ) ; }
1929	public function generate ( ) { if ( TL_MODE == 'BE' ) { $ return = '<pre>' . StringUtil :: specialchars ( $ this -> code ) . '</pre>' ; if ( $ this -> headline != '' ) { $ return = '<' . $ this -> hl . '>' . $ this -> headline . '</' . $ this -> hl . '>' . $ return ; } return $ return ; } return parent :: generate ( ) ; }
10751	public function init ( UserEntity $ user , ServiceManager $ sm ) { $ main = $ sm -> get ( 'neobazaar.service.main' ) ; $ userRepository = $ main -> getUserEntityRepository ( ) ; $ this -> hashId = $ userRepository -> getEncryptedId ( $ user -> getUserId ( ) ) ; $ this -> name = $ user -> getName ( ) ; $ this -> surname = $ user -> getSurname ( ) ; $ this -> email = $ user -> getEmail ( ) ; $ this -> gender = $ user -> getGender ( ) ; $ this -> dateBorn = $ this -> getDateBorn ( $ user , $ sm ) ; $ this -> nicename = $ user -> getNicename ( ) ; $ this -> mobile = $ this -> getMobile ( $ user ) ; $ this -> isAdmin = 'god' == $ user -> getRole ( ) ; $ this -> fullname = $ this -> getFullname ( $ user ) ; $ this -> role = $ user -> getRole ( ) ; $ this -> state = $ user -> getState ( ) ; $ this -> stateFormatted = $ this -> getStateFormatted ( $ user ) ; $ this -> editAddress = '/#/edituseerrr' ; $ this -> isActive = $ user -> getState ( ) == UserEntity :: USER_STATE_ACTIVE ; $ this -> isDeactive = $ user -> getState ( ) == UserEntity :: USER_STATE_DEACTIVE ; $ this -> isDeleted = $ user -> getState ( ) == UserEntity :: USER_STATE_DELETED ; $ this -> isBanned = $ user -> getState ( ) == UserEntity :: USER_STATE_BANNED ; $ this -> count = 'disabled' ; return $ this ; }
3598	public function parserHttpRequest ( HttpRequest $ httpRequest ) { $ json = \ json_decode ( $ httpRequest -> getContent ( ) , true ) ; if ( JSON_ERROR_NONE !== \ json_last_error ( ) ) { throw new Exceptions \ ParseException ( ) ; } $ createJsonRequest = function ( $ json ) use ( $ httpRequest ) { $ id = null ; $ method = null ; $ params = [ ] ; if ( \ is_array ( $ json ) ) { $ id = \ array_key_exists ( 'id' , $ json ) ? $ json [ 'id' ] : null ; $ method = \ array_key_exists ( 'method' , $ json ) ? $ json [ 'method' ] : null ; $ params = \ array_key_exists ( 'params' , $ json ) ? $ json [ 'params' ] : [ ] ; } $ request = new JsonRequest ( $ method , $ params , $ id ) ; $ request -> headers ( ) -> add ( $ httpRequest -> headers -> all ( ) ) ; return $ request ; } ; if ( \ array_keys ( $ json ) === \ range ( 0 , \ count ( $ json ) - 1 ) ) { $ requests = [ ] ; foreach ( $ json as $ part ) { $ requests [ ] = $ createJsonRequest ( $ part ) ; } } else { $ requests = $ createJsonRequest ( $ json ) ; } return $ requests ; }
9469	private function registerLogViewerRoutes ( ) { $ this -> prefix ( 'log-viewer' ) -> name ( 'log-viewer.' ) -> group ( function ( ) { $ this -> get ( '/' , 'LogViewerController@index' ) -> name ( 'index' ) ; $ this -> prefix ( 'logs' ) -> name ( 'logs.' ) -> group ( function ( ) { $ this -> get ( '/' , 'LogViewerController@listLogs' ) -> name ( 'list' ) ; $ this -> prefix ( '{logviewer_log_date}' ) -> group ( function ( ) { $ this -> get ( '/' , 'LogViewerController@show' ) -> name ( 'show' ) ; $ this -> get ( 'download' , 'LogViewerController@download' ) -> name ( 'download' ) ; $ this -> get ( '{level}' , 'LogViewerController@showByLevel' ) -> name ( 'filter' ) ; $ this -> get ( '{level}/search' , 'LogViewerController@search' ) -> name ( 'search' ) ; $ this -> delete ( 'delete' , 'LogViewerController@delete' ) -> middleware ( 'ajax' ) -> name ( 'delete' ) ; } ) ; } ) ; } ) ; }
7697	function MsPowerpoint_SearchInSlides ( $ str , $ returnFirstFound = true ) { $ this -> MsPowerpoint_InitSlideLst ( ) ; $ files = array ( ) ; foreach ( $ this -> OpenXmlSlideLst as $ i => $ s ) $ files [ $ i + 1 ] = $ s [ 'idx' ] ; $ find = $ this -> TbsSearchInFiles ( $ files , $ str , $ returnFirstFound ) ; return $ find ; }
3375	public function open ( $ file ) { if ( strlen ( $ file ) >= 1 && $ file [ 0 ] == '@' ) { try { if ( $ this -> fileLocator instanceof FileLocatorInterface ) { $ file = $ this -> fileLocator -> locate ( $ file ) ; } else { $ this -> fileLocator -> locateResource ( $ file ) ; } } catch ( \ InvalidArgumentException $ exception ) { if ( $ this -> throwException || false == $ this -> fallbackImage ) { throw $ exception ; } $ file = $ this -> fallbackImage ; } } return $ this -> createInstance ( $ file ) ; }
12910	public function group ( $ group ) { if ( ! is_array ( $ group ) ) { $ this -> group = array ( $ group ) ; } else { $ this -> group = $ group ; } return $ this ; }
3522	public static function refresh ( $ refresh_token ) { $ data = FortniteClient :: sendUnrealClientPostRequest ( FortniteClient :: EPIC_OAUTH_TOKEN_ENDPOINT , [ 'grant_type' => 'refresh_token' , 'refresh_token' => $ refresh_token , 'includePerms' => "false" , 'token_type' => 'eg1' , ] , FortniteClient :: FORTNITE_AUTHORIZATION ) ; if ( ! $ data -> access_token ) { throw new \ Exception ( $ data -> errorMessage ) ; } return new self ( $ data -> access_token , $ data -> in_app_id , $ data -> refresh_token , $ data -> account_id , $ data -> expires_in ) ; }
465	public function buildBetweenCondition ( $ operator , $ operands , & $ params ) { array_unshift ( $ operands , $ operator ) ; return $ this -> buildCondition ( $ operands , $ params ) ; }
11506	public function offsetSet ( $ slot , $ connection ) { if ( ! static :: isValid ( $ slot ) ) { throw new \ OutOfBoundsException ( "Invalid slot $slot for `$connection`" ) ; } $ this -> slots [ ( int ) $ slot ] = ( string ) $ connection ; }
11805	public function get ( $ columns = array ( '*' ) ) { $ columnsPassed = ( func_num_args ( ) > 1 ) ; $ columns = $ columnsPassed ? $ columns : $ this -> getQueryColumns ( ) ; $ query = $ this -> buildQuery ( $ columns ) ; if ( ! $ columnsPassed ) { return $ query -> get ( $ this -> getQueryColumns ( ) ) ; } if ( ! $ columns ) { return $ query -> get ( ) ; } return $ query -> get ( $ columns ) ; }
1810	public function adjustDcaByType ( $ dc ) { $ objCte = Contao \ ContentModel :: findByPk ( $ dc -> id ) ; if ( $ objCte === null ) { return ; } switch ( $ objCte -> type ) { case 'hyperlink' : unset ( $ GLOBALS [ 'TL_DCA' ] [ 'tl_content' ] [ 'fields' ] [ 'imageUrl' ] ) ; break ; case 'image' : $ GLOBALS [ 'TL_DCA' ] [ 'tl_content' ] [ 'fields' ] [ 'imagemargin' ] [ 'eval' ] [ 'tl_class' ] .= ' clr' ; break ; } }
11958	public function remove ( $ element ) { if ( ! $ this -> contains ( $ element ) ) { return false ; } $ this -> offsetUnset ( $ this -> indexOf ( $ element ) ) ; return true ; }
12621	public function set ( $ key , $ value ) { ArrayDot :: set ( $ _SESSION [ $ this -> root ] , $ key , $ value ) ; }
7794	protected function accountNumber ( $ text ) { if ( $ account = $ this -> getLine ( '25' , $ text ) ) { return ltrim ( substr ( $ account , 12 ) , '0' ) ; } return null ; }
6818	protected function writeInvoiceGoodsLines ( ) { $ sale = $ this -> invoice -> getSale ( ) ; $ date = $ sale -> getCreatedAt ( ) ; $ taxRule = $ this -> taxResolver -> resolveSaleTaxRule ( $ sale ) ; $ discounts = $ sale -> getAdjustments ( AdjustmentTypes :: TYPE_DISCOUNT ) -> toArray ( ) ; $ amounts = [ ] ; foreach ( $ this -> invoice -> getLinesByType ( DocumentLineTypes :: TYPE_GOOD ) as $ line ) { if ( $ line -> getSaleItem ( ) -> isPrivate ( ) ) { continue ; } $ rates = $ line -> getTaxRates ( ) ; if ( empty ( $ rates ) ) { $ rate = 0 ; } elseif ( 1 === count ( $ rates ) ) { $ rate = current ( $ rates ) ; } else { throw new LogicException ( "Multiple tax rates on goods lines are not yet supported." ) ; } $ amount = $ line -> getBase ( ) ; if ( ! empty ( $ discounts ) ) { $ base = $ amount ; foreach ( $ discounts as $ adjustment ) { if ( $ adjustment -> getMode ( ) === AdjustmentModes :: MODE_PERCENT ) { $ amount -= $ this -> round ( $ amount * $ adjustment -> getAmount ( ) / 100 ) ; } else { $ amount -= $ this -> round ( $ base / $ this -> invoice -> getGoodsBase ( ) * $ adjustment -> getAmount ( ) ) ; } } } if ( ! isset ( $ amounts [ ( string ) $ rate ] ) ) { $ amounts [ ( string ) $ rate ] = 0 ; } $ amounts [ ( string ) $ rate ] += $ this -> round ( $ amount ) ; } $ credit = $ this -> invoice -> getType ( ) === InvoiceTypes :: TYPE_CREDIT ; foreach ( $ amounts as $ rate => $ amount ) { $ amount = $ this -> round ( $ amount ) ; if ( 0 === $ this -> compare ( $ amount , 0 ) ) { continue ; } $ account = $ this -> getGoodAccountNumber ( $ taxRule , ( float ) $ rate , $ this -> invoice -> getNumber ( ) ) ; if ( $ credit ) { $ this -> writer -> credit ( $ account , ( string ) $ amount , $ date ) ; $ this -> balance -= $ amount ; } else { $ this -> writer -> debit ( $ account , ( string ) $ amount , $ date ) ; $ this -> balance += $ amount ; } } }
2963	public function isAuthorized ( ) { $ hasSession = Yii :: $ app -> session -> has ( $ this -> sessionParam ) ; $ sessionVal = Yii :: $ app -> session -> get ( $ this -> sessionParam ) ; return ( $ hasSession && ! empty ( $ sessionVal ) ) ; }
4737	public function sendException ( Request $ request , \ Exception $ exception ) { if ( ! $ this -> enabled ) { return ; } $ serverParams = $ request -> server -> all ( ) ; if ( isset ( $ serverParams [ 'PHP_AUTH_PW' ] ) ) { $ serverParams [ 'PHP_AUTH_PW' ] = '*****' ; } $ message = \ Swift_Message :: newInstance ( ) -> setSubject ( 'Error message from ' . $ request -> getHost ( ) . ' - ' . $ exception -> getMessage ( ) ) -> setFrom ( $ this -> from ) -> setTo ( $ this -> to ) -> setContentType ( 'text/html' ) -> setBody ( $ this -> templating -> render ( "SoclozMonitoringBundle:Notify:exception.html.twig" , array ( 'request' => $ request , 'exception' => $ exception , 'exception_class' => \ get_class ( $ exception ) , 'request_headers' => $ request -> server -> getHeaders ( ) , 'request_attributes' => $ this -> mailerTransformer -> transform ( $ request -> attributes -> all ( ) ) , 'server_params' => $ this -> mailerTransformer -> transform ( $ serverParams ) , ) ) ) ; try { $ this -> getMailer ( ) -> send ( $ message ) ; } catch ( \ Exception $ e ) { $ this -> logger -> error ( 'Sending mail error - ' . $ e -> getMessage ( ) ) ; } }
6698	public function compareTo ( $ version ) { $ major = $ version -> getMajor ( ) ; $ minor = $ version -> getMinor ( ) ; $ patch = $ version -> getPatch ( ) ; $ pre = $ version -> getPreRelease ( ) ; $ build = $ version -> getBuild ( ) ; switch ( true ) { case ( $ this -> major < $ major ) : return 1 ; case ( $ this -> major > $ major ) : return - 1 ; case ( $ this -> minor > $ minor ) : return - 1 ; case ( $ this -> minor < $ minor ) : return 1 ; case ( $ this -> patch > $ patch ) : return - 1 ; case ( $ this -> patch < $ patch ) : return 1 ; } if ( $ pre || $ this -> pre ) { if ( empty ( $ this -> pre ) && $ pre ) { return - 1 ; } if ( $ this -> pre && empty ( $ pre ) ) { return 1 ; } if ( 0 !== ( $ weight = $ this -> precedence ( $ this -> pre , $ pre ) ) ) { return $ weight ; } } if ( $ build || $ this -> build ) { if ( ( null === $ this -> build ) && $ build ) { return 1 ; } if ( $ this -> build && ( null === $ build ) ) { return - 1 ; } return $ this -> precedence ( $ this -> build , $ build ) ; } return 0 ; }
11049	function parse_info ( $ info ) { $ elements = explode ( ':' , $ info ) ; $ count = count ( $ elements ) ; if ( $ count > 4 ) { for ( $ i = 4 ; $ i < $ count ; ++ $ i ) { $ elements [ 3 ] .= ':' . $ elements [ $ i ] ; } } else { $ elements = array_pad ( $ elements , 4 , '' ) ; } return array ( $ elements [ 0 ] , $ elements [ 2 ] , $ elements [ 3 ] ) ; }
12158	public function getObjectLevel ( ) { if ( $ this -> isPrimaryType ) { return 1 ; } $ parents = $ this -> collectorItem -> parents ; if ( ! empty ( $ parents ) ) { $ maxLevel = 1 ; foreach ( $ parents as $ rel ) { if ( get_class ( $ rel -> parent ) === get_class ( $ this ) ) { continue ; } $ newLevel = $ rel -> parent -> objectLevel + 1 ; if ( $ newLevel > $ maxLevel ) { $ maxLevel = $ newLevel ; } } return $ maxLevel ; } return 1 ; }
8934	public function fetch ( $ name ) { $ template = false ; if ( array_key_exists ( $ name , $ this -> templates ) ) { $ template = $ this -> templates [ $ name ] ; } return $ template ; }
5816	public function onAfterWrite ( ) { parent :: onAfterWrite ( ) ; $ types = unserialize ( $ this -> TagTypes ) ; $ changed = $ this -> getChangedFields ( ) ; foreach ( $ this -> service -> getFusionTagTypes ( ) as $ type => $ field ) { if ( isset ( $ types [ $ type ] ) ) { $ newTypes = array ( ) ; if ( isset ( $ changed [ 'TagTypes' ] ) ) { $ before = unserialize ( $ changed [ 'TagTypes' ] [ 'before' ] ) ; $ after = unserialize ( $ changed [ 'TagTypes' ] [ 'after' ] ) ; $ newTypes = is_array ( $ before ) ? array_diff ( $ after , $ before ) : $ after ; } if ( ( isset ( $ changed [ 'ID' ] ) || isset ( $ newTypes [ $ type ] ) ) && ! ( $ type :: get ( ) -> filter ( $ field , $ this -> Title ) -> first ( ) ) ) { $ tag = $ type :: create ( ) ; $ tag -> $ field = $ this -> Title ; $ tag -> FusionTagID = $ this -> ID ; $ tag -> write ( ) ; } else if ( ! isset ( $ changed [ 'ID' ] ) && isset ( $ changed [ 'Title' ] ) && ( $ existing = $ type :: get ( ) -> filter ( $ field , $ changed [ 'Title' ] [ 'before' ] ) ) ) { foreach ( $ existing as $ tag ) { $ tag -> $ field = $ changed [ 'Title' ] [ 'after' ] ; $ tag -> write ( ) ; } } } } if ( ! isset ( $ changed [ 'ID' ] ) && isset ( $ changed [ 'Title' ] ) ) { $ this -> service -> updateTagging ( $ this -> ID ) ; } }
1382	protected function dataHas ( $ key ) : bool { if ( ! isset ( $ this -> document -> data ) ) { return false ; } return property_exists ( $ this -> document -> data , $ key ) ; }
9287	public function drop ( ) { $ adapter = $ this -> dbAdapter ; $ ddl = new Ddl \ DropTable ( self :: TABLE_NAME ) ; $ sql = ( new Sql ( $ adapter ) ) -> getSqlStringForSqlObject ( $ ddl ) ; $ adapter -> query ( $ sql , $ adapter :: QUERY_MODE_EXECUTE ) ; }
7149	private function calculateAdjustment ( AdjustmentDataInterface $ adjustment , $ base ) { if ( $ adjustment -> getMode ( ) === AdjustmentModes :: MODE_PERCENT ) { return Money :: round ( $ base * $ adjustment -> getAmount ( ) / 100 , $ this -> currency ) ; } if ( $ adjustment -> getMode ( ) === AdjustmentModes :: MODE_FLAT ) { return $ adjustment -> getAmount ( ) ; } throw new InvalidArgumentException ( "Unexpected adjustment mode." ) ; }
422	public function begin ( ) { if ( $ this -> form -> enableClientScript ) { $ clientOptions = $ this -> getClientOptions ( ) ; if ( ! empty ( $ clientOptions ) ) { $ this -> form -> attributes [ ] = $ clientOptions ; } } $ inputID = $ this -> getInputId ( ) ; $ attribute = Html :: getAttributeName ( $ this -> attribute ) ; $ options = $ this -> options ; $ class = isset ( $ options [ 'class' ] ) ? ( array ) $ options [ 'class' ] : [ ] ; $ class [ ] = "field-$inputID" ; if ( $ this -> model -> isAttributeRequired ( $ attribute ) ) { $ class [ ] = $ this -> form -> requiredCssClass ; } $ options [ 'class' ] = implode ( ' ' , $ class ) ; if ( $ this -> form -> validationStateOn === ActiveForm :: VALIDATION_STATE_ON_CONTAINER ) { $ this -> addErrorClassIfNeeded ( $ options ) ; } $ tag = ArrayHelper :: remove ( $ options , 'tag' , 'div' ) ; return Html :: beginTag ( $ tag , $ options ) ; }
7553	protected function match_tags ( $ tags ) { $ res = false ; foreach ( $ tags as $ tag => $ match ) { if ( ! is_array ( $ match ) ) { $ match = array ( 'match' => $ match , 'operator' => 'or' , 'compare' => 'total' , 'case_sensitive' => false ) ; } else { if ( is_int ( $ tag ) ) { $ tag = $ match [ 'tag' ] ; } if ( ! isset ( $ match [ 'match' ] ) ) { $ match [ 'match' ] = true ; } if ( ! isset ( $ match [ 'operator' ] ) ) { $ match [ 'operator' ] = 'or' ; } if ( ! isset ( $ match [ 'compare' ] ) ) { $ match [ 'compare' ] = 'total' ; } if ( ! isset ( $ match [ 'case_sensitive' ] ) ) { $ match [ 'case_sensitive' ] = false ; } } if ( ( $ match [ 'operator' ] === 'and' ) && ( ! $ res ) ) { return false ; } elseif ( ! ( $ res && ( $ match [ 'operator' ] === 'or' ) ) ) { if ( $ match [ 'compare' ] === 'total' ) { $ a = $ this -> tag ; } elseif ( $ match [ 'compare' ] === 'namespace' ) { $ a = $ this -> getNamespace ( ) ; } elseif ( $ match [ 'compare' ] === 'name' ) { $ a = $ this -> getTag ( ) ; } if ( $ match [ 'case_sensitive' ] ) { $ res = ( ( $ a === $ tag ) === $ match [ 'match' ] ) ; } else { $ res = ( ( strcasecmp ( $ a , $ tag ) === 0 ) === $ match [ 'match' ] ) ; } } } return $ res ; }
4814	private function createFrom ( $ filepath ) { if ( file_exists ( $ filepath ) ) { $ anyDataSet = XmlUtil :: createXmlDocumentFromFile ( $ filepath ) ; $ this -> collection = array ( ) ; $ rows = $ anyDataSet -> getElementsByTagName ( "row" ) ; foreach ( $ rows as $ row ) { $ sr = new Row ( ) ; $ fields = $ row -> getElementsByTagName ( "field" ) ; foreach ( $ fields as $ field ) { $ attr = $ field -> attributes -> getNamedItem ( "name" ) ; if ( is_null ( $ attr ) ) { throw new \ InvalidArgumentException ( 'Malformed anydataset file ' . basename ( $ filepath ) ) ; } $ sr -> addField ( $ attr -> nodeValue , $ field -> nodeValue ) ; } $ sr -> acceptChanges ( ) ; $ this -> collection [ ] = $ sr ; } $ this -> currentRow = count ( $ this -> collection ) - 1 ; } }
3887	public function editRenderSettingButton ( \ DC_Table $ dataContainer ) { if ( $ dataContainer -> value < 1 ) { return '' ; } $ url = $ this -> urlBuilderFactory -> create ( 'contao/main.php?do=metamodels&table=tl_metamodel_rendersetting' ) -> setQueryParameter ( 'pid' , ModelId :: fromValues ( 'tl_metamodel_rendersettings' , $ dataContainer -> value ) -> getSerialized ( ) ) ; return $ this -> renderEditButton ( $ GLOBALS [ 'TL_LANG' ] [ static :: $ tableName ] [ 'editrendersetting' ] [ 0 ] , sprintf ( StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ static :: $ tableName ] [ 'editrendersetting' ] [ 1 ] ) , $ dataContainer -> value ) , $ url ) ; }
5580	public function submitFormById ( $ id , $ additional = false ) { if ( ! ( $ form = $ this -> page -> getFormById ( $ id ) ) ) { return false ; } $ success = $ this -> load ( $ form -> getAction ( ) , $ form -> submit ( $ additional ) ) ; return ( $ success ? $ this -> getContent ( ) : $ success ) ; }
10266	public function setRotation ( $ pValue ) { if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'rotation' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> rotation = $ pValue ; } return $ this ; }
6377	public function toArray ( ) : array { $ res = [ ] ; Iterators :: each ( $ this -> iterator ( ) , function ( $ element ) use ( & $ res ) { $ res [ ] = $ element ; } ) ; return $ res ; }
5386	public function isLabel ( $ label ) { for ( $ i = 0 , $ count = count ( $ this -> widgets ) ; $ i < $ count ; $ i ++ ) { if ( $ this -> widgets [ $ i ] -> isLabel ( $ label ) ) { return true ; } } return false ; }
10331	public function load ( $ url ) { if ( ! is_string ( $ url ) ) { throw new \ InvalidArgumentException ( 'The url argument must be of type string' ) ; } $ this -> url = $ url ; set_error_handler ( function ( ) { throw new \ Exception ( func_get_arg ( 1 ) ) ; } ) ; $ errorReason = '' ; try { $ urlData = parse_url ( $ this -> url ) ; if ( isset ( $ urlData [ 'host' ] ) ) { $ hostname = $ urlData [ 'host' ] ; if ( substr ( $ hostname , 0 , 4 ) === 'www.' ) { $ hostname = substr ( $ hostname , 4 ) ; } foreach ( self :: $ providers as $ name => $ domains ) { $ done = false ; foreach ( $ domains as $ domain ) { if ( preg_match ( '/^' . str_replace ( [ '.' , '*' ] , [ '\.' , '.*' ] , $ domain ) . '$/' , $ hostname ) ) { include_once __DIR__ . DIRECTORY_SEPARATOR . 'VideoEmbed' . DIRECTORY_SEPARATOR . 'Internal' . DIRECTORY_SEPARATOR . 'Providers' . DIRECTORY_SEPARATOR . $ name . '.php' ; call_user_func ( [ '\IvoPetkov\VideoEmbed\Internal\Providers\\' . $ name , 'load' ] , $ this -> url , $ this ) ; $ done = true ; break ; } } if ( $ done ) { break ; } } } } catch ( \ Exception $ e ) { $ errorReason = $ e -> getMessage ( ) ; } restore_error_handler ( ) ; if ( $ this -> html === null ) { throw new \ Exception ( 'Cannot retrieve information about ' . $ this -> url . ' (reason: ' . ( isset ( $ errorReason { 0 } ) ? $ errorReason : 'unknown' ) . ')' ) ; } }
7160	public function buildSaleView ( Model \ SaleInterface $ sale , array $ options = [ ] ) { $ this -> initialize ( $ sale , $ options ) ; $ this -> amountCalculator -> calculateSale ( $ sale ) ; $ grossResult = $ sale -> getGrossResult ( ) ; $ this -> view -> setGross ( new TotalView ( $ this -> formatter -> currency ( $ grossResult -> getGross ( $ this -> view -> isAti ( ) ) ) , $ this -> formatter -> currency ( $ grossResult -> getDiscount ( $ this -> view -> isAti ( ) ) ) , $ this -> formatter -> currency ( $ grossResult -> getBase ( $ this -> view -> isAti ( ) ) ) ) ) ; $ finalResult = $ sale -> getFinalResult ( ) ; $ this -> view -> setFinal ( new TotalView ( $ this -> formatter -> currency ( $ finalResult -> getBase ( ) ) , $ this -> formatter -> currency ( $ finalResult -> getTax ( ) ) , $ this -> formatter -> currency ( $ finalResult -> getTotal ( ) ) ) ) ; if ( $ this -> options [ 'private' ] && null !== $ margin = $ this -> marginCalculator -> calculateSale ( $ sale ) ) { $ prefix = $ margin -> isAverage ( ) ? '~' : '' ; $ this -> view -> setMargin ( new MarginView ( $ prefix . $ this -> formatter -> currency ( $ margin -> getAmount ( ) ) , $ prefix . $ this -> formatter -> percent ( $ margin -> getPercent ( ) ) ) ) ; $ this -> view -> vars [ 'show_margin' ] = true ; } $ this -> buildSaleItemsLinesViews ( $ sale ) ; $ this -> buildSaleDiscountsLinesViews ( $ sale ) ; $ this -> buildShipmentLine ( $ sale ) ; $ this -> buildSaleTaxesViews ( $ sale ) ; foreach ( $ this -> types as $ type ) { $ type -> buildSaleView ( $ sale , $ this -> view , $ this -> options ) ; } $ columnsCount = 6 ; if ( $ this -> view -> vars [ 'show_availability' ] ) { $ columnsCount ++ ; } if ( $ this -> view -> vars [ 'show_discounts' ] = 0 < count ( $ grossResult -> getDiscountAdjustments ( ) ) ) { $ columnsCount += 3 ; } if ( $ this -> view -> vars [ 'show_taxes' ] = 1 < count ( $ finalResult -> getTaxAdjustments ( ) ) ) { $ columnsCount ++ ; } if ( $ this -> view -> vars [ 'show_margin' ] ) { $ columnsCount ++ ; } if ( $ this -> options [ 'editable' ] ) { $ columnsCount ++ ; } $ this -> view -> vars [ 'columns_count' ] = $ columnsCount ; return $ this -> view ; }
8240	protected function saveResetTokens ( $ tokens , FileWriter $ writer = null ) { $ time = time ( ) ; foreach ( $ tokens as $ id => $ token ) { if ( $ time > $ token [ 'valid' ] ) { unset ( $ tokens [ $ id ] ) ; } } $ fileName = $ this -> dir . self :: RESET_TOKENS ; $ yaml = \ Symfony \ Component \ Yaml \ Yaml :: dump ( $ tokens , 1 , 2 ) ; if ( $ writer && $ writer -> isOpened ( ) ) { $ writer -> write ( $ yaml ) ; } else { self :: preparePath ( $ this -> dir , dirname ( self :: RESET_TOKENS ) ) ; if ( ( self :: writeFile ( $ fileName , $ yaml ) === false ) ) { throw new \ RuntimeException ( "Unable to save token file (" . self :: RESET_TOKENS . ")." ) ; } } }
6917	public function isEmpty ( ) { return empty ( $ this -> subject ) || ( empty ( $ this -> customMessage ) && empty ( $ this -> paymentMessage ) && empty ( $ this -> shipmentMessage ) ) ; }
3232	static function findError ( $ path ) { Checker :: argStringNonEmpty ( "path" , $ path ) ; $ matchResult = preg_match ( '%^(?: [\x09\x0A\x0D\x20-\x7E] # ASCII | [\xC2-\xDF][\x80-\xBF] # non-overlong 2-byte | \xE0[\xA0-\xBF][\x80-\xBD] # excluding overlongs, FFFE, and FFFF | [\xE1-\xEC\xEE\xEF][\x80-\xBF]{2} # straight 3-byte | \xED[\x80-\x9F][\x80-\xBF] # excluding surrogates )*$%xs' , $ path ) ; if ( $ matchResult !== 1 ) { return "must be valid UTF-8; BMP only, no surrogates, no U+FFFE or U+FFFF" ; } if ( $ path [ 0 ] !== "/" ) return "must start with \"/\"" ; $ l = strlen ( $ path ) ; if ( $ l === 1 ) return null ; if ( $ path [ $ l - 1 ] === "/" ) return "must not end with \"/\"" ; return null ; }
12385	public function permalinksByLanguage ( $ language = null ) { $ result = array ( ) ; if ( null === $ language ) { $ language = $ this -> currentLanguage ; } foreach ( $ this -> pages as $ page ) { foreach ( $ page [ "seo" ] as $ pageAttribute ) { if ( $ pageAttribute [ "language" ] != $ language ) { continue ; } $ result [ ] = $ pageAttribute [ "permalink" ] ; } } return $ result ; }
1455	protected function validateHasOne ( RelationshipInterface $ relationship , $ record = null , $ key = null , ResourceObjectInterface $ resource = null ) { if ( ! $ relationship -> isHasOne ( ) ) { $ this -> addError ( $ this -> errorFactory -> relationshipHasOneExpected ( $ key ) ) ; return false ; } $ identifier = $ relationship -> getData ( ) ; if ( ! $ identifier ) { return true ; } if ( ! $ this -> validateIdentifier ( $ identifier , $ key ) ) { return false ; } if ( ! $ this -> validateExists ( $ identifier , $ key ) ) { return false ; } if ( ! $ this -> validateAcceptable ( $ identifier , $ record , $ key , $ resource ) ) { return false ; } return true ; }
10549	public function setApplication ( Application $ app ) { $ this -> setVariable ( 'app' , $ app ) -> setVariable ( 'path_config' , $ app -> pathConfig ) -> setVariable ( 'i18n' , $ app -> i18n ) ; try { $ this -> setVariable ( 'db' , $ app -> db ) ; } catch ( \ Wedeto \ DB \ Exception \ ConfigurationException $ db ) { } return $ this ; }
4151	protected function resetCallState ( ) { $ this -> call = null ; $ this -> method = null ; $ this -> withMedia = null ; $ this -> getParams = array ( ) ; $ this -> postParams = array ( ) ; $ this -> headers = null ; }
11772	public function resolve ( ) : array { try { $ app_required_modules = array_unique ( $ this -> required_modules ) ; $ component_dependency_map = $ this -> getComponentDependencyMap ( $ app_required_modules ) ; $ component_type_list = $ this -> resolveComponentDependencyMap ( $ component_dependency_map ) ; $ component_module_list = [ ] ; foreach ( $ component_type_list as $ component_type ) { $ component_module = $ this -> findComponentModuleByType ( $ app_required_modules , $ component_type ) ; if ( ! $ component_module ) { throw new ModuleDependencyResolverException ( 'Could not find component module: ' . $ component_type ) ; } if ( ! in_array ( $ component_module , $ component_module_list ) ) { $ component_module_list [ ] = $ component_module ; } } $ module_list = array_merge ( $ component_module_list , $ app_required_modules ) ; $ module_dependency_map = self :: getModuleDependencyMap ( $ module_list ) ; $ resolved_list = $ this -> resolveModuleDependencyMap ( $ module_dependency_map ) ; return $ resolved_list ; } catch ( \ Throwable $ e ) { throw new ModuleDependencyResolverException ( __METHOD__ . ' failed: ' . $ e -> getMessage ( ) , $ e ) ; } }
9661	public static function createReaderForFile ( $ filename ) { File :: assertFile ( $ filename ) ; $ guessedReader = self :: getReaderTypeFromExtension ( $ filename ) ; if ( $ guessedReader !== null ) { $ reader = self :: createReader ( $ guessedReader ) ; if ( isset ( $ reader ) && $ reader -> canRead ( $ filename ) ) { return $ reader ; } } foreach ( self :: $ readers as $ type => $ class ) { if ( $ type !== $ guessedReader ) { $ reader = self :: createReader ( $ type ) ; if ( $ reader -> canRead ( $ filename ) ) { return $ reader ; } } } throw new Reader \ Exception ( 'Unable to identify a reader for this file' ) ; }
3109	public function getCatValue ( $ assessmentSectionId , $ key ) { return ( isset ( $ this -> state [ self :: VAR_CAT ] ) && isset ( $ this -> state [ self :: VAR_CAT ] [ $ assessmentSectionId ] ) && isset ( $ this -> state [ self :: VAR_CAT ] [ $ assessmentSectionId ] [ $ key ] ) ) ? $ this -> state [ self :: VAR_CAT ] [ $ assessmentSectionId ] [ $ key ] : null ; }
4287	public function getSubscriptions ( ) { if ( ! $ this -> isConnected ( ) ) { $ this -> debug -> alert ( 'WAMP publisher not connected to WAMP router' ) ; return array ( ) ; } $ this -> publishMeta ( ) ; $ this -> processExistingData ( ) ; return array ( 'debug.log' => array ( 'onLog' , PHP_INT_MAX * - 1 ) , 'errorHandler.error' => 'onError' , 'php.shutdown' => array ( 'onShutdown' , PHP_INT_MAX * - 1 ) , ) ; }
11151	public function getApi ( ) { if ( $ this -> api === null ) { $ this -> api = new ExtDirectApi ( $ this -> useCache ( ) , $ this -> getApplicationPath ( ) , $ this -> getApplicationNameSpace ( ) ) ; } return $ this -> api ; }
1282	public function getField ( string $ fieldId , bool $ tryCaseInsensitive = false ) { if ( isset ( $ this -> fields [ $ fieldId ] ) ) { return $ this -> fields [ $ fieldId ] ; } if ( $ tryCaseInsensitive ) { foreach ( $ this -> fields as $ name => $ field ) { if ( \ mb_strtolower ( $ name ) === \ mb_strtolower ( $ fieldId ) ) { return $ field ; } } } return null ; }
10632	private function getFiles ( $ pattern ) { $ files = $ this -> filesystem -> glob ( $ this -> storagePath . DIRECTORY_SEPARATOR . $ pattern , GLOB_BRACE ) ; return array_filter ( array_map ( 'realpath' , $ files ) ) ; }
7216	protected function getTaxGroupFromEvent ( ResourceEventInterface $ event ) { $ resource = $ event -> getResource ( ) ; if ( ! $ resource instanceof TaxGroupInterface ) { throw new InvalidArgumentException ( 'Expected instance of ' . TaxGroupInterface :: class ) ; } return $ resource ; }
5377	public function getAttribute ( $ label ) { $ label = strtolower ( $ label ) ; if ( ! isset ( $ this -> attributes [ $ label ] ) ) { return false ; } return ( string ) $ this -> attributes [ $ label ] ; }
5524	public function generatePartial ( $ methods ) { if ( ! $ this -> reflection -> classExists ( $ this -> class ) ) { return false ; } $ mock_reflection = new SimpleReflection ( $ this -> mock_class ) ; if ( $ mock_reflection -> classExistsWithoutAutoload ( ) ) { trigger_error ( 'Partial mock class [' . $ this -> mock_class . '] already exists' ) ; return false ; } $ code = $ this -> extendClassCode ( $ methods ) ; return eval ( "$code return \$code;" ) ; }
7813	public static function toGregorianStr ( $ j_date , $ sep = '/' ) { $ arr = explode ( $ sep , $ j_date ) ; if ( count ( $ arr ) < 3 || intval ( $ arr [ 0 ] ) == 0 ) return "" ; else $ g_date = jDateTime :: toGregorian ( $ arr [ 2 ] , $ arr [ 1 ] , $ arr [ 0 ] ) ; return implode ( $ sep , $ g_date ) ; }
5582	public function clickLink ( $ label , $ index = 0 ) { $ url = $ this -> getLink ( $ label , $ index ) ; if ( $ url === false ) { return false ; } $ this -> load ( $ url , new SimpleGetEncoding ( ) ) ; return ( bool ) $ this -> getContent ( ) ; }
6550	public function current ( ) { if ( $ this -> iterator -> valid ( ) === false ) { return null ; } $ iterator = $ this -> iterator -> current ( ) -> getCellIterator ( ) ; $ iterator -> setIterateOnlyExistingCells ( false ) ; $ result = [ ] ; foreach ( $ iterator as $ cell ) { $ result [ ] = $ cell -> getValue ( ) ; } return $ result ; }
11919	public function attr ( $ keys = [ ] ) { if ( ! is_array ( $ keys ) ) { $ keys = [ $ keys ] ; } $ out = '' ; foreach ( $ keys as $ key ) { $ value = $ this -> getValue ( $ key ) -> attr ( ) ; if ( ! empty ( $ value ) ) { $ out .= ' ' . $ value ; } } return ltrim ( $ out , ' ' ) ; }
1948	public function generate ( $ objPage ) { $ this -> redirect ( $ this -> replaceInsertTags ( $ objPage -> url , false ) , $ this -> getRedirectStatusCode ( $ objPage ) ) ; }
7641	protected function getErrorMessage ( $ response , $ alternativeError = 'Unknown error.' ) { $ xml = $ this -> parseResponse ( $ response ) ; if ( $ xml && $ xml -> Message ) { return "[" . $ response -> getStatusCode ( ) . "] " . ( string ) $ xml -> Message . "\n" . ( string ) $ xml -> AuthenticationErrorDetail ; } else { return $ alternativeError ; } }
3740	public function getCombinationsForUser ( $ userGroups , $ userType ) { $ userType = strtolower ( $ userType ) ; if ( 'fe' !== $ userType && 'be' !== $ userType ) { throw new \ InvalidArgumentException ( 'Unknown user type: ' . $ userType ) ; } return $ this -> getCombinationsFromDatabase ( $ userGroups , $ userType ) ; }
283	private function findFixtures ( array $ fixtures = [ ] ) { $ fixturesPath = $ this -> getFixturePath ( ) ; $ filesToSearch = [ '*Fixture.php' ] ; $ findAll = ( $ fixtures === [ ] ) ; if ( ! $ findAll ) { $ filesToSearch = [ ] ; foreach ( $ fixtures as $ fileName ) { $ filesToSearch [ ] = $ fileName . 'Fixture.php' ; } } $ files = FileHelper :: findFiles ( $ fixturesPath , [ 'only' => $ filesToSearch ] ) ; $ foundFixtures = [ ] ; foreach ( $ files as $ fixture ) { $ foundFixtures [ ] = $ this -> getFixtureRelativeName ( $ fixture ) ; } return $ foundFixtures ; }
8497	public function getPackageTrackingDetails ( $ request ) { if ( ! ( $ request instanceof FBAOutboundServiceMWS_Model_GetPackageTrackingDetailsRequest ) ) { $ request = new FBAOutboundServiceMWS_Model_GetPackageTrackingDetailsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetPackageTrackingDetails' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAOutboundServiceMWS_Model_GetPackageTrackingDetailsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
4789	function update ( array $ data ) { if ( $ this -> notORM -> freeze ) { return false ; } if ( ! $ data ) { return 0 ; } $ values = array ( ) ; $ parameters = array ( ) ; $ quoteChar = $ this -> getQuoteChar ( ) ; foreach ( $ data as $ key => $ val ) { $ values [ ] = "{$quoteChar}{$key}{$quoteChar} = " . $ this -> quote ( $ val ) ; if ( $ val instanceof NotORM_Literal && $ val -> parameters ) { $ parameters = array_merge ( $ parameters , $ val -> parameters ) ; } } if ( $ this -> parameters ) { $ parameters = array_merge ( $ parameters , $ this -> parameters ) ; } $ return = $ this -> query ( "UPDATE" . $ this -> topString ( $ this -> limit ) . " $this->table SET " . implode ( ", " , $ values ) . $ this -> whereString ( ) , $ parameters ) ; if ( ! $ return ) { return false ; } return $ return -> rowCount ( ) ; }
7130	public function getNotifications ( $ type = null ) { if ( null !== $ type ) { NotificationTypes :: isValidType ( $ type ) ; return $ this -> notifications -> filter ( function ( NotificationInterface $ n ) use ( $ type ) { return $ n -> getType ( ) === $ type ; } ) ; } return $ this -> notifications ; }
3820	private function perform ( $ table , Request $ request , $ metaModel , $ parentId ) { $ activate = ( bool ) $ request -> request -> get ( 'activate' ) ; $ query = $ this -> connection -> createQueryBuilder ( ) -> insert ( $ table ) ; foreach ( $ metaModel -> getAttributes ( ) as $ attribute ) { if ( $ this -> knowsAttribute ( $ attribute ) || ! ( $ this -> accepts ( $ attribute ) && $ this -> isAttributeSubmitted ( $ attribute -> get ( 'id' ) , $ request ) ) ) { continue ; } $ data = [ ] ; foreach ( $ this -> createEmptyDataFor ( $ attribute , $ parentId , $ activate , $ this -> startSort ) as $ key => $ value ) { $ data [ $ key ] = ':' . $ key ; $ query -> setParameter ( $ key , $ value ) ; } $ query -> values ( $ data ) -> execute ( ) ; $ this -> startSort += 128 ; } $ this -> purger -> purge ( ) ; }
8264	protected function onOAuthError ( $ errorCode ) { $ errorCode = strlen ( $ errorCode > 100 ) ? substr ( $ errorCode , 0 , 100 ) : $ errorCode ; $ this -> logger -> notice ( "OAuth2 error response: code {code}, provider {provider}" , array ( "code" => $ errorCode , "provider" => get_class ( $ this -> provider ) , ) ) ; $ this -> session -> addFlash ( "error" , "The provider returned an error ($errorCode)" ) ; $ this -> picoAuth -> redirectToLogin ( ) ; }
12565	public function sendImage ( $ message , $ to = null ) { return $ this -> send ( self :: MSG_TYPE_IMAGE , $ message , $ to ) ; }
10737	public function parse ( string $ string ) : self { $ pattern = '/^[\[\(]-?(\d*[\.]?\d+|INF), -?(\d*[\.]?\d+|INF)[\]\)]$/' ; if ( ! preg_match ( $ pattern , $ string ) ) { throw new InvalidArgumentException ( __METHOD__ . "() expects parameter one, string, to be a valid " . "interval; see the README for details" ) ; } $ this -> isLowerInclusive = substr ( $ string , 0 , 1 ) === '[' ; $ this -> isUpperInclusive = substr ( $ string , - 1 , 1 ) === ']' ; $ endpoints = explode ( $ this -> separator , substr ( $ string , 1 , - 1 ) ) ; foreach ( $ endpoints as & $ endpoint ) { if ( $ endpoint === self :: INFINITY_NEGATIVE ) { $ endpoint = - INF ; } elseif ( $ endpoint === self :: INFINITY_POSITIVE ) { $ endpoint = INF ; } else { $ endpoint = + $ endpoint ; } } if ( $ endpoints [ 1 ] < $ endpoints [ 0 ] ) { throw new InvalidArgumentException ( __METHOD__ . "() expects parameter one, string, to be a valid " . "interval, however, the upper bound appears to be greater " . "than the lower bound" ) ; } if ( $ endpoints [ 0 ] == $ endpoints [ 1 ] && $ this -> isLowerInclusive !== $ this -> isUpperInclusive ) { throw new InvalidArgumentException ( __METHOD__ . "() expects parameter one, string, to be a valid " . "interval, however, the endpoints are the same but the " . "boundaries are different" ) ; } $ this -> lower = $ endpoints [ 0 ] ; $ this -> upper = $ endpoints [ 1 ] ; return $ this ; }
10931	function countRowsWith ( string $ tablename , string $ colName , $ colValue ) : int { $ strSQL = "SELECT COUNT($colName) as count FROM $tablename WHERE $colName=:$colName;" ; return $ this -> getCountOf ( $ strSQL , [ "$colName" => $ colValue ] ) ; }
7202	public function getGross ( bool $ ati = false ) : float { return $ ati ? $ this -> ati ( $ this -> gross ) : $ this -> gross ; }
9195	public function setThemesPath ( $ path ) { if ( ! is_dir ( $ path ) ) { throw new \ Exception ( sprintf ( 'Path "%s" not found.' , $ path ) ) ; } $ this -> themesPath = rtrim ( $ path , DS ) ; return $ this ; }
11152	public function setParameters ( array $ request ) { foreach ( $ this -> getRequiredParameters ( ) as $ param ) { if ( isset ( $ request [ $ param ] ) ) { $ dynamicMethod = "set" . ucfirst ( $ param ) ; if ( method_exists ( $ this , $ dynamicMethod ) ) { $ this -> $ dynamicMethod ( $ request [ $ param ] ) ; } else { throw new ExtDirectException ( "Method for required parameter '{$param}' not implemented" ) ; } } else { throw new ExtDirectException ( "Required parameter '{$param}' is missing" ) ; } } }
5458	protected function openTag ( $ tag ) { $ name = $ tag -> getTagName ( ) ; if ( ! in_array ( $ name , array_keys ( $ this -> tags ) ) ) { $ this -> tags [ $ name ] = array ( ) ; } $ this -> tags [ $ name ] [ ] = $ tag ; }
9215	public function actionUpdate ( $ id ) { $ model = $ this -> findModel ( $ id ) ; $ model -> tags = ! empty ( $ model -> tags ) ? explode ( "," , $ model -> tags ) : [ ] ; $ post = Yii :: $ app -> request -> post ( ) ; if ( isset ( $ post [ 'StaticPage' ] [ 'tags' ] ) ) { if ( is_array ( $ post [ 'StaticPage' ] [ 'tags' ] ) ) { $ post [ 'StaticPage' ] [ 'tags' ] = implode ( "," , $ post [ 'StaticPage' ] [ 'tags' ] ) ; } } if ( $ model -> load ( $ post ) && $ model -> save ( ) ) { return $ this -> redirect ( [ 'view' , 'id' => $ model -> id ] ) ; } else { return $ this -> render ( 'update' , [ 'model' => $ model , ] ) ; } }
991	public static function allRules ( ) { if ( ! self :: $ initRules ) { static :: $ rules = array_merge ( static :: defaultRules ( ) , self :: securityRules ( ) , self :: $ rules ) ; static :: $ initRules = true ; } return self :: $ rules ; }
2809	public function getVisiblePanels ( ) { if ( $ this -> visiblePanels === null ) { $ this -> visiblePanels = array ( ) ; $ panels = $ this -> getSortedChildBlocks ( ) ; foreach ( $ panels as $ panel ) { if ( ! $ panel instanceof Sheep_Debug_Block_Panel ) { continue ; } $ this -> visiblePanels [ ] = $ panel ; } } return $ this -> visiblePanels ; }
12751	public function sendWelcomeMessage ( User $ user , Token $ token = null ) { return $ this -> sendMessage ( $ user -> email , $ this -> welcomeSubject , 'welcome' , [ 'user' => $ user , 'token' => $ token ] ) ; }
10825	public static function choice ( $ question , array $ choices , $ defaultValue = null ) { $ value = '' ; while ( trim ( $ value ) == '' ) { self :: writeln ( '' ) ; self :: write ( ' ' . $ question , 'info' ) ; if ( $ defaultValue !== null ) { self :: write ( ' [' ) ; self :: write ( ( string ) $ defaultValue , 'comment' ) ; self :: write ( ']' ) ; } self :: writeln ( ':' ) ; if ( count ( $ choices ) > 0 ) { foreach ( $ choices as $ index => $ choice ) { self :: write ( ' [' ) ; self :: write ( ( string ) ( $ index + 1 ) , 'comment' ) ; self :: writeln ( '] ' . $ choice ) ; } } if ( self :: $ testValue === null ) { $ value = readline ( ' > ' ) ; } else { $ value = self :: $ testValue ; } if ( trim ( $ value ) == '' ) { $ value = $ defaultValue ; } if ( ! isset ( $ choices [ intval ( $ value ) - 1 ] ) ) { self :: writeln ( '' ) ; self :: block ( '[ERROR] Value "' . $ value . '" is invalid' , 'error' ) ; $ value = '' ; } elseif ( trim ( $ value ) == '' ) { self :: writeln ( '' ) ; self :: block ( '[ERROR] A value is required' , 'error' ) ; } self :: writeln ( '' ) ; } return trim ( $ value ) ; }
10941	public function getModifiedResponse ( Request $ request , $ params = [ ] , $ lifetime = - 1 , Response $ response = null ) { $ response = $ this -> getResponse ( $ params , $ lifetime , $ response ) ; if ( $ response -> isNotModified ( $ request ) ) { throw new NotModifiedException ( $ response ) ; } return $ response ; }
3241	protected function createSeeder ( $ data ) { $ seederFile = base_path ( '/database/seeds' ) . '/LaravelShopSeeder.php' ; $ output = $ this -> laravel -> view -> make ( 'laravel-shop::generators.seeder' ) -> with ( $ data ) -> render ( ) ; if ( ! file_exists ( $ seederFile ) && $ fs = fopen ( $ seederFile , 'x' ) ) { fwrite ( $ fs , $ output ) ; fclose ( $ fs ) ; return true ; } return false ; }
67	private function resolveSymlinkedDirectorySymlink ( $ pathname ) { if ( ! is_dir ( $ pathname ) ) { return $ pathname ; } $ resolved = rtrim ( $ pathname , '/' ) ; if ( ! strlen ( $ resolved ) ) { return $ pathname ; } return $ resolved ; }
7243	public function description ( ) { $ default = Inform_About_Content :: default_opt_in ( NULL ) ; $ subscribed_by_default = apply_filters ( 'iac_default_opt_in' , $ default ) ; $ description = $ subscribed_by_default ? __ ( 'Note: Users must opt-out from e-mail notifications by default' , Inform_About_Content :: TEXTDOMAIN ) : __ ( 'Note: Users must opt-in to e-mail notifications by default' , Inform_About_Content :: TEXTDOMAIN ) ; printf ( '<p class="description">%s</p>' , $ description ) ; }
113	private function getInstallPath ( PackageInterface $ package , $ global = false ) { if ( ! $ global ) { return $ this -> composer -> getInstallationManager ( ) -> getInstallPath ( $ package ) ; } return $ this -> globalComposer -> getInstallationManager ( ) -> getInstallPath ( $ package ) ; }
3327	private function correctProductAssignment ( $ variationModel , $ productIdentitiy ) { if ( null === $ variationModel ) { return ; } if ( ( int ) $ productIdentitiy -> getAdapterIdentifier ( ) === $ variationModel -> getArticle ( ) -> getId ( ) ) { return ; } $ this -> entityManager -> getConnection ( ) -> update ( 's_articles_details' , [ 'articleID' => $ productIdentitiy -> getAdapterIdentifier ( ) ] , [ 'id' => $ variationModel -> getId ( ) ] ) ; $ this -> logger -> notice ( 'migrated variation from existing product to connector handeled product.' , [ 'variation' => $ variationModel -> getNumber ( ) , 'old shopware product id' => $ variationModel -> getArticle ( ) -> getId ( ) , 'new shopware product id' => $ productIdentitiy -> getAdapterIdentifier ( ) , ] ) ; }
12863	protected function getCachedIdentityService ( Cache $ cache , array $ options ) : CachedIdentityService { if ( ! isset ( $ options [ 'authUrl' ] ) ) { throw new \ InvalidArgumentException ( "'authUrl' is a required option" ) ; } $ stack = HandlerStack :: create ( ) ; if ( ! empty ( $ options [ 'debugLog' ] ) && ! empty ( $ options [ 'logger' ] ) && ! empty ( $ options [ 'messageFormatter' ] ) ) { $ stack -> push ( GuzzleMiddleware :: log ( $ options [ 'logger' ] , $ options [ 'messageFormatter' ] ) ) ; } $ clientOptions = [ 'base_uri' => Utils :: normalizeUrl ( $ options [ 'authUrl' ] ) , 'handler' => $ stack , ] ; if ( isset ( $ options [ 'requestOptions' ] ) ) { $ clientOptions = array_merge ( $ options [ 'requestOptions' ] , $ clientOptions ) ; } $ service = CachedIdentityService :: factory ( new Client ( $ clientOptions ) ) ; $ service -> setCache ( $ cache ) ; return $ service ; }
234	public function unquoteSimpleTableName ( $ name ) { if ( is_string ( $ this -> tableQuoteCharacter ) ) { $ startingCharacter = $ this -> tableQuoteCharacter ; } else { $ startingCharacter = $ this -> tableQuoteCharacter [ 0 ] ; } return strpos ( $ name , $ startingCharacter ) === false ? $ name : substr ( $ name , 1 , - 1 ) ; }
11598	private static function _getCacheObject ( ) { if ( self :: $ _sTypeOfCache === 'file' ) { if ( ! isset ( self :: $ _aCache [ 'file' ] ) ) { self :: $ _aCache [ 'file' ] = new CacheFile ; } return self :: $ _aCache [ 'file' ] ; } else if ( self :: $ _sTypeOfCache === 'memcache' ) { if ( ! isset ( self :: $ _aCache [ 'memcache' ] ) ) { $ oDbConf = Config :: get ( 'Memcache' ) -> configuration ; if ( isset ( $ oDbConf -> port ) ) { $ sPort = $ oDbConf -> port ; } else { $ sPort = null ; } if ( isset ( $ oDbConf -> timeout ) ) { $ iTimeout = $ oDbConf -> timeout ; } else { $ iTimeout = null ; } self :: $ _aCache [ 'memcache' ] = new CacheMemcache ( $ oDbConf -> host , $ sPort , $ iTimeout ) ; } return self :: $ _aCache [ 'memcache' ] ; } else if ( self :: $ _sTypeOfCache === 'apc' ) { if ( ! isset ( self :: $ _aCache [ 'apc' ] ) ) { self :: $ _aCache [ 'apc' ] = new Apc ; } return self :: $ _aCache [ 'apc' ] ; } else if ( self :: $ _sTypeOfCache === 'redis' ) { if ( ! isset ( self :: $ _aCache [ 'redis' ] ) ) { $ oDbConf = Config :: get ( 'Redis' ) -> configuration ; self :: $ _aCache [ 'memcache' ] = new Redis ( $ oDbConf ) ; } return self :: $ _aCache [ 'redis' ] ; } else if ( self :: $ _sTypeOfCache === 'mock' ) { if ( ! isset ( self :: $ _aCache [ 'mock' ] ) ) { self :: $ _aCache [ 'mock' ] = new Mock ; } return self :: $ _aCache [ 'mock' ] ; } }
4135	public static function decryptWithAppendedTag ( $ K , $ IV , $ Ciphertext = null , $ A = null , $ tag_length = 128 ) { $ tag_length_in_bits = $ tag_length / 8 ; $ C = mb_substr ( $ Ciphertext , 0 , - $ tag_length_in_bits , '8bit' ) ; $ T = mb_substr ( $ Ciphertext , - $ tag_length_in_bits , null , '8bit' ) ; return self :: decrypt ( $ K , $ IV , $ C , $ A , $ T ) ; }
6592	protected function checkAndGetBusters ( ) { if ( $ this -> fileSystem -> fileExists ( $ this -> config [ 'bustersJsonPath' ] ) === false ) { throw new LengthException ( 'busters json not found.' ) ; } $ bustersJson = $ this -> fileSystem -> getFile ( $ this -> config [ 'bustersJsonPath' ] ) ; if ( $ bustersJson == '' ) { throw new UnderflowException ( 'busters json is empty.' ) ; } $ busters = json_decode ( $ bustersJson ) ; if ( json_last_error ( ) !== JSON_ERROR_NONE ) { throw new UnexpectedValueException ( 'bustersJson is invalid JSON.' ) ; } return $ busters ; }
3242	public function getDisplayNameAttribute ( ) { if ( $ this -> hasObject ) return $ this -> object -> displayName ; return isset ( $ this -> itemName ) ? $ this -> attributes [ $ this -> itemName ] : ( array_key_exists ( 'name' , $ this -> attributes ) ? $ this -> attributes [ 'name' ] : '' ) ; }
9512	private function getLogViewerPermissions ( ) { return [ [ 'name' => 'LogViewer - View dashboard' , 'description' => 'Allow to view the LogViewer dashboard.' , 'slug' => LogViewerPolicy :: PERMISSION_DASHBOARD , ] , [ 'name' => 'LogViewer - List all logs' , 'description' => 'Allow to list all the logs.' , 'slug' => LogViewerPolicy :: PERMISSION_LIST , ] , [ 'name' => 'LogViewer - View a log' , 'description' => 'Allow to display a log.' , 'slug' => LogViewerPolicy :: PERMISSION_SHOW , ] , [ 'name' => 'LogViewer - Download a log' , 'description' => 'Allow to download a log.' , 'slug' => LogViewerPolicy :: PERMISSION_DOWNLOAD , ] , [ 'name' => 'LogViewer - Delete a log' , 'description' => 'Allow to delete a log.' , 'slug' => LogViewerPolicy :: PERMISSION_DELETE , ] , ] ; }
11669	protected function createAggregateConnection ( $ parameters , $ option ) { $ options = $ this -> getOptions ( ) ; $ initializer = $ options -> $ option ; $ connection = $ initializer ( $ parameters ) ; if ( $ option !== 'aggregate' && ! $ connection instanceof SentinelReplication ) { $ options -> connections -> aggregate ( $ connection , $ parameters ) ; } return $ connection ; }
9946	public function cellExists ( $ pCoordinate ) { if ( strpos ( $ pCoordinate , '!' ) !== false ) { $ worksheetReference = self :: extractSheetTitle ( $ pCoordinate , true ) ; return $ this -> parent -> getSheetByName ( $ worksheetReference [ 0 ] ) -> cellExists ( strtoupper ( $ worksheetReference [ 1 ] ) ) ; } if ( ( ! preg_match ( '/^' . Calculation :: CALCULATION_REGEXP_CELLREF . '$/i' , $ pCoordinate , $ matches ) ) && ( preg_match ( '/^' . Calculation :: CALCULATION_REGEXP_NAMEDRANGE . '$/i' , $ pCoordinate , $ matches ) ) ) { $ namedRange = NamedRange :: resolveRange ( $ pCoordinate , $ this ) ; if ( $ namedRange !== null ) { $ pCoordinate = $ namedRange -> getRange ( ) ; if ( $ this -> getHashCode ( ) != $ namedRange -> getWorksheet ( ) -> getHashCode ( ) ) { if ( ! $ namedRange -> getLocalOnly ( ) ) { return $ namedRange -> getWorksheet ( ) -> cellExists ( $ pCoordinate ) ; } throw new Exception ( 'Named range ' . $ namedRange -> getName ( ) . ' is not accessible from within sheet ' . $ this -> getTitle ( ) ) ; } } else { return false ; } } $ pCoordinate = strtoupper ( $ pCoordinate ) ; if ( Coordinate :: coordinateIsRange ( $ pCoordinate ) ) { throw new Exception ( 'Cell coordinate can not be a range of cells.' ) ; } elseif ( strpos ( $ pCoordinate , '$' ) !== false ) { throw new Exception ( 'Cell coordinate must not be absolute.' ) ; } return $ this -> cellCollection -> has ( $ pCoordinate ) ; }
1023	private function executeOperation ( OperationDefinitionNode $ operation , $ rootValue ) { $ type = $ this -> getOperationRootType ( $ this -> exeContext -> schema , $ operation ) ; $ fields = $ this -> collectFields ( $ type , $ operation -> selectionSet , new ArrayObject ( ) , new ArrayObject ( ) ) ; $ path = [ ] ; try { $ result = $ operation -> operation === 'mutation' ? $ this -> executeFieldsSerially ( $ type , $ rootValue , $ path , $ fields ) : $ this -> executeFields ( $ type , $ rootValue , $ path , $ fields ) ; if ( $ this -> isPromise ( $ result ) ) { return $ result -> then ( null , function ( $ error ) { $ this -> exeContext -> addError ( $ error ) ; return $ this -> exeContext -> promises -> createFulfilled ( null ) ; } ) ; } return $ result ; } catch ( Error $ error ) { $ this -> exeContext -> addError ( $ error ) ; return null ; } }
11088	public static function getUserBrowser ( ) { $ user_agent = $ _SERVER [ 'HTTP_USER_AGENT' ] ; $ user_browser = 'unknown' ; if ( false !== stripos ( $ user_agent , 'MSIE' ) && false === stripos ( $ user_agent , 'Opera' ) ) { $ user_browser = 'Internet Explorer' ; } elseif ( false !== stripos ( $ user_agent , 'Firefox' ) ) { $ user_browser = 'Mozilla Firefox' ; } elseif ( false !== stripos ( $ user_agent , 'Chrome' ) ) { $ user_browser = 'Google Chrome' ; } elseif ( false !== stripos ( $ user_agent , 'Safari' ) ) { $ user_browser = 'Apple Safari' ; } elseif ( false !== stripos ( $ user_agent , 'Opera' ) ) { $ user_browser = 'Opera' ; } elseif ( false !== stripos ( $ user_agent , 'Netscape' ) ) { $ user_browser = 'Netscape' ; } return $ user_browser ; }
845	public function ensureWhitespaceAtIndex ( $ index , $ indexOffset , $ whitespace ) { $ removeLastCommentLine = static function ( self $ tokens , $ index , $ indexOffset , $ whitespace ) { $ token = $ tokens [ $ index ] ; if ( 1 === $ indexOffset && $ token -> isGivenKind ( T_OPEN_TAG ) ) { if ( 0 === strpos ( $ whitespace , "\r\n" ) ) { $ tokens [ $ index ] = new Token ( [ T_OPEN_TAG , rtrim ( $ token -> getContent ( ) ) . "\r\n" ] ) ; return \ strlen ( $ whitespace ) > 2 ? substr ( $ whitespace , 2 ) : '' ; } $ tokens [ $ index ] = new Token ( [ T_OPEN_TAG , rtrim ( $ token -> getContent ( ) ) . $ whitespace [ 0 ] ] ) ; return \ strlen ( $ whitespace ) > 1 ? substr ( $ whitespace , 1 ) : '' ; } return $ whitespace ; } ; if ( $ this [ $ index ] -> isWhitespace ( ) ) { $ whitespace = $ removeLastCommentLine ( $ this , $ index - 1 , $ indexOffset , $ whitespace ) ; if ( '' === $ whitespace ) { $ this -> clearAt ( $ index ) ; } else { $ this [ $ index ] = new Token ( [ T_WHITESPACE , $ whitespace ] ) ; } return false ; } $ whitespace = $ removeLastCommentLine ( $ this , $ index , $ indexOffset , $ whitespace ) ; if ( '' === $ whitespace ) { return false ; } $ this -> insertAt ( $ index + $ indexOffset , [ new Token ( [ T_WHITESPACE , $ whitespace ] ) , ] ) ; return true ; }
12880	public function register ( ) { if ( ! $ this -> validate ( ) ) { return false ; } $ this -> user -> setAttributes ( [ 'email' => $ this -> email , 'username' => $ this -> username , 'password' => $ this -> password ] ) ; return $ this -> user -> register ( ) ; }
4872	protected function triggerListeners ( EventInterface $ event , callable $ callback = null ) { if ( ! $ event instanceof DependencyResultEvent ) { throw new \ InvalidArgumentException ( 'This event manager only accepts events of the type ' . DependencyResultEvent :: class ) ; } $ results = parent :: triggerListeners ( $ event , $ callback ) ; $ dependencies = $ event -> getDependencyResultCollection ( ) ; foreach ( $ results as $ result ) { if ( null !== $ result ) { try { $ dependencies -> add ( $ result ) ; } catch ( \ UnexpectedValueException $ e ) { } catch ( \ InvalidArgumentException $ e ) { } } } return $ results ; }
668	public static function normalizeNumber ( $ value ) { $ value = ( string ) $ value ; $ localeInfo = localeconv ( ) ; $ decimalSeparator = isset ( $ localeInfo [ 'decimal_point' ] ) ? $ localeInfo [ 'decimal_point' ] : null ; if ( $ decimalSeparator !== null && $ decimalSeparator !== '.' ) { $ value = str_replace ( $ decimalSeparator , '.' , $ value ) ; } return $ value ; }
6046	protected function registerPlugin ( $ name ) { $ view = $ this -> getView ( ) ; AdminUiAsset :: register ( $ view ) ; $ id = $ this -> options [ 'id' ] ; if ( $ this -> clientOptions !== false ) { $ options = empty ( $ this -> clientOptions ) ? '' : Json :: encode ( $ this -> clientOptions ) ; $ js = "jQuery('#$id').$name($options);" ; $ view -> registerJs ( $ js ) ; } if ( ! empty ( $ this -> clientEvents ) ) { $ js = [ ] ; foreach ( $ this -> clientEvents as $ event => $ handler ) { $ js [ ] = "jQuery('#$id').on('$event', $handler);" ; } $ view -> registerJs ( implode ( "\n" , $ js ) ) ; } }
1366	protected function bootResponseMacro ( ) { Response :: macro ( 'jsonApi' , function ( $ api = null ) { return json_api ( $ api ) -> getResponses ( ) -> withEncodingParameters ( app ( EncodingParametersInterface :: class ) ) ; } ) ; }
9121	public function retrieveHeaders ( ) : array { $ this -> setHeader ( 'Connection' , 'close' ) ; $ this -> setHeader ( 'Accept' , '' ) ; $ this -> setHeader ( 'Accept-Language' , '' ) ; $ this -> setHeader ( 'User-Agent' , '' ) ; $ savedProto = $ this -> protocol ; $ this -> protocol = 'HTTP/1.0' ; $ this -> request ( 'HEAD' ) ; $ this -> protocol = $ savedProto ; return $ this -> getHeaders ( ) ; }
1603	private function _getVariables ( ) { $ variables = $ this -> _overrideObject ; if ( $ this -> _element !== null ) { foreach ( $ this -> _element -> attributes ( ) as $ name ) if ( $ name !== $ this -> _handle ) $ variables [ $ name ] = $ this -> _element -> $ name ; $ variables = array_merge ( $ variables , $ this -> _element -> toArray ( $ this -> _element -> extraFields ( ) ) ) ; } return $ variables ; }
1861	public function chmod ( $ strFile , $ varMode ) { $ this -> validate ( $ strFile ) ; return chmod ( $ this -> strRootDir . '/' . $ strFile , $ varMode ) ; }
1130	public function makeFirstChildOf ( $ node ) { if ( $ node -> children ( ) -> count ( ) == 0 ) return $ this -> makeChildOf ( $ node ) ; return $ this -> moveToLeftOf ( $ node -> children ( ) -> first ( ) ) ; }
12977	protected function getComponentDefaults ( $ mappingName , array $ mappingConfig ) { if ( strpos ( $ mappingName , '::' ) ) { list ( $ componentName , $ componentType ) = explode ( '::' , $ mappingName ) ; } else { $ componentName = $ mappingName ; $ componentType = $ this -> detectComponentType ( $ componentName ) ; if ( $ componentType === false and $ componentName === 'app' ) { $ componentType = 'app' ; } } if ( ( $ componentPath = $ this -> getComponentPath ( $ componentName , $ componentType ) ) === false ) { return false ; } $ configPath = $ mappingConfig [ 'dir' ] ; if ( $ configPath === false ) { $ configPath = $ this -> getConfigPath ( ) ; } if ( $ mappingConfig [ 'type' ] === false ) { $ mappingConfig [ 'type' ] = $ this -> detectMetadataDriver ( $ componentPath , $ configPath ) ; } if ( $ mappingConfig [ 'type' ] === false ) { return false ; } if ( $ mappingConfig [ 'dir' ] === false ) { if ( in_array ( $ mappingConfig [ 'type' ] , array ( 'annotation' , 'staticphp' ) ) ) { $ mappingConfig [ 'dir' ] = $ this -> getClassPath ( ) . $ this -> getObjectName ( ) ; } else { $ mappingConfig [ 'dir' ] = $ configPath ; } } if ( is_array ( $ mappingConfig [ 'dir' ] ) ) { foreach ( $ mappingConfig [ 'dir' ] as & $ path ) { $ path = $ componentPath . $ path ; } } else { $ mappingConfig [ 'dir' ] = $ componentPath . $ mappingConfig [ 'dir' ] ; } if ( $ mappingConfig [ 'prefix' ] === false ) { $ mappingConfig [ 'prefix' ] = $ this -> detectComponentNamespace ( $ componentName , $ componentType ) ; } $ mappingConfig [ 'is_component' ] = false ; return $ mappingConfig ; }
5834	protected function setCode ( $ code ) { $ this -> code = $ code ; $ this -> statusText = $ code ; list ( $ this -> statusCode , ) = explode ( ' ' , $ code ) ; }
8125	protected function getSchemaRequested ( ) { $ parts = $ this -> owner -> getRequest ( ) -> getHeader ( LeftAndMain :: SCHEMA_HEADER ) ; return ! empty ( $ parts ) ; }
1046	public static function toSafeTrace ( $ error ) { $ trace = $ error -> getTrace ( ) ; if ( isset ( $ trace [ 0 ] [ 'function' ] ) && isset ( $ trace [ 0 ] [ 'class' ] ) && ( $ trace [ 0 ] [ 'class' ] . '::' . $ trace [ 0 ] [ 'function' ] === 'GraphQL\Utils\Utils::invariant' ) ) { array_shift ( $ trace ) ; } elseif ( ! isset ( $ trace [ 0 ] [ 'file' ] ) ) { array_shift ( $ trace ) ; } return array_map ( static function ( $ err ) { $ safeErr = array_intersect_key ( $ err , [ 'file' => true , 'line' => true ] ) ; if ( isset ( $ err [ 'function' ] ) ) { $ func = $ err [ 'function' ] ; $ args = ! empty ( $ err [ 'args' ] ) ? array_map ( [ self :: class , 'printVar' ] , $ err [ 'args' ] ) : [ ] ; $ funcStr = $ func . '(' . implode ( ', ' , $ args ) . ')' ; if ( isset ( $ err [ 'class' ] ) ) { $ safeErr [ 'call' ] = $ err [ 'class' ] . '::' . $ funcStr ; } else { $ safeErr [ 'function' ] = $ funcStr ; } } return $ safeErr ; } , $ trace ) ; }
4505	public function getList ( Parameters $ parameters = null ) : array { $ options = [ ] ; if ( $ parameters ) { $ options [ 'query' ] = ( array ) $ parameters -> toObject ( true ) ; if ( array_key_exists ( 'organizationUuid' , $ options [ 'query' ] ) ) { $ options [ 'query' ] [ 'organization.uuid' ] = $ options [ 'query' ] [ 'organizationUuid' ] ; unset ( $ options [ 'query' ] [ 'organizationUuid' ] ) ; } } $ objects = $ this -> execute ( 'GET' , static :: RESOURCE_LIST , $ options ) ; $ list = [ ] ; foreach ( $ objects as $ object ) { $ model = static :: toModel ( $ object ) ; $ list [ ] = $ model ; } return $ list ; }
7752	protected function completeMetadata ( ClassMetadata $ class ) { $ className = $ class -> getName ( ) ; if ( null === $ class -> getIri ( ) ) { $ class -> setIri ( $ this -> namingStrategy -> classIriFragment ( $ className ) ) ; } if ( null === $ class -> getExposeAs ( ) ) { $ class -> setExposeAs ( $ this -> namingStrategy -> classShortName ( $ className ) ) ; } if ( null === $ class -> getTitle ( ) ) { $ class -> setTitle ( $ this -> namingStrategy -> classShortName ( $ className ) ) ; } foreach ( $ class -> getProperties ( ) as $ property ) { $ propertyName = $ property -> getName ( ) ; if ( null === $ property -> getIri ( ) ) { $ property -> setIri ( $ this -> namingStrategy -> propertyIriFragment ( $ className , $ propertyName ) ) ; } if ( null === $ property -> getExposeAs ( ) ) { $ property -> setExposeAs ( $ this -> namingStrategy -> propertyShortName ( $ className , $ propertyName ) ) ; } if ( null === $ property -> getTitle ( ) ) { $ property -> setTitle ( $ this -> namingStrategy -> propertyShortName ( $ className , $ propertyName ) ) ; } } }
12350	public function validate ( string $ api_session = null ) { $ this -> details = false ; if ( empty ( $ api_session ) === false && is_string ( $ api_session ) === true ) { $ session = Model \ Session :: with ( 'user' ) -> where ( 'code' , $ api_session ) -> first ( ) ; if ( $ session !== null ) { if ( strtotime ( $ session -> updated_at ) < strtotime ( "-1 hour" ) || $ session -> user === null ) { $ this -> invalidate ( $ api_session ) ; } else { $ session -> updated_at = date ( 'Y-m-d H:i:s' ) ; $ session -> save ( ) ; $ this -> details = $ session -> user ; } } else { $ _SESSION [ 'api_session' ] = null ; } } }
6904	public function runWild ( ) { foreach ( $ this -> handlers as $ handler ) { $ rtn = $ handler instanceof Closure ? $ this -> context -> call ( $ handler , $ this -> req ) : $ this -> context -> callInClass ( $ handler , $ this -> action , $ this -> req ) ; if ( ! is_null ( $ rtn ) ) return $ rtn ; } return null ; }
5804	public function check ( $ value ) { foreach ( $ this -> _definitions as $ definition ) if ( $ definition -> match ( $ value ) ) return true ; return false ; }
1309	public static function demoteHtmlHeaderTags ( $ html ) { $ originalHeaderTags = [ ] ; $ demotedHeaderTags = [ ] ; foreach ( range ( 100 , 1 ) as $ index ) { $ originalHeaderTags [ ] = '<h' . $ index . '>' ; $ originalHeaderTags [ ] = '</h' . $ index . '>' ; $ demotedHeaderTags [ ] = '<h' . ( $ index + 1 ) . '>' ; $ demotedHeaderTags [ ] = '</h' . ( $ index + 1 ) . '>' ; } return str_ireplace ( $ originalHeaderTags , $ demotedHeaderTags , $ html ) ; }
2661	public function deleteRequest ( $ version , $ name ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/request_settings/' . $ name ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: DELETE ) ; if ( ! $ result ) { throw new LocalizedException ( __ ( 'Failed to delete the REQUEST object.' ) ) ; } }
3129	private function loadItemData ( $ itemRef , $ path ) { $ cacheKey = $ itemRef . $ path ; if ( ! empty ( $ cacheKey ) && isset ( $ this -> dataCache [ $ itemRef . $ path ] ) ) { return $ this -> dataCache [ $ itemRef . $ path ] ; } $ directoryIds = explode ( '|' , $ itemRef ) ; if ( count ( $ directoryIds ) < 3 ) { if ( is_scalar ( $ itemRef ) ) { $ itemRefInfo = gettype ( $ itemRef ) . ': ' . strval ( $ itemRef ) ; } elseif ( is_object ( $ itemRef ) ) { $ itemRefInfo = gettype ( $ itemRef ) . ': ' . get_class ( $ itemRef ) ; } else { $ itemRefInfo = gettype ( $ itemRef ) ; } throw new \ common_exception_InconsistentData ( "The itemRef (value = '${itemRefInfo}') is not formatted correctly." ) ; } $ itemUri = $ directoryIds [ 0 ] ; $ userDataLang = \ common_session_SessionManager :: getSession ( ) -> getDataLanguage ( ) ; $ directory = \ tao_models_classes_service_FileStorage :: singleton ( ) -> getDirectoryById ( $ directoryIds [ 2 ] ) ; if ( $ directory -> has ( $ userDataLang ) ) { $ lang = $ userDataLang ; } elseif ( $ directory -> has ( DEFAULT_LANG ) ) { \ common_Logger :: d ( $ userDataLang . ' is not part of compilation directory for item : ' . $ itemUri . ' use ' . DEFAULT_LANG ) ; $ lang = DEFAULT_LANG ; } else { throw new \ common_Exception ( 'item : ' . $ itemUri . 'is neither compiled in ' . $ userDataLang . ' nor in ' . DEFAULT_LANG ) ; } try { $ content = $ directory -> read ( $ lang . DIRECTORY_SEPARATOR . $ path ) ; $ assetService = $ this -> getServiceManager ( ) -> get ( ItemAssetsReplacement :: SERVICE_ID ) ; $ jsonContent = json_decode ( $ content , true ) ; $ jsonAssets = [ ] ; if ( isset ( $ jsonContent [ 'assets' ] ) ) { foreach ( $ jsonContent [ 'assets' ] as $ type => $ assets ) { foreach ( $ assets as $ key => $ asset ) { $ jsonAssets [ $ type ] [ $ key ] = $ assetService -> postProcessAssets ( $ asset ) ; } } $ jsonContent [ "assets" ] = $ jsonAssets ; } $ this -> dataCache [ $ cacheKey ] = $ jsonContent ; return $ this -> dataCache [ $ cacheKey ] ; } catch ( \ FileNotFoundException $ e ) { throw new \ tao_models_classes_FileNotFoundException ( $ path . ' for item reference ' . $ itemRef ) ; } catch ( \ League \ Flysystem \ FileNotFoundException $ e ) { throw new \ tao_models_classes_FileNotFoundException ( $ path . ' for item reference ' . $ itemRef ) ; } }
6041	public function search ( $ sessionId , Search $ search , $ hits ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'sessionId' => $ sessionId , 'search' => $ search , 'hits' => $ hits ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/events/search' , $ parameters , true ) ; return $ result ; }
8705	public function extend ( EloquentBuilder $ builder ) { $ builder -> macro ( 'onlyTranslated' , function ( EloquentBuilder $ builder , $ locale = null ) { $ builder -> getModel ( ) -> setOnlyTranslated ( true ) ; if ( $ locale ) { $ builder -> getModel ( ) -> setLocale ( $ locale ) ; } return $ builder ; } ) ; $ builder -> macro ( 'withUntranslated' , function ( EloquentBuilder $ builder ) { $ builder -> getModel ( ) -> setOnlyTranslated ( false ) ; return $ builder ; } ) ; $ builder -> macro ( 'withFallback' , function ( EloquentBuilder $ builder , $ fallbackLocale = null ) { $ builder -> getModel ( ) -> setWithFallback ( true ) ; if ( $ fallbackLocale ) { $ builder -> getModel ( ) -> setFallbackLocale ( $ fallbackLocale ) ; } return $ builder ; } ) ; $ builder -> macro ( 'withoutFallback' , function ( EloquentBuilder $ builder ) { $ builder -> getModel ( ) -> setWithFallback ( false ) ; return $ builder ; } ) ; $ builder -> macro ( 'translateInto' , function ( EloquentBuilder $ builder , $ locale ) { if ( $ locale ) { $ builder -> getModel ( ) -> setLocale ( $ locale ) ; } return $ builder ; } ) ; $ builder -> macro ( 'withoutTranslations' , function ( EloquentBuilder $ builder ) { $ builder -> withoutGlobalScope ( static :: class ) ; return $ builder ; } ) ; $ builder -> macro ( 'withAllTranslations' , function ( EloquentBuilder $ builder ) { $ builder -> withoutGlobalScope ( static :: class ) -> with ( 'translations' ) ; return $ builder ; } ) ; }
12957	public function authenticate ( ) { $ identity = $ this -> getIdentity ( ) ; $ results = $ this -> model -> findByIdentity ( $ identity ) ; $ identityObject = null ; $ count = 0 ; foreach ( $ results as $ identityObject ) { if ( $ count > 1 ) { return new Result ( Result :: FAILURE_IDENTITY_AMBIGUOUS , $ identity , [ 'More than one record matches the supplied identity.' ] ) ; } $ count ++ ; } if ( $ count == 0 ) { return new Result ( Result :: FAILURE_IDENTITY_NOT_FOUND , $ identity , [ 'A record with the supplied identity could not be found.' ] ) ; } if ( $ identityObject instanceof ObjectInterface ) { if ( $ identityObject -> validateCredential ( $ this -> getCredential ( ) ) ) { return new Result ( Result :: SUCCESS , $ identity ) ; } return new Result ( Result :: FAILURE_CREDENTIAL_INVALID , $ identity , [ 'wrong password' ] ) ; } return new Result ( Result :: FAILURE_UNCATEGORIZED , $ identity , [ 'generic error' ] ) ; }
4065	public function getReferencedAttributes ( ) { $ arrAttributes = array ( ) ; foreach ( $ this -> arrChildren as $ objSetting ) { $ arrAttributes = array_merge ( $ arrAttributes , $ objSetting -> getReferencedAttributes ( ) ) ; } return $ arrAttributes ; }
2371	public static function splitCsv ( $ strString , $ strDelimiter = ',' ) { $ arrValues = preg_split ( '/' . $ strDelimiter . '(?=(?:[^"]*"[^"]*")*(?![^"]*"))/' , $ strString ) ; foreach ( $ arrValues as $ k => $ v ) { $ arrValues [ $ k ] = trim ( $ v , ' "' ) ; } return $ arrValues ; }
11906	public function handle ( ServerRequestInterface $ request ) : ResponseInterface { $ msg = "This is the default request handler. This means no middleware produced a response before hitting it." ; $ contents = json_encode ( [ 'type' => MiddlewareStackExhaustedException :: class , 'message' => $ msg , ] ) ; $ response = $ this -> factory -> createResponse ( 404 ) -> withHeader ( 'Content-type' , 'application/json' ) ; $ response -> getBody ( ) -> write ( $ contents ) ; return $ response ; }
5566	public function get ( $ url , $ parameters = false ) { if ( ! is_object ( $ url ) ) { $ url = new SimpleUrl ( $ url ) ; } if ( $ this -> getUrl ( ) ) { $ url = $ url -> makeAbsolute ( $ this -> getUrl ( ) ) ; } return $ this -> load ( $ url , new SimpleGetEncoding ( $ parameters ) ) ; }
2579	protected function loadCustomerRefs ( $ dkNumber ) { if ( ! is_null ( $ dkNumber ) ) { $ this -> customerRef = new MasterPricer \ CustomerRef ( ) ; $ this -> customerRef -> customerReferences [ ] = new MasterPricer \ CustomerReferences ( $ dkNumber , MasterPricer \ CustomerReferences :: QUAL_AGENCY_GROUPING_ID ) ; } }
9841	public function createSealedJsonRequest ( string $ method , string $ uri , array $ arrayToJsonify , SealingPublicKey $ key , array $ headers = [ ] ) : RequestInterface { if ( empty ( $ headers [ 'Content-Type' ] ) ) { $ headers [ 'Content-Type' ] = 'application/json' ; } $ body = \ json_encode ( $ arrayToJsonify , JSON_PRETTY_PRINT ) ; if ( ! \ is_string ( $ body ) ) { throw new InvalidMessageException ( 'Cannot JSON-encode this message.' ) ; } return $ this -> createSealedRequest ( $ method , $ uri , $ body , $ key , $ headers ) ; }
9208	protected function truncateTable ( $ Table ) { $ truncateSql = $ Table -> schema ( ) -> truncateSql ( $ Table -> connection ( ) ) [ 0 ] ; $ success = $ Table -> connection ( ) -> query ( $ truncateSql ) ; if ( $ success ) { $ this -> verbose ( "<success>{$Table->alias()}: Existing DB records truncated.</success>" ) ; } else { $ this -> quiet ( "<warning>{$Table->alias()}: Can not truncate existing records.</warning>" ) ; } return $ success ; }
4069	public function handle ( GetOptionsEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ event -> setOptions ( array_flip ( array_filter ( array_flip ( System :: getLanguages ( ) ) , function ( $ langCode ) { return ( strlen ( $ langCode ) == 2 ) ; } ) ) ) ; }
3345	public function __batchProcessFilesChunk ( $ filesUuidArr , $ request_type ) { if ( count ( $ filesUuidArr ) > $ this -> batchFilesChunkSize ) { throw new \ Exception ( 'Files number should not exceed ' . $ this -> batchFilesChunkSize . ' items per request.' ) ; } $ data = $ this -> __preparedRequest ( 'files_storage' , $ request_type , array ( ) , $ filesUuidArr ) ; $ files_raw = ( array ) $ data -> result ; $ result = array ( ) ; foreach ( $ files_raw as $ file_raw ) { $ result [ ] = new File ( $ file_raw -> uuid , $ this , $ file_raw ) ; } return array ( 'status' => ( string ) $ data -> status , 'files' => $ result , 'problems' => $ data -> problems , ) ; }
8619	public function getBlockWithKey ( $ key ) { if ( isset ( $ this -> blocks [ $ key ] ) ) return $ this -> blocks [ $ key ] ; return null ; }
7079	public static function getTypes ( ) { return [ self :: TYPE_WEBSITE , self :: TYPE_USER , self :: TYPE_ADMINISTRATOR , self :: TYPE_IN_CHARGE , self :: TYPE_CUSTOMER , self :: TYPE_SALESMAN , self :: TYPE_ACCOUNTABLE , self :: TYPE_SUPPLIER , ] ; }
3513	public function getPublish ( $ group ) { if ( $ group && $ group != '*' ) { $ this -> manager -> exportTranslations ( $ group ) ; } else { $ this -> manager -> exportAllTranslations ( ) ; } $ errors = $ this -> manager -> errors ( ) ; event ( new TranslationsPublished ( $ group , $ errors ) ) ; return Response :: json ( array ( 'status' => $ errors ? 'errors' : 'ok' , 'errors' => $ errors ) ) ; }
10811	protected function bindValues ( $ sql , array $ settings ) { $ bindings = & $ this -> bindings ; $ escape = $ this -> getEscapeCallable ( $ settings [ 'escapeFunction' ] ) ; $ params = $ this -> getBuilder ( ) -> getPlaceholderMapping ( ) ; $ function = function ( $ v ) use ( $ settings , & $ bindings , $ escape ) { if ( $ settings [ 'positionedParam' ] ) { $ bindings [ ] = $ v ; return '?' ; } elseif ( $ settings [ 'namedParam' ] && isset ( $ v [ 0 ] ) && ':' == $ v [ 0 ] ) { return $ v ; } elseif ( is_numeric ( $ v ) && ! is_string ( $ v ) ) { return $ v ; } else { return $ escape ( $ v ) ; } } ; return preg_replace_callback ( '/\b__PH_[0-9]++__\b/' , function ( $ m ) use ( & $ params , $ function ) { return $ function ( $ params [ $ m [ 0 ] ] ) ; } , $ sql ) ; }
2747	public function getGeoIpMappingForCountry ( $ countryCode ) { if ( $ mapping = $ this -> _scopeConfig -> getValue ( self :: XML_FASTLY_GEOIP_COUNTRY_MAPPING ) ) { return $ this -> extractMapping ( $ mapping , $ countryCode ) ; } return null ; }
791	public function addErrors ( array $ items ) { foreach ( $ items as $ attribute => $ errors ) { if ( is_array ( $ errors ) ) { foreach ( $ errors as $ error ) { $ this -> addError ( $ attribute , $ error ) ; } } else { $ this -> addError ( $ attribute , $ errors ) ; } } }
9819	public function setSegmentSize ( $ size ) { if ( null !== $ this -> memory ) { throw new Exception \ RuntimeException ( 'You can not change the segment size because memory is already allocated.' . ' Use realloc() function to create new memory segment.' ) ; } $ this -> segmentSize = ( integer ) $ size ; return $ this ; }
9590	public function radioWithGap ( $ options = [ ] , $ enclosedByLabel = true ) { Html :: addCssClass ( $ options , $ this -> radioGapCssClass ) ; return self :: radio ( $ options , $ enclosedByLabel ) ; }
12630	public function pay ( Order $ order ) { return $ this -> request ( $ this -> wrapApi ( self :: API_PAY_ORDER ) , $ order -> all ( ) ) ; }
6161	public function addPropertyRequest ( $ item ) { if ( ! ( $ item instanceof PropertyRequest ) ) { if ( is_array ( $ item ) ) { try { $ item = new PropertyRequest ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate PropertyRequest. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "PropertyRequest"!' , E_USER_WARNING ) ; } } $ this -> properties [ ] = $ item ; return $ this ; }
625	public function handleHhvmError ( $ code , $ message , $ file , $ line , $ context , $ backtrace ) { if ( $ this -> handleError ( $ code , $ message , $ file , $ line ) ) { return true ; } if ( E_ERROR & $ code ) { $ exception = new ErrorException ( $ message , $ code , $ code , $ file , $ line ) ; $ ref = new \ ReflectionProperty ( '\Exception' , 'trace' ) ; $ ref -> setAccessible ( true ) ; $ ref -> setValue ( $ exception , $ backtrace ) ; $ this -> _hhvmException = $ exception ; } return false ; }
11039	function store_node ( & $ elts , $ ptype , & $ i , & $ line , $ cname , $ cvalue , $ ncontent , $ content , $ code = FALSE ) { $ isabsolute = FALSE ; if ( $ cname { 0 } == '/' && $ cname { 1 } == '/' ) { $ isabsolute = TRUE ; $ cname = substr ( $ cname , 2 ) ; } $ elements = explode ( '/' , $ cname ) ; if ( count ( $ elements ) == 1 && ! $ isabsolute ) { $ elts [ $ ptype . ':' . $ i . ':' . $ cname . ':' . $ cvalue ] = $ this -> parse ( $ code ? _ETS_CODE : $ ptype , $ i , $ line , $ ncontent , $ content ) ; } else { if ( $ isabsolute ) { $ elts [ _ETS_TEMPLATE . ':' . $ i . '.1://' ] = $ this -> node_path_walk ( $ elements , 2 , $ ptype , $ i , $ line , $ cvalue , $ ncontent , $ content , $ code ) ; } else { $ element1 = array_shift ( $ elements ) ; $ masktype = ( $ ptype == _ETS_MIS || $ ptype == _ETS_MISVAL ) ? _ETS_MIS_TEMPLATE : _ETS_TEMPLATE ; $ elts [ $ masktype . ':' . $ i . '.1:' . $ element1 ] = $ this -> node_path_walk ( $ elements , 2 , $ ptype , $ i , $ line , $ cvalue , $ ncontent , $ content , $ code ) ; } } }
3895	protected function getMetaModel ( $ metaModelId ) { if ( null === $ this -> factory ) { throw new \ RuntimeException ( 'No factory set.' ) ; } $ metaModelName = $ this -> factory -> translateIdToMetaModelName ( $ metaModelId ) ; $ metaModel = $ this -> factory -> getMetaModel ( $ metaModelName ) ; return $ metaModel ; }
2297	public static function handleRunOnce ( ) { try { $ files = System :: getContainer ( ) -> get ( 'contao.resource_locator' ) -> locate ( 'config/runonce.php' , null , false ) ; } catch ( \ InvalidArgumentException $ e ) { return ; } foreach ( $ files as $ file ) { try { include $ file ; } catch ( \ Exception $ e ) { } $ strRelpath = StringUtil :: stripRootDir ( $ file ) ; if ( ! unlink ( $ file ) ) { throw new \ Exception ( "The file $strRelpath cannot be deleted. Please remove the file manually and correct the file permission settings on your server." ) ; } System :: log ( "File $strRelpath ran once and has then been removed successfully" , __METHOD__ , TL_GENERAL ) ; } }
6159	public function createUrl ( $ action , $ model , $ key , $ index ) { if ( $ this -> urlCreator instanceof Closure ) { return call_user_func ( $ this -> urlCreator , $ action , $ model , $ key , $ index ) ; } else { $ params [ 0 ] = $ this -> controller ? $ this -> controller . '/' . $ action : $ action ; return Url :: toRoute ( $ params ) ; } }
5155	public function setConfiguration ( $ configuration , $ configure = true ) { if ( ! $ configuration instanceof ConfigurationInterface ) { $ configuration = new Configuration ( $ configuration ) ; } unset ( $ this -> configuration ) ; $ this -> configuration = $ configuration ; if ( $ configure ) { $ this -> configure ( ) ; } }
5026	protected function getCustomizationOptions ( ContainerInterface $ container , $ requestedName , array $ options = null ) { if ( ! static :: OPTIONS_NAME ) { throw new \ RuntimeException ( 'The class constants "OPTIONS_NAME" must be non empty.' ) ; } return $ container -> get ( static :: OPTIONS_NAME ) ; }
6308	public function setA ( StringType $ name , Attribute $ attribute ) { if ( $ this -> hasA ( $ name ) ) { $ this -> attributes = $ this -> attributes -> kDiff ( new AttributeMap ( [ $ name ( ) => $ attribute ] ) ) ; } $ this -> attributes = $ this -> attributes -> append ( [ $ name ( ) => $ attribute ] ) ; return $ this ; }
5089	public function queryMapRow ( $ key = 0 , $ removeColumnFromRow = false ) { $ fetchMode = $ this -> resolveFetchMode ( is_string ( $ key ) ) ; $ result = $ this -> execute ( ) ; $ map = [ ] ; try { while ( $ row = $ result -> fetch ( $ fetchMode ) ) { if ( ! isset ( $ row [ $ key ] ) ) throw new MySqlException ( "Key '$key' column not found in the query result: " . implode ( array_keys ( $ row ) ) ) ; if ( $ removeColumnFromRow ) { $ map [ $ row [ $ key ] ] = $ row ; unset ( $ map [ $ row [ $ key ] ] [ $ key ] ) ; } else { $ map [ $ row [ $ key ] ] = $ row ; } } } finally { $ result -> closeCursor ( ) ; } return $ map ; }
7661	function SetWordWrap ( ) { if ( $ this -> WordWrap < 1 ) return ; switch ( $ this -> message_type ) { case "alt" : case "alt_attachments" : $ this -> AltBody = $ this -> WrapText ( $ this -> AltBody , $ this -> WordWrap ) ; break ; default : $ this -> Body = $ this -> WrapText ( $ this -> Body , $ this -> WordWrap ) ; break ; } }
2673	public function getSingleAcl ( $ version , $ acl ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/acl/' . $ acl ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; }
3223	function createTemporaryDirectLink ( $ path ) { Path :: checkArgNonRoot ( "path" , $ path ) ; $ response = $ this -> doPost ( $ this -> apiHost , $ this -> appendFilePath ( "1/media" , $ path ) ) ; if ( $ response -> statusCode === 404 ) return null ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; $ j = RequestUtil :: parseResponseJson ( $ response -> body ) ; $ url = self :: getField ( $ j , "url" ) ; $ expires = self :: parseDateTime ( self :: getField ( $ j , "expires" ) ) ; return array ( $ url , $ expires ) ; }
8296	public function write ( $ data ) { if ( ! is_string ( $ data ) ) { throw new \ InvalidArgumentException ( "The data is not a string." ) ; } $ this -> open ( ) ; if ( ! ftruncate ( $ this -> handle , 0 ) ) { $ this -> writeErrors = true ; throw new \ RuntimeException ( "Could not truncate file " . $ this -> filePath ) ; } fseek ( $ this -> handle , 0 ) ; $ res = fwrite ( $ this -> handle , $ data ) ; if ( strlen ( $ data ) !== $ res ) { $ this -> writeErrors = true ; throw new \ RuntimeException ( "Could not write to file " . $ this -> filePath ) ; } }
7667	function InlineImageExists ( ) { $ result = false ; for ( $ i = 0 ; $ i < count ( $ this -> attachment ) ; $ i ++ ) { if ( $ this -> attachment [ $ i ] [ 6 ] == "inline" ) { $ result = true ; break ; } } return $ result ; }
6749	public function transformCollection ( $ collection ) { if ( is_object ( $ collection ) ) $ collection = $ collection -> toArray ( ) [ "data" ] ; return array_map ( [ $ this , "transform" ] , $ collection ) ; }
6187	public function assign ( $ name , $ value ) { if ( ! isset ( $ this -> view ) ) { throw new ViewException ( 'Please Define view engine in app/View.php' , 500 ) ; } return $ this -> view -> assign ( $ name , $ value ) ; }
3947	private function handleNonMetaModelTable ( $ tableName ) { if ( substr ( $ tableName , 0 , 3 ) === 'mm_' ) { return ; } static $ map ; if ( ! isset ( $ map ) ) { $ map = $ this -> buildMap ( ) ; } if ( ! isset ( $ map [ $ tableName ] ) ) { return ; } $ parentDCA = & $ GLOBALS [ 'TL_DCA' ] [ $ tableName ] ; $ this -> controller -> loadLanguageFile ( 'default' ) ; foreach ( $ map [ $ tableName ] as $ metaModelTable => $ inputScreen ) { $ metaModel = $ this -> factory -> getMetaModel ( $ metaModelTable ) ; $ caption = $ this -> buildCaption ( $ metaModel , $ inputScreen ) ; $ operationName = 'edit_' . $ metaModel -> getTableName ( ) ; $ parentDCA [ 'list' ] [ 'operations' ] [ $ operationName ] = array ( 'label' => & $ caption , 'href' => 'table=' . $ metaModelTable , 'icon' => $ this -> iconBuilder -> getBackendIcon ( $ inputScreen [ 'meta' ] [ 'backendicon' ] ) , 'attributes' => 'onclick="Backend.getScrollOffset()"' , ) ; if ( $ metaModel -> hasVariants ( ) ) { $ parentDCA [ 'list' ] [ 'operations' ] [ $ operationName ] [ 'idparam' ] = 'id_' . $ tableName ; } else { $ parentDCA [ 'list' ] [ 'operations' ] [ $ operationName ] [ 'idparam' ] = 'pid' ; } if ( $ parentDCA [ 'config' ] [ 'dataContainer' ] !== 'General' ) { $ idParameter = $ parentDCA [ 'list' ] [ 'operations' ] [ $ operationName ] [ 'idparam' ] ; $ parentDCA [ 'list' ] [ 'operations' ] [ $ operationName ] [ 'button_callback' ] = function ( $ row , $ href , $ label , $ name , $ icon , $ attributes , $ table ) use ( $ idParameter ) { return $ this -> buildChildOperationButton ( $ idParameter , $ row [ 'id' ] , $ href , $ label , $ name , $ icon , $ attributes , $ table ) ; } ; } } }
3652	public function parse ( $ strOutputFormat , $ blnFailIfNotFound = false ) { if ( $ this -> strTemplate == '' ) { return '' ; } $ this -> strFormat = $ strOutputFormat ; $ this -> callParseTemplateHook ( ) ; $ strBuffer = '' ; $ this -> strParent = $ this -> strTemplate ; while ( $ this -> strParent !== null ) { $ strCurrent = $ this -> strParent ; $ strParent = $ this -> strDefault ? : $ this -> getTemplate ( $ this -> strParent , $ this -> strFormat , $ blnFailIfNotFound ) ; if ( empty ( $ strParent ) ) { return sprintf ( 'Template %s not found (it is maybe within a unreachable theme folder?).' , $ this -> strParent ) ; } $ this -> strParent = null ; $ this -> strDefault = null ; ob_start ( ) ; include ( $ strParent ) ; if ( $ this -> strParent === null ) { $ strBuffer = ob_get_contents ( ) ; } elseif ( $ this -> strParent == $ strCurrent ) { $ this -> strDefault = $ this -> getTemplate ( $ this -> strParent , $ this -> strFormat , $ blnFailIfNotFound ) ; } ob_end_clean ( ) ; } $ this -> arrBlocks = array ( ) ; if ( \ Config :: get ( 'debugMode' ) && in_array ( $ this -> strFormat , [ 'html5' , 'xhtml' ] ) ) { $ strRelPath = str_replace ( TL_ROOT . '/' , '' , $ this -> getTemplate ( $ this -> strTemplate , $ this -> strFormat ) ) ; $ strBuffer = <<<EOF<!-- TEMPLATE START: $strRelPath ; } return $ strBuffer ; }
958	public function remainingTrialDaysFromCancel ( ) { if ( ! $ this -> isTrial ( ) ) { return ; } $ cancelledDate = Carbon :: parse ( $ this -> cancelled_on ) ; $ trialEndsDate = Carbon :: parse ( $ this -> trial_ends_on ) ; if ( $ this -> isCancelled ( ) && $ cancelledDate -> lte ( $ trialEndsDate ) ) { return $ this -> trial_days - ( $ this -> trial_days - $ cancelledDate -> diffInDays ( $ trialEndsDate ) ) ; } return 0 ; }
2545	protected function makeDomXpath ( $ response ) { $ domDoc = $ this -> loadDomDocument ( $ response ) ; $ domXpath = new \ DOMXPath ( $ domDoc ) ; $ domXpath -> registerNamespace ( self :: XMLNS_PREFIX , $ domDoc -> documentElement -> lookupNamespaceUri ( null ) ) ; return $ domXpath ; }
115	public function execute ( $ command , $ url , $ cwd = null , $ path = null , $ verbose = false ) { $ this -> config -> prohibitUrlByConfig ( $ url , $ this -> io ) ; return $ this -> executeWithAuthRetry ( $ command , $ cwd , $ url , $ path , $ verbose ) ; }
10591	protected function findProduct ( int $ id ) : ProductInterface { $ product = $ this -> repository -> find ( $ id ) ; if ( ! $ product instanceof ProductInterface ) { throw new ProductNotFoundException ( $ id ) ; } return $ product ; }
8300	public function handleEvent ( $ eventName , array $ params ) { parent :: handleEvent ( $ eventName , $ params ) ; if ( $ this -> isEnabled ( ) ) { $ this -> picoAuthPlugin -> handleEvent ( $ eventName , $ params ) ; } }
6326	public static function getClassNameWithoutNamespace ( $ object ) { $ className = get_class ( $ object ) ; if ( preg_match ( '@\\\\([\w]+)$@' , $ className , $ matches ) ) { $ className = $ matches [ 1 ] ; } return $ className ; }
9669	private function writeFont ( XMLWriter $ objWriter , Font $ pFont ) { $ objWriter -> startElement ( 'font' ) ; if ( $ pFont -> getBold ( ) !== null ) { $ objWriter -> startElement ( 'b' ) ; $ objWriter -> writeAttribute ( 'val' , $ pFont -> getBold ( ) ? '1' : '0' ) ; $ objWriter -> endElement ( ) ; } if ( $ pFont -> getItalic ( ) !== null ) { $ objWriter -> startElement ( 'i' ) ; $ objWriter -> writeAttribute ( 'val' , $ pFont -> getItalic ( ) ? '1' : '0' ) ; $ objWriter -> endElement ( ) ; } if ( $ pFont -> getStrikethrough ( ) !== null ) { $ objWriter -> startElement ( 'strike' ) ; $ objWriter -> writeAttribute ( 'val' , $ pFont -> getStrikethrough ( ) ? '1' : '0' ) ; $ objWriter -> endElement ( ) ; } if ( $ pFont -> getUnderline ( ) !== null ) { $ objWriter -> startElement ( 'u' ) ; $ objWriter -> writeAttribute ( 'val' , $ pFont -> getUnderline ( ) ) ; $ objWriter -> endElement ( ) ; } if ( $ pFont -> getSuperscript ( ) === true || $ pFont -> getSubscript ( ) === true ) { $ objWriter -> startElement ( 'vertAlign' ) ; if ( $ pFont -> getSuperscript ( ) === true ) { $ objWriter -> writeAttribute ( 'val' , 'superscript' ) ; } elseif ( $ pFont -> getSubscript ( ) === true ) { $ objWriter -> writeAttribute ( 'val' , 'subscript' ) ; } $ objWriter -> endElement ( ) ; } if ( $ pFont -> getSize ( ) !== null ) { $ objWriter -> startElement ( 'sz' ) ; $ objWriter -> writeAttribute ( 'val' , StringHelper :: formatNumber ( $ pFont -> getSize ( ) ) ) ; $ objWriter -> endElement ( ) ; } if ( $ pFont -> getColor ( ) -> getARGB ( ) !== null ) { $ objWriter -> startElement ( 'color' ) ; $ objWriter -> writeAttribute ( 'rgb' , $ pFont -> getColor ( ) -> getARGB ( ) ) ; $ objWriter -> endElement ( ) ; } if ( $ pFont -> getName ( ) !== null ) { $ objWriter -> startElement ( 'name' ) ; $ objWriter -> writeAttribute ( 'val' , $ pFont -> getName ( ) ) ; $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; }
11211	protected function hasInLookup ( $ key ) { foreach ( $ this -> lookup_pool as $ registry ) { if ( $ this -> hasInRegistry ( $ registry , $ key ) ) { $ this -> cache_key = $ key ; $ this -> cache_reg = $ registry ; return true ; } } return false ; }
841	public function offsetUnset ( $ index ) { $ this -> changed = true ; $ this -> unregisterFoundToken ( $ this [ $ index ] ) ; parent :: offsetUnset ( $ index ) ; }
4220	private function getLogArgs ( $ cleared ) { $ cleared = \ array_filter ( $ cleared ) ; if ( ! $ cleared ) { return array ( ) ; } $ count = \ count ( $ cleared ) ; $ glue = $ count == 2 ? ' and ' : ', ' ; if ( $ count > 2 ) { $ cleared [ $ count - 1 ] = 'and ' . $ cleared [ $ count - 1 ] ; } $ msg = 'Cleared ' . \ implode ( $ glue , $ cleared ) ; if ( $ this -> channelName ) { return array ( $ msg . ' %c(%s)' , 'background-color:#c0c0c0; padding:0 .33em;' , $ this -> channelName , ) ; } return array ( $ msg ) ; }
10225	public function itemsFor ( $ model , $ items = null , $ targetUrl = null , $ nextPageUrl = null , $ offset = - 1 , ModelConfig $ config = null ) { $ modelName = $ this -> resolveModelName ( $ model ) ; if ( $ items == null ) { $ items = call_user_func ( array ( $ modelName , 'simplePaginate' ) , 10 ) ; } $ factory = $ this -> app -> make ( 'Label305\AujaLaravel\Factory\ResourceItemsFactory' ) ; return $ factory -> create ( $ modelName , $ items , $ targetUrl , $ nextPageUrl , $ offset , $ config ) ; }
8778	public function redirect ( $ data = null , int $ statusCode = 301 , $ secure = false ) { if ( substr ( $ data , 0 , 4 ) === 'http' || substr ( $ data , 0 , 5 ) === 'https' ) { header ( 'Location: ' . $ data , true , $ statusCode ) ; } else { $ data = ( ! is_null ( $ data ) ) ? $ this -> url . '/' . $ data : $ this -> url ; header ( 'Location: ' . $ this -> getUrl ( $ data , $ secure ) , true , $ statusCode ) ; } die ( ) ; }
8626	public function setTermsAndConditionsNotAcceptedCarrierList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'TermsAndConditionsNotAcceptedCarrierList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
6525	public function createMessage ( array $ data = [ ] ) { $ className = $ this -> className ; if ( empty ( $ data ) ) { return $ className :: create ( ) ; } return $ className :: fromArray ( $ data ) ; }
3925	public function decodeValue ( DecodePropertyValueForWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } if ( is_array ( $ event -> getValue ( ) ) ) { $ values = [ ] ; foreach ( $ event -> getValue ( ) as $ value ) { $ values [ ] = 'value_' . $ value ; } $ event -> setValue ( $ values ) ; } else { $ event -> setValue ( 'value_' . $ event -> getValue ( ) ) ; } }
8428	public function getFileIcon ( $ fileType , $ iconLib = 'cmti' ) { switch ( $ iconLib ) { case 'cmti' : { return $ this -> getCmtiFileIcon ( $ fileType ) ; } case 'fa' : { return $ this -> getFaFileIcon ( $ fileType ) ; } } }
305	private function setRelationDependencies ( $ name , $ relation , $ viaRelationName = null ) { if ( empty ( $ relation -> via ) && $ relation -> link ) { foreach ( $ relation -> link as $ attribute ) { $ this -> _relationsDependencies [ $ attribute ] [ $ name ] = $ name ; if ( $ viaRelationName !== null ) { $ this -> _relationsDependencies [ $ attribute ] [ ] = $ viaRelationName ; } } } elseif ( $ relation -> via instanceof ActiveQueryInterface ) { $ this -> setRelationDependencies ( $ name , $ relation -> via ) ; } elseif ( is_array ( $ relation -> via ) ) { list ( $ viaRelationName , $ viaQuery ) = $ relation -> via ; $ this -> setRelationDependencies ( $ name , $ viaQuery , $ viaRelationName ) ; } }
3313	protected function appendAppIdAndBucketIfEmpty ( array $ options = [ ] ) { $ options [ 'appid' ] = empty ( $ options [ 'appid' ] ) ? $ this -> authorization -> getAppId ( ) : $ options [ 'appid' ] ; $ options [ 'bucket' ] = empty ( $ options [ 'bucket' ] ) ? $ this -> authorization -> getBucket ( ) : $ options [ 'bucket' ] ; return $ options ; }
12744	public function askSlotMap ( NodeConnectionInterface $ connection = null ) { if ( ! $ connection && ! $ connection = $ this -> getRandomConnection ( ) ) { return ; } $ this -> slotmap -> reset ( ) ; $ response = $ this -> queryClusterNodeForSlotMap ( $ connection ) ; foreach ( $ response as $ slots ) { list ( $ start , $ end , $ master ) = $ slots ; if ( $ master [ 0 ] === '' ) { $ this -> slotmap -> setSlots ( $ start , $ end , ( string ) $ connection ) ; } else { $ this -> slotmap -> setSlots ( $ start , $ end , "{$master[0]}:{$master[1]}" ) ; } } }
7865	protected function drawBordered ( $ content ) { $ left = $ this -> geometry -> getLeftBordersWith ( static :: BORDER_X ) ; $ right = $ this -> geometry -> getRightBordersWith ( static :: BORDER_X ) ; $ this -> drawRow ( $ left . $ content . $ right ) ; }
7744	public function getValue ( $ entity ) { if ( null === $ this -> getter ) { throw new \ Exception ( "Can't get the entity's {$this->name} property as no getter has been found." ) ; } elseif ( false === ( $ entity instanceof $ this -> class ) ) { throw new \ Exception ( "Can't get the entity's {$this->name} property as the entity is not an instance of {$this->class}." ) ; } if ( self :: GETTER_SETTER_METHOD === $ this -> getterType ) { return $ entity -> { $ this -> getter } ( ) ; } else { return $ entity -> { $ this -> getter } ; } }
11043	function is_space ( $ char ) { $ asc = ord ( $ char ) ; if ( $ asc == 32 ) { return TRUE ; } elseif ( $ asc > 8 && $ asc < 14 ) { return TRUE ; } return FALSE ; }
7713	function FindEndTag ( $ Encaps = false ) { if ( is_null ( $ this -> SelfClosing ) ) { $ pe = $ this -> PosEnd ; $ SelfClosing = ( substr ( $ this -> Txt , $ pe - 1 , 1 ) == '/' ) ; if ( ! $ SelfClosing ) { if ( $ Encaps ) { $ loc = clsTinyButStrong :: f_Xml_FindTag ( $ this -> Txt , $ this -> FindName ( ) , null , $ pe , true , - 1 , false , false ) ; if ( $ loc === false ) return false ; $ this -> pET_PosBeg = $ loc -> PosBeg ; $ this -> PosEnd = $ loc -> PosEnd ; } else { $ pe = clsTinyButStrong :: f_Xml_FindTagStart ( $ this -> Txt , $ this -> FindName ( ) , false , $ pe , true , true ) ; if ( $ pe === false ) return false ; $ this -> pET_PosBeg = $ pe ; $ pe = strpos ( $ this -> Txt , '>' , $ pe ) ; if ( $ pe === false ) return false ; $ this -> PosEnd = $ pe ; } } $ this -> SelfClosing = $ SelfClosing ; } return true ; }
8881	private function isValidRelativePath ( string $ relativePath , string $ cwd ) : bool { $ valid = false ; if ( './' === substr ( $ relativePath , 0 , 2 ) ) { $ tmpPath = $ cwd . DIRECTORY_SEPARATOR . substr ( $ relativePath , 2 , strlen ( $ relativePath ) ) ; $ valid = $ this -> isValidFullPath ( $ tmpPath ) ; } return $ valid ; }
4388	public function setConfigFE ( \ Aimeos \ MShop \ Order \ Item \ Base \ Service \ Iface $ orderServiceItem , array $ attributes ) { $ this -> setAttributes ( $ orderServiceItem , $ attributes , 'session' ) ; }
3814	private function injectServiceContainerIntoDataDrivers ( $ providerDefinitions , $ environment ) { foreach ( $ providerDefinitions as $ provider ) { $ providerInstance = $ environment -> getDataProvider ( $ provider -> getName ( ) ) ; if ( $ providerInstance instanceof Driver ) { $ initialization = $ provider -> getInitializationData ( ) ; $ metaModel = $ this -> factory -> getMetaModel ( $ initialization [ 'source' ] ) ; $ providerInstance -> setBaseConfig ( array_merge ( $ initialization , [ 'metaModel' => $ metaModel ] ) ) ; $ providerInstance -> setDispatcher ( $ this -> dispatcher ) ; $ providerInstance -> setConnection ( $ this -> connection ) ; } } }
9499	public function processRequest ( RequestInterface $ request ) { $ response = $ request -> send ( ) ; $ attempt = 0 ; while ( $ response -> getStatusCode ( ) == 429 && $ attempt < 5 ) { $ wait = $ response -> getHeader ( 'Retry-After' ) ; if ( $ wait > 0 ) { sleep ( $ wait ) ; } $ attempt ++ ; $ response = $ request -> send ( ) ; } if ( $ response -> getStatusCode ( ) >= 500 ) { throw new ZendeskException ( 'Zendesk Server Error Detected.' ) ; } if ( $ response -> getStatusCode ( ) >= 400 ) { if ( $ response -> getContentType ( ) == 'application/json' ) { $ result = $ response -> json ( ) ; $ description = array_key_exists ( $ result , 'description' ) ? $ result [ 'description' ] : 'Invalid Request' ; $ value = array_key_exists ( $ result , 'value' ) ? $ result [ 'value' ] : array ( ) ; $ exception = new ZendeskException ( $ description ) ; $ exception -> setError ( $ value ) ; throw $ exception ; } else { throw new ZendeskException ( 'Invalid API Request' ) ; } } return $ response ; }
3529	public static function sendUnrealClientGetRequest ( $ endpoint , $ authorization = self :: EPIC_LAUNCHER_AUTHORIZATION , $ oauth = false ) { $ client = new Client ( ) ; try { $ response = $ client -> get ( $ endpoint , [ 'headers' => [ 'User-Agent' => self :: UNREAL_CLIENT_USER_AGENT , 'Authorization' => ( ! $ oauth ) ? 'basic ' . $ authorization : 'bearer ' . $ authorization ] ] ) ; return json_decode ( $ response -> getBody ( ) -> getContents ( ) ) ; } catch ( GuzzleException $ e ) { throw $ e ; } }
8891	public function singleton ( $ key , $ value ) { if ( is_callable ( $ value ) ) { $ this -> registerFactory ( $ key , $ value ) ; } else { $ this -> sm -> setService ( $ key , $ value ) ; } }
8099	protected function validateAll ( $ includeAllRules = false ) { if ( $ includeAllRules ) { $ fieldData = new Collection ( array_fill_keys ( array_keys ( $ this -> _validations -> toArray ( ) ) , null ) ) ; $ fieldData -> update ( $ this -> _updates -> toArray ( ) ) ; } else { $ fieldData = clone $ this -> _updates ; } foreach ( $ fieldData -> toArray ( ) as $ field => $ val ) { $ field2 = $ field . '2' ; if ( ! is_null ( $ fieldData -> $ field2 ) ) { if ( $ val != $ fieldData -> $ field2 ) { $ this -> log -> formError ( $ field , ucfirst ( $ field ) . 's did not match' ) ; } else { $ this -> log -> report ( ucfirst ( $ field ) . 's matched' ) ; } } if ( $ this -> _updates -> $ field ) { $ this -> _updates -> $ field = trim ( $ val ) ; } if ( $ validation = $ this -> _validations -> $ field ) { $ this -> validate ( $ field , $ validation -> limit , $ validation -> regEx ) ; } } return ! $ this -> log -> hasError ( ) ; }
8669	protected function computeFileSystemDifferences ( ) { $ entityPathByFilesystems = [ ] ; foreach ( $ this -> resourceManager -> getResourceConfigurations ( ) as $ resourceConfiguration ) { $ className = $ resourceConfiguration -> getEntity ( ) ; $ entityManager = $ this -> doctrine -> getManagerForClass ( $ className ) ; if ( ! $ entityManager instanceof EntityManagerInterface ) { throw new \ UnexpectedValueException ( "No manager found for class {$className}" ) ; } $ repository = $ entityManager -> getRepository ( $ className ) ; if ( ! $ repository instanceof ResourceRepositoryInterface ) { throw new \ UnexpectedValueException ( "Repository for class {$className} must implement ResourceRepositoryInterface" ) ; } $ paths = $ repository -> getPaths ( ) ; $ adapterReference = $ this -> adaptersByResourceType [ $ resourceConfiguration -> getCode ( ) ] ; if ( array_key_exists ( $ adapterReference , $ entityPathByFilesystems ) ) { $ entityPathByFilesystems [ $ adapterReference ] = array_merge ( $ entityPathByFilesystems [ $ adapterReference ] , $ paths ) ; } else { $ entityPathByFilesystems [ $ adapterReference ] = $ paths ; } } foreach ( $ this -> adapters as $ adapterReference => $ adapter ) { $ existingPaths = [ ] ; foreach ( $ adapter -> listContents ( ) as $ metadata ) { $ entityPath = $ metadata [ 'path' ] ; if ( '.gitkeep' === $ entityPath ) { continue ; } $ existingPaths [ $ entityPath ] = $ entityPath ; } $ entityPaths = $ entityPathByFilesystems [ $ adapterReference ] ; $ this -> extraFiles [ $ adapterReference ] = array_diff_key ( $ existingPaths , $ entityPaths ) ; $ this -> missingFiles [ $ adapterReference ] = array_diff_key ( $ entityPaths , $ existingPaths ) ; } }
2146	protected function generateEmailObject ( Result $ objNewsletter , $ arrAttachments ) { $ objEmail = new Email ( ) ; $ objEmail -> from = $ objNewsletter -> sender ; $ objEmail -> subject = $ objNewsletter -> subject ; if ( $ objNewsletter -> senderName != '' ) { $ objEmail -> fromName = $ objNewsletter -> senderName ; } $ objEmail -> embedImages = ! $ objNewsletter -> externalImages ; $ objEmail -> logFile = TL_NEWSLETTER . '_' . $ objNewsletter -> id ; if ( ! empty ( $ arrAttachments ) && \ is_array ( $ arrAttachments ) ) { $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; foreach ( $ arrAttachments as $ strAttachment ) { $ objEmail -> attachFile ( $ rootDir . '/' . $ strAttachment ) ; } } return $ objEmail ; }
10157	private function readBoolErr ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; $ row = self :: getUInt2d ( $ recordData , 0 ) ; $ column = self :: getUInt2d ( $ recordData , 2 ) ; $ columnString = Coordinate :: stringFromColumnIndex ( $ column + 1 ) ; if ( ( $ this -> getReadFilter ( ) !== null ) && $ this -> getReadFilter ( ) -> readCell ( $ columnString , $ row + 1 , $ this -> phpSheet -> getTitle ( ) ) ) { $ xfIndex = self :: getUInt2d ( $ recordData , 4 ) ; $ boolErr = ord ( $ recordData [ 6 ] ) ; $ isError = ord ( $ recordData [ 7 ] ) ; $ cell = $ this -> phpSheet -> getCell ( $ columnString . ( $ row + 1 ) ) ; switch ( $ isError ) { case 0 : $ value = ( bool ) $ boolErr ; $ cell -> setValueExplicit ( $ value , DataType :: TYPE_BOOL ) ; break ; case 1 : $ value = Xls \ ErrorCode :: lookup ( $ boolErr ) ; $ cell -> setValueExplicit ( $ value , DataType :: TYPE_ERROR ) ; break ; } if ( ! $ this -> readDataOnly ) { $ cell -> setXfIndex ( $ this -> mapCellXfIndex [ $ xfIndex ] ) ; } } }
10203	public function setVertical ( $ pValue ) { if ( $ pValue == '' ) { $ pValue = self :: VERTICAL_BOTTOM ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'vertical' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> vertical = $ pValue ; } return $ this ; }
7064	protected function supports ( PaymentInterface $ payment ) { if ( null === $ method = $ payment -> getMethod ( ) ) { throw new RuntimeException ( "Payment method must be set." ) ; } if ( $ method -> isCredit ( ) || $ method -> isOutstanding ( ) ) { return true ; } return false ; }
7779	protected function extractRules ( array $ data ) { $ rules = [ ] ; foreach ( $ data as $ field => $ fieldData ) { $ rules [ $ field ] = $ fieldData [ 1 ] ; } return $ rules ; }
1041	public function wait ( Promise $ promise ) { $ this -> beforeWait ( $ promise ) ; $ dfdQueue = Deferred :: getQueue ( ) ; $ promiseQueue = SyncPromise :: getQueue ( ) ; while ( $ promise -> adoptedPromise -> state === SyncPromise :: PENDING && ! ( $ dfdQueue -> isEmpty ( ) && $ promiseQueue -> isEmpty ( ) ) ) { Deferred :: runQueue ( ) ; SyncPromise :: runQueue ( ) ; $ this -> onWait ( $ promise ) ; } $ syncPromise = $ promise -> adoptedPromise ; if ( $ syncPromise -> state === SyncPromise :: FULFILLED ) { return $ syncPromise -> result ; } if ( $ syncPromise -> state === SyncPromise :: REJECTED ) { throw $ syncPromise -> result ; } throw new InvariantViolation ( 'Could not resolve promise' ) ; }
5370	public function add ( $ key , $ value ) { if ( $ value === false ) { return ; } if ( is_array ( $ value ) ) { foreach ( $ value as $ item ) { $ this -> addPair ( $ key , $ item ) ; } } else { $ this -> addPair ( $ key , $ value ) ; } }
130	protected function requestXml ( $ origin , $ path ) { $ xml = simplexml_load_string ( $ this -> requestContent ( $ origin , $ path ) , "SimpleXMLElement" , LIBXML_NOERROR ) ; if ( false === $ xml ) { throw new \ UnexpectedValueException ( sprintf ( 'The PEAR channel at ' . $ origin . ' is broken. (Invalid XML at file `%s`)' , $ path ) ) ; } return $ xml ; }
2268	public function isUniqueValue ( $ strTable , $ strField , $ varValue , $ intId = null ) { $ strQuery = "SELECT * FROM $strTable WHERE " . static :: quoteIdentifier ( $ strField ) . "=?" ; if ( $ intId !== null ) { $ strQuery .= " AND id!=?" ; } $ objUnique = $ this -> prepare ( $ strQuery ) -> limit ( 1 ) -> execute ( $ varValue , $ intId ) ; return $ objUnique -> numRows ? false : true ; }
8965	public function rewriteCountQuery ( $ query ) { if ( \ preg_match ( '/^\s*SELECT\s+\bDISTINCT\b/is' , $ query ) || \ preg_match ( '/\s+GROUP\s+BY\s+/is' , $ query ) ) { return '' ; } $ openParenthesis = '(?:\()' ; $ closeParenthesis = '(?:\))' ; $ subQueryInSelect = $ openParenthesis . '.*\bFROM\b.*' . $ closeParenthesis ; $ pattern = '/(?:.*' . $ subQueryInSelect . '.*)\bFROM\b\s+/Uims' ; if ( \ preg_match ( $ pattern , $ query ) ) { return '' ; } $ subQueryWithLimitOrder = $ openParenthesis . '.*\b(LIMIT|ORDER)\b.*' . $ closeParenthesis ; $ pattern = '/.*\bFROM\b.*(?:.*' . $ subQueryWithLimitOrder . '.*).*/Uims' ; if ( \ preg_match ( $ pattern , $ query ) ) { return '' ; } $ queryCount = \ preg_replace ( '/(?:.*)\bFROM\b\s+/Uims' , 'SELECT COUNT(*) FROM ' , $ query , 1 ) ; list ( $ queryCount ) = \ preg_split ( '/\s+ORDER\s+BY\s+/is' , $ queryCount ) ; list ( $ queryCount ) = \ preg_split ( '/\bLIMIT\b/is' , $ queryCount ) ; return \ trim ( $ queryCount ) ; }
7145	public function add_custom_profile_fields ( $ user ) { $ user_settings = apply_filters ( 'iac_get_user_settings' , array ( ) , $ user -> ID ) ; $ nonce = wp_create_nonce ( 'iac_user_settings' ) ; ?> <h3> <?php _e ( 'Informer?' , $ this -> get_textdomain ( ) ) ; ?> </h3> <table class="form-table"> <tr id="post_subscription"> <th> <label for="post_subscription_checkbox"> <?php _e ( 'Posts subscription' , $ this -> get_textdomain ( ) ) ; ?> </label> </th> <td> <input type="checkbox" id="post_subscription_checkbox" name="post_subscription" value="1" <?php checked ( '1' , $ user_settings [ 'inform_about_posts' ] ) ; ?> /> <span class="description"> <?php _e ( 'Inform about new posts via e-mail, without your own posts.' , $ this -> get_textdomain ( ) ) ; ?> </span> </td> </tr> <tr id="comment_subscription"> <th> <label for="comment_subscription_checkbox"> <?php _e ( 'Comments subscription' , $ this -> get_textdomain ( ) ) ; ?> </label> </th> <td> <input type="checkbox" id="comment_subscription_checkbox" name="comment_subscription" value="1" <?php checked ( '1' , $ user_settings [ 'inform_about_comments' ] ) ; ?> /> <span class="description"> <?php _e ( 'Inform about new comments via e-mail, without your own comments.' , $ this -> get_textdomain ( ) ) ; ?> </span> <input type="hidden" name="iac_nonce" value=" <?php echo $ nonce ; ?> " /> </td> </tr> </table> <?php }
10160	private function readMsoDrawing ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ splicedRecordData = $ this -> getSplicedRecordData ( ) ; $ recordData = $ splicedRecordData [ 'recordData' ] ; $ this -> drawingData .= $ recordData ; }
9068	protected function convert_value_to_string ( $ value ) { if ( $ this -> is_resource ( $ value ) ) { $ type = get_resource_type ( $ value ) ; return "(Resource:$type)" ; } if ( is_object ( $ value ) ) { if ( $ value instanceof \ Exception || $ value instanceof \ Throwable ) { return '(' . get_class ( $ value ) . "#{$value->getCode()}:{$value->getMessage()})" ; } elseif ( $ value instanceof \ DateTime || ( interface_exists ( '\DateTimeInterface' ) && $ value instanceof \ DateTimeInterface ) ) { return $ value -> format ( \ DateTime :: ATOM ) ; } elseif ( method_exists ( $ value , '__toString' ) ) { return ( string ) $ value ; } else { $ class = get_class ( $ value ) ; return "($class)" ; } } if ( is_array ( $ value ) ) { return '(Array)' ; } if ( is_scalar ( $ value ) ) { return $ value ; } if ( $ value === null ) { return '(Null)' ; } return '(Invalid)' ; }
10532	public function valid ( ) { if ( $ this -> items === null ) { return false ; } $ key = key ( $ this -> items ) ; return ( $ key !== null && $ key !== false ) ; }
12861	private function buildCache ( ) : array { $ dispatchData = $ this -> routeCollector -> getData ( ) ; file_put_contents ( $ this -> cacheFile , '<?php return ' . var_export ( $ dispatchData , true ) . ';' ) ; return $ dispatchData ; }
3128	protected function getRangeDuration ( $ start , $ end ) { if ( $ start -> getTarget ( ) != $ end -> getTarget ( ) ) { throw new InconsistentRangeException ( 'A time range must be defined by two TimePoint with the same target' ) ; } $ rangeDuration = $ end -> getTimestamp ( ) - $ start -> getTimestamp ( ) ; if ( $ rangeDuration < 0 ) { throw new InconsistentRangeException ( 'A START TimePoint cannot take place after the END!' ) ; } return $ rangeDuration ; }
4796	protected function execute ( ) { if ( ! isset ( $ this -> rows ) ) { $ result = false ; $ exception = null ; $ parameters = array ( ) ; foreach ( array_merge ( $ this -> select , array ( $ this , $ this -> group , $ this -> having ) , $ this -> order , $ this -> unionOrder ) as $ val ) { if ( ( $ val instanceof NotORM_Literal || $ val instanceof self ) && $ val -> parameters ) { $ parameters = array_merge ( $ parameters , $ val -> parameters ) ; } } try { $ result = $ this -> query ( $ this -> __toString ( ) , $ parameters ) ; } catch ( PDOException $ exception ) { } if ( ! $ result ) { if ( ! $ this -> select && $ this -> accessed ) { $ this -> accessed = '' ; $ this -> access = array ( ) ; $ result = $ this -> query ( $ this -> __toString ( ) , $ parameters ) ; } elseif ( $ exception ) { throw $ exception ; } } $ this -> rows = array ( ) ; if ( $ result ) { $ result -> setFetchMode ( PDO :: FETCH_ASSOC ) ; foreach ( $ result as $ key => $ row ) { if ( isset ( $ row [ $ this -> primary ] ) ) { $ key = $ row [ $ this -> primary ] ; if ( ! is_string ( $ this -> access ) ) { $ this -> access [ $ this -> primary ] = true ; } } if ( $ this -> notORM -> isKeepPrimaryKeyIndex ) { $ this -> rows [ $ key ] = $ row ; } else { $ this -> rows [ ] = $ row ; } } } $ this -> data = $ this -> rows ; } }
8199	public function expect ( $ type , $ value = null , $ message = null ) { $ token = $ this -> tokens [ $ this -> current ] ; if ( ! $ token -> test ( $ type , $ value ) ) { $ line = $ token -> getLine ( ) ; throw new Twig_Error_Syntax ( sprintf ( '%sUnexpected token "%s" of value "%s" ("%s" expected%s).' , $ message ? $ message . '. ' : '' , Twig_Token :: typeToEnglish ( $ token -> getType ( ) ) , $ token -> getValue ( ) , Twig_Token :: typeToEnglish ( $ type ) , $ value ? sprintf ( ' with value "%s"' , $ value ) : '' ) , $ line , $ this -> source ) ; } $ this -> next ( ) ; return $ token ; }
11977	public function getInterfaceObject ( ) { if ( is_null ( $ this -> _interfaceObject ) ) { $ this -> _interfaceObject = DataInterface :: find ( ) -> where ( [ 'system_id' => $ this -> object -> systemId ] ) -> one ( ) ; if ( empty ( $ this -> _interfaceObject ) ) { $ this -> _interfaceObject = new DataInterface ( ) ; $ this -> _interfaceObject -> name = $ this -> object -> name ; $ this -> _interfaceObject -> system_id = $ this -> object -> systemId ; if ( ! $ this -> _interfaceObject -> save ( ) ) { var_dump ( $ this -> _interfaceObject -> errors ) ; throw new Exception ( "Unable to save interface object!" ) ; } } } return $ this -> _interfaceObject ; }
7982	public function addDeleteTask ( $ sessionId ) { return json_decode ( self :: getClient ( ) -> createPcaDeleteTask ( $ this -> pp , $ this -> sn , $ sessionId ) ) ; }
5484	public function hasSubmit ( SelectorInterface $ selector ) { foreach ( $ this -> buttons as $ button ) { if ( $ selector -> isMatch ( $ button ) ) { return true ; } } return false ; }
5590	public function setIdentity ( $ host , $ realm , $ username , $ password ) { $ this -> authenticator -> setIdentityForRealm ( $ host , $ realm , $ username , $ password ) ; }
9631	public function setSetting ( $ key , $ value ) { $ settings = $ this -> getSettings ( ) ; $ settings [ $ key ] = $ value ; $ this -> setSettings ( $ settings ) ; }
10154	private function readPageSetup ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( ! $ this -> readDataOnly ) { $ paperSize = self :: getUInt2d ( $ recordData , 0 ) ; $ scale = self :: getUInt2d ( $ recordData , 2 ) ; $ fitToWidth = self :: getUInt2d ( $ recordData , 6 ) ; $ fitToHeight = self :: getUInt2d ( $ recordData , 8 ) ; $ isPortrait = ( 0x0002 & self :: getUInt2d ( $ recordData , 10 ) ) >> 1 ; $ isNotInit = ( 0x0004 & self :: getUInt2d ( $ recordData , 10 ) ) >> 2 ; if ( ! $ isNotInit ) { $ this -> phpSheet -> getPageSetup ( ) -> setPaperSize ( $ paperSize ) ; switch ( $ isPortrait ) { case 0 : $ this -> phpSheet -> getPageSetup ( ) -> setOrientation ( PageSetup :: ORIENTATION_LANDSCAPE ) ; break ; case 1 : $ this -> phpSheet -> getPageSetup ( ) -> setOrientation ( PageSetup :: ORIENTATION_PORTRAIT ) ; break ; } $ this -> phpSheet -> getPageSetup ( ) -> setScale ( $ scale , false ) ; $ this -> phpSheet -> getPageSetup ( ) -> setFitToPage ( ( bool ) $ this -> isFitToPages ) ; $ this -> phpSheet -> getPageSetup ( ) -> setFitToWidth ( $ fitToWidth , false ) ; $ this -> phpSheet -> getPageSetup ( ) -> setFitToHeight ( $ fitToHeight , false ) ; } $ marginHeader = self :: extractNumber ( substr ( $ recordData , 16 , 8 ) ) ; $ this -> phpSheet -> getPageMargins ( ) -> setHeader ( $ marginHeader ) ; $ marginFooter = self :: extractNumber ( substr ( $ recordData , 24 , 8 ) ) ; $ this -> phpSheet -> getPageMargins ( ) -> setFooter ( $ marginFooter ) ; } }
9760	function containOnly ( string $ type ) : self { return $ this -> expect ( $ this -> target , containsOnly ( $ type ) ) ; }
487	public function dropCommentFromTable ( $ table ) { $ time = $ this -> beginCommand ( "drop comment from table $table" ) ; $ this -> db -> createCommand ( ) -> dropCommentFromTable ( $ table ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
11111	public function migrate ( array $ options = [ ] ) : void { $ files = $ this -> getMigrationFiles ( M :: TYPE_UP ) ; $ migrations = $ this -> pendingMigrations ( $ files , $ this -> repository -> getRan ( ) ) ; $ this -> runPending ( $ migrations , $ options ) ; }
10103	private function writeDimensions ( ) { $ record = 0x0200 ; $ length = 0x000E ; $ data = pack ( 'VVvvv' , $ this -> firstRowIndex , $ this -> lastRowIndex + 1 , $ this -> firstColumnIndex , $ this -> lastColumnIndex + 1 , 0x0000 ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ this -> append ( $ header . $ data ) ; }
12240	public function getElementsByClassName ( $ class ) { if ( strpos ( $ class , '"' ) !== false || strpos ( $ class , "'" ) !== false ) { return array ( ) ; } $ xpath = './/*[contains(concat(" ", @class, " "), " ' . htmlspecialchars ( $ class ) . ' ")]' ; return $ this -> xpath ( $ xpath ) ; }
7681	function TbsPrepareMergeCell ( & $ Txt , & $ Loc ) { if ( $ this -> ExtEquiv == 'docx' ) { $ xml = clsTbsXmlLoc :: FindStartTag ( $ Txt , 'w:tcPr' , $ Loc -> PosBeg , false ) ; if ( $ xml ) { $ Txt = substr_replace ( $ Txt , '' , $ Loc -> PosBeg , $ Loc -> PosEnd - $ Loc -> PosBeg + 1 ) ; $ Loc -> PosBeg = $ xml -> PosEnd + 1 ; $ Loc -> PosEnd = $ xml -> PosEnd ; $ this -> PrevVals [ $ Loc -> FullName ] = '' ; $ Loc -> ConvStr = false ; } } }
5521	public static function generate ( $ class , $ mock_class = false , $ methods = false ) { $ generator = new MockGenerator ( $ class , $ mock_class ) ; return $ generator -> generateSubclass ( $ methods ) ; }
7470	public function newAction ( ) { $ user = new User ( ) ; $ form = $ this -> createForm ( UserType :: class , $ user ) ; return array ( 'user' => $ user , 'form' => $ form -> createView ( ) ) ; }
12855	function goWait ( $ maxExecution = null ) { $ jobExecution = 0 ; $ sleep = 0 ; while ( 1 ) { if ( 0 == $ executed = $ this -> goUntilEmpty ( ) ) { $ sleep += 100000 ; usleep ( $ sleep ) ; if ( $ sleep > 2 * 1000000 ) $ sleep = 100000 ; continue ; } $ jobExecution += $ executed ; if ( $ jobExecution >= $ maxExecution ) break ; if ( $ sleep = $ this -> getSleep ( ) ) usleep ( $ sleep ) ; $ sleep = 0 ; } }
4042	public function getReadableValue ( RenderReadablePropertyValueEvent $ event ) { $ environment = $ event -> getEnvironment ( ) ; $ definition = $ environment -> getDataDefinition ( ) ; $ model = $ event -> getModel ( ) ; if ( ! ( $ model instanceof Model ) ) { return ; } $ nativeItem = $ model -> getItem ( ) ; $ metaModel = $ nativeItem -> getMetaModel ( ) ; $ renderSetting = $ this -> renderSettingFactory -> createCollection ( $ metaModel , $ definition -> getMetaModelDefinition ( ) -> getActiveRenderSetting ( ) ) ; if ( ! $ renderSetting ) { return ; } $ result = $ nativeItem -> parseAttribute ( $ event -> getProperty ( ) -> getName ( ) , 'text' , $ renderSetting ) ; if ( ! isset ( $ result [ 'text' ] ) ) { $ event -> setRendered ( sprintf ( 'Unexpected behaviour, attribute %s text representation was not rendered.' , $ event -> getProperty ( ) -> getName ( ) ) ) ; return ; } $ event -> setRendered ( $ result [ 'text' ] ) ; }
7539	function isParent ( $ tag , $ recursive = false ) { return ( $ this -> hasParent ( $ tag , $ recursive ) === ( $ tag !== null ) ) ; }
8640	public function setShipmentItemList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ShipmentItemList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
5311	protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ fontFile = realpath ( $ input -> getArgument ( 'font-file' ) ) ; if ( $ fontFile === false || ! file_exists ( $ fontFile ) ) { throw new \ InvalidArgumentException ( '"' . $ input -> getArgument ( 'font-file' ) . '" does not exist' ) ; } $ outputFile = $ input -> getArgument ( 'output-file' ) ; $ generator = new IconFontGenerator ; $ output -> writeln ( 'reading font file from "' . $ fontFile . '" ...' ) ; $ generator -> generateFromFont ( new Font ( array ( ) , file_get_contents ( $ fontFile ) ) ) ; $ output -> writeln ( 'writing HTML file to "' . $ outputFile . '" ...' ) ; if ( $ input -> getOption ( 'as-list' ) ) { $ html = $ this -> getHTMLListFromGenerator ( $ generator , basename ( $ fontFile ) ) ; } else { $ html = $ this -> getHTMLFromGenerator ( $ generator , basename ( $ fontFile ) ) ; } file_put_contents ( $ outputFile , $ html ) ; $ output -> getFormatter ( ) -> setStyle ( 'success' , new OutputFormatterStyle ( null , null , array ( 'bold' , 'reverse' ) ) ) ; $ output -> writeln ( '<success>created HTML info page successfully</success>' ) ; }
4764	protected function validateDeliveryAddressOptIn ( ) { $ return = true ; $ optin = ( int ) $ this -> getRequestParameter ( 'oegdproptin_deliveryaddress' ) ; $ changeExistigAddress = ( int ) $ this -> getRequestParameter ( 'oegdproptin_changeDelAddress' ) ; $ addressId = $ this -> getRequestParameter ( 'oxaddressid' ) ; $ deliveryAddressData = $ this -> _getDelAddressData ( ) ; if ( \ OxidEsales \ Eshop \ Core \ Registry :: getConfig ( ) -> getConfigParam ( 'blOeGdprOptinDeliveryAddress' ) && ( ( null == $ addressId ) || ( '-1' == $ addressId ) || ( 1 == $ changeExistigAddress ) ) && ! empty ( $ deliveryAddressData ) && ( 1 !== $ optin ) ) { $ return = false ; } return $ return ; }
8522	public function setGlobalSellingRecommendations ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GlobalSellingRecommendations' ] [ 'FieldValue' ] = $ value ; return $ this ; }
10610	public function checkEmailAction ( ) { $ email = $ this -> get ( 'session' ) -> get ( 'fos_user_send_confirmation_email/email' ) ; $ this -> get ( 'session' ) -> remove ( 'fos_user_send_confirmation_email/email' ) ; $ user = $ this -> get ( 'fos_user.user_manager' ) -> findUserByEmail ( $ email ) ; if ( null === $ user ) { throw new NotFoundHttpException ( sprintf ( 'The user with email "%s" does not exist' , $ email ) ) ; } return $ this -> render ( '@MikyUser/Frontend/Registration/checkEmail.html.twig' , array ( 'user' => $ user , ) ) ; }
4636	public function send ( $ email , array $ options = [ ] ) : ResultInterface { if ( is_string ( $ email ) ) { $ email = $ this -> emailBuilder -> build ( $ email , $ options ) ; } elseif ( is_array ( $ email ) ) { $ email = $ this -> emailBuilder -> build ( Email :: class , $ email ) ; } elseif ( ! $ email instanceof Email ) { throw Exception \ InvalidArgumentException :: fromValidTypes ( [ 'string' , 'array' , Email :: class ] , $ email , 'email' ) ; } $ this -> events -> triggerEvent ( $ this -> createMailEvent ( $ email , MailEvent :: EVENT_MAIL_PRE_RENDER ) ) ; $ this -> renderEmailBody ( $ email ) ; $ eventResp = $ this -> events -> triggerEvent ( $ this -> createMailEvent ( $ email , MailEvent :: EVENT_MAIL_PRE_SEND ) ) ; if ( $ eventResp -> contains ( false ) ) { return new MailResult ( $ email , false ) ; } try { $ message = MessageFactory :: createMessageFromEmail ( $ email ) -> setBody ( $ this -> buildBody ( $ email -> getBody ( ) , $ email -> getCharset ( ) ) ) ; $ this -> attachFiles ( $ message , $ email ) ; $ this -> addCustomHeaders ( $ message , $ email ) ; $ this -> transport -> send ( $ message ) ; $ result = new MailResult ( $ email ) ; $ this -> events -> triggerEvent ( $ this -> createMailEvent ( $ email , MailEvent :: EVENT_MAIL_POST_SEND , $ result ) ) ; return $ result ; } catch ( Throwable $ e ) { $ this -> events -> triggerEvent ( $ this -> createMailEvent ( $ email , MailEvent :: EVENT_MAIL_SEND_ERROR , new MailResult ( $ email , false , $ e ) ) ) ; throw new Exception \ MailException ( 'An error occurred while trying to send the email' , $ e -> getCode ( ) , $ e ) ; } }
6033	public function getMetadata ( $ section = null , $ key = null ) { if ( null === $ section ) { return $ this -> metadata ; } foreach ( $ this -> metadata as $ md ) { if ( $ section != $ md -> getSection ( ) ) { continue ; } if ( null === $ key ) { return $ md ; } foreach ( $ md -> getData ( ) as $ k => $ data ) { if ( $ key == $ k ) { return $ data ; } } throw new NotFoundException ( 'No metadata with section "' . $ section . '" and key "' . $ key . '" exists.' ) ; } throw new NotFoundException ( 'No metadata with section "' . $ section . '" exists.' ) ; }
11764	protected function handleStage ( & $ stages , $ stage ) { if ( $ stage instanceof Pipeline ) { $ stages = array_merge ( $ stages , $ stage -> stages ( ) ) ; } elseif ( $ stage instanceof MiddlewareInterface ) { $ stages [ ] = $ stage ; } elseif ( $ stage instanceof RequestHandlerInterface ) { $ stages [ ] = new RequestHandler ( $ stage ) ; } elseif ( is_callable ( $ stage ) ) { $ stages [ ] = new Lambda ( $ stage ) ; } else { throw new InvalidMiddlewareArgument ( is_string ( $ stage ) ? $ stage : get_class ( $ stage ) ) ; } }
3796	private function checkForRoot ( $ containedModel , $ action ) { if ( $ this -> hasVariants ( ) && $ action == 'cut' && $ containedModel -> getProperty ( 'varbase' ) == 0 ) { $ this -> disablePI = true ; } }
3061	public function getCurrentPosition ( ) { $ route = $ this -> getTestSession ( ) -> getRoute ( ) ; $ routeCount = $ route -> count ( ) ; $ routeItemPosition = $ route -> getPosition ( ) ; $ currentRouteItem = $ route -> getRouteItemAt ( $ routeItemPosition ) ; $ finalPosition = 0 ; for ( $ i = 0 ; $ i < $ routeCount ; $ i ++ ) { $ routeItem = $ route -> getRouteItemAt ( $ i ) ; if ( $ routeItem !== $ currentRouteItem ) { if ( ! $ this -> isAdaptive ( $ routeItem -> getAssessmentItemRef ( ) ) ) { $ finalPosition ++ ; } else { $ finalPosition += count ( $ this -> getShadowTest ( $ routeItem ) ) ; } } else { if ( $ this -> isAdaptive ( $ routeItem -> getAssessmentItemRef ( ) ) ) { $ finalPosition += array_search ( $ this -> getCurrentCatItemId ( $ routeItem ) , $ this -> getShadowTest ( $ routeItem ) ) ; } break ; } } return $ finalPosition ; }
8437	public static function countRows ( array $ conditions , bool $ critical = false ) { $ entity = new static ( ) ; $ selectQuery = new Select ( $ entity -> getDatabaseName ( ) , $ critical ) ; $ selectQuery -> select ( [ 'count' => 'COUNT(*)' ] ) ; $ selectQuery -> from ( $ entity -> getTableName ( ) ) ; if ( count ( $ conditions ) > 0 ) { $ where = array ( ) ; foreach ( $ conditions as $ key => $ value ) { $ realName = constant ( get_called_class ( ) . '::FIELD_' . strtoupper ( Helper :: codifyName ( $ key ) ) ) ; $ where [ $ realName ] = ':where' . ucfirst ( $ key ) ; $ selectQuery -> bind ( 'where' . ucfirst ( $ key ) , $ value ) ; } $ selectQuery -> where ( $ where ) ; } if ( $ selectQuery -> execute ( ) === false ) { return false ; } $ data = $ selectQuery -> fetch ( ) ; if ( $ data === false ) { return false ; } return $ data [ 'count' ] ; }
7203	public function addDiscountAdjustment ( Adjustment $ discount ) : void { foreach ( $ this -> discounts as $ d ) { if ( $ d -> isSameAs ( $ discount ) ) { $ d -> addAmount ( $ discount -> getAmount ( ) ) ; return ; } } $ this -> discounts [ ] = clone $ discount ; }
2788	public static function getMutation ( array & $ tokens , $ index ) { $ num = ( integer ) $ tokens [ $ index ] [ 1 ] ; if ( $ num == 0 ) { $ replace = 1 ; } elseif ( $ num == 1 ) { $ replace = 0 ; } else { $ replace = $ num + 1 ; } $ tokens [ $ index ] = [ T_LNUMBER , ( string ) $ replace ] ; }
6809	public function currency ( float $ number , string $ currency = null ) : string { return $ this -> getCurrencyFormatter ( ) -> formatCurrency ( $ number , $ currency ? $ currency : $ this -> currency ) ; }
5388	protected function valuesArePossible ( $ values ) { $ matches = array ( ) ; $ widgets = & $ this -> getWidgets ( ) ; for ( $ i = 0 , $ count = count ( $ widgets ) ; $ i < $ count ; $ i ++ ) { $ possible = $ widgets [ $ i ] -> getAttribute ( 'value' ) ; if ( in_array ( $ possible , $ values ) ) { $ matches [ ] = $ possible ; } } return ( $ values == $ matches ) ; }
6102	public function listPropertyTypes ( $ systemName = null , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/propertysets/propertytypes' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new PropertyType ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; if ( null !== $ systemName ) { foreach ( $ result as $ entry ) { if ( $ entry -> getSystemName ( ) === $ systemName ) { return $ entry ; } } return null ; } return $ result ; }
4080	protected function isInputScreenStandalone ( $ metaModel ) { $ information = $ this -> information [ $ metaModel ] ; $ inputScreen = isset ( $ information [ self :: INPUTSCREEN ] ) ? $ information [ self :: INPUTSCREEN ] : null ; if ( ! is_object ( $ inputScreen ) ) { return ( $ inputScreen [ 'row' ] [ 'rendertype' ] == 'standalone' ) ; } return $ inputScreen -> isStandalone ( ) ; }
7826	protected function getLongestPipeLength ( ) { if ( empty ( $ this -> pipes ) ) return 0 ; return array_reduce ( $ this -> pipes , function ( $ carry , $ pipe ) { return strlen ( $ pipe ) > $ carry ? strlen ( $ pipe ) : $ carry ; } , static :: MIN_PIPE_LENGTH ) ; }
2463	public static function findSentByPid ( $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid=?" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ arrColumns [ ] = "$t.sent=1" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.date DESC" ; } return static :: findBy ( $ arrColumns , $ intPid , $ arrOptions ) ; }
11783	public function add ( $ title , $ description , $ pageUrl , $ iconUrl , $ comment = '' ) { $ params = [ 'title' => $ title , 'description' => $ description , 'page_url' => $ pageUrl , 'icon_url' => $ iconUrl , ] ; if ( $ comment !== '' ) { $ params [ 'comment' ] = $ comment ; } return $ this -> parseJSON ( 'json' , [ self :: API_ADD , $ params ] ) ; }
12100	public function priceBrutto ( $ netto , $ tax ) { $ tax = round ( ( double ) $ tax / 100.0 , 2 ) ; if ( $ tax < 0.00 ) { throw new Exception ( sprintf ( 'Tax must be greater than or equal to 0, given %s.' , $ tax ) ) ; } if ( $ tax === 0.00 ) { return $ netto ; } $ result = $ netto * ( $ tax + 1 ) ; return round ( $ result , 2 , PHP_ROUND_HALF_UP ) ; }
600	public function andOnCondition ( $ condition , $ params = [ ] ) { if ( $ this -> on === null ) { $ this -> on = $ condition ; } else { $ this -> on = [ 'and' , $ this -> on , $ condition ] ; } $ this -> addParams ( $ params ) ; return $ this ; }
1501	public function matchesTo ( MediaTypeInterface $ mediaType ) : ? Encoding { return collect ( $ this -> stack ) -> first ( function ( Encoding $ encoding ) use ( $ mediaType ) { return $ encoding -> matchesTo ( $ mediaType ) ; } ) ; }
103	protected function pruneToHighestPriorityOrInstalled ( Pool $ pool , array $ installedMap , array $ literals ) { $ selected = array ( ) ; $ priority = null ; foreach ( $ literals as $ literal ) { $ package = $ pool -> literalToPackage ( $ literal ) ; if ( isset ( $ installedMap [ $ package -> id ] ) ) { $ selected [ ] = $ literal ; continue ; } if ( null === $ priority ) { $ priority = $ this -> getPriority ( $ pool , $ package ) ; } if ( $ this -> getPriority ( $ pool , $ package ) != $ priority ) { break ; } $ selected [ ] = $ literal ; } return $ selected ; }
5631	public function paintFooter ( $ test_name ) { ob_start ( ) ; parent :: paintFooter ( $ test_name ) ; $ output = trim ( ob_get_clean ( ) ) ; if ( $ output ) { if ( ( $ this -> getFailCount ( ) + $ this -> getExceptionCount ( ) ) == 0 ) { $ color = $ this -> _passColor ; } else { $ color = $ this -> _failColor ; } $ this -> _setColor ( $ color ) ; echo $ output ; $ this -> _resetColor ( ) ; } }
5209	public function convert ( array $ stmts , ClassMetadata $ metadata , ClassCollector $ classCollector , Logger $ logger ) { $ this -> metadata = $ metadata ; $ this -> classCollector = $ classCollector ; $ this -> logger = $ logger ; return ltrim ( str_replace ( "\n" . self :: noIndentToken , "\n" , $ this -> pStmts ( $ stmts , false ) ) ) ; }
10529	protected function normalizeProxyHeader ( $ header ) { $ header = strtoupper ( $ header ) ; $ header = str_replace ( '-' , '_' , $ header ) ; if ( 0 !== strpos ( $ header , 'HTTP_' ) ) { $ header = 'HTTP_' . $ header ; } return $ header ; }
6955	private function getTaxesRates ( ShipmentMethodInterface $ method , CountryInterface $ country ) { return array_map ( function ( TaxInterface $ tax ) { return $ tax -> getRate ( ) ; } , $ this -> taxResolver -> resolveTaxes ( $ method , $ country ) ) ; }
7981	public function getSessionFilesProperties ( $ sessId , $ fileId ) { return json_decode ( self :: getClient ( ) -> getPcaSessionFilesProperties ( $ this -> pp , $ this -> sn , $ sessId , $ fileId ) ) ; }
6579	public function setParts ( array $ parts ) { $ parts = array_intersect_key ( $ parts , $ this -> params ) ; if ( isset ( $ parts [ 'port' ] ) ) $ parts [ 'port' ] = ( int ) $ parts [ 'port' ] ; if ( isset ( $ parts [ 'query' ] ) ) { $ query = $ this -> _parse_str ( $ parts [ 'query' ] ) ; $ this -> _rksort ( $ query ) ; $ parts [ 'query' ] = $ query ; } array_walk ( $ parts , function ( & $ part , $ key ) { if ( is_string ( $ part ) ) { $ part = strlen ( $ part ) ? $ part : null ; } else { $ part = $ part ? : null ; } } ) ; $ self = clone $ this ; $ self -> params = array_replace ( $ this -> params , $ parts ) ; return $ self ; }
11879	public static function getTrace ( ) { $ trace = debug_backtrace ( ) ; $ dump = '' ; $ dump .= static :: getHeader ( 'Trace du contexte' ) ; $ dump .= '<div class="dump_segment">Contexte</div>' ; $ nb = count ( $ trace ) ; for ( $ i = 1 ; $ i < $ nb ; $ i ++ ) { if ( $ i < $ nb - 1 ) { $ dump .= static :: getContext ( $ trace [ $ i ] , $ trace [ $ i + 1 ] ) ; } else { $ dump .= static :: getContext ( $ trace [ $ i ] ) ; } } $ dump .= static :: getFooter ( ) ; return $ dump ; }
505	public function init ( ) { parent :: init ( ) ; if ( ! isset ( $ this -> translations [ 'yii' ] ) && ! isset ( $ this -> translations [ 'yii*' ] ) ) { $ this -> translations [ 'yii' ] = [ 'class' => 'yii\i18n\PhpMessageSource' , 'sourceLanguage' => 'en-US' , 'basePath' => '@yii/messages' , ] ; } if ( ! isset ( $ this -> translations [ 'app' ] ) && ! isset ( $ this -> translations [ 'app*' ] ) ) { $ this -> translations [ 'app' ] = [ 'class' => 'yii\i18n\PhpMessageSource' , 'sourceLanguage' => Yii :: $ app -> sourceLanguage , 'basePath' => '@app/messages' , ] ; } }
2334	public function onSwitchUser ( SwitchUserEvent $ event ) : void { $ token = $ this -> tokenStorage -> getToken ( ) ; if ( null === $ token ) { throw new \ RuntimeException ( 'The token storage did not contain a token.' ) ; } $ sourceUser = $ token -> getUser ( ) ; if ( $ sourceUser instanceof UserInterface ) { $ sourceUser = $ sourceUser -> getUsername ( ) ; } $ targetUser = $ event -> getTargetUser ( ) ; if ( $ targetUser instanceof UserInterface ) { $ targetUser = $ targetUser -> getUsername ( ) ; } $ this -> logger -> info ( sprintf ( 'User "%s" has switched to user "%s"' , $ sourceUser , $ targetUser ) , [ 'contao' => new ContaoContext ( __METHOD__ , ContaoContext :: ACCESS , $ sourceUser ) ] ) ; }
9847	public function createSealedResponse ( int $ status , string $ body , SealingPublicKey $ key , array $ headers = [ ] , string $ version = '1.1' ) : ResponseInterface { return new Response ( $ status , new Headers ( $ headers ) , $ this -> stringToStream ( Base64UrlSafe :: encode ( Simple :: seal ( $ body , $ key ) ) ) ) ; }
5841	public function addRole ( $ role ) { if ( is_string ( $ role ) ) { $ role = new Role ( $ role ) ; } elseif ( ! $ role instanceof RoleInterface ) { throw new \ InvalidArgumentException ( sprintf ( 'Role must be a string or RoleInterface instance, but got %s.' , gettype ( $ role ) ) ) ; } if ( ! \ in_array ( $ role , $ this -> roles ) ) { $ this -> roles [ ] = $ role ; } }
8977	public function setParameter ( $ name , $ value ) { if ( ! isset ( $ ref ) ) { $ ref = new \ ReflectionClass ( $ this -> config ) ; } $ function = sprintf ( 'set%s' , ucfirst ( $ name ) ) ; if ( ! $ ref -> hasMethod ( $ function ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The function "%s" does not exists on configuration' , $ name ) ) ; } $ this -> config -> $ function ( $ value ) ; return $ this ; }
10489	public static function unbufferConnection ( Connection $ connection ) { $ wrappedConnection = $ connection -> getWrappedConnection ( ) ; if ( ! $ wrappedConnection instanceof PDOConnection ) { throw new InvalidArgumentException ( 'unbufferConection can only be used with pdo_mysql Doctrine driver.' ) ; } if ( $ wrappedConnection -> getAttribute ( PDO :: ATTR_DRIVER_NAME ) != 'mysql' ) { throw new InvalidArgumentException ( 'unbufferConection can only be used with PDO mysql driver, got "' . $ wrappedConnection -> getAttribute ( PDO :: ATTR_DRIVER_NAME ) . '" instead.' ) ; } if ( $ connection -> isConnected ( ) ) { $ connection -> close ( ) ; } $ connection -> getWrappedConnection ( ) -> setAttribute ( PDO :: MYSQL_ATTR_USE_BUFFERED_QUERY , false ) ; $ connection -> connect ( ) ; }
12754	protected function prepareRequest ( ) { if ( $ this -> method === static :: GET && ! empty ( $ this -> data ) ) { $ url = trim ( $ this -> url , '/' ) . '?' ; $ url .= http_build_query ( $ this -> data ) ; } else { $ url = $ this -> url ; } $ options = array ( CURLOPT_URL => $ url , CURLOPT_POST => $ this -> method === static :: POST , CURLOPT_HEADER => true , CURLOPT_NOBODY => $ this -> method === static :: HEAD , CURLOPT_RETURNTRANSFER => true , CURLOPT_USERAGENT => $ this -> userAgent , CURLOPT_SSL_VERIFYPEER => false ) ; if ( ! in_array ( $ this -> method , [ static :: GET , static :: HEAD , static :: POST ] ) ) { $ options [ CURLOPT_CUSTOMREQUEST ] = $ this -> method ; } if ( ! empty ( $ this -> data ) && $ this -> method !== static :: GET ) { $ options [ CURLOPT_POSTFIELDS ] = http_build_query ( $ this -> data ) ; } if ( ! empty ( $ this -> headers ) ) { $ headersToSend = [ ] ; foreach ( $ this -> headers as $ key => $ value ) { $ headersToSend [ ] = "{$key}: {$value}" ; } $ options [ CURLOPT_HTTPHEADER ] = $ headersToSend ; } if ( ! empty ( $ this -> cookies ) ) { $ cookiesToSend = [ ] ; foreach ( $ this -> cookies as $ key => $ value ) { $ cookiesToSend [ ] = "{$key}={$value}" ; } $ options [ CURLOPT_COOKIE ] = implode ( '; ' , $ cookiesToSend ) ; } curl_setopt_array ( $ this -> resource , $ options ) ; }
367	public function renderFilters ( ) { if ( $ this -> filterModel !== null ) { $ cells = [ ] ; foreach ( $ this -> columns as $ column ) { $ cells [ ] = $ column -> renderFilterCell ( ) ; } return Html :: tag ( 'tr' , implode ( '' , $ cells ) , $ this -> filterRowOptions ) ; } return '' ; }
8257	protected function startAuthentication ( ) { $ authorizationUrl = $ this -> provider -> getAuthorizationUrl ( ) ; $ this -> session -> migrate ( true ) ; $ this -> session -> set ( "oauth2state" , $ this -> provider -> getState ( ) ) ; $ this -> picoAuth -> redirectToPage ( $ authorizationUrl , null , false ) ; }
4108	public function getSkinFileContent ( $ file ) { $ package = Mage :: getSingleton ( 'core/design_package' ) ; $ areaBackup = $ package -> getArea ( ) ; $ path = $ package -> setArea ( 'frontend' ) -> getFilename ( $ file , array ( '_type' => 'skin' ) ) ; $ content = file_get_contents ( $ path ) ; $ package -> setArea ( $ areaBackup ) ; return $ content ; }
5576	public function clickSubmitById ( $ id , $ additional = false ) { if ( ! ( $ form = $ this -> page -> getFormBySubmit ( new SelectById ( $ id ) ) ) ) { return false ; } $ success = $ this -> load ( $ form -> getAction ( ) , $ form -> submitButton ( new SelectById ( $ id ) , $ additional ) ) ; return ( $ success ? $ this -> getContent ( ) : $ success ) ; }
5275	public function having ( $ column , $ param1 = null , $ param2 = null ) { $ this -> statements [ 'having' ] = $ this -> generateWhere ( $ column , $ param1 , $ param2 , 'having' ) ; return $ this ; }
11618	private function compressPhase2 ( $ calcIdWriteOff , $ calcIdPhase1 , $ calcIdPhase2 , $ scheme ) { $ pv = $ this -> rouGetPv -> exec ( $ calcIdWriteOff ) ; $ dwnlPlain = $ this -> daoBonDwnl -> getByCalcId ( $ calcIdWriteOff ) ; $ dwnlPhase1 = $ this -> daoBonDwnl -> getByCalcId ( $ calcIdPhase1 ) ; $ ctx = new \ Praxigento \ Core \ Data ( ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_CALC_ID_PHASE2 , $ calcIdPhase2 ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_SCHEME , $ scheme ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_DWNL_PLAIN , $ dwnlPlain ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_DWNL_PHASE1 , $ dwnlPhase1 ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_MAP_PV , $ pv ) ; $ out = $ this -> procCmprsPhase2 -> exec ( $ ctx ) ; $ dwnlPhase2 = $ out -> get ( PCpmrsPhase2 :: OUT_DWNL_PHASE2 ) ; $ legs = $ out -> get ( PCpmrsPhase2 :: OUT_LEGS ) ; $ result = [ $ dwnlPhase2 , $ legs ] ; return $ result ; }
8330	public function connect ( array $ params , $ username = null , $ password = null , array $ driverOptions = [ ] ) { if ( PlatformHelper :: isWindows ( ) ) { return $ this -> connectWindows ( $ params , $ username , $ password , $ driverOptions ) ; } return $ this -> connectUnix ( $ params , $ username , $ password , $ driverOptions ) ; }
5031	public function setLoadedPage ( $ loadedPage ) { $ this -> dispatch ( Event \ PageEvents :: PAGE_VIEW , new Event \ PageViewEvent ( $ loadedPage ) ) ; $ this -> loadedPage = $ loadedPage ; }
3999	protected function getCount ( $ strType , $ intID ) { switch ( $ strType ) { case 'mod' : $ objMetaModelResult = $ this -> getMetaModelDataFrom ( 'tl_module' , $ intID ) ; break ; case 'ce' : $ objMetaModelResult = $ this -> getMetaModelDataFrom ( 'tl_content' , $ intID ) ; break ; default : return false ; } if ( $ objMetaModelResult != null ) { return $ this -> getCountFor ( $ objMetaModelResult -> metamodel , $ objMetaModelResult -> metamodel_filtering ) ; } return false ; }
6513	public function copyJob ( JobInterface $ from , \ Abc \ Bundle \ JobBundle \ Model \ JobInterface $ to ) { $ to -> setType ( $ from -> getType ( ) ) ; $ to -> setResponse ( $ from -> getResponse ( ) ) ; $ to -> setParameters ( $ from -> getParameters ( ) ) ; if ( null != $ from -> getStatus ( ) ) { $ to -> setStatus ( $ from -> getStatus ( ) ) ; } foreach ( $ from -> getSchedules ( ) as $ schedule ) { $ to -> addSchedule ( $ schedule ) ; } return $ to ; }
4114	public function getRemoteCallEnabled ( ) { if ( is_null ( $ this -> remoteCallEnabled ) ) { $ this -> remoteCallEnabled = Mage :: getStoreConfigFlag ( 'dev/aoe_templatehints/enablePhpstormRemoteCall' ) ; } return $ this -> remoteCallEnabled ; }
11075	public function setArray ( string $ key , $ value , callable $ callback = null , array $ ignoredDefaultValue = null ) { if ( $ value instanceof Traversable ) { $ value = iterator_to_array ( $ value ) ; } if ( is_array ( $ value ) ) { if ( is_callable ( $ callback ) ) { $ value = array_map ( $ callback , $ value ) ; } $ this -> set ( $ key , $ value , $ ignoredDefaultValue ) ; } return $ this ; }
11414	public function decryptData ( $ sessionKey , $ iv , $ encrypted ) { try { $ decrypted = openssl_decrypt ( base64_decode ( $ encrypted , true ) , 'aes-128-cbc' , base64_decode ( $ sessionKey , true ) , OPENSSL_RAW_DATA | OPENSSL_NO_PADDING , base64_decode ( $ iv , true ) ) ; } catch ( Exception $ e ) { throw new EncryptionException ( $ e -> getMessage ( ) , EncryptionException :: ERROR_DECRYPT_AES ) ; } if ( is_null ( $ result = json_decode ( $ this -> decode ( $ decrypted ) , true ) ) ) { throw new EncryptionException ( 'ILLEGAL_BUFFER' , EncryptionException :: ILLEGAL_BUFFER ) ; } return $ result ; }
10859	protected function cacheMarkers ( string $ marker ) : void { $ this -> marked [ $ marker ] = [ ] ; foreach ( $ this -> definitions as $ definition ) { foreach ( ( array ) $ definition -> markers as $ m ) { if ( $ m instanceof $ marker ) { $ this -> marked [ $ marker ] [ ] = [ $ definition , $ m ] ; } } } }
12758	public static function getNew ( ) { $ class = new MediaLink ; $ medialink = get_class_vars ( get_class ( $ class ) ) ; foreach ( $ medialink as $ name => $ default ) : $ class :: set ( $ name , null ) ; $ class :: set ( "objectType" , "medialink" ) ; endforeach ; return $ class ; }
10300	private function writeBubbles ( $ plotSeriesValues , $ objWriter ) { if ( $ plotSeriesValues === null ) { return ; } $ objWriter -> startElement ( 'c:bubbleSize' ) ; $ objWriter -> startElement ( 'c:numLit' ) ; $ objWriter -> startElement ( 'c:formatCode' ) ; $ objWriter -> writeRawData ( 'General' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:ptCount' ) ; $ objWriter -> writeAttribute ( 'val' , $ plotSeriesValues -> getPointCount ( ) ) ; $ objWriter -> endElement ( ) ; $ dataValues = $ plotSeriesValues -> getDataValues ( ) ; if ( ! empty ( $ dataValues ) ) { if ( is_array ( $ dataValues ) ) { foreach ( $ dataValues as $ plotSeriesKey => $ plotSeriesValue ) { $ objWriter -> startElement ( 'c:pt' ) ; $ objWriter -> writeAttribute ( 'idx' , $ plotSeriesKey ) ; $ objWriter -> startElement ( 'c:v' ) ; $ objWriter -> writeRawData ( 1 ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; } } } $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:bubble3D' ) ; $ objWriter -> writeAttribute ( 'val' , 0 ) ; $ objWriter -> endElement ( ) ; }
9004	protected function months_dropdown ( $ post_type ) { global $ wpdb , $ wp_locale ; $ tn = $ this -> table -> get_table_name ( $ wpdb ) ; $ months = $ wpdb -> get_results ( " SELECT DISTINCT YEAR( time ) AS year, MONTH( time ) AS month FROM $tn ORDER BY time DESC " ) ; $ month_count = count ( $ months ) ; if ( ! $ month_count || ( 1 == $ month_count && 0 == $ months [ 0 ] -> month ) ) { return ; } $ m = isset ( $ _GET [ 'm' ] ) ? ( int ) $ _GET [ 'm' ] : 0 ; ?> <label for="filter-by-date" class="screen-reader-text"> <?php _e ( 'Filter by date' ) ; ?> </label> <select name="m" id="filter-by-date"> <option <?php selected ( $ m , 0 ) ; ?> value="0"> <?php _e ( 'All dates' ) ; ?> </option> <?php foreach ( $ months as $ arc_row ) { if ( 0 == $ arc_row -> year ) { continue ; } $ month = zeroise ( $ arc_row -> month , 2 ) ; $ year = $ arc_row -> year ; printf ( "<option %s value='%s'>%s</option>\n" , selected ( $ m , $ year . $ month , false ) , esc_attr ( $ arc_row -> year . $ month ) , sprintf ( __ ( '%1$s %2$d' ) , $ wp_locale -> get_month ( $ month ) , $ year ) ) ; } ?> </select> <?php }
6757	public function supportsDenormalization ( $ data , $ type , $ format = null ) { if ( ! \ class_exists ( $ type ) ) { return false ; } $ classAnnotation = $ this -> annotationReader -> getClassAnnotation ( new \ ReflectionClass ( $ type ) , NestedPropertyDenormalizerAnnotation :: class ) ; return $ classAnnotation instanceof NestedPropertyDenormalizerAnnotation ; }
105	public function watch2OnHighest ( Decisions $ decisions ) { $ literals = $ this -> rule -> getLiterals ( ) ; if ( count ( $ literals ) < 3 ) { return ; } $ watchLevel = 0 ; foreach ( $ literals as $ literal ) { $ level = $ decisions -> decisionLevel ( $ literal ) ; if ( $ level > $ watchLevel ) { $ this -> watch2 = $ literal ; $ watchLevel = $ level ; } } }
4599	public function kernelRequest ( GetResponseEvent $ event ) { $ request = $ event -> getRequest ( ) ; $ entity = $ request -> attributes -> get ( '_api_resource_class' ) ; if ( null === $ entity ) { return ; } if ( ! in_array ( Translatable :: class , class_implements ( $ entity ) , true ) ) { return ; } $ model = $ request -> attributes -> get ( 'data' ) ; if ( 'post' === $ request -> attributes -> get ( '_api_collection_operation_name' ) ) { $ this -> translationService -> transfer ( $ model ) ; } else if ( 'put' === $ request -> attributes -> get ( '_api_item_operation_name' ) ) { $ this -> translationService -> transfer ( $ model ) ; $ this -> translationService -> translate ( $ model ) ; } }
8991	public function build ( $ attributes = null ) { if ( $ attributes instanceof \ ElggEntity ) { return $ attributes ; } if ( is_numeric ( $ attributes ) ) { return $ this -> get ( $ attributes ) ; } $ attributes = ( array ) $ attributes ; if ( ! empty ( $ attributes [ 'guid' ] ) ) { return $ this -> get ( $ attributes [ 'guid' ] ) ; } $ type = elgg_extract ( 'type' , $ attributes , 'object' ) ; $ subtype = elgg_extract ( 'subtype' , $ attributes , ELGG_ENTITIES_ANY_VALUE ) ; unset ( $ attributes [ 'type' ] ) ; unset ( $ attributes [ 'subtype' ] ) ; $ class = get_subtype_class ( $ type , $ subtype ) ; if ( class_exists ( $ class ) ) { $ entity = new $ class ( ) ; } else { switch ( $ type ) { case 'object' : $ entity = new \ ElggObject ( ) ; $ entity -> subtype = $ subtype ; break ; case 'user' : $ entity = new \ ElggUser ( ) ; $ entity -> subtype = $ subtype ; break ; case 'group' : $ entity = new \ ElggGroup ( ) ; $ entity -> subtype = $ subtype ; break ; } } foreach ( $ attributes as $ key => $ value ) { if ( in_array ( $ key , $ this -> getAttributeNames ( $ entity ) ) ) { $ entity -> $ key = $ value ; } } return $ entity ; }
618	private function parseString ( $ value , & $ i ) { $ isQuoted = $ value [ $ i ] === '"' ; $ stringEndChars = $ isQuoted ? [ '"' ] : [ $ this -> delimiter , '}' ] ; $ result = '' ; $ len = strlen ( $ value ) ; for ( $ i += $ isQuoted ? 1 : 0 ; $ i < $ len ; ++ $ i ) { if ( in_array ( $ value [ $ i ] , [ '\\' , '"' ] , true ) && in_array ( $ value [ $ i + 1 ] , [ $ value [ $ i ] , '"' ] , true ) ) { ++ $ i ; } elseif ( in_array ( $ value [ $ i ] , $ stringEndChars , true ) ) { break ; } $ result .= $ value [ $ i ] ; } $ i -= $ isQuoted ? 0 : 1 ; if ( ! $ isQuoted && $ result === 'NULL' ) { $ result = null ; } return $ result ; }
6825	protected function getPaymentAccountNumber ( PaymentMethodInterface $ method , string $ origin ) { foreach ( $ this -> accounts as $ account ) { if ( $ account -> getType ( ) !== AccountingTypes :: TYPE_PAYMENT ) { continue ; } if ( $ account -> getPaymentMethod ( ) !== $ method ) { continue ; } return $ account -> getNumber ( ) ; } throw new LogicException ( sprintf ( "No payment account number configured for payment method '%s' (%s)" , $ method -> getName ( ) , $ origin ) ) ; }
8767	protected function registerBaseBindings ( ) { static :: setInstance ( $ this ) ; $ this -> instance ( 'app' , $ this ) ; $ this -> instance ( Container :: class , $ this ) ; $ this -> singleton ( 'config' , function ( ) { return new \ Nur \ Config \ Config ( $ this -> config ) ; } ) ; $ this -> singleton ( 'files' , function ( ) { return new Filesystem ; } ) ; $ this -> instance ( PackageManifest :: class , new PackageManifest ( new Filesystem , $ this -> basePath ( ) , $ this -> getCachedPackagesPath ( ) ) ) ; }
9652	protected function initFormField ( ) { $ options = $ this -> Options ( ) -> map ( 'EscapedTitle' , 'Title' ) ; return new OptionsetField ( $ this -> Name , $ this -> Title , $ options ) ; }
4310	public function getChannels ( $ allDescendants = false ) { if ( $ allDescendants ) { $ channels = array ( ) ; foreach ( $ this -> channels as $ channel ) { $ channels = \ array_merge ( $ channels , array ( $ channel -> getCfg ( 'channel' ) => $ channel ) , $ channel -> getChannels ( true ) ) ; } return $ channels ; } return $ this -> channels ; }
9843	public function createSignedJsonRequest ( string $ method , string $ uri , array $ arrayToJsonify , SigningSecretKey $ key , array $ headers = [ ] ) : RequestInterface { if ( empty ( $ headers [ 'Content-Type' ] ) ) { $ headers [ 'Content-Type' ] = 'application/json' ; } $ body = \ json_encode ( $ arrayToJsonify , JSON_PRETTY_PRINT ) ; if ( ! \ is_string ( $ body ) ) { throw new InvalidMessageException ( 'Cannot JSON-encode this message.' ) ; } return $ this -> createSignedRequest ( $ method , $ uri , $ body , $ key , $ headers ) ; }
12915	protected function getColumnReference ( $ column , $ tableless ) { if ( $ tableless ) { return $ column ; } if ( count ( explode ( "." , $ column ) ) > 1 ) { return $ column ; } return "`" . $ this -> table . "`.`" . $ column . "`" ; }
2733	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ activateVcl = $ this -> getRequest ( ) -> getParam ( 'activate_flag' ) ; $ html = $ this -> getRequest ( ) -> getParam ( 'html' ) ; $ service = $ this -> api -> checkServiceDetails ( ) ; $ this -> vcl -> checkCurrentVersionActive ( $ service -> versions , $ activeVersion ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; $ snippets = $ this -> config -> getVclSnippets ( Config :: VCL_ERROR_SNIPPET_PATH , Config :: VCL_ERROR_SNIPPET ) ; foreach ( $ snippets as $ key => $ value ) { $ snippetData = [ 'name' => Config :: FASTLY_MAGENTO_MODULE . '_error_page_' . $ key , 'type' => $ key , 'dynamic' => '0' , 'content' => $ value ] ; $ this -> api -> uploadSnippet ( $ clone -> number , $ snippetData ) ; } $ condition = [ 'name' => Config :: FASTLY_MAGENTO_MODULE . '_error_page_condition' , 'statement' => 'req.http.ResponseObject == "970"' , 'type' => 'REQUEST' , 'priority' => '9' ] ; $ createCondition = $ this -> api -> createCondition ( $ clone -> number , $ condition ) ; $ response = [ 'name' => Config :: ERROR_PAGE_RESPONSE_OBJECT , 'request_condition' => $ createCondition -> name , 'content' => $ html , 'status' => "503" , 'content_type' => "text/html; charset=utf-8" , 'response' => "Service Temporarily Unavailable" ] ; $ createResponse = $ this -> api -> createResponse ( $ clone -> number , $ response ) ; if ( ! $ createResponse ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to create a RESPONSE object.' ] ) ; } $ this -> api -> validateServiceVersion ( $ clone -> number ) ; if ( $ activateVcl === 'true' ) { $ this -> api -> activateVersion ( $ clone -> number ) ; } if ( $ this -> config -> areWebHooksEnabled ( ) && $ this -> config -> canPublishConfigChanges ( ) ) { $ this -> api -> sendWebHook ( '*New Error/Maintenance page has updated and activated under config version ' . $ clone -> number . '*' ) ; } $ comment = [ 'comment' => 'Magento Module updated Error Page html' ] ; $ this -> api -> addComment ( $ clone -> number , $ comment ) ; return $ result -> setData ( [ 'status' => true , 'active_version' => $ clone -> number ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
1912	public function pickerAction ( Request $ request ) : RedirectResponse { $ extras = [ ] ; if ( $ request -> query -> has ( 'extras' ) ) { $ extras = $ request -> query -> get ( 'extras' ) ; if ( ! \ is_array ( $ extras ) ) { throw new BadRequestHttpException ( 'Invalid picker extras' ) ; } } $ config = new PickerConfig ( $ request -> query -> get ( 'context' ) , $ extras , $ request -> query -> get ( 'value' ) ) ; $ picker = $ this -> get ( 'contao.picker.builder' ) -> create ( $ config ) ; if ( null === $ picker ) { throw new BadRequestHttpException ( 'Unsupported picker context' ) ; } return new RedirectResponse ( $ picker -> getCurrentUrl ( ) ) ; }
5779	public function getOne ( ) : ? string { $ result = $ this -> execute ( ) ; if ( pg_num_rows ( $ result ) == 1 ) { if ( pg_num_fields ( $ result ) == 1 ) { return pg_fetch_array ( $ result ) [ 0 ] ; } else { throw new \ Exception ( "Too many result fields" ) ; } } else { if ( pg_num_rows ( $ result ) == 0 ) { return null ; } else { throw new \ Exception ( "Multiple results" ) ; } } }
3486	private static function addDefaultResolvers ( ) : void { static $ added = false ; if ( $ added ) { return ; } $ added = true ; self :: addResolver ( [ __CLASS__ , 'tryResolveByWebTokenJwtSystem' ] ) ; self :: addResolver ( [ __CLASS__ , 'tryResolveBySpomkyLabsJoseSystem' ] ) ; }
4429	protected function getChoiceQuestion ( $ questionName , $ defaultValue = null , array $ choices = array ( ) ) { $ questionName = $ defaultValue ? '<info>' . $ questionName . '</info> [<comment>' . $ defaultValue . '</comment>]: ' : '<info>' . $ questionName . '</info>: ' ; return new ChoiceQuestion ( $ questionName , $ choices , $ defaultValue ) ; }
1133	public function setDefaultLeftAndRight ( ) { $ withHighestRight = $ this -> newNestedSetQuery ( ) -> reOrderBy ( $ this -> getRightColumnName ( ) , 'desc' ) -> take ( 1 ) -> sharedLock ( ) -> first ( ) ; $ maxRgt = 0 ; if ( ! is_null ( $ withHighestRight ) ) $ maxRgt = $ withHighestRight -> getRight ( ) ; $ this -> setAttribute ( $ this -> getLeftColumnName ( ) , $ maxRgt + 1 ) ; $ this -> setAttribute ( $ this -> getRightColumnName ( ) , $ maxRgt + 2 ) ; }
1828	public function save ( ) { if ( \ count ( \ func_get_args ( ) ) ) { throw new \ InvalidArgumentException ( 'The $blnForceInsert argument has been removed (see system/docs/UPGRADE.md)' ) ; } if ( $ this -> blnPreventSaving ) { throw new \ RuntimeException ( 'The model instance has been detached and cannot be saved' ) ; } $ objDatabase = Database :: getInstance ( ) ; $ arrFields = $ objDatabase -> getFieldNames ( static :: $ strTable ) ; if ( Registry :: getInstance ( ) -> isRegistered ( $ this ) ) { $ arrSet = array ( ) ; $ arrRow = $ this -> row ( ) ; foreach ( $ this -> arrModified as $ k => $ v ) { if ( \ in_array ( $ k , $ arrFields ) ) { $ arrSet [ $ k ] = $ arrRow [ $ k ] ; } } $ arrSet = $ this -> preSave ( $ arrSet ) ; if ( empty ( $ arrSet ) ) { return $ this ; } $ intPk = $ this -> { static :: $ strPk } ; if ( isset ( $ this -> arrModified [ static :: $ strPk ] ) ) { $ intPk = $ this -> arrModified [ static :: $ strPk ] ; } if ( $ intPk === null ) { throw new \ RuntimeException ( 'The primary key has not been set' ) ; } $ objDatabase -> prepare ( "UPDATE " . static :: $ strTable . " %s WHERE " . Database :: quoteIdentifier ( static :: $ strPk ) . "=?" ) -> set ( $ arrSet ) -> execute ( $ intPk ) ; $ this -> postSave ( self :: UPDATE ) ; $ this -> arrModified = array ( ) ; } else { $ arrSet = $ this -> row ( ) ; foreach ( $ arrSet as $ k => $ v ) { if ( ! \ in_array ( $ k , $ arrFields ) ) { unset ( $ arrSet [ $ k ] ) ; } } $ arrSet = $ this -> preSave ( $ arrSet ) ; if ( empty ( $ arrSet ) ) { return $ this ; } $ stmt = $ objDatabase -> prepare ( "INSERT INTO " . static :: $ strTable . " %s" ) -> set ( $ arrSet ) -> execute ( ) ; if ( static :: $ strPk == 'id' ) { $ this -> id = $ stmt -> insertId ; } $ this -> postSave ( self :: INSERT ) ; $ this -> arrModified = array ( ) ; Registry :: getInstance ( ) -> register ( $ this ) ; } return $ this ; }
822	private function fixSemicolonAfterCurlyBraceClose ( Tokens $ tokens , $ index , $ curlyCloseIndex ) { static $ beforeCurlyOpeningKinds = null ; if ( null === $ beforeCurlyOpeningKinds ) { $ beforeCurlyOpeningKinds = [ T_ELSE , T_FINALLY , T_NAMESPACE , T_OPEN_TAG ] ; } $ curlyOpeningIndex = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_CURLY_BRACE , $ curlyCloseIndex ) ; $ beforeCurlyOpening = $ tokens -> getPrevMeaningfulToken ( $ curlyOpeningIndex ) ; if ( $ tokens [ $ beforeCurlyOpening ] -> isGivenKind ( $ beforeCurlyOpeningKinds ) || $ tokens [ $ beforeCurlyOpening ] -> equalsAny ( [ ';' , '{' , '}' ] ) ) { $ tokens -> clearTokenAndMergeSurroundingWhitespace ( $ index ) ; return ; } if ( $ tokens [ $ beforeCurlyOpening ] -> isGivenKind ( T_STRING ) ) { $ classyTest = $ tokens -> getPrevMeaningfulToken ( $ beforeCurlyOpening ) ; while ( $ tokens [ $ classyTest ] -> equals ( ',' ) || $ tokens [ $ classyTest ] -> isGivenKind ( [ T_STRING , T_NS_SEPARATOR , T_EXTENDS , T_IMPLEMENTS ] ) ) { $ classyTest = $ tokens -> getPrevMeaningfulToken ( $ classyTest ) ; } $ tokensAnalyzer = new TokensAnalyzer ( $ tokens ) ; if ( $ tokens [ $ classyTest ] -> isGivenKind ( T_NAMESPACE ) || ( $ tokens [ $ classyTest ] -> isClassy ( ) && ! $ tokensAnalyzer -> isAnonymousClass ( $ classyTest ) ) ) { $ tokens -> clearTokenAndMergeSurroundingWhitespace ( $ index ) ; } return ; } if ( ! $ tokens [ $ beforeCurlyOpening ] -> equals ( ')' ) ) { return ; } $ openingBrace = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ beforeCurlyOpening ) ; $ beforeOpeningBrace = $ tokens -> getPrevMeaningfulToken ( $ openingBrace ) ; if ( $ tokens [ $ beforeOpeningBrace ] -> isGivenKind ( [ T_IF , T_ELSEIF , T_FOR , T_FOREACH , T_WHILE , T_SWITCH , T_CATCH , T_DECLARE ] ) ) { $ tokens -> clearTokenAndMergeSurroundingWhitespace ( $ index ) ; return ; } if ( $ tokens [ $ beforeOpeningBrace ] -> isGivenKind ( T_STRING ) ) { $ beforeString = $ tokens -> getPrevMeaningfulToken ( $ beforeOpeningBrace ) ; if ( $ tokens [ $ beforeString ] -> isGivenKind ( T_FUNCTION ) ) { $ tokens -> clearTokenAndMergeSurroundingWhitespace ( $ index ) ; } } }
8050	public function getCalendarEvent ( $ id ) { $ calendarEvent = null ; $ cache = $ this -> cache ; if ( $ cache :: has ( self :: CACHE_KEY . $ id ) ) { return $ cache :: get ( self :: CACHE_KEY . $ id ) ; } $ calendarEvent = $ this -> calendarEvent -> with ( [ 'calendarEventRepeatDates' ] ) -> where ( 'id' , $ id ) -> firstOrFail ( ) ; $ cache :: put ( self :: CACHE_KEY . $ id , $ calendarEvent , $ this -> cacheTimeToLive ) ; return $ calendarEvent ; }
9690	public function render ( $ file , $ env = array ( ) ) { $ file = $ this -> views_path . '/' . $ file ; if ( ! file_exists ( $ file ) ) { throw new \ Exception ( "Could not compile $file, file not found" ) ; } $ cacheHash = md5 ( $ file . serialize ( $ env ) ) ; $ cache_file = $ this -> views_cache . "/$cacheHash.cache" ; if ( ! $ this -> debug && ( file_exists ( $ cache_file ) && filemtime ( $ cache_file ) > filemtime ( $ file ) ) ) { return file_get_contents ( $ cache_file ) ; } $ this -> currFile = $ file ; $ hash = md5 ( $ file ) ; $ this -> compile ( $ file ) ; $ compiled_file = $ this -> views_cache . '/' . $ hash ; set_error_handler ( array ( $ this , 'onTemplateError' ) ) ; require_once ( $ compiled_file ) ; $ output = call_user_func ( 'katar_' . $ hash , $ env ) ; restore_error_handler ( ) ; file_put_contents ( $ cache_file , $ output ) ; return $ output ; }
11833	public function doRestore ( ModulesEvent $ event ) { $ cache = $ this -> getCache ( ) ; $ data = $ cache -> get ( 'config' ) ; if ( $ data ) { $ services = $ this -> getServices ( ) ; $ services -> set ( 'Config' , $ data ) ; $ event -> stopPropagation ( true ) ; } }
3601	private function collectException ( $ httpRequest , $ httpResponse , $ exception ) { if ( $ this -> profiler ) { $ collector = new ExceptionDataCollector ( ) ; $ collector -> collect ( $ httpRequest , $ httpResponse , $ exception ) ; $ this -> profiler -> add ( $ collector ) ; } }
7783	public function registerTimezoneScript ( $ actionRoute ) { Yii :: $ app -> on ( Controller :: EVENT_BEFORE_ACTION , function ( $ event ) use ( $ actionRoute ) { $ view = $ event -> sender -> view ; $ js = <<<JS var timezone = ''; var timezoneAbbr = ''; try { var timezone = Intl.DateTimeFormat().resolvedOptions().timeZone; var timezoneAbbr = /\((.*)\)/.exec(new Date().toString())[1]; } catch(err) { console.log(err); } $.post("$actionRoute", { timezone: timezone, timezoneAbbr: timezoneAbbr, timezoneOffset: -new Date().getTimezoneOffset() / 60 });JS ; $ view -> registerJs ( $ js ) ; } ) ; }
758	protected function renderImageByImagick ( $ code ) { $ backColor = $ this -> transparent ? new \ ImagickPixel ( 'transparent' ) : new \ ImagickPixel ( '#' . str_pad ( dechex ( $ this -> backColor ) , 6 , 0 , STR_PAD_LEFT ) ) ; $ foreColor = new \ ImagickPixel ( '#' . str_pad ( dechex ( $ this -> foreColor ) , 6 , 0 , STR_PAD_LEFT ) ) ; $ image = new \ Imagick ( ) ; $ image -> newImage ( $ this -> width , $ this -> height , $ backColor ) ; $ draw = new \ ImagickDraw ( ) ; $ draw -> setFont ( $ this -> fontFile ) ; $ draw -> setFontSize ( 30 ) ; $ fontMetrics = $ image -> queryFontMetrics ( $ draw , $ code ) ; $ length = strlen ( $ code ) ; $ w = ( int ) $ fontMetrics [ 'textWidth' ] - 8 + $ this -> offset * ( $ length - 1 ) ; $ h = ( int ) $ fontMetrics [ 'textHeight' ] - 8 ; $ scale = min ( ( $ this -> width - $ this -> padding * 2 ) / $ w , ( $ this -> height - $ this -> padding * 2 ) / $ h ) ; $ x = 10 ; $ y = round ( $ this -> height * 27 / 40 ) ; for ( $ i = 0 ; $ i < $ length ; ++ $ i ) { $ draw = new \ ImagickDraw ( ) ; $ draw -> setFont ( $ this -> fontFile ) ; $ draw -> setFontSize ( ( int ) ( mt_rand ( 26 , 32 ) * $ scale * 0.8 ) ) ; $ draw -> setFillColor ( $ foreColor ) ; $ image -> annotateImage ( $ draw , $ x , $ y , mt_rand ( - 10 , 10 ) , $ code [ $ i ] ) ; $ fontMetrics = $ image -> queryFontMetrics ( $ draw , $ code [ $ i ] ) ; $ x += ( int ) $ fontMetrics [ 'textWidth' ] + $ this -> offset ; } $ image -> setImageFormat ( 'png' ) ; return $ image -> getImageBlob ( ) ; }
281	private function confirmUnload ( $ fixtures , $ except ) { $ this -> stdout ( "Fixtures namespace is: \n" , Console :: FG_YELLOW ) ; $ this -> stdout ( "\t" . $ this -> namespace . "\n\n" , Console :: FG_GREEN ) ; if ( count ( $ this -> globalFixtures ) ) { $ this -> stdout ( "Global fixtures will be used:\n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ this -> globalFixtures ) ; } if ( count ( $ fixtures ) ) { $ this -> stdout ( "\nFixtures below will be unloaded:\n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ fixtures ) ; } if ( count ( $ except ) ) { $ this -> stdout ( "\nFixtures that will NOT be unloaded:\n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ except ) ; } return $ this -> confirm ( "\nUnload fixtures?" ) ; }
223	protected function normalizeNumericStringValue ( $ value ) { $ powerPosition = strrpos ( $ value , 'E' ) ; if ( $ powerPosition !== false ) { $ valuePart = substr ( $ value , 0 , $ powerPosition ) ; $ powerPart = substr ( $ value , $ powerPosition + 1 ) ; } else { $ powerPart = null ; $ valuePart = $ value ; } $ separatorPosition = strrpos ( $ valuePart , '.' ) ; if ( $ separatorPosition !== false ) { $ integerPart = substr ( $ valuePart , 0 , $ separatorPosition ) ; $ fractionalPart = substr ( $ valuePart , $ separatorPosition + 1 ) ; } else { $ integerPart = $ valuePart ; $ fractionalPart = null ; } $ integerPart = preg_replace ( '/^\+?(-?)0*(\d+)$/' , '$1$2' , $ integerPart ) ; $ integerPart = preg_replace ( '/^\+?(-?)0*$/' , '${1}0' , $ integerPart ) ; if ( $ fractionalPart !== null ) { $ fractionalPart = rtrim ( $ fractionalPart , '0' ) ; if ( empty ( $ fractionalPart ) ) { $ fractionalPart = $ powerPart !== null ? '0' : null ; } } $ normalizedValue = $ integerPart ; if ( $ fractionalPart !== null ) { $ normalizedValue .= '.' . $ fractionalPart ; } elseif ( $ normalizedValue === '-0' ) { $ normalizedValue = '0' ; } if ( $ powerPart !== null ) { $ normalizedValue .= 'E' . $ powerPart ; } return $ normalizedValue ; }
4710	public function detab ( Text $ text , array $ options = array ( ) ) { $ text -> replace ( '/(.*?)\t/' , function ( Text $ whole , Text $ string ) use ( $ options ) { return $ string . str_repeat ( ' ' , $ options [ 'tabWidth' ] - $ string -> getLength ( ) % $ options [ 'tabWidth' ] ) ; } ) ; }
6549	public function add ( $ data ) { $ columnNum = 0 ; $ rowNum = $ this -> iterator -> current ( ) -> getRowIndex ( ) ; foreach ( ( array ) $ data as $ value ) { $ this -> sheet -> setCellValueByColumnAndRow ( $ columnNum ++ , $ rowNum , $ value ) ; } $ this -> iterator -> next ( ) ; }
8356	public function generateModels ( ) { $ definition = $ this -> getDefinition ( ) ; foreach ( $ definition as $ modelName => $ modelDefinition ) { $ type = 'model' ; if ( isset ( $ modelDefinition [ 'type' ] ) === true && in_array ( $ modelDefinition [ 'type' ] , [ 'enum' , 'model' ] ) === true ) { $ type = $ modelDefinition [ 'type' ] ; } if ( $ type == 'enum' ) { $ this -> generateEnum ( $ modelName , $ modelDefinition ) ; } else { $ this -> generateModel ( $ modelName , $ modelDefinition ) ; } } }
12582	public function setTranslator ( $ translator , $ translatorDomain = null , $ translatorLocale = null ) { $ this -> translator = $ translator ; $ this -> setTranslatorDomain ( $ translatorDomain ) ; $ this -> setTranslatorLocale ( $ translatorLocale ) ; $ this -> setCaption ( $ this -> translate ( $ this -> getCaption ( ) ) ) ; }
7457	public function persist ( ObjectManager $ manager ) { foreach ( $ this -> entities as $ entity ) { $ manager -> persist ( $ entity ) ; } if ( $ this -> root ) { $ manager -> persist ( $ this -> root ) ; } }
5126	public static function init ( array $ directories , EnvironmentInterface $ environment = null , bool $ handleErrors = true ) : ? self { if ( $ handleErrors ) { ExceptionHandler :: register ( ) ; } $ core = new static ( new Container ( ) , $ directories ) ; $ core -> container -> bindSingleton ( EnvironmentInterface :: class , $ environment ?? new Environment ( ) ) ; try { ContainerScope :: runScope ( $ core -> container , function ( ) use ( $ core ) { $ core -> bootload ( ) ; $ core -> bootstrap ( ) ; } ) ; } catch ( \ Throwable $ e ) { ExceptionHandler :: handleException ( $ e ) ; return null ; } return $ core ; }
1304	public function show ( $ category , $ slug = null ) { if ( ! isset ( $ category ) || ! isset ( $ slug ) ) { return redirect ( config ( 'chatter.routes.home' ) ) ; } $ discussion = Models :: discussion ( ) -> where ( 'slug' , '=' , $ slug ) -> first ( ) ; if ( is_null ( $ discussion ) ) { abort ( 404 ) ; } $ discussion_category = Models :: category ( ) -> find ( $ discussion -> chatter_category_id ) ; if ( $ category != $ discussion_category -> slug ) { return redirect ( config ( 'chatter.routes.home' ) . '/' . config ( 'chatter.routes.discussion' ) . '/' . $ discussion_category -> slug . '/' . $ discussion -> slug ) ; } $ posts = Models :: post ( ) -> with ( 'user' ) -> where ( 'chatter_discussion_id' , '=' , $ discussion -> id ) -> orderBy ( config ( 'chatter.order_by.posts.order' ) , config ( 'chatter.order_by.posts.by' ) ) -> paginate ( 10 ) ; $ chatter_editor = config ( 'chatter.editor' ) ; if ( $ chatter_editor == 'simplemde' ) { \ App :: register ( 'GrahamCampbell\Markdown\MarkdownServiceProvider' ) ; } $ discussion -> increment ( 'views' ) ; return view ( 'chatter::discussion' , compact ( 'discussion' , 'posts' , 'chatter_editor' ) ) ; }
12624	public function useHeaders ( $ name ) { $ headers = $ this -> httpHeaders -> getHeaders ( $ name ) ; $ this -> mergeOptions ( array ( 'headers' => $ headers ) ) ; }
8685	public static function set ( & $ data , $ path , $ value ) { Assert :: isArrayAccessible ( $ data ) ; Assert :: stringNotEmpty ( $ path ) ; $ queue = explode ( '/' , $ path ) ; if ( count ( $ queue ) === 1 ) { if ( $ path === '[]' ) { $ data [ ] = $ value ; } elseif ( static :: $ unsetMarker && $ value === static :: $ unsetMarker ) { unset ( $ data [ $ path ] ) ; } else { $ data [ $ path ] = $ value ; } return ; } $ invalidKey = null ; $ current = & $ data ; while ( ( $ key = array_shift ( $ queue ) ) !== null ) { if ( ! is_array ( $ current ) && ! ( $ current instanceof ArrayAccess ) ) { throw new RuntimeException ( sprintf ( "Cannot set '%s', because '%s' is already set and not an array or an object implementing ArrayAccess." , $ path , $ invalidKey ) ) ; } if ( ! $ queue ) { if ( $ key === '[]' ) { $ current [ ] = $ value ; } elseif ( static :: $ unsetMarker && $ value === static :: $ unsetMarker ) { unset ( $ current [ $ key ] ) ; } else { $ current [ $ key ] = $ value ; } return ; } if ( $ current instanceof Bag && ! ( $ current instanceof MutableBag ) ) { Deprecated :: warn ( 'Mutating items in a ' . Bag :: class , 1.1 , 'Use a ' . MutableBag :: class . ' instead.' ) ; } if ( ! isset ( $ current [ $ key ] ) ) { $ current [ $ key ] = [ ] ; } $ next = null ; if ( $ current instanceof ArrayAccess && ! static :: canReturnArraysByReference ( $ current , $ key , $ next , $ e ) ) { throw new RuntimeException ( sprintf ( "Cannot set '%s', because '%s' is an %s which does not return arrays by reference from its offsetGet() method. See %s for an example of how to do this." , $ path , $ invalidKey , get_class ( $ current ) , MutableBag :: class ) , 0 , $ e ) ; } if ( $ next !== null ) { $ current = & $ next ; unset ( $ next ) ; } else { $ current = & $ current [ $ key ] ; } $ invalidKey = $ key ; } }
5595	protected function createRoute ( $ url ) { if ( $ this -> proxy ) { return new SimpleProxyRoute ( $ url , $ this -> proxy , $ this -> proxy_username , $ this -> proxy_password ) ; } return new SimpleRoute ( $ url ) ; }
7654	public function dir_readdir ( ) { $ object = current ( $ this -> blobs ) ; if ( $ object !== false ) { next ( $ this -> blobs ) ; return $ object -> Name ; } return false ; }
1632	public function log ( $ level , $ message , array $ context = [ ] ) { parent :: log ( $ level , $ message , $ context ) ; $ this -> fireLogEvent ( $ level , $ message , $ context ) ; }
9454	protected function doParse ( StringReader $ string ) { $ val = null ; $ type = substr ( $ string -> read ( 2 ) , 0 , 1 ) ; switch ( $ type ) { case 'a' : $ count = ( int ) $ string -> readUntil ( ':' ) ; $ string -> read ( 1 ) ; $ val = [ ] ; for ( $ i = 0 ; $ i < $ count ; $ i ++ ) { $ array_key = $ this -> doParse ( $ string ) ; $ array_value = $ this -> doParse ( $ string ) ; $ val [ $ array_key ] = $ array_value ; } $ string -> read ( 1 ) ; break ; case 'O' : $ len = ( int ) $ string -> readUntil ( ':' ) ; $ class = $ string -> read ( 2 + $ len ) ; $ string -> read ( 1 ) ; $ properties = [ '__class_name' => $ class ] ; $ len = ( int ) $ string -> readUntil ( ':' ) ; $ string -> read ( 1 ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ prop_key = $ this -> doParse ( $ string ) ; $ prop_value = $ this -> doParse ( $ string ) ; if ( substr ( $ prop_key , 0 , strlen ( self :: PROTECTED_PREFIX ) ) == self :: PROTECTED_PREFIX ) { $ prop_key = substr ( $ prop_key , strlen ( self :: PROTECTED_PREFIX ) ) ; } if ( substr ( $ prop_key , 0 , 1 ) == "\0" ) { list ( , $ private_class , $ private_property_name ) = explode ( "\0" , $ prop_key ) ; $ prop_key = $ private_property_name ; } $ properties [ $ prop_key ] = $ prop_value ; } $ string -> read ( 1 ) ; $ val = ( object ) $ properties ; break ; case 's' : $ len = ( int ) $ string -> readUntil ( ':' ) ; $ val = $ string -> read ( $ len + 2 ) ; $ string -> read ( 1 ) ; break ; case 'i' : $ val = ( int ) $ string -> readUntil ( ';' ) ; break ; case 'd' : $ val = ( float ) $ string -> readUntil ( ';' ) ; break ; case 'b' : $ bool = $ string -> read ( 2 ) ; $ val = substr ( $ bool , 0 , 1 ) == '1' ; break ; case 'N' : $ val = null ; break ; default : throw new \ Exception ( sprintf ( 'Unable to unserialize type "%s"' , $ type ) ) ; } return $ val ; }
3642	public function only ( $ keys , bool $ trim = true , bool $ clean = true ) { $ values = [ ] ; foreach ( ( array ) $ keys as $ key ) { $ values [ $ key ] = $ this -> get ( $ key , null , $ trim , $ clean ) ; } return $ values ; }
7988	public function deleteSnapshot ( $ domain ) { $ domain = ( string ) $ domain ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; try { $ r = $ this -> delete ( 'vps/' . $ domain . '/snapshot' ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new VpsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r ; }
5030	public function findPageBy ( $ repository , $ conditions ) { $ ret = $ this -> em -> getRepository ( $ repository ) -> findOneBy ( $ conditions ) ; if ( ! $ ret ) { throw new NotFoundHttpException ; } return $ ret ; }
10053	public function setDataType ( $ dataType ) { if ( ! in_array ( $ dataType , self :: $ dataTypeValues ) ) { throw new Exception ( 'Invalid datatype for chart data series values' ) ; } $ this -> dataType = $ dataType ; return $ this ; }
11201	public function fetchOffset ( $ num ) { if ( $ this -> contentModified ) { $ this -> generateContent ( ) ; } $ key = $ this -> fetchOffsetKey ( $ num ) ; if ( $ key != null ) { return $ this -> content [ $ key ] ; } return null ; }
2839	public function getFilteredRequestListUrl ( $ filters = array ( ) ) { $ currentFilters = Mage :: helper ( 'sheep_debug/filter' ) -> getRequestFilters ( $ this -> getRequest ( ) ) ; $ filters = array_merge ( $ currentFilters , $ filters ) ; return $ this -> getRequestListUrl ( $ filters ) ; }
2721	private function getMessageInStoreLocale ( StoreInterface $ emulatedStore ) { $ currentStore = $ this -> storeManager -> getStore ( ) ; $ this -> localeResolver -> emulate ( $ emulatedStore -> getId ( ) ) ; $ this -> storeManager -> setCurrentStore ( $ emulatedStore -> getId ( ) ) ; $ message = __ ( 'You are in the wrong store. Click OK to visit the %1 store.' , [ $ emulatedStore -> getName ( ) ] ) -> __toString ( ) ; $ this -> localeResolver -> revert ( ) ; $ this -> storeManager -> setCurrentStore ( $ currentStore -> getId ( ) ) ; return $ message ; }
11697	public function __ ( $ key , array $ parameters = [ ] , $ locale = null , $ default = null , $ parseBBCode = true ) { return $ this -> translate ( $ key , $ parameters , $ locale , $ default , $ parseBBCode ) ; }
2714	public function getCheckedValues ( ) { if ( $ this -> values === null ) { $ data = $ this -> config -> getImageOptimizationRatios ( ) ; if ( ! isset ( $ data ) ) { $ data = '' ; } $ this -> values = explode ( ',' , $ data ) ; } return $ this -> values ; }
10502	public function setParameters ( $ subject , ParameterBagInterface $ parameters ) { if ( ! is_object ( $ subject ) ) { throw new InvalidSubjectException ( $ subject ) ; } if ( $ subject instanceof ParameterBagAwareInterface ) { $ subject -> setParameters ( $ parameters ) ; } else { foreach ( $ parameters as $ key => $ value ) { $ this -> setParameter ( $ subject , $ key , $ value ) ; } } }
3050	protected function initStorage ( ) { $ deliveryServerService = $ this -> getServiceManager ( ) -> get ( DeliveryServerService :: SERVICE_ID ) ; $ resultStore = $ deliveryServerService -> getResultStoreWrapper ( $ this -> getTestExecutionUri ( ) ) ; $ testResource = new \ core_kernel_classes_Resource ( $ this -> getTestDefinitionUri ( ) ) ; $ sessionManager = new \ taoQtiTest_helpers_SessionManager ( $ resultStore , $ testResource ) ; $ seeker = new BinaryAssessmentTestSeeker ( $ this -> getTestDefinition ( ) ) ; $ userUri = $ this -> getUserUri ( ) ; $ config = \ common_ext_ExtensionsManager :: singleton ( ) -> getExtensionById ( 'taoQtiTest' ) -> getConfig ( 'testRunner' ) ; $ storageClassName = $ config [ 'test-session-storage' ] ; $ this -> storage = new $ storageClassName ( $ sessionManager , $ seeker , $ userUri ) ; $ this -> sessionManager = $ sessionManager ; }
7805	protected function openingBalance ( $ text ) { if ( $ line = $ this -> getLine ( '60F|60M' , $ text ) ) { return $ this -> balance ( $ this -> reader -> createOpeningBalance ( ) , $ line ) ; } }
935	public static function isKeyCaseSensitive ( $ caseSensitive , $ key ) { if ( \ is_array ( $ caseSensitive ) ) { return isset ( $ caseSensitive [ $ key ] ) ? $ caseSensitive [ $ key ] : true ; } return $ caseSensitive ; }
4356	protected function methodTable ( $ array , $ columns = array ( ) ) { if ( ! \ is_array ( $ array ) ) { return $ this -> dump ( $ array ) ; } $ keys = $ columns ? : $ this -> debug -> methodTable -> colKeys ( $ array ) ; $ table = array ( ) ; $ classnames = array ( ) ; if ( $ this -> debug -> abstracter -> isAbstraction ( $ array ) && $ array [ 'traverseValues' ] ) { $ array = $ array [ 'traverseValues' ] ; } foreach ( $ array as $ k => $ row ) { $ values = $ this -> debug -> methodTable -> keyValues ( $ row , $ keys , $ objInfo ) ; $ values = $ this -> methodTableCleanValues ( $ values ) ; $ table [ $ k ] = $ values ; $ classnames [ $ k ] = $ objInfo [ 'row' ] ? $ objInfo [ 'row' ] [ 'className' ] : '' ; } if ( \ array_filter ( $ classnames ) ) { foreach ( $ classnames as $ k => $ classname ) { $ table [ $ k ] = \ array_merge ( array ( ' class_name' => $ classname ) , $ table [ $ k ] ) ; } } return $ table ; }
8200	public function look ( $ number = 1 ) { if ( ! isset ( $ this -> tokens [ $ this -> current + $ number ] ) ) { throw new Twig_Error_Syntax ( 'Unexpected end of template.' , $ this -> tokens [ $ this -> current + $ number - 1 ] -> getLine ( ) , $ this -> source ) ; } return $ this -> tokens [ $ this -> current + $ number ] ; }
4320	public static function arrayMergeDeep ( $ arrayDef , $ array2 ) { if ( ! \ is_array ( $ arrayDef ) || self :: isCallable ( $ arrayDef ) ) { return $ array2 ; } if ( ! \ is_array ( $ array2 ) || self :: isCallable ( $ array2 ) ) { return $ array2 ; } foreach ( $ array2 as $ k2 => $ v2 ) { if ( \ is_int ( $ k2 ) ) { if ( ! \ in_array ( $ v2 , $ arrayDef ) ) { $ arrayDef [ ] = $ v2 ; } } elseif ( ! isset ( $ arrayDef [ $ k2 ] ) ) { $ arrayDef [ $ k2 ] = $ v2 ; } else { $ arrayDef [ $ k2 ] = self :: arrayMergeDeep ( $ arrayDef [ $ k2 ] , $ v2 ) ; } } return $ arrayDef ; }
6497	public function iSwitchToWindow ( ) { $ windows = $ this -> getWindowNames ( ) ; if ( empty ( $ this -> mainWindow ) ) { $ this -> mainWindow [ 'name' ] = array_shift ( $ windows ) ; $ this -> mainWindow [ 'element' ] = $ this -> getWorkingElement ( ) ; $ window = reset ( $ windows ) ; } else { $ window = $ this -> mainWindow [ 'name' ] ; $ element = $ this -> mainWindow [ 'element' ] ; $ this -> mainWindow = [ ] ; } $ this -> getSession ( ) -> switchToWindow ( $ window ) ; $ this -> setWorkingElement ( isset ( $ element ) ? $ element : $ this -> getBodyElement ( ) ) ; }
5062	public function output ( ) : string { if ( is_null ( $ this -> buffer ) ) { $ this -> exec ( ) ; } curl_close ( $ this -> ch ) ; if ( strlen ( $ this -> buffer ) === 0 ) { throw new NoOutputException ( ) ; } return $ this -> buffer ; }
138	public function update ( RepositoryInterface $ repo , UpdateOperation $ operation ) { $ initial = $ operation -> getInitialPackage ( ) ; $ target = $ operation -> getTargetPackage ( ) ; $ initialType = $ initial -> getType ( ) ; $ targetType = $ target -> getType ( ) ; if ( $ initialType === $ targetType ) { $ installer = $ this -> getInstaller ( $ initialType ) ; $ installer -> update ( $ repo , $ initial , $ target ) ; $ this -> markForNotification ( $ target ) ; } else { $ this -> getInstaller ( $ initialType ) -> uninstall ( $ repo , $ initial ) ; $ this -> getInstaller ( $ targetType ) -> install ( $ repo , $ target ) ; } }
1268	private function createRequest ( ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ avRequest = $ xml -> appendChild ( $ xml -> createElement ( 'AddressValidationRequest' ) ) ; $ avRequest -> setAttribute ( 'xml:lang' , 'en-US' ) ; $ request = $ avRequest -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , 'AV' ) ) ; if ( null !== $ this -> address ) { $ addressNode = $ avRequest -> appendChild ( $ xml -> createElement ( 'Address' ) ) ; if ( $ this -> address -> getStateProvinceCode ( ) ) { $ addressNode -> appendChild ( $ xml -> createElement ( 'StateProvinceCode' , $ this -> address -> getStateProvinceCode ( ) ) ) ; } if ( $ this -> address -> getCity ( ) ) { $ addressNode -> appendChild ( $ xml -> createElement ( 'City' , $ this -> address -> getCity ( ) ) ) ; } if ( $ this -> address -> getCountryCode ( ) ) { $ addressNode -> appendChild ( $ xml -> createElement ( 'CountryCode' , $ this -> address -> getCountryCode ( ) ) ) ; } if ( $ this -> address -> getPostalCode ( ) ) { $ addressNode -> appendChild ( $ xml -> createElement ( 'PostalCode' , $ this -> address -> getPostalCode ( ) ) ) ; } } return $ xml -> saveXML ( ) ; }
3582	protected function metaSelectListsKey ( Builder $ query , $ key ) { if ( strpos ( $ key , '.' ) !== false ) { return $ query -> addSelect ( $ key ) ; } elseif ( $ this -> hasColumn ( $ key ) ) { return $ query -> addSelect ( $ this -> getTable ( ) . '.' . $ key ) ; } $ alias = $ this -> joinMeta ( $ query , $ key ) ; return $ query -> addSelect ( "{$alias}.meta_value as {$key}" ) ; }
4893	protected function array_compare ( $ array1 , $ array2 , $ maxDepth = 2 ) { $ result = array ( ) ; $ arraykeys = array_unique ( array_merge ( array_keys ( $ array1 ) , array_keys ( $ array2 ) ) ) ; foreach ( $ arraykeys as $ key ) { if ( ! empty ( $ key ) && is_string ( $ key ) && $ key [ 0 ] != "\0" && substr ( $ key , 0 , 8 ) != 'Doctrine' ) { if ( array_key_exists ( $ key , $ array1 ) && ! array_key_exists ( $ key , $ array2 ) ) { $ result [ $ key ] = array ( $ array1 [ $ key ] , '' ) ; } if ( ! array_key_exists ( $ key , $ array1 ) && array_key_exists ( $ key , $ array2 ) ) { $ result [ $ key ] = array ( '' , $ array2 [ $ key ] ) ; } if ( array_key_exists ( $ key , $ array1 ) && array_key_exists ( $ key , $ array2 ) ) { $ subResult = null ; if ( is_array ( $ array1 [ $ key ] ) && is_array ( $ array2 [ $ key ] ) ) { if ( 0 < $ maxDepth ) { $ subResult = $ this -> array_compare ( $ array1 [ $ key ] , $ array2 [ $ key ] , $ maxDepth - 1 ) ; } } elseif ( is_object ( $ array1 [ $ key ] ) && is_object ( $ array2 [ $ key ] ) ) { if ( 0 < $ maxDepth ) { $ hydrator = new EntityHydrator ( ) ; $ a1 = $ hydrator -> extract ( $ array1 [ $ key ] ) ; $ a2 = $ hydrator -> extract ( $ array2 [ $ key ] ) ; $ subResult = $ this -> array_compare ( $ a1 , $ a2 , $ maxDepth - 1 ) ; } } else { if ( $ array1 [ $ key ] != $ array2 [ $ key ] ) { $ result [ $ key ] = array ( $ array1 [ $ key ] , $ array2 [ $ key ] ) ; } } if ( ! empty ( $ subResult ) ) { foreach ( $ subResult as $ subKey => $ subValue ) { if ( ! empty ( $ subKey ) && is_string ( $ subKey ) ) { $ result [ $ key . '.' . $ subKey ] = $ subValue ; } } } } } } return $ result ; }
6209	public function notifyOnError ( $ message , array $ backtrace = null , $ extraParams = null ) { if ( ! $ backtrace ) { $ backtrace = debug_backtrace ( ) ; if ( count ( $ backtrace ) > 1 ) { array_shift ( $ backtrace ) ; } } $ notice = new Notice ; $ notice -> load ( array ( 'errorClass' => 'PHP::Error' , 'backtrace' => $ backtrace , 'errorMessage' => $ message , 'extraParameters' => $ extraParams , ) ) ; return $ this -> notify ( $ notice ) ; }
11616	public function invite ( $ account , $ wechatId ) { $ params = [ 'kf_account' => $ account , 'invite_wx' => $ wechatId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_INVITE_BIND , $ params ] ) ; }
1820	public function extractVimeoId ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ dc -> activeRecord -> vimeo != $ varValue ) { $ matches = array ( ) ; if ( preg_match ( '%vimeo\.com/(?:channels/(?:\w+/)?|groups/(?:[^/]+)/videos/|album/(?:\d+)/video/)?(\d+)(?:$|/|\?)%i' , $ varValue , $ matches ) ) { $ varValue = $ matches [ 1 ] ; } } return $ varValue ; }
4937	protected function createNestedOptions ( $ className , $ options ) { $ class = new $ className ( ) ; foreach ( $ options as $ key => $ spec ) { if ( is_array ( $ spec ) && array_key_exists ( '__class__' , $ spec ) ) { $ nestedClassName = $ spec [ '__class__' ] ; unset ( $ spec [ '__class__' ] ) ; $ spec = $ this -> createNestedOptions ( $ nestedClassName , $ spec ) ; } $ class -> { $ key } = $ spec ; } return $ class ; }
12225	protected function retryMiddleware ( ) { return Middleware :: retry ( function ( $ retries , RequestInterface $ request , ResponseInterface $ response = null ) { if ( $ retries <= self :: $ maxRetries && $ response && $ body = $ response -> getBody ( ) ) { if ( stripos ( $ body , 'errcode' ) && ( stripos ( $ body , '40001' ) || stripos ( $ body , '42001' ) ) ) { $ field = $ this -> accessToken -> getQueryName ( ) ; $ token = $ this -> accessToken -> getToken ( true ) ; $ request = $ request -> withUri ( $ newUri = Uri :: withQueryValue ( $ request -> getUri ( ) , $ field , $ token ) ) ; Log :: debug ( "Retry with Request Token: {$token}" ) ; Log :: debug ( "Retry with Request Uri: {$newUri}" ) ; return true ; } } return false ; } ) ; }
9916	public function configure ( array $ modelConfigurations ) { if ( empty ( $ modelConfigurations ) ) { throw new \ LogicException ( 'Supply at least one model or model configuration!' ) ; } foreach ( $ modelConfigurations as $ className ) { $ modelClass = $ className ; if ( is_subclass_of ( $ className , 'Illuminate\Database\Eloquent\Model' ) ) { $ config = new ModelConfig ( ) ; $ config -> setModelClass ( $ modelClass ) ; } else if ( is_subclass_of ( $ className , 'Label305\AujaLaravel\Config\ModelConfig' ) ) { $ config = new $ className ( ) ; $ modelClass = $ config -> getModelClass ( ) ; } else { throw new \ InvalidArgumentException ( "Model configuration should be class name string of either a ModelConfig or Eloquent subclass." ) ; } $ model = new Model ( $ modelClass ) ; $ this -> models [ $ modelClass ] = $ model ; $ this -> relations [ $ modelClass ] = [ ] ; $ configResolver = new ConfigResolver ( $ config , $ model ) ; $ this -> configs [ $ modelClass ] = $ configResolver -> resolve ( ) ; $ this -> findColumns ( $ this -> models [ $ modelClass ] ) ; $ this -> configs [ $ modelClass ] = $ configResolver -> resolve ( ) ; } $ this -> findRelations ( array_values ( $ this -> models ) ) ; }
9367	public function equal ( $ z ) { if ( is_numeric ( $ z ) ) { $ z = new self ( $ z , 0 ) ; } return ( $ z -> real == $ this -> float_r ) && ( $ z -> imaginary == $ this -> float_i ) ; }
8895	protected function _initialize_event_listeners ( ) { foreach ( $ this -> event_listeners as $ event_listener => $ e ) { if ( isset ( $ this -> $ event_listener ) && ! empty ( $ this -> $ event_listener ) ) { foreach ( $ this -> $ event_listener as $ event ) { $ this -> subscribe ( $ event_listener , $ event ) ; } } } $ this -> subscribe ( 'before_update' , 'protect_attributes' , TRUE ) ; }
3944	public static function searchFiles ( $ folder , $ extension ) { $ scanResult = array ( ) ; $ result = array ( ) ; if ( is_dir ( TL_ROOT . '/' . $ folder ) ) { $ scanResult = scan ( TL_ROOT . '/' . $ folder ) ; } foreach ( $ scanResult as $ value ) { if ( ! is_file ( TL_ROOT . '/' . $ folder . '/' . $ value ) ) { $ result += self :: searchFiles ( $ folder . '/' . $ value , $ extension ) ; } else { if ( preg_match ( '/' . $ extension . '$/i' , $ value ) ) { $ result [ $ folder ] [ $ folder . '/' . $ value ] = $ value ; } } } return $ result ; }
6921	public function get ( TaxGroupInterface $ taxGroup , CountryInterface $ country , $ business = false ) { $ key = $ this -> buildKey ( $ taxGroup , $ country , $ business ) ; if ( isset ( $ this -> taxes [ $ key ] ) ) { return $ this -> taxes [ $ key ] ; } return null ; }
11297	protected function _getModelsFromTableColumn ( $ attributeName , $ objName , $ relationColumnName , $ query = false , $ loadMap = false ) { $ relatedObj = $ this -> fetchRelatedObj ( $ objName ) ; $ idField = $ relatedObj -> getPrimaryKey ( ) ; $ repo = \ Cora \ RepositoryFactory :: make ( $ objName , false , false , false , $ this -> model_db ) ; if ( ! $ query ) $ query = $ this -> _getQueryObjectForRelation ( $ attributeName ) ; $ query -> where ( $ relationColumnName , $ this -> { $ this -> getPrimaryKey ( ) } ) ; return $ repo -> findAll ( $ query , false , $ loadMap ) ; }
1620	public function buildOne ( $ query ) { $ modelClass = $ query -> modelClass ; $ key = $ this -> quoteValue ( $ modelClass :: keyPrefix ( ) . ':a:' ) ; return $ this -> build ( $ query , "do return redis.call('HGETALL',$key .. pk) end" , 'pks' ) ; }
5619	public function paintFail ( $ message ) { parent :: paintFail ( $ message ) ; $ msg = '<span class="fail">Fail</span>: ' ; $ breadcrumb = $ this -> getTestList ( ) ; array_shift ( $ breadcrumb ) ; $ msg .= implode ( '-&gt;' , $ breadcrumb ) ; $ msg .= '-&gt;' . htmlentities ( $ message ) . '<br />' ; echo "add_fail('$msg');\n" ; }
2830	public function disableSqlProfilerAction ( ) { try { $ this -> getService ( ) -> setSqlProfilerStatus ( false ) ; $ this -> getService ( ) -> flushCache ( ) ; Mage :: getSingleton ( 'core/session' ) -> addSuccess ( 'SQL profiler was disabled.' ) ; } catch ( Exception $ e ) { Mage :: getSingleton ( 'core/session' ) -> addError ( 'Unable to disable SQL profiler: ' . $ e -> getMessage ( ) ) ; } $ this -> _redirectReferer ( ) ; }
3292	public function twitter ( ) { if ( is_null ( $ this -> title ) ) { $ this -> title = config ( 'laravel-share.services.twitter.text' ) ; } $ base = config ( 'laravel-share.services.twitter.uri' ) ; $ url = $ base . '?text=' . urlencode ( $ this -> title ) . '&url=' . $ this -> url ; $ this -> buildLink ( 'twitter' , $ url ) ; return $ this ; }
10020	public function removeCellXfByIndex ( $ pIndex ) { if ( $ pIndex > count ( $ this -> cellXfCollection ) - 1 ) { throw new Exception ( 'CellXf index is out of bounds.' ) ; } array_splice ( $ this -> cellXfCollection , $ pIndex , 1 ) ; foreach ( $ this -> workSheetCollection as $ worksheet ) { foreach ( $ worksheet -> getCoordinates ( false ) as $ coordinate ) { $ cell = $ worksheet -> getCell ( $ coordinate ) ; $ xfIndex = $ cell -> getXfIndex ( ) ; if ( $ xfIndex > $ pIndex ) { $ cell -> setXfIndex ( $ xfIndex - 1 ) ; } elseif ( $ xfIndex == $ pIndex ) { $ cell -> setXfIndex ( 0 ) ; } } } }
5690	public static function normalise ( $ html ) { $ rules = array ( '#<!--.*? , '#<(script|option|textarea)[^>]*>.*?</\1>#si' , '#<img[^>]*alt\s*=\s*("([^"]*)"|\'([^\']*)\'|([a-zA-Z_]+))[^>]*>#' , '#<[^>]*>#' , ) ; $ replace = array ( '' , '' , ' \2\3\4 ' , '' , ) ; $ text = preg_replace ( $ rules , $ replace , $ html ) ; $ text = html_entity_decode ( $ text , ENT_QUOTES ) ; $ text = preg_replace ( '#\s+#' , ' ' , $ text ) ; return trim ( trim ( $ text ) , "\xA0" ) ; }
10475	public function listen ( string $ event , callable $ callback ) : EventChannelInterface { $ this -> channel -> listen ( $ event , $ callback ) ; return $ this ; }
3622	public function enableHumidifier ( $ enabled , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ data = json_encode ( array ( 'target_humidity_enabled' => ( ( boolean ) $ enabled ) ) ) ; return $ this -> doPOST ( "/v2/put/device." . $ serial_number , $ data ) ; }
6653	public function removeExtraData ( array $ extraDataKeys = [ ] ) { foreach ( $ extraDataKeys as $ key ) { if ( array_key_exists ( $ key , $ this -> extraData ) ) { unset ( $ this -> extraData [ $ key ] ) ; } } }
11475	public function setObjectType ( $ type ) { if ( ! is_object ( $ type ) ) { if ( Yii :: $ app -> collectors [ 'types' ] -> has ( $ type ) ) { $ type = Yii :: $ app -> collectors [ 'types' ] -> getOne ( $ type ) -> object ; } else { $ type = null ; } } $ this -> _objectType = $ type ; }
969	public function getType ( ) { $ config = Config :: get ( 'shopify-app.api_grant_mode' ) ; if ( $ config === self :: GRANT_PERUSER ) { return self :: GRANT_PERUSER ; } return self :: GRANT_OFFLINE ; }
1742	public function syncFiles ( $ href , $ label , $ title , $ class , $ attributes ) { return $ this -> User -> hasAccess ( 'f6' , 'fop' ) ? '<a href="' . $ this -> addToUrl ( $ href ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '" class="' . $ class . '"' . $ attributes . '>' . $ label . '</a> ' : '' ; }
5008	public function trigger ( $ event , $ target = null ) { if ( empty ( $ this -> _template ) || ! is_string ( $ this -> _template ) ) { throw new \ InvalidArgumentException ( 'ContentCollector must have a template-name' ) ; } $ responseCollection = $ this -> getController ( ) -> getEventManager ( ) -> trigger ( $ event , $ target ) ; $ viewModel = new ViewModel ( ) ; $ viewModel -> setTemplate ( $ this -> _template ) ; foreach ( $ responseCollection as $ i => $ response ) { if ( is_string ( $ response ) ) { $ template = $ response ; $ response = new ViewModel ( array ( 'target' => $ target ) ) ; $ response -> setTemplate ( $ template ) ; } $ viewModel -> addChild ( $ response , $ this -> _captureTo . $ i ) ; } return $ viewModel ; }
9637	public function handle ( GetResponseEvent $ event ) { $ apiKey = $ this -> getApiKeyFromQueryOrHeader ( $ event -> getRequest ( ) ) ; if ( false === $ apiKey ) { return ; } try { $ token = $ this -> authenticationManager -> authenticate ( new ApiKeyToken ( $ apiKey ) ) ; $ this -> tokenStorage -> setToken ( $ token ) ; } catch ( AuthenticationException $ failed ) { $ this -> tokenStorage -> setToken ( null ) ; $ this -> doFailureResponse ( $ event ) ; } }
9152	public function view ( $ vars = array ( ) ) { $ output = '' ; $ vars [ 'entity' ] = $ this -> entity ; foreach ( $ this -> fields as $ field ) { if ( ! $ field instanceof Field ) { continue ; } if ( $ field -> getOutputView ( ) === false ) { continue ; } if ( $ field -> getType ( ) == 'hidden' || $ field -> getValueType ( ) == 'hidden' ) { continue ; } if ( $ field -> isHiddenOnProfile ( ) ) { continue ; } $ field_view = $ field -> viewOutput ( $ vars ) ; if ( $ field_view ) { $ output .= elgg_format_element ( 'div' , array ( 'class' => 'prototyper-output' , ) , $ field_view ) ; } } return $ output ; }
5471	private function getProperty ( $ name , $ object ) { $ reflection = new ReflectionObject ( $ object ) ; $ property = $ reflection -> getProperty ( $ name ) ; if ( method_exists ( $ property , 'setAccessible' ) ) { $ property -> setAccessible ( true ) ; } try { return $ property -> getValue ( $ object ) ; } catch ( ReflectionException $ e ) { return $ this -> getPrivatePropertyNoMatterWhat ( $ name , $ object ) ; } }
11819	public function addAppDependencies ( ) { $ container = $ this -> getContainer ( ) ; $ container [ 'person' ] = $ container -> protect ( function ( $ name ) { return 'Person name: ' . $ name ; } ) ; return $ this ; }
2586	protected function loadBare ( PnrAddMultiElementsOptions $ params ) { $ tattooCounter = 0 ; if ( ! is_null ( $ params -> actionCode ) ) { $ this -> pnrActions = new AddMultiElements \ PnrActions ( $ params -> actionCode ) ; } if ( ! is_null ( $ params -> recordLocator ) ) { $ this -> reservationInfo = new AddMultiElements \ ReservationInfo ( $ params -> recordLocator ) ; } if ( $ params -> travellerGroup !== null ) { $ this -> addTravellerGroup ( $ params -> travellerGroup ) ; } else { $ this -> addTravellers ( $ params -> travellers ) ; } $ this -> addItineraries ( $ params -> itineraries , $ params -> tripSegments , $ tattooCounter ) ; if ( ! empty ( $ params -> elements ) ) { $ this -> addElements ( $ params -> elements , $ tattooCounter , $ params -> autoAddReceivedFrom , $ params -> defaultReceivedFrom , $ params -> receivedFrom ) ; } else { $ this -> addReceivedFrom ( $ params -> receivedFrom , $ params -> autoAddReceivedFrom , $ params -> defaultReceivedFrom , $ tattooCounter ) ; } }
4891	protected function getTarget ( $ generateInstance = true ) { $ serviceLocator = $ this -> getServicelocator ( ) ; $ this -> getGenerator ( ) ; $ target = null ; if ( array_key_exists ( 'target' , $ this -> options ) ) { $ target = $ this -> options [ 'target' ] ; if ( is_string ( $ target ) ) { if ( $ serviceLocator -> has ( $ target ) ) { $ target = $ serviceLocator -> get ( $ target ) ; if ( $ generateInstance ) { $ target = get_class ( $ target ) ; } } else { if ( $ generateInstance ) { $ target = new $ target ; } } } } return $ target ; }
6623	public function parseResponse ( Response $ response ) { $ json = $ response -> json ( ) ; if ( ! is_null ( $ json ) ) { if ( isset ( $ json -> error ) ) { $ error = $ json -> error ; throw new AccessTokenException ( $ error -> type . ': ' . $ error -> message , $ error -> code ) ; } } $ token = $ response -> content ( ) ; return $ this -> parseToken ( $ token ) ; }
3726	public static function createFromQueryBuilder ( QueryBuilder $ builder , $ columnName = 'id' ) { return new self ( $ builder -> getSQL ( ) , $ builder -> getParameters ( ) , $ columnName , $ builder -> getConnection ( ) , $ builder -> getParameterTypes ( ) ) ; }
1467	public static function doesResponseHaveBody ( $ request , $ response ) { if ( 'HEAD' === strtoupper ( $ request -> getMethod ( ) ) ) { return false ; } $ status = $ response -> getStatusCode ( ) ; if ( ( 100 <= $ status && 200 > $ status ) || 204 === $ status || 304 === $ status ) { return false ; } if ( self :: hasHeader ( $ response , 'Transfer-Encoding' ) ) { return true ; } ; if ( ! $ contentLength = self :: getHeader ( $ response , 'Content-Length' ) ) { return false ; } return 0 < $ contentLength [ 0 ] ; }
8128	public static function findByPasswordResetToken ( $ id , $ code ) { if ( ! static :: isPasswordResetTokenValid ( $ code ) ) { return NULL ; } return static :: findOne ( [ 'id' => $ id , 'password_reset_token' => $ code , 'status' => self :: STATUS_ACTIVE , ] ) ; }
4542	public function postFlush ( PostFlushEventArgs $ args ) { $ maps = $ args -> getEntityManager ( ) -> getUnitOfWork ( ) -> getIdentityMap ( ) ; foreach ( $ maps as $ entities ) { foreach ( $ entities as $ entity ) { if ( ! $ entity instanceof Parameter ) { continue ; } $ entity -> setValue ( unserialize ( $ entity -> getValue ( ) ) ) ; } } }
3802	private function getOrCreatePaletteDefinition ( IMetaModelDataDefinition $ container ) { if ( $ container -> hasDefinition ( PalettesDefinitionInterface :: NAME ) ) { return $ container -> getDefinition ( PalettesDefinitionInterface :: NAME ) ; } $ container -> setDefinition ( PalettesDefinitionInterface :: NAME , $ palettesDefinition = new DefaultPalettesDefinition ( ) ) ; return $ palettesDefinition ; }
11560	public function SetShortcuts ( array $ shortcuts , $ lang = '' ) { if ( ! $ lang ) $ lang = $ this -> lang ; $ this -> shortcuts [ $ lang ] = $ shortcuts ; return $ this ; }
10316	function getBouncesCount ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ statusCodeFilter = null , $ typeFilter = null , $ sourceFilter = null , $ excludeAnonymousBounces = false ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , null ) ; if ( isset ( $ excludeAnonymousBounces ) ) $ params [ 'exclude_anonymous_bounces' ] = ( $ excludeAnonymousBounces == true ) ? "true" : "false" ; if ( isset ( $ typeFilter ) ) $ params [ 'type' ] = $ typeFilter ; if ( isset ( $ sourceFilter ) ) $ params [ 'source_filter' ] = $ sourceFilter ; return $ this -> get ( 'reports/bounces/count' , $ params ) ; }
2421	public static function copyResource ( $ strSource , $ strDestination ) { $ objDatabase = Database :: getInstance ( ) ; $ objFile = FilesModel :: findByPath ( $ strSource ) ; if ( $ objFile === null ) { $ objFile = static :: addResource ( $ strSource ) ; } $ strFolder = \ dirname ( $ strDestination ) ; $ objNewFile = clone $ objFile -> current ( ) ; if ( $ strFolder == Config :: get ( 'uploadPath' ) ) { $ objNewFile -> pid = null ; } else { $ objFolder = FilesModel :: findByPath ( $ strFolder ) ; if ( $ objFolder === null ) { $ objFolder = static :: addResource ( $ strFolder ) ; } $ objNewFile -> pid = $ objFolder -> uuid ; } $ objNewFile -> tstamp = time ( ) ; $ objNewFile -> uuid = $ objDatabase -> getUuid ( ) ; $ objNewFile -> path = $ strDestination ; $ objNewFile -> name = basename ( $ strDestination ) ; $ objNewFile -> save ( ) ; if ( $ objFile -> type == 'folder' ) { $ objFiles = FilesModel :: findMultipleByBasepath ( $ strSource . '/' ) ; if ( $ objFiles !== null ) { while ( $ objFiles -> next ( ) ) { $ objNew = clone $ objFiles -> current ( ) ; $ objNew -> pid = $ objNewFile -> uuid ; $ objNew -> tstamp = time ( ) ; $ objNew -> uuid = $ objDatabase -> getUuid ( ) ; $ objNew -> path = str_replace ( $ strSource . '/' , $ strDestination . '/' , $ objFiles -> path ) ; $ objNew -> save ( ) ; } } } if ( ( $ strPath = \ dirname ( $ strSource ) ) != Config :: get ( 'uploadPath' ) ) { static :: updateFolderHashes ( $ strPath ) ; } if ( ( $ strPath = \ dirname ( $ strDestination ) ) != Config :: get ( 'uploadPath' ) ) { static :: updateFolderHashes ( $ strPath ) ; } return $ objNewFile ; }
9069	public function purge ( $ days_older_than = 60 , \ wpdb $ wpdb ) { $ days_older_than = absint ( $ days_older_than ) ; $ tn = $ this -> table -> get_table_name ( $ wpdb ) ; $ sql = "DELETE FROM {$tn} WHERE time < DATE_SUB(NOW(), INTERVAL $days_older_than DAY)" ; $ wpdb -> query ( $ sql ) ; }
5867	public static function getOrientation ( $ fileName ) { $ orientation = 1 ; $ metadata = static :: getMetadata ( $ fileName ) ; if ( isset ( $ metadata [ 'Orientation' ] ) ) { $ orientation = $ metadata [ 'Orientation' ] ; } return $ orientation ; }
2369	public static function splitFriendlyEmail ( $ strEmail ) { if ( strpos ( $ strEmail , '<' ) !== false ) { return array_map ( 'trim' , explode ( ' <' , str_replace ( '>' , '' , $ strEmail ) ) ) ; } elseif ( strpos ( $ strEmail , '[' ) !== false ) { return array_map ( 'trim' , explode ( ' [' , str_replace ( ']' , '' , $ strEmail ) ) ) ; } else { return array ( '' , $ strEmail ) ; } }
753	public function init ( ) { $ this -> fontFile = Yii :: getAlias ( $ this -> fontFile ) ; if ( ! is_file ( $ this -> fontFile ) ) { throw new InvalidConfigException ( "The font file does not exist: {$this->fontFile}" ) ; } }
8429	protected function getCmtiFileIcon ( $ fileType ) { switch ( $ fileType ) { case FileManager :: FILE_TYPE_IMAGE : { return 'cmti-image' ; } case FileManager :: FILE_TYPE_VIDEO : { return 'cmti-file-video' ; } case FileManager :: FILE_TYPE_AUDIO : { return 'cmti-file-audio' ; } case FileManager :: FILE_TYPE_DOCUMENT : { return 'cmti-document' ; } case FileManager :: FILE_TYPE_COMPRESSED : { return 'cmti-file-zip' ; } } }
12294	public function delete ( $ id ) { $ resource = $ this -> model -> find ( $ id ) ; if ( ! $ resource ) { return '' ; } return $ resource -> delete ( ) ; }
10333	function fromXML ( $ xmlElement ) { parent :: fromXML ( $ xmlElement ) ; if ( isset ( $ xmlElement -> permissionType ) ) $ this -> permission = Permission :: getPermission ( $ xmlElement -> permissionType ) ; if ( isset ( $ xmlElement -> field_backups ) ) $ this -> fieldBackups = XMLDeserializer :: deserialize ( $ xmlElement -> field_backups ) ; }
8360	private function startProcessQueue ( ) { $ this -> logger -> info ( 'Starting queue in process mode' ) ; $ dispatcher = new ProcessDispatcher ( $ this -> client , $ this -> logger , $ this -> queue , \ array_merge ( $ this -> queueConfig , [ 'process' => $ this -> config [ 'process' ] ] ) , [ 'configFile' => $ this -> configName ] ) ; $ dispatcher -> start ( ) ; }
8410	public function connect ( ) { if ( $ this -> isConnected ( ) === false ) { try { if ( isset ( $ this -> servers [ 'all' ] ) === true ) { $ dsn = $ this -> providerDatabase -> getDsn ( $ this -> servers [ 'all' ] ) ; $ this -> servers [ 'all' ] [ 'link' ] = new \ PDO ( $ dsn , $ this -> servers [ 'all' ] [ 'user' ] , $ this -> servers [ 'all' ] [ 'pass' ] ) ; } else { $ dsn = $ this -> providerDatabase -> getDsn ( $ this -> servers [ 'read' ] ) ; $ this -> servers [ 'read' ] [ 'link' ] = new \ PDO ( $ dsn , $ this -> servers [ 'read' ] [ 'user' ] , $ this -> servers [ 'read' ] [ 'pass' ] ) ; $ dsn = $ this -> providerDatabase -> getDsn ( $ this -> servers [ 'write' ] ) ; $ this -> servers [ 'write' ] [ 'link' ] = new \ PDO ( $ dsn , $ this -> servers [ 'write' ] [ 'user' ] , $ this -> servers [ 'write' ] [ 'pass' ] ) ; } } catch ( \ PDOException $ e ) { throw new ExternalLink ( 'can\'t connect to database (' . $ e -> getMessage ( ) . ')' ) ; } } }
4392	public function checkConfigBE ( array $ attributes ) { return array_merge ( parent :: checkConfigBE ( $ attributes ) , $ this -> checkConfig ( $ this -> beConfig , $ attributes ) ) ; }
7760	protected function detectMetadataDriver ( $ dir , ContainerBuilder $ container ) { $ configPath = $ this -> getMappingResourceConfigDirectory ( ) ; $ resource = $ dir . '/' . $ configPath ; while ( ! is_dir ( $ resource ) ) { $ resource = dirname ( $ resource ) ; } $ container -> addResource ( new FileResource ( $ resource ) ) ; $ extension = $ this -> getMappingResourceExtension ( ) ; if ( ( $ files = glob ( $ dir . '/' . $ configPath . '/*.' . $ extension . '.xml' ) ) && count ( $ files ) ) { return 'xml' ; } elseif ( ( $ files = glob ( $ dir . '/' . $ configPath . '/*.' . $ extension . '.yml' ) ) && count ( $ files ) ) { return 'yml' ; } elseif ( ( $ files = glob ( $ dir . '/' . $ configPath . '/*.' . $ extension . '.php' ) ) && count ( $ files ) ) { return 'php' ; } $ container -> addResource ( new FileResource ( $ dir ) ) ; if ( is_dir ( $ dir . '/' . $ this -> getMappingObjectDefaultName ( ) ) ) { return 'annotation' ; } return null ; }
9382	public function getTag ( $ classNames , $ color = null ) { return ArrayData :: create ( [ 'ClassNames' => $ classNames , 'Color' => $ color ] ) -> renderWith ( sprintf ( '%s\Tag' , self :: class ) ) ; }
5961	public function serverGroupGetByName ( $ name , $ type = TeamSpeak3 :: GROUP_DBTYPE_REGULAR ) { foreach ( $ this -> serverGroupList ( ) as $ group ) { if ( $ group [ "name" ] == $ name && $ group [ "type" ] == $ type ) { return $ group ; } } throw new Ts3Exception ( "invalid groupID" , 0xA00 ) ; }
10730	public function getHour ( ) { if ( $ this -> value !== null ) { preg_match ( '/^(?P<year>[0-9]{4,4})-(?P<month>[0-9]{2,2})-(?P<day>[0-9]{2,2}) (?P<hour>[0-9]{2,2}):(?P<minute>[0-9]{2,2}):(?P<second>[0-9]{2,2})$/ui' , $ this -> value , $ m ) ; return ( int ) $ m [ 'hour' ] ; } }
927	private function getCommentBlock ( Tokens $ tokens , $ index ) { $ commentType = $ this -> getCommentType ( $ tokens [ $ index ] -> getContent ( ) ) ; $ empty = $ this -> isEmptyComment ( $ tokens [ $ index ] -> getContent ( ) ) ; $ start = $ index ; $ count = \ count ( $ tokens ) ; ++ $ index ; for ( ; $ index < $ count ; ++ $ index ) { if ( $ tokens [ $ index ] -> isComment ( ) ) { if ( $ commentType !== $ this -> getCommentType ( $ tokens [ $ index ] -> getContent ( ) ) ) { break ; } if ( $ empty ) { $ empty = $ this -> isEmptyComment ( $ tokens [ $ index ] -> getContent ( ) ) ; } continue ; } if ( ! $ tokens [ $ index ] -> isWhitespace ( ) || $ this -> getLineBreakCount ( $ tokens , $ index , $ index + 1 ) > 1 ) { break ; } } return [ $ start , $ index - 1 , $ empty ] ; }
5837	public function transform ( $ orig , $ transformation = null , $ overrides = array ( ) ) { return $ this -> transformer -> transform ( $ orig , $ transformation , $ overrides ) ; }
7342	protected function scheduleSupplierOrderContentChangeEvent ( Model \ SupplierOrderInterface $ order ) { $ this -> persistenceHelper -> scheduleEvent ( SupplierOrderEvents :: CONTENT_CHANGE , $ order ) ; }
4762	protected function send ( $ data ) { if ( $ this -> doNotTrack ) { return ; } try { $ fp = fsockopen ( "udp://$this->host" , $ this -> port , $ errno , $ errstr ) ; if ( ! $ fp ) { return ; } fwrite ( $ fp , $ data ) ; fclose ( $ fp ) ; } catch ( \ Exception $ e ) { } }
6926	protected function didStateChangeTo ( $ resource , $ state ) { if ( empty ( $ stateCs = $ this -> tracker -> getChangeSet ( $ resource , 'state' ) ) ) { return false ; } if ( $ stateCs [ 1 ] === $ state && $ stateCs [ 0 ] !== $ state ) { return true ; } return false ; }
2348	public static function putContent ( $ strFile , $ strContent ) { $ objFile = new static ( $ strFile ) ; $ objFile -> write ( $ strContent ) ; $ objFile -> close ( ) ; }
7985	public function getAvailableOptions ( $ domain ) { $ domain = ( string ) $ domain ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; try { $ r = $ this -> get ( 'vps/' . $ domain . '/availableOptions' ) -> send ( ) ; } catch ( ClientErrorResponseException $ e ) { if ( $ e -> getResponse ( ) -> getStatusCode ( ) == '404' && json_decode ( $ e -> getResponse ( ) -> getBody ( ) ) -> message == "No options found" ) return "[]" ; else throw new VpsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } catch ( \ Exception $ e ) { throw new VpsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
711	public function smallInteger ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_SMALLINT , $ length ) ; }
9720	public function setEscher ( \ PhpOffice \ PhpSpreadsheet \ Shared \ Escher $ pValue = null ) { $ this -> escher = $ pValue ; }
10482	public function getBucket ( string $ name ) : SessionBucketInterface { $ segment = $ this -> session -> getSegment ( $ name ) ; if ( ! $ segment ) { return null ; } return new AuraSessionBucketAdapter ( $ segment ) ; }
6411	public static function any ( IteratorAggregate $ iterable , callable $ predicate ) : bool { return Iterators :: any ( Iterators :: from ( $ iterable -> getIterator ( ) ) , $ predicate ) ; }
7482	public function changeEncoding ( $ encoding ) { $ encoding = ( string ) $ encoding ; $ this -> string = iconv ( $ this -> encoding , $ encoding , $ this -> string ) ; $ this -> encoding = $ encoding ; return $ this ; }
637	public function truncateTable ( $ table ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> truncateTable ( $ table ) ; return $ this -> setSql ( $ sql ) ; }
3675	private function collectAttributeFactories ( $ container ) { $ attributeFactory = $ container -> getDefinition ( 'metamodels.attribute_factory' ) ; foreach ( array_keys ( $ container -> findTaggedServiceIds ( self :: TAG_ATTRIBUTE_FACTORY ) ) as $ factory ) { $ attributeFactory -> addMethodCall ( 'addTypeFactory' , [ new Reference ( $ factory ) ] ) ; } }
7118	protected function getGetAvailableSumBySubjectQuery ( ) { if ( null !== $ this -> getAvailableSumBySubjectQuery ) { return $ this -> getAvailableSumBySubjectQuery ; } $ as = $ this -> getAlias ( ) ; $ qb = $ this -> createFindBySubjectQueryBuilder ( ) ; $ qb -> andWhere ( $ qb -> expr ( ) -> gte ( $ as . '.availableStock' , 0 ) ) -> select ( 'SUM(' . $ as . '.availableStock) as available' ) ; return $ this -> getAvailableSumBySubjectQuery = $ qb -> getQuery ( ) ; }
4678	public function render ( string $ file , array $ data ) : void { if ( ! is_readable ( $ file ) ) { throw new Exception ( "Could not find template file: " . $ this -> template ) ; } $ di = $ this -> di ; $ app = null ; if ( $ di -> has ( "app" ) ) { $ app = $ di -> get ( "app" ) ; } extract ( $ data ) ; require $ file ; }
7643	protected function parseMetadataHeaders ( $ headers = array ( ) ) { if ( ! is_array ( $ headers ) ) { return array ( ) ; } $ metadata = array ( ) ; foreach ( $ headers as $ key => $ value ) { if ( substr ( strtolower ( $ key ) , 0 , 10 ) == "x-ms-meta-" ) { $ metadata [ str_replace ( "x-ms-meta-" , '' , strtolower ( $ key ) ) ] = $ value ; } } return $ metadata ; }
9884	private function writeNamedRanges ( XMLWriter $ objWriter , Spreadsheet $ spreadsheet ) { $ namedRanges = $ spreadsheet -> getNamedRanges ( ) ; foreach ( $ namedRanges as $ namedRange ) { $ this -> writeDefinedNameForNamedRange ( $ objWriter , $ namedRange ) ; } }
9911	function fromArray ( $ object_vars ) { foreach ( $ object_vars as $ key => $ value ) { if ( class_exists ( 'AbstractJSONWrapper' ) && is_subclass_of ( $ this -> { $ key } , 'AbstractJSONWrapper' ) ) { $ this -> { $ key } -> fromArray ( $ value ) ; } else { $ this -> { $ key } = $ value ; } } }
1867	private function validateSessionLifetime ( User $ user ) : void { if ( ! $ this -> session -> isStarted ( ) ) { return ; } $ config = $ this -> framework -> getAdapter ( Config :: class ) ; $ timeout = ( int ) $ config -> get ( 'sessionTimeout' ) ; if ( $ timeout > 0 && ( time ( ) - $ this -> session -> getMetadataBag ( ) -> getLastUsed ( ) ) < $ timeout ) { return ; } if ( null !== $ this -> logger ) { $ this -> logger -> info ( sprintf ( 'User "%s" has been logged out automatically due to inactivity' , $ user -> username ) , [ 'contao' => new ContaoContext ( __METHOD__ , ContaoContext :: ACCESS , $ user -> username ) ] ) ; } throw new UsernameNotFoundException ( sprintf ( 'User "%s" has been logged out automatically due to inactivity.' , $ user -> username ) ) ; }
206	public static function stdin ( $ raw = false ) { return $ raw ? fgets ( \ STDIN ) : rtrim ( fgets ( \ STDIN ) , PHP_EOL ) ; }
11899	public function getDuration ( ) { $ ended = microtime ( true ) ; if ( $ this -> ended ) { $ ended = strtotime ( $ this -> ended ) ; } $ started = strtotime ( $ this -> started ) ; return Date :: niceDuration ( $ ended - $ started ) ; }
979	protected function response ( Request $ request , Closure $ next ) { $ response = $ next ( $ request ) ; if ( Config :: get ( 'shopify-app.esdk_enabled' ) && ( $ request -> ajax ( ) || $ request -> expectsJson ( ) || $ request -> isJson ( ) ) === false ) { if ( ( $ response instanceof BaseResponse ) === false ) { $ response = new Response ( $ response ) ; } $ response -> headers -> set ( 'P3P' , 'CP="Not used"' ) ; $ response -> headers -> remove ( 'X-Frame-Options' ) ; } return $ response ; }
9791	public function getCalculatedValue ( $ resetLog = true ) { if ( $ this -> dataType == DataType :: TYPE_FORMULA ) { try { $ result = Calculation :: getInstance ( $ this -> getWorksheet ( ) -> getParent ( ) ) -> calculateCellValue ( $ this , $ resetLog ) ; if ( is_array ( $ result ) ) { while ( is_array ( $ result ) ) { $ result = array_pop ( $ result ) ; } } } catch ( Exception $ ex ) { if ( ( $ ex -> getMessage ( ) === 'Unable to access External Workbook' ) && ( $ this -> calculatedValue !== null ) ) { return $ this -> calculatedValue ; } throw new \ PhpOffice \ PhpSpreadsheet \ Calculation \ Exception ( $ this -> getWorksheet ( ) -> getTitle ( ) . '!' . $ this -> getCoordinate ( ) . ' -> ' . $ ex -> getMessage ( ) ) ; } if ( $ result === '#Not Yet Implemented' ) { return $ this -> calculatedValue ; } return $ result ; } elseif ( $ this -> value instanceof RichText ) { return $ this -> value -> getPlainText ( ) ; } return $ this -> value ; }
537	protected function updateDocComment ( $ doc , $ properties ) { $ lines = explode ( "\n" , $ doc ) ; $ propertyPart = false ; $ propertyPosition = false ; foreach ( $ lines as $ i => $ line ) { $ line = trim ( $ line ) ; if ( strncmp ( $ line , '* @property ' , 12 ) === 0 ) { $ propertyPart = true ; } elseif ( $ propertyPart && $ line == '*' ) { $ propertyPosition = $ i ; $ propertyPart = false ; } if ( strncmp ( $ line , '* @author ' , 10 ) === 0 && $ propertyPosition === false ) { $ propertyPosition = $ i - 1 ; $ propertyPart = false ; } if ( $ propertyPart ) { unset ( $ lines [ $ i ] ) ; } } if ( $ propertyPosition === false ) { $ propertyPosition = \ count ( $ lines ) - 2 ; } $ finalDoc = '' ; foreach ( $ lines as $ i => $ line ) { $ finalDoc .= $ line . "\n" ; if ( $ i == $ propertyPosition ) { $ finalDoc .= $ properties ; } } return $ finalDoc ; }
11646	private function generateExecuteDocBlock ( $ methodDescription , $ returnType ) { $ docBlock = new DocBlockGenerator ( $ methodDescription , null ) ; $ tags [ ] = new GenericTag ( 'return' , $ returnType ) ; $ docBlock -> setTags ( $ tags ) ; return $ docBlock ; }
12511	private function buildGroup ( $ group ) { if ( is_null ( $ group ) ) { $ group = [ 'filter' => [ 'is_to_all' => true , ] , ] ; } elseif ( is_array ( $ group ) ) { $ group = [ 'touser' => $ group , ] ; } else { $ group = [ 'filter' => [ 'is_to_all' => false , 'group_id' => $ group , ] , ] ; } return $ group ; }
12788	public static function setStatus ( $ iCode ) { if ( $ iCode === 200 ) { header ( 'HTTP/1.1 200 Ok' ) ; } else if ( $ iCode === 201 ) { header ( 'HTTP/1.1 201 Created' ) ; } else if ( $ iCode === 204 ) { header ( "HTTP/1.0 204 No Content" ) ; } else if ( $ iCode === 403 ) { header ( 'HTTP/1.1 403 Forbidden' ) ; } else if ( $ iCode === 404 ) { header ( 'HTTP/1.1 404 Not Found' ) ; } }
12016	public function unwatch ( ) { if ( ! $ this -> client -> getCommandFactory ( ) -> supportsCommand ( 'UNWATCH' ) ) { throw new NotSupportedException ( 'UNWATCH is not supported by the current command factory.' ) ; } $ this -> state -> unflag ( MultiExecState :: WATCH ) ; $ this -> __call ( 'UNWATCH' , array ( ) ) ; return $ this ; }
7930	public function setCollection ( array $ collection ) { list ( $ collection ) = $ this -> fireEvent ( 'collection.set' , [ $ collection ] ) ; $ this -> collection = [ ] ; foreach ( $ collection as $ asset ) { $ this -> appendToCollection ( $ asset ) ; } return $ this ; }
6838	public function mapDatas ( $ kvs ) { foreach ( $ kvs as $ k => $ v ) { $ this -> mapData ( $ k , $ v ) ; } }
12110	public function deletePage ( $ id ) { $ this -> getPage ( $ id ) ; unset ( $ this -> pages [ $ id ] ) ; $ this -> persist ( ) ; }
8855	public function getArchiveDate ( ) { $ year = $ this -> getArchiveYear ( ) ; $ month = $ this -> getArchiveMonth ( ) ; $ day = $ this -> getArchiveDay ( ) ; if ( $ year ) { if ( $ month ) { $ date = $ year . '-' . $ month . '-01' ; if ( $ day ) { $ date = $ year . '-' . $ month . '-' . $ day ; } } else { $ date = $ year . '-01-01' ; } return DBField :: create_field ( "Date" , $ date ) ; } }
2712	public function _getElementHtml ( AbstractElement $ element ) { $ this -> setNamePrefix ( $ element -> getName ( ) ) -> setHtmlId ( $ element -> getHtmlId ( ) ) ; return $ this -> _toHtml ( ) ; }
6935	protected function formatMessage ( $ message , $ format = [ Console :: FG_RED , Console :: BOLD ] ) { $ stream = ( PHP_SAPI === 'cli' ) ? \ STDERR : \ STDOUT ; if ( Console :: stream_supports_ansi_colors ( $ stream ) ) { $ message = Console :: ansi_format ( $ message , $ format ) ; } return $ message ; }
7583	protected function extractInfo ( ) { $ this -> info = curl_getinfo ( $ this -> CurlRequest ) ; $ this -> status = $ this -> info [ 'http_code' ] ; if ( curl_errno ( $ this -> CurlRequest ) !== CURLE_OK ) { $ this -> error = curl_error ( $ this -> CurlRequest ) ; } else { $ this -> error = false ; } }
3178	public function getItemClasses ( ) { $ itemClass = $ this -> getClass ( self :: ITEM_ROOT_CLASS_URI ) ; return $ this -> getResourceService ( ) -> getAllClasses ( $ itemClass ) ; }
6586	protected function request ( array $ options ) { $ this -> info = null ; $ this -> setOpt ( $ options ) ; $ result = $ this -> perform ( 'curl_exec' ) ; $ this -> info = $ this -> perform ( 'curl_getinfo' ) ; return $ result ; }
394	public static function updateAll ( $ attributes , $ condition = '' , $ params = [ ] ) { $ command = static :: getDb ( ) -> createCommand ( ) ; $ command -> update ( static :: tableName ( ) , $ attributes , $ condition , $ params ) ; return $ command -> execute ( ) ; }
1358	public static function create ( $ mediaType , int $ options = 0 , string $ urlPrefix = null , int $ depth = 512 ) : self { if ( ! $ mediaType instanceof MediaTypeInterface ) { $ mediaType = MediaType :: parse ( 0 , $ mediaType ) ; } return new self ( $ mediaType , new EncoderOptions ( $ options , $ urlPrefix , $ depth ) ) ; }
11904	public function getLogModel ( $ refresh = false ) { $ config = $ this -> config ; if ( isset ( $ config [ 'logModel' ] ) ) { if ( ! is_object ( $ config [ 'logModel' ] ) ) { if ( $ refresh ) { return DataInterfaceLog :: find ( ) -> where ( [ 'id' => $ config [ 'logModel' ] ] ) -> one ( ) ; } else { return DataInterfaceLog :: get ( $ config [ 'logModel' ] ) ; } } if ( $ refresh ) { return DataInterfaceLog :: find ( ) -> where ( [ 'id' => $ config [ 'logModel' ] -> primaryKey ] ) -> one ( ) ; } return $ config [ 'logModel' ] ; } return ; }
5469	public function overlayMessage ( $ compare , $ dumper ) { $ this -> dumper = $ dumper ; return sprintf ( $ this -> message , $ this -> testMessage ( $ compare ) ) ; }
8161	public function block ( ) { $ this -> status = User :: STATUS_BLOCKED ; if ( $ this -> save ( FALSE ) ) return TRUE ; return FALSE ; }
10117	private function writeVcenter ( ) { $ record = 0x0084 ; $ length = 0x0002 ; $ fVCenter = $ this -> phpSheet -> getPageSetup ( ) -> getVerticalCentered ( ) ? 1 : 0 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ fVCenter ) ; $ this -> append ( $ header . $ data ) ; }
12508	public function msgType ( $ msgType ) { if ( ! in_array ( $ msgType , $ this -> msgTypes , true ) ) { throw new InvalidArgumentException ( 'This message type not exist.' ) ; } $ this -> msgType = $ msgType ; return $ this ; }
1307	private static function replaceUrlParameter ( $ url , $ source ) { $ parameter = static :: urlParameter ( $ url ) ; return str_replace ( '{' . $ parameter . '}' , $ source [ $ parameter ] , $ url ) ; }
4190	protected function dumpMethods ( $ methods ) { $ label = \ count ( $ methods ) ? 'methods' : 'no methods' ; $ str = '<dt class="methods">' . $ label . '</dt>' . "\n" ; $ magicMethods = \ array_intersect ( array ( '__call' , '__callStatic' ) , \ array_keys ( $ methods ) ) ; $ str .= $ this -> magicMethodInfo ( $ magicMethods ) ; foreach ( $ methods as $ methodName => $ info ) { if ( ! isset ( $ info [ 'phpDoc' ] [ 'return' ] ) ) { $ info [ 'phpDoc' ] [ 'return' ] = array ( 'desc' => null , 'type' => null , ) ; } $ classes = \ array_keys ( \ array_filter ( array ( 'method' => true , 'deprecated' => $ info [ 'isDeprecated' ] , ) ) ) ; $ modifiers = \ array_keys ( \ array_filter ( array ( 'final' => $ info [ 'isFinal' ] , $ info [ 'visibility' ] => true , 'static' => $ info [ 'isStatic' ] , ) ) ) ; $ str .= $ this -> debug -> utilities -> buildTag ( 'dd' , array ( 'class' => \ array_merge ( $ classes , $ modifiers ) , 'data-implements' => $ info [ 'implements' ] , ) , \ implode ( ' ' , \ array_map ( function ( $ modifier ) { return '<span class="t_modifier_' . $ modifier . '">' . $ modifier . '</span>' ; } , $ modifiers ) ) . ' ' . $ this -> debug -> utilities -> buildTag ( 'span' , array ( 'class' => 't_type' , 'title' => $ info [ 'phpDoc' ] [ 'return' ] [ 'desc' ] , ) , $ info [ 'phpDoc' ] [ 'return' ] [ 'type' ] ) . ' ' . $ this -> debug -> utilities -> buildTag ( 'span' , array ( 'class' => 'method-name' , 'title' => \ trim ( $ info [ 'phpDoc' ] [ 'summary' ] . ( $ this -> debug -> output -> getCfg ( 'outputMethodDescription' ) ? "\n\n" . $ info [ 'phpDoc' ] [ 'description' ] : '' ) ) , ) , $ methodName ) . '<span class="t_punct">(</span>' . $ this -> dumpMethodParams ( $ info [ 'params' ] ) . '<span class="t_punct">)</span>' . ( $ methodName == '__toString' ? '<br />' . $ this -> debug -> output -> html -> dump ( $ info [ 'returnValue' ] ) : '' ) ) . "\n" ; } $ str = \ str_replace ( ' data-implements="null"' , '' , $ str ) ; $ str = \ str_replace ( ' <span class="t_type"></span>' , '' , $ str ) ; return $ str ; }
3389	public function redirectAfterRegistrationPath ( ) { if ( method_exists ( $ this , 'redirectAfterRegistrationTo' ) ) { return $ this -> redirectAfterRegistrationTo ( ) ; } return property_exists ( $ this , 'redirectAfterRegistrationTo' ) ? $ this -> redirectAfterRegistrationTo : route ( 'login' ) ; }
6021	public function setApiKey ( $ apiKey ) { $ this -> apiKey = $ apiKey ; list ( , $ datacentre ) = explode ( '-' , $ this -> apiKey ) ; $ this -> apiUrl = str_replace ( '<dc>' , $ datacentre , $ this -> apiUrl ) ; }
10962	private function isInvalidLogDate ( $ file ) { $ pattern = '/laravel-(\d){4}-(\d){2}-(\d){2}.log/' ; if ( ( bool ) preg_match ( $ pattern , $ file , $ matches ) === false ) { return true ; } return false ; }
7020	private function format_i ( & $ str ) { if ( strstr ( $ str , '%i' ) ) $ str = str_replace ( '%i' , sprintf ( '%02d' , $ this -> min ) , $ str ) ; }
801	private function clearRangeLeaveComments ( Tokens $ tokens , $ indexStart , $ indexEnd ) { for ( $ i = $ indexStart ; $ i <= $ indexEnd ; ++ $ i ) { $ token = $ tokens [ $ i ] ; if ( $ token -> isComment ( ) ) { continue ; } if ( $ token -> isWhitespace ( "\n\r" ) ) { continue ; } $ tokens -> clearAt ( $ i ) ; } }
5138	public static function handleException ( \ Throwable $ e ) { if ( php_sapi_name ( ) == 'cli' ) { $ handler = new ConsoleHandler ( self :: $ output ) ; } else { $ handler = new HtmlHandler ( HtmlHandler :: INVERTED ) ; } fwrite ( self :: $ output , $ handler -> renderException ( $ e , AbstractHandler :: VERBOSITY_VERBOSE ) ) ; }
12136	public function edit ( QuestionRequest $ request , Question $ question ) { return $ this -> response -> title ( trans ( 'forum::question.name' ) ) -> view ( 'forum::public.question.newdiscussion' ) -> data ( compact ( 'question' ) ) -> output ( ) ; }
5978	public function objecttypes ( ) { if ( ! $ this -> objecttypes instanceof ObjecttypesController ) { $ this -> objecttypes = new ObjecttypesController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> objecttypes -> setLogger ( $ this -> logger ) ; } return $ this -> objecttypes ; }
8993	public function expecting ( ) { $ possibilities = count ( $ this -> samples ) ; $ orderedByOccurance = array_count_values ( $ this -> samples ) ; array_multisort ( $ orderedByOccurance , SORT_DESC ) ; $ probabilities = [ ] ; foreach ( $ orderedByOccurance as $ item => $ value ) { $ probabilities [ $ item ] = $ value / $ possibilities ; } return $ probabilities ; }
3046	protected function saveToolStates ( ) { $ toolStateParameter = 'toolStates' ; if ( $ this -> hasRequestParameter ( $ toolStateParameter ) ) { $ param = $ this -> getRawRequestParameter ( $ toolStateParameter ) ; if ( $ param ) { $ toolStates = json_decode ( $ param , true ) ; if ( count ( $ toolStates ) > 0 ) { array_walk ( $ toolStates , function ( & $ toolState ) { $ toolState = json_encode ( $ toolState ) ; } ) ; $ this -> getRunnerService ( ) -> setToolsStates ( $ this -> getServiceContext ( ) , $ toolStates ) ; return true ; } } } return false ; }
359	function checkUploadMaxFileSize ( $ min = null , $ max = null ) { $ postMaxSize = ini_get ( 'post_max_size' ) ; $ uploadMaxFileSize = ini_get ( 'upload_max_filesize' ) ; if ( $ min !== null ) { $ minCheckResult = $ this -> compareByteSize ( $ postMaxSize , $ min , '>=' ) && $ this -> compareByteSize ( $ uploadMaxFileSize , $ min , '>=' ) ; } else { $ minCheckResult = true ; } if ( $ max !== null ) { $ maxCheckResult = $ this -> compareByteSize ( $ postMaxSize , $ max , '<=' ) && $ this -> compareByteSize ( $ uploadMaxFileSize , $ max , '<=' ) ; } else { $ maxCheckResult = true ; } return ( $ minCheckResult && $ maxCheckResult ) ; }
7251	protected function validateIdentity ( SaleInterface $ sale , Constraint $ constraint ) { if ( null === $ sale -> getCustomer ( ) ) { if ( null === $ sale -> getCustomerGroup ( ) ) { $ this -> context -> buildViolation ( $ constraint -> customer_group_is_required_if_no_customer ) -> atPath ( 'customerGroup' ) -> addViolation ( ) ; } if ( 0 == strlen ( $ sale -> getEmail ( ) ) ) { $ this -> context -> buildViolation ( $ constraint -> email_is_required_if_no_customer ) -> atPath ( 'email' ) -> addViolation ( ) ; } IdentityValidator :: validateIdentity ( $ this -> context , $ sale ) ; } }
268	protected function getContextMessage ( ) { $ context = ArrayHelper :: filter ( $ GLOBALS , $ this -> logVars ) ; foreach ( $ this -> maskVars as $ var ) { if ( ArrayHelper :: getValue ( $ context , $ var ) !== null ) { ArrayHelper :: setValue ( $ context , $ var , '***' ) ; } } $ result = [ ] ; foreach ( $ context as $ key => $ value ) { $ result [ ] = "\${$key} = " . VarDumper :: dumpAsString ( $ value ) ; } return implode ( "\n\n" , $ result ) ; }
961	public function handle ( $ type ) { $ jobClass = '\\App\\Jobs\\' . str_replace ( '-' , '' , ucwords ( $ type , '-' ) ) . 'Job' ; $ jobClass :: dispatch ( Request :: header ( 'x-shopify-shop-domain' ) , json_decode ( Request :: getContent ( ) ) ) ; return Response :: make ( '' , 201 ) ; }
6849	public static function months ( $ format = null ) { $ months = array ( ) ; if ( $ format === static :: MONTHS_LONG || $ format === static :: MONTHS_SHORT ) { for ( $ i = 1 ; $ i <= 12 ; ++ $ i ) { $ months [ $ i ] = strftime ( $ format , mktime ( 0 , 0 , 0 , $ i , 1 ) ) ; } } else { $ months = static :: hours ( ) ; } return $ months ; }
2982	public function addBundle ( $ bundle ) { if ( ! $ this -> getFilename ( ) ) { return false ; } $ src = file ( $ this -> getFilename ( ) ) ; $ method = $ this -> reflected -> getMethod ( 'registerBundles' ) ; $ lines = array_slice ( $ src , $ method -> getStartLine ( ) - 1 , $ method -> getEndLine ( ) - $ method -> getStartLine ( ) + 1 ) ; if ( false !== strpos ( implode ( '' , $ lines ) , $ bundle ) ) { throw new \ RuntimeException ( sprintf ( 'Bundle "%s" is already defined in "AppKernel::registerBundles()".' , $ bundle ) ) ; } $ this -> setCode ( token_get_all ( '<?php ' . implode ( '' , $ lines ) ) , $ method -> getStartLine ( ) ) ; while ( $ token = $ this -> next ( ) ) { if ( T_VARIABLE !== $ token [ 0 ] || '$bundles' !== $ token [ 1 ] ) { continue ; } $ this -> next ( ) ; $ token = $ this -> next ( ) ; if ( T_ARRAY !== $ token [ 0 ] && '[' !== $ this -> value ( $ token ) ) { return false ; } while ( $ token = $ this -> next ( ) ) { if ( ')' !== $ this -> value ( $ token ) && ']' !== $ this -> value ( $ token ) ) { continue ; } if ( ';' !== $ this -> value ( $ this -> peek ( ) ) ) { continue ; } $ this -> next ( ) ; $ leadingContent = implode ( '' , array_slice ( $ src , 0 , $ this -> line ) ) ; $ leadingContent = rtrim ( rtrim ( $ leadingContent ) , ';' ) ; $ closingSymbolRegex = '#(\)|])$#' ; preg_match ( $ closingSymbolRegex , $ leadingContent , $ matches ) ; $ closingSymbol = $ matches [ 0 ] ; $ leadingContent = rtrim ( preg_replace ( $ closingSymbolRegex , '' , rtrim ( $ leadingContent ) ) ) ; if ( '(' !== substr ( $ leadingContent , - 1 ) && '[' !== substr ( $ leadingContent , - 1 ) ) { $ leadingContent = rtrim ( $ leadingContent , ',' ) . ',' ; } $ lines = array_merge ( array ( $ leadingContent , "\n" ) , array ( str_repeat ( ' ' , 12 ) , sprintf ( 'new %s(),' , $ bundle ) , "\n" ) , array ( str_repeat ( ' ' , 8 ) , $ closingSymbol . ';' , "\n" ) , array_slice ( $ src , $ this -> line ) ) ; Generator :: dump ( $ this -> getFilename ( ) , implode ( '' , $ lines ) ) ; return true ; } } }
2698	public function upgrade ( ModuleDataSetupInterface $ setup , ModuleContextInterface $ context ) { $ version = $ context -> getVersion ( ) ; if ( ! $ version ) { return ; } $ oldConfigPaths = [ 'stale_ttl' => 'system/full_page_cache/fastly/stale_ttl' , 'stale_error_ttl' => 'system/full_page_cache/fastly/stale_error_ttl' , 'purge_catalog_category' => 'system/full_page_cache/fastly/purge_catalog_category' , 'purge_catalog_product' => 'system/full_page_cache/fastly/purge_catalog_product' , 'purge_cms_page' => 'system/full_page_cache/fastly/purge_cms_page' , 'soft_purge' => 'system/full_page_cache/fastly/soft_purge' , 'enable_geoip' => 'system/full_page_cache/fastly/enable_geoip' , 'geoip_action' => 'system/full_page_cache/fastly/geoip_action' , 'geoip_country_mapping' => 'system/full_page_cache/fastly/geoip_country_mapping' , ] ; $ newConfigPaths = [ 'stale_ttl' => 'system/full_page_cache/fastly/fastly_advanced_configuration/stale_ttl' , 'stale_error_ttl' => 'system/full_page_cache/fastly/fastly_advanced_configuration/stale_error_ttl' , 'purge_catalog_category' => 'system/full_page_cache/fastly/fastly_advanced_configuration/purge_catalog_category' , 'purge_catalog_product' => 'system/full_page_cache/fastly/fastly_advanced_configuration/purge_catalog_product' , 'purge_cms_page' => 'system/full_page_cache/fastly/fastly_advanced_configuration/purge_cms_page' , 'soft_purge' => 'system/full_page_cache/fastly/fastly_advanced_configuration/soft_purge' , 'enable_geoip' => 'system/full_page_cache/fastly/fastly_advanced_configuration/enable_geoip' , 'geoip_action' => 'system/full_page_cache/fastly/fastly_advanced_configuration/geoip_action' , 'geoip_country_mapping' => 'system/full_page_cache/fastly/fastly_advanced_configuration/geoip_country_mapping' ] ; $ setup -> startSetup ( ) ; if ( version_compare ( $ version , '1.0.8' , '<=' ) ) { $ this -> upgrade108 ( $ oldConfigPaths , $ newConfigPaths ) ; } if ( version_compare ( $ version , '1.0.9' , '<=' ) ) { $ this -> upgrade109 ( $ setup ) ; } $ magVer = $ this -> productMetadata -> getVersion ( ) ; if ( version_compare ( $ version , '1.0.10' , '<=' ) && version_compare ( $ magVer , '2.2' , '>=' ) ) { $ this -> upgrade1010 ( $ newConfigPaths ) ; $ setup -> endSetup ( ) ; } elseif ( version_compare ( $ magVer , '2.2' , '<' ) ) { $ setup -> endSetup ( ) ; } }
980	public function api ( ) { if ( ! $ this -> api ) { $ shopDomain = $ this -> shopify_domain ; $ token = $ this -> session ( ) -> getToken ( ) ; $ this -> api = ShopifyApp :: api ( ) ; $ this -> api -> setSession ( $ shopDomain , $ token ) ; } return $ this -> api ; }
8605	public function listRegisteredDestinations ( $ request ) { if ( ! ( $ request instanceof MWSSubscriptionsService_Model_ListRegisteredDestinationsInput ) ) { require_once ( dirname ( __FILE__ ) . '/Model/ListRegisteredDestinationsInput.php' ) ; $ request = new MWSSubscriptionsService_Model_ListRegisteredDestinationsInput ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListRegisteredDestinations' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/ListRegisteredDestinationsResponse.php' ) ; $ response = MWSSubscriptionsService_Model_ListRegisteredDestinationsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
1999	private function getAcceptedLocales ( ) : array { $ accepted = [ ] ; $ locales = [ ] ; preg_match_all ( '/([a-z]{1,8}(-[a-z]{1,8})?)\s*(;\s*q\s*=\s*(1|0\.\d+))?/i' , $ this -> requestStack -> getCurrentRequest ( ) -> headers -> get ( 'accept-language' ) , $ accepted ) ; foreach ( $ accepted [ 1 ] as $ v ) { $ chunks = explode ( '-' , $ v ) ; if ( isset ( $ chunks [ 1 ] ) ) { $ locale = $ chunks [ 0 ] . '-' . strtoupper ( $ chunks [ 1 ] ) ; if ( preg_match ( '/^[a-z]{2}(\-[A-Z]{2})?$/' , $ locale ) ) { $ locales [ ] = $ locale ; } } if ( preg_match ( '/^[a-z]{2}$/' , $ chunks [ 0 ] ) ) { $ locales [ ] = $ chunks [ 0 ] ; } } return \ array_slice ( array_unique ( $ locales ) , 0 , 8 ) ; }
1194	public function setRequest ( Request $ request ) { @ trigger_error ( sprintf ( 'The %s() method is deprecated since version 2.3 and will be removed in 3.0. Pass a RequestStack in the constructor instead.' , __METHOD__ ) , E_USER_DEPRECATED ) ; $ this -> request = $ request ; }
1220	private function validateSeq ( $ from , array $ types , $ a , $ b ) { $ ta = Utils :: type ( $ a ) ; $ tb = Utils :: type ( $ b ) ; if ( $ ta !== $ tb ) { $ msg = "encountered a type mismatch in sequence: {$ta}, {$tb}" ; $ this -> typeError ( $ from , $ msg ) ; } $ typeMatch = ( $ types && $ types [ 0 ] == 'any' ) || in_array ( $ ta , $ types ) ; if ( ! $ typeMatch ) { $ msg = 'encountered a type error in sequence. The argument must be ' . 'an array of ' . implode ( '|' , $ types ) . ' types. ' . "Found {$ta}, {$tb}." ; $ this -> typeError ( $ from , $ msg ) ; } }
12616	public function setAttributes ( array $ attributes ) { foreach ( $ attributes as $ key => $ attribute ) { if ( ! ( $ attribute instanceof AttributeInterface ) ) { if ( is_array ( $ attribute ) ) { $ attr = new AttributeCollection ( $ key ) ; $ attr -> setAttributes ( $ attribute ) ; $ attribute = $ attr ; } else { $ attribute = new Attribute ( $ key , $ attribute ) ; } } $ this -> attributes [ $ attribute -> getName ( ) ] = $ attribute ; } }
2956	public function deviceClose ( ) { if ( $ this -> _dState !== SERIAL_DEVICE_OPENED ) { return true ; } if ( fclose ( $ this -> _dHandle ) ) { $ this -> _dHandle = null ; $ this -> _dState = SERIAL_DEVICE_SET ; return true ; } trigger_error ( "Unable to close the device" , E_USER_ERROR ) ; return false ; }
7345	public function modifySubmitedValueBeforeValidation ( $ value , array $ data ) { if ( $ this -> hasSubmittedValueModifier ( ) ) { return call_user_func ( $ this -> getSubmittedValueModifier ( ) , $ value , $ data ) ; } else { return $ value ; } }
7295	public function send_mail ( $ to , $ subject = '' , $ message = '' , $ headers = array ( ) , $ attachments = array ( ) ) { if ( $ this -> options [ 'static_options' ] [ 'mail_to_chunking' ] [ 'chunking' ] === TRUE ) { $ send_next_group = array ( ) ; if ( array_key_exists ( 'send_next_group' , $ this -> options [ 'static_options' ] ) ) { $ object_id = $ this -> options [ 'static_options' ] [ 'object' ] [ 'id' ] ; $ send_next_group = $ this -> options [ 'static_options' ] [ 'send_next_group' ] [ $ object_id ] ; } if ( $ this -> options [ 'send_by_bcc' ] ) { $ headers [ 'Bcc' ] = $ this -> get_mail_to_chunk ( $ headers [ 'Bcc' ] , $ send_next_group ) ; } else { $ to = $ this -> get_mail_to_chunk ( $ to , $ send_next_group ) ; } } foreach ( $ headers as $ k => $ v ) { $ headers [ ] = $ k . ': ' . $ v ; unset ( $ headers [ $ k ] ) ; } return wp_mail ( $ to , $ subject , $ message , $ headers , $ attachments ) ; }
6584	public function sum ( $ n , $ m = 0 ) { if ( $ m > 0 ) return $ this -> sum ( $ n + $ m ) - $ this -> sum ( $ m ) ; static :: ensureValid ( $ n ) ; return $ this -> b * ( 1 - pow ( $ this -> q , $ n ) ) / ( 1 - $ this -> q ) ; }
12271	public function getRoute ( ) : string { $ uri = $ _SERVER [ 'REQUEST_URI' ] ; if ( $ this -> uriBase != '/' ) { $ uri = str_replace ( $ this -> uriBase , '/' , $ uri ) ; } $ pos = strpos ( $ uri , '?' ) ; if ( $ pos !== false ) { $ uri = substr ( $ uri , 0 , $ pos ) ; } return $ uri ; }
6854	private function findPaymentTokens ( PaymentInterface $ payment ) { $ identity = $ this -> getPaymentIdentity ( $ payment ) ; $ tokens = $ this -> payum -> getTokenStorage ( ) -> findBy ( [ 'details' => $ identity , ] ) ; return $ tokens ; }
9389	protected function parse ( $ route ) { $ route [ 0 ] = strtoupper ( $ route [ 0 ] ) ; $ route [ 1 ] = str_replace ( '//' , '/' , $ this -> prefix . $ route [ 1 ] ) ; is_string ( $ route [ 2 ] ) && $ route [ 2 ] = explode ( '@' , $ route [ 2 ] ) ; is_array ( $ route [ 2 ] ) && $ route [ 2 ] [ 0 ] = $ this -> namespace . $ route [ 2 ] [ 0 ] ; is_array ( $ route [ 3 ] ) || $ route [ 3 ] = array ( $ route [ 3 ] ) ; return $ route ; }
7693	function MsExcel_SheetIsIt ( $ FileName ) { $ this -> MsExcel_SheetInit ( ) ; foreach ( $ this -> MsExcel_Sheets as $ o ) { if ( $ FileName == 'xl/' . $ o -> file ) return true ; } return false ; }
4342	public function start ( ) { if ( $ this -> isProfiling ) { return false ; } $ backtrace = \ debug_backtrace ( DEBUG_BACKTRACE_IGNORE_ARGS ) ; $ backtrace = $ this -> backtraceRemoveInternal ( $ backtrace ) ; foreach ( $ backtrace as $ frame ) { $ class = isset ( $ frame [ 'class' ] ) ? $ frame [ 'class' ] . '::' : '' ; $ this -> rootStack [ ] = $ class . $ frame [ 'function' ] ; } \ register_tick_function ( array ( $ this , 'tickFunction' ) ) ; $ this -> isProfiling = true ; $ this -> timeLastTick = \ microtime ( true ) ; return true ; }
10541	public function getFiltroConfiguration ( $ filtroName ) { if ( ! isset ( $ this -> config [ 'filtros' ] [ $ filtroName ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Filtro "%s" is not managed.' , $ filtroName ) ) ; } return $ this -> config [ 'filtros' ] [ $ filtroName ] ; }
6590	public function put ( $ url , $ data = null , $ len = null , $ method = "PUT" ) { return $ this -> request ( [ CURLOPT_PUT => true , CURLOPT_CUSTOMREQUEST => $ method ? : "PUT" , CURLOPT_URL => "$url" , CURLOPT_INFILE => $ data , CURLOPT_INFILESIZE => $ len , ] ) ; }
5036	public function indexAction ( ) { $ events = $ this -> adminControllerEvents ; $ event = $ events -> getEvent ( AdminControllerEvent :: EVENT_DASHBOARD , $ this ) ; $ events -> trigger ( $ event , $ this ) ; $ model = new ViewModel ( ) ; $ widgets = [ ] ; foreach ( $ event -> getViewModels ( ) as $ name => $ child ) { $ model -> addChild ( $ child , $ name ) ; $ widgets [ ] = $ name ; } $ model -> setVariable ( 'widgets' , $ widgets ) ; return $ model ; }
11377	public function getAction ( ) { if ( ! preg_match ( '/\/page\/(\w+[\-\w]*)\/text\/(..)(\/(\w+))?$/' , $ this -> name , $ matches ) ) { throw new InvalidParameterException ( "Invalid parameters" ) ; } $ pageName = $ matches [ 1 ] ; $ language = $ matches [ 2 ] ; $ pageTexts = $ this -> getTextModel ( $ pageName ) ; if ( empty ( $ matches [ 4 ] ) ) { $ result = array_values ( $ pageTexts -> getTextsWithBaseTexts ( $ language ) ) ; } else { $ result = $ pageTexts -> getText ( $ matches [ 4 ] , $ language ) ; } $ this -> environment -> sendJSONResult ( $ result ) ; }
9936	public function setGrouping ( $ pGrouping ) { if ( ( $ pGrouping !== null ) && ( ! in_array ( $ pGrouping , self :: $ dateTimeGroups ) ) && ( ! in_array ( $ pGrouping , self :: $ dynamicTypes ) ) && ( ! in_array ( $ pGrouping , self :: $ topTenType ) ) ) { throw new PhpSpreadsheetException ( 'Invalid rule type for column AutoFilter Rule.' ) ; } $ this -> grouping = $ pGrouping ; return $ this ; }
1762	public static function convertXlfToPhp ( $ strName , $ strLanguage , $ blnLoad = false ) { @ trigger_error ( 'Using System::convertXlfToPhp() has been deprecated and will no longer work in Contao 5.0. Use the Contao\CoreBundle\Config\Loader\XliffFileLoader instead.' , E_USER_DEPRECATED ) ; $ rootDir = self :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( strpos ( $ strName , $ rootDir . '/' ) === false ) { $ strName = $ rootDir . '/' . $ strName ; } $ loader = new XliffFileLoader ( static :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) , $ blnLoad ) ; return $ loader -> load ( $ strName , $ strLanguage ) ; }
10638	protected function processUploadedFiles ( FileBag $ filebag ) { $ adapter = new LocalAdapter ( $ this -> get ( 'kernel' ) -> getRootDir ( ) . '/../web/media' ) ; $ filesystem = new Filesystem ( $ adapter ) ; $ processed = array ( ) ; if ( $ filebag -> get ( 'files' ) ) { foreach ( $ filebag -> get ( 'files' ) as $ file ) { $ dest = $ this -> createUniquePath ( $ file ) ; if ( $ filesystem -> write ( $ dest [ 'path' ] , file_get_contents ( $ file -> getPathname ( ) ) ) ) { $ processed [ ] = $ dest [ 'path' ] ; } ; } } return $ processed ; }
6877	private function buildRevenueData ( array $ result , $ detailed = false ) { $ data = [ ] ; foreach ( $ result as $ r ) { $ data [ $ r [ 'date' ] ] = $ detailed ? json_decode ( $ r [ 'details' ] , true ) : $ r [ 'revenue' ] ; } return $ data ; }
1789	public function pasteArticle ( Contao \ DataContainer $ dc , $ row , $ table , $ cr , $ arrClipboard = null ) { $ imagePasteAfter = Contao \ Image :: getHtml ( 'pasteafter.svg' , sprintf ( $ GLOBALS [ 'TL_LANG' ] [ $ dc -> table ] [ 'pasteafter' ] [ 1 ] , $ row [ 'id' ] ) ) ; $ imagePasteInto = Contao \ Image :: getHtml ( 'pasteinto.svg' , sprintf ( $ GLOBALS [ 'TL_LANG' ] [ $ dc -> table ] [ 'pasteinto' ] [ 1 ] , $ row [ 'id' ] ) ) ; if ( $ table == $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'config' ] [ 'ptable' ] ) { return ( $ row [ 'type' ] == 'root' || ! $ this -> User -> isAllowed ( Contao \ BackendUser :: CAN_EDIT_ARTICLE_HIERARCHY , $ row ) || $ cr ) ? Contao \ Image :: getHtml ( 'pasteinto_.svg' ) . ' ' : '<a href="' . $ this -> addToUrl ( 'act=' . $ arrClipboard [ 'mode' ] . '&amp;mode=2&amp;pid=' . $ row [ 'id' ] . ( ! \ is_array ( $ arrClipboard [ 'id' ] ) ? '&amp;id=' . $ arrClipboard [ 'id' ] : '' ) ) . '" title="' . Contao \ StringUtil :: specialchars ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ $ dc -> table ] [ 'pasteinto' ] [ 1 ] , $ row [ 'id' ] ) ) . '" onclick="Backend.getScrollOffset()">' . $ imagePasteInto . '</a> ' ; } $ objPage = Contao \ PageModel :: findById ( $ row [ 'pid' ] ) ; return ( ( $ arrClipboard [ 'mode' ] == 'cut' && $ arrClipboard [ 'id' ] == $ row [ 'id' ] ) || ( $ arrClipboard [ 'mode' ] == 'cutAll' && \ in_array ( $ row [ 'id' ] , $ arrClipboard [ 'id' ] ) ) || ! $ this -> User -> isAllowed ( Contao \ BackendUser :: CAN_EDIT_ARTICLE_HIERARCHY , $ objPage -> row ( ) ) || $ cr ) ? Contao \ Image :: getHtml ( 'pasteafter_.svg' ) . ' ' : '<a href="' . $ this -> addToUrl ( 'act=' . $ arrClipboard [ 'mode' ] . '&amp;mode=1&amp;pid=' . $ row [ 'id' ] . ( ! \ is_array ( $ arrClipboard [ 'id' ] ) ? '&amp;id=' . $ arrClipboard [ 'id' ] : '' ) ) . '" title="' . Contao \ StringUtil :: specialchars ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ $ dc -> table ] [ 'pasteafter' ] [ 1 ] , $ row [ 'id' ] ) ) . '" onclick="Backend.getScrollOffset()">' . $ imagePasteAfter . '</a> ' ; }
12182	public function getPrimaryChild ( $ parentObject ) { if ( ! $ this -> handlePrimary ) { return false ; } if ( ! $ this -> child -> getPrimaryAsChild ( $ this -> parent ) ) { return false ; } $ key = json_encode ( [ __FUNCTION__ , $ this -> systemId , $ parentObject -> primaryKey ] ) ; if ( ! isset ( self :: $ _cache [ $ key ] ) ) { self :: $ _cache [ $ key ] = null ; $ relationClass = Yii :: $ app -> classes [ 'Relation' ] ; $ childClass = $ this -> child -> primaryModel ; $ relation = $ relationClass :: find ( ) ; $ alias = $ relationClass :: tableName ( ) ; $ relation -> andWhere ( [ '`' . $ alias . '`.`parent_object_id`' => $ parentObject -> primaryKey , '`' . $ alias . '`.`primary_child`' => 1 ] ) ; $ relation -> andWhere ( [ 'or' , '`' . $ alias . '`.`child_object_id` LIKE :prefix' ] ) ; $ relation -> params [ ':prefix' ] = $ childClass :: modelPrefix ( ) . '-%' ; $ parentObject -> addActiveConditions ( $ relation , $ alias ) ; $ relation = $ relation -> one ( ) ; if ( ! empty ( $ relation ) ) { self :: $ _cache [ $ key ] = $ relation ; } } return self :: $ _cache [ $ key ] ; }
5198	public function save ( ) { try { $ connection = new Connection ( $ this -> buildConnectionOptions ( ) ) ; $ connection -> open ( ) ; $ msg = new AMQPMessage ( $ this -> message , array ( 'content_type' => $ this -> content_type , 'delivery_mode' => 2 ) ) ; $ connection -> channel -> basic_publish ( $ msg , $ this -> exchange , $ this -> queue_name ) ; $ connection -> close ( ) ; } catch ( Exception $ e ) { $ connection -> close ( ) ; throw new Exception ( $ e ) ; } }
6170	protected function onAddError ( \ Exception $ e ) { $ this -> writeProgressWithColor ( 'fg-red,bold' , 'E' ) ; $ this -> exception = $ e ; $ this -> lastTestFailed = true ; $ this -> flawless = false ; }
12600	public static function copy ( $ src , $ dest , $ force = true ) { $ src = Path :: clean ( $ src ) ; $ dest = Path :: clean ( $ dest ) ; if ( ! Folder :: exists ( dirname ( $ dest ) ) ) { Folder :: create ( dirname ( $ dest ) ) ; } $ fs = new Filesystem ( ) ; try { $ fs -> copy ( $ src , $ dest , $ force ) ; } catch ( IOExceptionInterface $ e ) { throw new Exception ( Helper :: getTranslation ( 'CANNOT_FIND_SOURCE' ) . ' ' . $ e -> getPath ( ) ) ; } return true ; }
3759	public function buildWidget ( BuildWidgetEvent $ event ) { if ( ! ( $ this -> wantToHandle ( $ event ) && \ in_array ( $ event -> getProperty ( ) -> getName ( ) , [ 'name' , 'description' ] ) ) ) { return ; } $ metaModel = $ this -> getMetaModelByModelPid ( $ event -> getModel ( ) ) ; Helper :: prepareLanguageAwareWidget ( $ event -> getEnvironment ( ) , $ event -> getProperty ( ) , $ metaModel , $ this -> translator -> trans ( 'tl_metamodel_attribute.name_langcode' , [ ] , 'contao_tl_metamodel_attribute' ) , $ this -> translator -> trans ( 'tl_metamodel_attribute.name_value' , [ ] , 'contao_tl_metamodel_attribute' ) , false , StringUtil :: deserialize ( $ event -> getModel ( ) -> getProperty ( $ event -> getProperty ( ) -> getName ( ) ) , true ) ) ; }
9526	private function checkValidityAndContinueParse ( ) { $ valid = $ this -> validateRequiredParameters ( ) ; if ( $ valid !== true ) { $ this -> errorHandler -> call ( $ this , $ valid , 'Missing required argument: ' . $ valid -> parameterName ) ; $ this -> valid = false ; return [ ] ; } return $ this -> parseEvery ( ) ; }
153	public function each ( $ batchSize = 100 , $ db = null ) { return Yii :: createObject ( [ 'class' => BatchQueryResult :: className ( ) , 'query' => $ this , 'batchSize' => $ batchSize , 'db' => $ db , 'each' => true , ] ) ; }
12210	private function saveTransLogs ( $ orders , $ transIds ) { $ bySaleId = [ ] ; foreach ( $ orders as $ custId => $ order ) { $ saleId = $ order [ QGetOrders :: A_SALE_ID ] ; $ bySaleId [ $ saleId ] = $ order ; } foreach ( $ transIds as $ tranId => $ one ) { $ pref = substr ( $ one , 0 , 2 ) ; $ orderId = str_replace ( $ pref , '' , $ one ) ; if ( $ pref == self :: PREFIX_PV ) { $ custId = $ bySaleId [ $ orderId ] [ QGetOrders :: A_CUST_ID ] ; $ this -> daoLogCust -> create ( [ LogCust :: A_TRANS_ID => $ tranId , LogCust :: A_CUSTOMER_ID => $ custId ] ) ; $ this -> daoLogSale -> create ( [ LogSales :: A_TRANS_ID => $ tranId , LogSales :: A_SALE_ORDER_ID => $ orderId ] ) ; } elseif ( $ pref == self :: PREFIX_BONUS_FATHER ) { $ custId = $ bySaleId [ $ orderId ] [ QGetOrders :: A_PARENT_ID ] ; $ this -> daoLogCust -> create ( [ LogCust :: A_TRANS_ID => $ tranId , LogCust :: A_CUSTOMER_ID => $ custId ] ) ; } else { $ custId = $ bySaleId [ $ orderId ] [ QGetOrders :: A_PARENT_GRAND_ID ] ; $ this -> daoLogCust -> create ( [ LogCust :: A_TRANS_ID => $ tranId , LogCust :: A_CUSTOMER_ID => $ custId ] ) ; } } }
3244	public function getWasPurchasedAttribute ( ) { if ( Auth :: guest ( ) ) return false ; return Auth :: user ( ) -> orders ( ) -> whereSKU ( $ this -> attributes [ 'sku' ] ) -> whereStatusIn ( config ( 'shop.order_status_purchase' ) ) -> count ( ) > 0 ; }
10269	function setHTMLContent ( $ mailingId , $ html , $ doImageGrabbing = true , $ doLinkTracking = false ) { $ queryParameters = array ( 'doImageGrabbing' => ( $ doImageGrabbing == TRUE ) ? "true" : "false" , 'doLinkTracking' => ( $ doLinkTracking == TRUE ) ? "true" : "false" ) ; return $ this -> post ( 'mailings/' . $ mailingId . '/contents/html' , $ html , $ queryParameters , "text/html" ) ; }
4948	public function findDraftsBy ( array $ criteria , array $ sort = null , $ limit = null , $ skip = null ) { $ criteria [ 'isDraft' ] = true ; return parent :: findBy ( $ criteria , $ sort , $ limit , $ skip ) ; }
1782	public static function isValidFileName ( $ strName ) { if ( $ strName == '' ) { return false ; } if ( preg_match ( '@[\\\\/:*?"<>|]@' , $ strName ) ) { return false ; } if ( preg_match ( '/[\pC]/u' , $ strName ) !== 0 ) { return false ; } if ( Utf8 :: strlen ( $ strName ) > 255 ) { return false ; } return true ; }
6039	public function custom ( $ sessionId , $ mediaId , $ event ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'sessionId' => $ sessionId , 'mediaId' => $ mediaId , 'event' => $ event ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/events/custom' , $ parameters , true ) ; return $ result ; }
10668	public static function build ( $ input , array $ options = [ ] ) { if ( ! \ is_array ( $ options ) ) { $ options = [ 'return' => ( string ) $ options ] ; } $ defaults = [ 'return' => 'simplexml' , ] ; $ options = array_merge ( $ defaults , $ options ) ; if ( is_array ( $ input ) || is_object ( $ input ) ) { return self :: fromArray ( ( array ) $ input , $ options ) ; } if ( strpos ( $ input , '<' ) !== false ) { if ( $ options [ 'return' ] === 'simplexml' || $ options [ 'return' ] === 'simplexmlelement' ) { return new \ SimpleXMLElement ( $ input , LIBXML_NOCDATA ) ; } $ dom = new \ DOMDocument ( ) ; $ dom -> loadXML ( $ input ) ; return $ dom ; } if ( file_exists ( $ input ) || strpos ( $ input , 'http://' ) === 0 || strpos ( $ input , 'https://' ) === 0 ) { if ( $ options [ 'return' ] === 'simplexml' || $ options [ 'return' ] === 'simplexmlelement' ) { return new \ SimpleXMLElement ( $ input , LIBXML_NOCDATA , true ) ; } $ dom = new \ DOMDocument ( ) ; $ dom -> load ( $ input ) ; return $ dom ; } if ( ! \ is_string ( $ input ) ) { throw new \ RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'Invalid input.' ) ) ; } throw new \ RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'XML cannot be read.' ) ) ; }
7568	protected function parse ( ) { $ p = & $ this -> parser ; $ p -> setPos ( 0 ) ; $ this -> result = array ( ) ; if ( ! $ this -> parse_single ( ) ) { return false ; } while ( count ( $ this -> result ) > 0 ) { switch ( $ p -> token ) { case CSSQueryTokenizer :: TOK_CHILD : $ this -> parser -> next_no_whitespace ( ) ; if ( ! $ this -> parse_result ( false , 1 ) ) { return false ; } break ; case CSSQueryTokenizer :: TOK_SIBLING : $ this -> parser -> next_no_whitespace ( ) ; if ( ! $ this -> parse_result ( true , 1 ) ) { return false ; } break ; case CSSQueryTokenizer :: TOK_PLUS : $ this -> parser -> next_no_whitespace ( ) ; if ( ! $ this -> parse_adjacent ( ) ) { return false ; } break ; case CSSQueryTokenizer :: TOK_ALL : case CSSQueryTokenizer :: TOK_IDENTIFIER : case CSSQueryTokenizer :: TOK_STRING : case CSSQueryTokenizer :: TOK_BRACE_OPEN : case CSSQueryTokenizer :: TOK_BRACKET_OPEN : case CSSQueryTokenizer :: TOK_ID : case CSSQueryTokenizer :: TOK_CLASS : case CSSQueryTokenizer :: TOK_COLON : if ( ! $ this -> parse_result ( ) ) { return false ; } break ; case CSSQueryTokenizer :: TOK_NULL : break 2 ; default : $ this -> error ( 'Invalid search pattern(3): No result modifier found!' ) ; return false ; } } return true ; }
3791	protected function fetchExistingIdsFor ( $ idList , $ langCode ) { $ queryBuilder = $ this -> connection -> createQueryBuilder ( ) -> select ( 'item_id' ) -> from ( $ this -> getValueTable ( ) ) ; $ this -> buildWhere ( $ queryBuilder , $ idList , $ langCode ) ; $ statement = $ queryBuilder -> execute ( ) ; return $ statement -> fetchAll ( \ PDO :: FETCH_COLUMN ) ; }
211	protected function hashPluginOptions ( $ view ) { $ encOptions = empty ( $ this -> clientOptions ) ? '{}' : Json :: htmlEncode ( $ this -> clientOptions ) ; $ this -> _hashVar = self :: PLUGIN_NAME . '_' . hash ( 'crc32' , $ encOptions ) ; $ this -> options [ 'data-plugin-' . self :: PLUGIN_NAME ] = $ this -> _hashVar ; $ view -> registerJs ( "var {$this->_hashVar} = {$encOptions};" , View :: POS_HEAD ) ; }
12075	public function childShow ( FilterRequest $ filters , $ id , $ idChild , $ relation ) { $ id = $ this -> getRealId ( $ id ) ; $ idChild = $ this -> getRealId ( $ idChild ) ; $ resource = $ this -> repository -> getChild ( $ id , $ relation , $ idChild , $ filters ) ; if ( ! $ resource ) { } return $ this -> success ( $ resource ) ; }
5914	public function updateLastLogin ( $ id , $ successful = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'successful' => $ successful ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/accounts/users/' . $ id . '/registerloginattempt' , $ parameters ) ; $ result = new User ( $ result ) ; return $ result ; }
12087	public static function create ( $ validator , $ command ) { static $ cache = [ ] ; $ cacheKey = $ validator ; if ( isset ( $ cache [ $ cacheKey ] ) ) { $ class = $ cache [ $ cacheKey ] [ 'class' ] ; $ validator = $ cache [ $ cacheKey ] [ 'validator' ] ; } else { if ( false === strpos ( $ validator , '.' ) ) { $ class = __NAMESPACE__ . '\\' . String :: convertToCamelCase ( $ validator ) ; } else { $ class = explode ( '.' , $ validator ) ; $ class = array_map ( array ( 'In2pire\\Component\\Utility\\Text' , 'convertToCamelCase' ) , $ class ) ; $ class = implode ( '\\' , $ class ) ; $ validator = substr ( $ validator , strrpos ( $ validator , '.' ) + 1 ) ; } $ cache [ $ cacheKey ] = [ 'class' => $ class , 'validator' => $ validator ] ; } if ( ! class_exists ( $ class ) ) { throw new \ RuntimeException ( 'Unknow validator ' . $ cacheKey ) ; } return new $ class ( $ command ) ; }
3771	public function fixupModules ( DataContainer $ dataContainer ) { if ( ! class_exists ( 'tl_user_group' , false ) ) { throw new \ RuntimeException ( 'data container is not loaded!' ) ; } $ original = new \ tl_user_group ( ) ; $ modules = $ original -> getModules ( ) ; foreach ( array_keys ( $ modules ) as $ group ) { foreach ( $ modules [ $ group ] as $ key => $ module ) { if ( strpos ( $ module , 'metamodel_' ) === 0 ) { unset ( $ modules [ $ group ] [ $ key ] ) ; } } $ modules [ $ group ] = array_values ( $ modules [ $ group ] ) ; } $ modules [ 'metamodels' ] [ ] = 'support_metamodels' ; if ( false !== $ index = array_search ( 'metamodels' , $ modules [ 'metamodels' ] , true ) ) { unset ( $ modules [ 'metamodels' ] [ $ index ] ) ; $ modules [ 'metamodels' ] = array_values ( $ modules [ 'metamodels' ] ) ; } $ combinations = $ this -> combinationBuilder -> getCombinationsForUser ( [ $ dataContainer -> activeRecord -> id ] , 'be' ) ; $ screenIds = array_map ( function ( $ combination ) { return $ combination [ 'dca_id' ] ; } , $ combinations [ 'byName' ] ) ; $ screens = $ this -> inputScreens -> fetchInputScreens ( $ screenIds ) ; $ locale = $ this -> requestStack -> getCurrentRequest ( ) -> getLocale ( ) ; foreach ( $ screens as $ metaModel => $ screen ) { if ( 'standalone' === $ screen [ 'meta' ] [ 'rendertype' ] ) { $ modules [ $ screen [ 'meta' ] [ 'backendsection' ] ] [ ] = 'metamodel_' . $ metaModel ; $ this -> buildLanguageString ( 'metamodel_' . $ metaModel , $ screen , $ locale ) ; } } return $ modules ; }
10423	public function setTriggerType ( $ type ) { if ( ! array_key_exists ( $ type , $ this -> validTypes ) ) { throw new \ InvalidArgumentException ( 'The type MUST be one of:' . implode ( ',' , $ this -> validTypes ) ) ; } $ this -> type = $ this -> validTypes [ $ type ] ; $ this -> typeAlias = $ type ; }
11529	public function replaceVariables ( $ string , $ replaces = [ ] ) { $ callback = function ( $ match ) use ( $ replaces ) { $ variable = trim ( $ match [ 0 ] , '{}' ) ; if ( array_key_exists ( $ variable , $ replaces ) ) { return $ replaces [ $ variable ] ; } return $ variable ; } ; return preg_replace_callback ( '/{.*?}/' , $ callback , $ string ) ; }
10341	protected function validateColumns ( $ columns ) { $ patterns = array ( '((?P<minute>(?:\*|(?:(?:[0-9]|[1-5][0-9])(?:-(?:[0-9]|[1-5][0-9]))?)(?:,(?:[0-9]|[1-5][0-9])(?:-(?:[0-9]|[1-5][0-9]))?)*)(?:/(?:[1-9]|[1-5][0-9]))?)$)AD' , '((?P<hour>(?:\*|(?:(?:[0-9]|1[0-9]|2[0-3])(?:-(?:[0-9]|1[0-9]|2[0-3]))?)(?:,(?:[0-9]|1[0-9]|2[0-3])(?:-(?:[0-9]|1[0-9]|2[0-3]))?)*)(?:/(?:[1-9]|1[0-9]|2[0-3]))?)$)AD' , '((?P<dayOfMonth>(?:\*|(?:(?:[1-9]|[1-2][0-9]|3[0-1])(?:-(?:[1-9]|[1-2][0-9]|3[0-1]))?)(?:,(?:[1-9]|[1-2][0-9]|3[0-1])(?:-(?:[1-9]|[1-2][0-9]|3[0-1]))?)*)(?:/(?:[1-9]|[1-2][0-9]|3[0-1]))?)$)AD' , '((?P<month>(?:\*|(?:(?:[1-9]|1[0-2])(?:-(?:[1-9]|1[1-2]))?)(?:,(?:[1-9]|1[1-2])(?:-(?:[1-9]|1[1-2]))?)*)(?:/(?:[1-9]|1[1-2]))?)$)AD' , '((?P<dayOfWeek>(?:\*|(?:(?:[0-7])(?:-(?:[0-7]))?)(?:,(?:[0-7])(?:-(?:[0-7]))?)*)(?:/(?:[1-7]))?)$)AD' , ) ; if ( count ( $ columns ) !== 5 ) { return false ; } foreach ( $ columns as $ key => $ column ) { if ( preg_match ( $ patterns [ $ key ] , $ column ) !== 1 ) { return ( int ) $ key ; } } return true ; }
7135	public function getPercent ( ) : float { $ amount = $ this -> getAmount ( ) ; if ( 0 < $ this -> sellingPrice ) { return round ( $ amount * 100 / $ this -> sellingPrice , 2 ) ; } return 0 ; }
4622	protected function pickNode ( ) { $ nodes = $ this -> getNodes ( ) ; $ index = mt_rand ( 0 , count ( $ nodes ) - 1 ) ; return array_keys ( $ nodes ) [ $ index ] ; }
6552	public function lock ( ) { if ( $ this -> pid === $ this -> getSerial ( ) ) { return ; } $ this -> pid = $ this -> getSerial ( ) ; $ this -> fh = fopen ( $ filename = $ this -> getPidFilename ( ) , 'a+' ) ; if ( ! flock ( $ this -> fh , LOCK_EX | LOCK_NB ) ) { throw new ImportAlreadyRunningException ( sprintf ( 'PID file %s is already in use' , $ filename ) ) ; } if ( fwrite ( $ this -> fh , $ this -> pid . PHP_EOL ) === false ) { throw new \ Exception ( sprintf ( 'Can\'t write PID %s to PID file %s' , $ this -> pid , $ filename ) ) ; } }
2958	public function confStopBits ( $ length ) { if ( $ this -> _dState !== SERIAL_DEVICE_SET ) { trigger_error ( "Unable to set the length of a stop bit : the " . "device is either not set or opened" , E_USER_WARNING ) ; return false ; } if ( $ length != 1 and $ length != 2 and $ length != 1.5 and ! ( $ length == 1.5 and $ this -> _os === "linux" ) ) { trigger_error ( "Specified stop bit length is invalid" , E_USER_WARNING ) ; return false ; } if ( $ this -> _os === "linux" ) { $ ret = $ this -> _exec ( "stty -F " . $ this -> _device . " " . ( ( $ length == 1 ) ? "-" : "" ) . "cstopb" , $ out ) ; } elseif ( $ this -> _os === "osx" ) { $ ret = $ this -> _exec ( "stty -f " . $ this -> _device . " " . ( ( $ length == 1 ) ? "-" : "" ) . "cstopb" , $ out ) ; } else { $ ret = $ this -> _exec ( "mode " . $ this -> _winDevice . " STOP=" . $ length , $ out ) ; } if ( $ ret === 0 ) { return true ; } trigger_error ( "Unable to set stop bit length : " . $ out [ 1 ] , E_USER_WARNING ) ; return false ; }
3120	public function remove ( $ tag , $ target = TimePoint :: TARGET_ALL , $ type = TimePoint :: TYPE_ALL ) { $ tags = is_array ( $ tag ) ? $ tag : [ $ tag ] ; $ removed = 0 ; foreach ( $ this -> points as $ idx => $ point ) { if ( $ point -> match ( $ tags , $ target , $ type ) ) { unset ( $ this -> points [ $ idx ] ) ; $ removed ++ ; } } return $ removed ; }
4123	public function generateProxyClasses ( array $ classes , $ toDir = null ) { $ proxyDir = $ toDir ? : $ this -> proxyDir ; $ proxyDir = rtrim ( $ proxyDir , DIRECTORY_SEPARATOR ) . DIRECTORY_SEPARATOR ; foreach ( $ classes as $ class ) { if ( $ class -> isMappedSuperclass ) { continue ; } $ proxyFileName = $ this -> getProxyFileName ( $ class -> name , $ toDir ) ; $ this -> generateProxyClass ( $ class , $ proxyFileName , self :: $ proxyClassTemplate ) ; } }
1967	public static function findById ( $ intId , array $ arrOptions = array ( ) ) { if ( Validator :: isUuid ( $ intId ) ) { return static :: findByUuid ( $ intId , $ arrOptions ) ; } return static :: findOneBy ( 'id' , $ intId , $ arrOptions ) ; }
10288	protected function getJobsSince ( $ time ) { $ now = time ( ) ; $ jobs = array ( ) ; foreach ( $ this -> rescheduled as $ scheduled => $ cronjob ) { if ( $ scheduled <= $ now ) { $ jobs [ $ scheduled ] [ ] = $ cronjob ; unset ( $ this -> rescheduled [ $ scheduled ] ) ; } } foreach ( $ this -> crontab as $ cronjob ) { $ cronjob -> iterator -> startTime = $ time ; if ( ( $ scheduled = $ cronjob -> iterator -> current ( ) ) < $ now ) { $ jobs [ $ scheduled ] [ ] = $ cronjob ; } } ksort ( $ jobs ) ; return $ jobs ; }
9196	public function config ( ) { if ( ! $ this -> config ) { $ config = array ( ) ; $ configFile = $ this -> getThemesPath ( ) . DIRECTORY_SEPARATOR . $ this -> getName ( ) . DIRECTORY_SEPARATOR . 'theme.config.php' ; if ( file_exists ( $ configFile ) ) { ob_start ( ) ; set_error_handler ( function ( $ errno , $ errstr ) { throw new \ ErrorException ( $ errstr , $ errno ) ; } , E_ALL ) ; $ config = include $ configFile ; restore_error_handler ( ) ; ob_get_clean ( ) ; if ( ! is_array ( $ config ) ) throw new \ Exception ( 'Invalid "' . $ this -> getName ( ) . '" Theme Config File. It must return array.' ) ; } $ this -> config = new Entity ( $ config ) ; } return $ this -> config ; }
8319	public function matches ( $ regexp , $ message ) { if ( ! is_string ( $ regexp ) || ! is_string ( $ message ) ) { throw new \ InvalidArgumentException ( "Both arguments must be string." ) ; } $ this -> constraints [ ] = ( function ( Password $ str ) use ( $ regexp , $ message ) { if ( ! preg_match ( $ regexp , $ str ) ) { return $ message ; } else { return true ; } } ) ; return $ this ; }
8189	final protected function getContext ( $ context , $ item , $ ignoreStrictCheck = false ) { if ( ! array_key_exists ( $ item , $ context ) ) { if ( $ ignoreStrictCheck || ! $ this -> env -> isStrictVariables ( ) ) { return ; } throw new Twig_Error_Runtime ( sprintf ( 'Variable "%s" does not exist.' , $ item ) , - 1 , $ this -> getSourceContext ( ) ) ; } return $ context [ $ item ] ; }
4945	public function revoke ( $ resource , $ permission = null , $ build = true ) { if ( self :: PERMISSION_NONE == $ permission || ! $ this -> isAssigned ( $ resource ) ) { return $ this ; } if ( self :: PERMISSION_CHANGE == $ permission ) { return $ this -> grant ( $ resource , self :: PERMISSION_VIEW , $ build ) ; } return $ this -> grant ( $ resource , self :: PERMISSION_NONE , $ build ) ; }
4556	public function setOrganizationUuid ( ? string $ organizationUuid ) { $ this -> organizationUuid = $ organizationUuid ; $ this -> _organizationUuid = true ; return $ this ; }
2040	private function createConfigItem ( $ imageSize ) : PictureConfigurationItem { $ configItem = new PictureConfigurationItem ( ) ; $ resizeConfig = new ResizeConfiguration ( ) ; if ( null !== $ imageSize ) { $ resizeConfig -> setWidth ( $ imageSize -> width ) -> setHeight ( $ imageSize -> height ) -> setMode ( $ imageSize -> resizeMode ) -> setZoomLevel ( $ imageSize -> zoom ) ; $ configItem -> setResizeConfig ( $ resizeConfig ) -> setSizes ( $ imageSize -> sizes ) -> setDensities ( $ imageSize -> densities ) ; if ( isset ( $ imageSize -> media ) ) { $ configItem -> setMedia ( $ imageSize -> media ) ; } } return $ configItem ; }
11785	public function pagination ( $ begin , $ count ) { $ params = [ 'type' => 2 , 'begin' => intval ( $ begin ) , 'count' => intval ( $ count ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_SEARCH , $ params ] ) ; }
11167	protected function generateApi ( ) { $ api = array ( ) ; $ api [ "url" ] = $ this -> getUrl ( ) ; $ api [ "type" ] = "remoting" ; $ actionsArray = array ( ) ; $ actions = $ this -> getActions ( ) ; foreach ( $ actions as $ class ) { $ methodArray = array ( ) ; foreach ( $ class -> getMethods ( ) as $ method ) { $ methodArray [ ] = array ( "name" => $ method -> getAnnotatedName ( ) , "len" => $ method -> getLen ( ) ) ; } $ actionsArray [ $ class -> getAnnotatedName ( ) ] = $ methodArray ; } $ api [ "actions" ] = $ actionsArray ; return $ api ; }
8138	public function getTemplateClass ( $ name , $ index = null ) { $ key = $ this -> getLoader ( ) -> getCacheKey ( $ name ) . $ this -> optionsHash ; return $ this -> templateClassPrefix . hash ( 'sha256' , $ key ) . ( null === $ index ? '' : '_' . $ index ) ; }
7507	function getTokenString ( $ start_offset = 0 , $ end_offset = 0 ) { $ token_start = ( ( is_int ( $ this -> token_start ) ) ? $ this -> token_start : $ this -> pos ) + $ start_offset ; $ len = $ this -> pos - $ token_start + 1 + $ end_offset ; return ( ( $ len > 0 ) ? substr ( $ this -> doc , $ token_start , $ len ) : '' ) ; }
6714	public function getRequestChain ( ) { if ( is_null ( $ this -> requestChain ) ) { $ this -> requestChain = $ this -> getRequestChainFromUri ( $ this -> requestedUri ) ; } return $ this -> requestChain ; }
464	public function buildNotCondition ( $ operator , $ operands , & $ params ) { array_unshift ( $ operands , $ operator ) ; return $ this -> buildCondition ( $ operands , $ params ) ; }
5915	public function sendPasswordReset ( $ id , $ link = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'link' => $ link ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/accounts/users/' . $ id . '/resetpassword' , $ parameters ) ; return $ result ; }
1201	public function isCurrent ( ItemInterface $ item ) { if ( null === $ this -> matcher ) { throw new \ BadMethodCallException ( 'The matcher must be set to get the breadcrumbs array' ) ; } return $ this -> matcher -> isCurrent ( $ item ) ; }
10809	protected function __templates ( $ customTemplate = null , $ customTemplateSuffix = null ) { $ templates = SSViewer :: get_templates_by_class ( $ this -> class , $ customTemplateSuffix , \ FormField :: class ) ; if ( ! $ templates ) { throw new \ Exception ( "No template found for {$this->class}" ) ; } if ( $ customTemplate ) { array_unshift ( $ templates , $ customTemplate ) ; } return $ templates ; }
8634	public function setOrderChargeAdjustmentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'OrderChargeAdjustmentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
2789	public static function reconstructFromTokens ( array & $ tokens ) { $ str = '' ; foreach ( $ tokens as $ token ) { if ( is_string ( $ token ) ) { $ str .= $ token ; } else { $ str .= $ token [ 1 ] ; } } return $ str ; }
8311	public function applyDefaults ( $ config , array $ defaults , $ depth = 1 ) { if ( ! is_int ( $ depth ) || $ depth < 0 ) { throw new \ InvalidArgumentException ( "Depth must be non-negative integer." ) ; } if ( ! is_array ( $ config ) ) { return $ defaults ; } if ( $ depth === 0 ) { $ config += $ defaults ; return $ config ; } foreach ( $ defaults as $ key => $ defaultValue ) { if ( ! isset ( $ config [ $ key ] ) ) { $ config [ $ key ] = $ defaultValue ; continue ; } if ( is_array ( $ defaultValue ) ) { if ( is_array ( $ config [ $ key ] ) ) { $ config [ $ key ] = $ this -> applyDefaults ( $ config [ $ key ] , $ defaultValue , $ depth - 1 ) ; } else { throw new ConfigurationException ( "Configuration key " . $ key . " expects an array, a scalar value found." ) ; } } else { if ( is_array ( $ config [ $ key ] ) ) { throw new ConfigurationException ( "Configuration key " . $ key . " expects scalar, an array found." ) ; } } } return $ config ; }
2542	protected function analyzeWithErrorCodeMsgQueryLevel ( SendResult $ response , $ qErr , $ qMsg , $ qLvl , $ lvlToText ) { $ analyzeResponse = new Result ( $ response ) ; $ domXpath = $ this -> makeDomXpath ( $ response -> responseXml ) ; $ errorCodeNodeList = $ domXpath -> query ( $ qErr ) ; if ( $ errorCodeNodeList -> length > 0 ) { $ analyzeResponse -> status = Result :: STATUS_ERROR ; $ lvlNodeList = $ domXpath -> query ( $ qLvl ) ; $ level = null ; if ( $ lvlNodeList -> length > 0 ) { if ( array_key_exists ( $ lvlNodeList -> item ( 0 ) -> nodeValue , $ lvlToText ) ) { $ level = $ lvlToText [ $ lvlNodeList -> item ( 0 ) -> nodeValue ] ; } } $ analyzeResponse -> messages [ ] = new Result \ NotOk ( $ errorCodeNodeList -> item ( 0 ) -> nodeValue , $ this -> makeMessageFromMessagesNodeList ( $ domXpath -> query ( $ qMsg ) ) , $ level ) ; } return $ analyzeResponse ; }
12014	public static function execute ( ConnectionInterface $ connection , $ forceSimpleUrl = false ) { $ url = $ connection -> host . '/' . $ connection -> accountId . '/' . $ connection -> db . '' . $ connection -> action . ( isset ( $ connection -> transactionId ) ? '?transaction_id=' . $ connection -> transactionId : '' ) ; if ( $ forceSimpleUrl ) { $ url = $ connection -> host . '/' . $ connection -> accountId ; } if ( $ connection -> debug === true ) { echo "URL: " . $ url . "\r\n" ; echo "USER:PWD: " . $ connection -> username . ":" . str_repeat ( 'X' , strlen ( $ connection -> password ) ) . "\r\n" ; echo "METHOD: " . $ connection -> method . "\r\n" ; echo "QUERY: " . ( isset ( $ connection -> query ) ? $ connection -> query : null ) . "\r\n" ; } $ curl = curl_init ( ) ; curl_setopt ( $ curl , CURLOPT_URL , $ url ) ; curl_setopt ( $ curl , CURLOPT_USERPWD , $ connection -> username . ":" . $ connection -> password ) ; curl_setopt ( $ curl , CURLOPT_CUSTOMREQUEST , $ connection -> method ) ; curl_setopt ( $ curl , CURLOPT_POSTFIELDS , isset ( $ connection -> query ) ? $ connection -> query : null ) ; curl_setopt ( $ curl , CURLOPT_HTTPHEADER , array ( 'Content-Type: text/plain' ) ) ; curl_setopt ( $ curl , CURLOPT_RETURNTRANSFER , true ) ; curl_setopt ( $ curl , CURLOPT_SSL_VERIFYPEER , 0 ) ; curl_setopt ( $ curl , CURLOPT_SSL_VERIFYHOST , 0 ) ; $ curlResponse = curl_exec ( $ curl ) ; if ( $ connection -> debug === true ) { if ( curl_error ( $ curl ) ) { echo "cURL error: " . curl_error ( $ curl ) . "\r\n" ; } echo "RESPONSE: " . $ curlResponse . "\r\n\r\n" ; } curl_close ( $ curl ) ; return ( $ connection -> query === 'BEGIN_TRANSACTION' ) ? json_decode ( $ curlResponse ) -> transaction_id : ( ( isset ( $ connection -> multiple ) && $ connection -> multiple ) ? new Batch ( $ curlResponse , $ connection ) : new Single ( $ curlResponse , $ connection ) ) ; }
9849	public function createSignedResponse ( int $ status , string $ body , SigningSecretKey $ key , array $ headers = [ ] , string $ version = '1.1' ) : ResponseInterface { $ signature = \ ParagonIE_Sodium_Compat :: crypto_sign_detached ( $ body , $ key -> getString ( true ) ) ; if ( isset ( $ headers [ Sapient :: HEADER_SIGNATURE_NAME ] ) ) { $ headers [ Sapient :: HEADER_SIGNATURE_NAME ] [ ] = Base64UrlSafe :: encode ( $ signature ) ; } else { $ headers [ Sapient :: HEADER_SIGNATURE_NAME ] = Base64UrlSafe :: encode ( $ signature ) ; } return new Response ( $ status , new Headers ( $ headers ) , $ this -> stringToStream ( $ body ) ) ; }
8025	public function addFree ( ProcessDetails $ processDetails ) { $ pid = $ processDetails -> getPid ( ) ; $ this -> processDetails [ $ pid ] = $ processDetails ; $ this -> sockets [ $ pid ] = $ processDetails -> getSocket ( ) ; $ this -> registerFreeProcess ( $ processDetails ) ; return $ this ; }
8438	public function setPostLink ( TimelineLinkEvent $ event ) : void { $ action = $ event -> getAction ( ) ; if ( ! in_array ( $ action -> getVerb ( ) , [ 'post' , 'reply' ] ) ) { return ; } $ production = $ action -> getComponent ( 'indirectComplement' ) -> getData ( ) ; $ post = $ action -> getComponent ( 'directComplement' ) -> getData ( ) ; $ event -> setLink ( $ this -> url_generator -> generate ( 'bkstg_board_show' , [ 'production_slug' => $ production -> getSlug ( ) , '_fragment' => 'post-' . $ post -> getId ( ) , ] ) ) ; }
9060	public function setPrimaryKey ( string ... $ key ) : self { $ this -> primaryKey = new PrimaryKey ( $ this , ... $ key ) ; return $ this ; }
1535	protected function fill ( $ record , ResourceObject $ resource , EncodingParametersInterface $ parameters ) { $ this -> fillAttributes ( $ record , $ resource -> getAttributes ( ) ) ; $ this -> fillRelationships ( $ record , $ resource -> getRelationships ( ) , $ parameters ) ; }
7703	function OpenDoc_ChartInit ( ) { $ this -> OpenDocCharts = array ( ) ; $ idx = $ this -> Ext_GetMainIdx ( ) ; $ Txt = $ this -> TbsStoreGet ( $ idx , 'OpenDoc_ChartInit' ) ; $ p = 0 ; while ( $ drEl = clsTbsXmlLoc :: FindElement ( $ Txt , 'draw:frame' , $ p ) ) { $ src = $ drEl -> GetInnerSrc ( ) ; $ objEl = clsTbsXmlLoc :: FindStartTag ( $ src , 'draw:object' , 0 ) ; if ( $ objEl ) { $ href = $ objEl -> GetAttLazy ( 'xlink:href' ) ; if ( $ href ) { $ imgEl = clsTbsXmlLoc :: FindElement ( $ src , 'draw:image' , 0 ) ; $ img_href = ( $ imgEl ) ? $ imgEl -> GetAttLazy ( 'xlink:href' ) : false ; $ img_src = ( $ imgEl ) ? $ imgEl -> GetSrc ( 'xlink:href' ) : false ; $ titEl = clsTbsXmlLoc :: FindElement ( $ src , 'svg:title' , 0 ) ; $ title = ( $ titEl ) ? $ titEl -> GetInnerSrc ( ) : '' ; if ( substr ( $ href , 0 , 2 ) == './' ) $ href = substr ( $ href , 2 ) ; if ( is_string ( $ img_href ) && ( substr ( $ img_href , 0 , 2 ) == './' ) ) $ img_href = substr ( $ img_href , 2 ) ; $ this -> OpenDocCharts [ ] = array ( 'href' => $ href , 'title' => $ title , 'img_href' => $ img_href , 'img_src' => $ img_src , 'to_clear' => ( $ img_href !== false ) ) ; } } $ p = $ drEl -> PosEnd ; } }
12255	public function removeCompiler ( $ compiler ) { if ( ( $ idx = array_search ( $ compiler , $ this -> compilers ) ) !== false ) { unset ( $ this -> compilers [ $ idx ] ) ; $ this -> orderedCompilers = NULL ; } }
5634	protected function handle ( & $ test , $ filename ) { if ( preg_match ( $ this -> pattern , $ filename ) ) { parent :: handle ( $ test , $ filename ) ; } }
4862	private function createEnvelope ( JobInterface $ job , array $ options = [ ] ) { $ scheduled = $ this -> parseOptionsToDateTime ( $ options ) ; $ tried = isset ( $ options [ 'tried' ] ) ? ( int ) $ options [ 'tried' ] : null ; $ message = isset ( $ options [ 'message' ] ) ? $ options [ 'message' ] : null ; $ trace = isset ( $ options [ 'trace' ] ) ? $ options [ 'trace' ] : null ; $ envelope = [ 'queue' => $ this -> getName ( ) , 'status' => self :: STATUS_PENDING , 'tried' => $ tried , 'message' => $ message , 'trace' => $ trace , 'created' => $ this -> dateTimeToUTCDateTime ( $ this -> now ) , 'data' => $ this -> serializeJob ( $ job ) , 'scheduled' => $ this -> dateTimeToUTCDateTime ( $ scheduled ) , 'priority' => isset ( $ options [ 'priority' ] ) ? $ options [ 'priority' ] : self :: DEFAULT_PRIORITY , ] ; return $ envelope ; }
2754	public static function plainText ( $ value ) { $ element = render ( $ value ) ; $ element = strip_tags ( $ element ) ; $ element = html_entity_decode ( $ element , ENT_QUOTES ) ; return $ element ; }
12038	public function drop ( $ key ) { if ( $ this -> has ( $ key ) ) { unset ( $ _SESSION [ $ this -> root ] [ $ key ] ) ; return true ; } return false ; }
3962	private function createOrGetDefinition ( IMetaModelDataDefinition $ container ) { if ( $ container -> hasMetaModelDefinition ( ) ) { return $ container -> getMetaModelDefinition ( ) ; } $ container -> setMetaModelDefinition ( $ definition = new MetaModelDefinition ( ) ) ; return $ definition ; }
560	protected function buildOperatorCondition ( $ operator , $ condition , $ attribute ) { if ( isset ( $ this -> queryOperatorMap [ $ operator ] ) ) { $ operator = $ this -> queryOperatorMap [ $ operator ] ; } return [ $ operator , $ attribute , $ this -> filterAttributeValue ( $ attribute , $ condition ) ] ; }
3937	private function setOptions ( PropertyInterface $ property , $ propInfo ) { if ( null !== $ property -> getOptions ( ) || ! isset ( $ propInfo [ 'options' ] ) ) { return ; } $ property -> setOptions ( $ propInfo [ 'options' ] ) ; }
9842	public function createSealedJsonResponse ( int $ status , array $ arrayToJsonify , SealingPublicKey $ key , array $ headers = [ ] , string $ version = '1.1' ) : ResponseInterface { if ( empty ( $ headers [ 'Content-Type' ] ) ) { $ headers [ 'Content-Type' ] = 'application/json' ; } $ body = \ json_encode ( $ arrayToJsonify , JSON_PRETTY_PRINT ) ; if ( ! \ is_string ( $ body ) ) { throw new InvalidMessageException ( 'Cannot JSON-encode this message.' ) ; } return $ this -> createSealedResponse ( $ status , $ body , $ key , $ headers , $ version ) ; }
5541	public function setFrameFocus ( $ name ) { if ( is_integer ( $ this -> focus ) ) { if ( $ this -> frames [ $ this -> focus ] -> hasFrames ( ) ) { return $ this -> frames [ $ this -> focus ] -> setFrameFocus ( $ name ) ; } } if ( in_array ( $ name , array_keys ( $ this -> names ) ) ) { $ this -> focus = $ this -> names [ $ name ] ; return true ; } return false ; }
334	protected function getTableSequenceName ( $ tableName ) { $ sequenceNameSql = <<<'SQL'SELECT UD.REFERENCED_NAME AS SEQUENCE_NAMEFROM USER_DEPENDENCIES UD JOIN USER_TRIGGERS UT ON (UT.TRIGGER_NAME = UD.NAME)WHERE UT.TABLE_NAME = :tableName AND UD.TYPE = 'TRIGGER' AND UD.REFERENCED_TYPE = 'SEQUENCE'SQL ; $ sequenceName = $ this -> db -> createCommand ( $ sequenceNameSql , [ ':tableName' => $ tableName ] ) -> queryScalar ( ) ; return $ sequenceName === false ? null : $ sequenceName ; }
7313	public function setDate ( $ year , $ month , $ day ) { $ status = IAU :: Cal2jd ( ( int ) $ year , ( int ) $ month , ( int ) $ day , $ djm0 , $ djm ) ; $ this -> checkDate ( $ status ) ; $ this -> jd = $ djm0 + $ djm ; return $ this ; }
9807	private function readBlipJPEG ( ) { $ recInstance = ( 0xFFF0 & Xls :: getUInt2d ( $ this -> data , $ this -> pos ) ) >> 4 ; $ length = Xls :: getInt4d ( $ this -> data , $ this -> pos + 4 ) ; $ recordData = substr ( $ this -> data , $ this -> pos + 8 , $ length ) ; $ this -> pos += 8 + $ length ; $ pos = 0 ; $ rgbUid1 = substr ( $ recordData , 0 , 16 ) ; $ pos += 16 ; if ( in_array ( $ recInstance , [ 0x046B , 0x06E3 ] ) ) { $ rgbUid2 = substr ( $ recordData , 16 , 16 ) ; $ pos += 16 ; } $ tag = ord ( $ recordData [ $ pos ] ) ; $ pos += 1 ; $ data = substr ( $ recordData , $ pos ) ; $ blip = new Blip ( ) ; $ blip -> setData ( $ data ) ; $ this -> object -> setBlip ( $ blip ) ; }
8249	protected function needsPasswordRehash ( array $ userData ) { if ( $ this -> config [ "login" ] [ "passwordRehash" ] !== true ) { return false ; } if ( isset ( $ userData [ 'encoder' ] ) && $ userData [ 'encoder' ] !== $ this -> config [ "encoder" ] ) { return true ; } $ encoder = $ this -> getPasswordEncoder ( $ userData ) ; return $ encoder -> needsRehash ( $ userData [ 'pwhash' ] ) ; }
2122	public function add ( $ strFile , $ strVersion = null , $ strMedia = 'all' ) { $ strType = strrchr ( $ strFile , '.' ) ; if ( $ strType != self :: CSS && $ strType != self :: JS && $ strType != self :: SCSS && $ strType != self :: LESS ) { throw new \ InvalidArgumentException ( "Invalid file $strFile" ) ; } $ strMode = ( $ strType == self :: JS ) ? self :: JS : self :: CSS ; if ( $ this -> strMode === null ) { $ this -> strMode = $ strMode ; } elseif ( $ this -> strMode != $ strMode ) { throw new \ LogicException ( 'You cannot mix different file types. Create another Combiner object instead.' ) ; } if ( ! file_exists ( $ this -> strRootDir . '/' . $ strFile ) ) { if ( file_exists ( $ this -> strRootDir . '/' . $ this -> strWebDir . '/' . $ strFile ) ) { $ strFile = $ this -> strWebDir . '/' . $ strFile ; } else { return ; } } if ( isset ( $ this -> arrFiles [ $ strFile ] ) ) { return ; } if ( $ strVersion === null ) { $ strVersion = filemtime ( $ this -> strRootDir . '/' . $ strFile ) ; } $ arrFile = array ( 'name' => $ strFile , 'version' => $ strVersion , 'media' => $ strMedia , 'extension' => $ strType ) ; $ this -> arrFiles [ $ strFile ] = $ arrFile ; $ this -> strKey .= '-f' . $ strFile . '-v' . $ strVersion . '-m' . $ strMedia ; }
3137	public function parsesItemResponse ( RunnerServiceContext $ context , $ itemRef , $ response ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ session = $ context -> getTestSession ( ) ; $ currentItem = $ context -> getCurrentAssessmentItemRef ( ) ; $ responses = new State ( ) ; if ( $ currentItem === false ) { $ msg = "Trying to store item variables but the state of the test session is INITIAL or CLOSED.\n" ; $ msg .= "Session state value: " . $ session -> getState ( ) . "\n" ; $ msg .= "Session ID: " . $ session -> getSessionId ( ) . "\n" ; $ msg .= "JSON Payload: " . mb_substr ( json_encode ( $ response ) , 0 , 1000 ) ; \ common_Logger :: e ( $ msg ) ; } $ filler = new \ taoQtiCommon_helpers_PciVariableFiller ( $ currentItem , $ this -> getServiceManager ( ) -> get ( QtiFlysystemFileManager :: SERVICE_ID ) ) ; if ( is_array ( $ response ) ) { foreach ( $ response as $ id => $ responseData ) { try { $ var = $ filler -> fill ( $ id , $ responseData ) ; if ( \ taoQtiCommon_helpers_Utils :: isQtiFilePlaceHolder ( $ var ) === false ) { $ responses -> setVariable ( $ var ) ; } } catch ( \ OutOfRangeException $ e ) { \ common_Logger :: d ( "Could not convert client-side value for variable '${id}'." ) ; } catch ( \ OutOfBoundsException $ e ) { \ common_Logger :: d ( "Could not find variable with identifier '${id}' in current item." ) ; } } } else { \ common_Logger :: e ( 'Invalid json payload' ) ; } return $ responses ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'storeItemResponse' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } }
5606	public function paintGroupStart ( $ group , $ size ) { $ this -> group = self :: escapeVal ( $ group ) ; if ( $ this -> cc ) { if ( extension_loaded ( 'xdebug' ) ) { xdebug_start_code_coverage ( XDEBUG_CC_UNUSED | XDEBUG_CC_DEAD_CODE ) ; } } }
12109	public function renamePage ( $ id , $ newName ) { $ this -> pages [ $ newName ] = $ this -> getPage ( $ id ) ; unset ( $ this -> pages [ $ id ] ) ; $ this -> persist ( ) ; }
9900	private function advance ( ) { $ i = $ this -> currentCharacter ; $ formula_length = strlen ( $ this -> formula ) ; if ( $ i < $ formula_length ) { while ( $ this -> formula [ $ i ] == ' ' ) { ++ $ i ; } if ( $ i < ( $ formula_length - 1 ) ) { $ this -> lookAhead = $ this -> formula [ $ i + 1 ] ; } $ token = '' ; } while ( $ i < $ formula_length ) { $ token .= $ this -> formula [ $ i ] ; if ( $ i < ( $ formula_length - 1 ) ) { $ this -> lookAhead = $ this -> formula [ $ i + 1 ] ; } else { $ this -> lookAhead = '' ; } if ( $ this -> match ( $ token ) != '' ) { $ this -> currentCharacter = $ i + 1 ; $ this -> currentToken = $ token ; return 1 ; } if ( $ i < ( $ formula_length - 2 ) ) { $ this -> lookAhead = $ this -> formula [ $ i + 2 ] ; } else { $ this -> lookAhead = '' ; } ++ $ i ; } }
3998	protected function getAttribute ( $ metaModelIdOrName , $ intDataId , $ strAttributeName , $ strOutput = 'raw' ) { $ objMM = $ this -> loadMetaModel ( $ metaModelIdOrName ) ; if ( null === $ objMM ) { return false ; } if ( empty ( $ strOutput ) ) { $ strOutput = 'raw' ; } $ objMetaModelItem = $ objMM -> findById ( $ intDataId ) ; if ( null === $ objMetaModelItem ) { throw new \ RuntimeException ( 'MetaModel item not found: ' . $ intDataId ) ; } $ arrAttr = $ objMetaModelItem -> parseAttribute ( $ strAttributeName ) ; return $ arrAttr [ $ strOutput ] ; }
9865	private function writeHyperlinks ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { $ hyperlinkCollection = $ pSheet -> getHyperlinkCollection ( ) ; $ relationId = 1 ; if ( ! empty ( $ hyperlinkCollection ) ) { $ objWriter -> startElement ( 'hyperlinks' ) ; foreach ( $ hyperlinkCollection as $ coordinate => $ hyperlink ) { $ objWriter -> startElement ( 'hyperlink' ) ; $ objWriter -> writeAttribute ( 'ref' , $ coordinate ) ; if ( ! $ hyperlink -> isInternal ( ) ) { $ objWriter -> writeAttribute ( 'r:id' , 'rId_hyperlink_' . $ relationId ) ; ++ $ relationId ; } else { $ objWriter -> writeAttribute ( 'location' , str_replace ( 'sheet://' , '' , $ hyperlink -> getUrl ( ) ) ) ; } if ( $ hyperlink -> getTooltip ( ) != '' ) { $ objWriter -> writeAttribute ( 'tooltip' , $ hyperlink -> getTooltip ( ) ) ; } $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; } }
3275	public function delete ( string $ key ) { Validation :: validateKey ( $ key ) ; if ( $ this -> get ( $ key ) !== false ) { $ this -> replace ( $ key , false ) ; } }
3492	public function withHeaders ( array $ headers ) : Request { $ cloned = clone $ this ; foreach ( $ headers as $ name => $ value ) { $ cloned = $ cloned -> withHeader ( $ name , $ value ) ; } return $ cloned ; }
6907	public function removeExtraRecipient ( Recipient $ recipient ) { if ( $ this -> extraRecipients -> contains ( $ recipient ) ) { $ this -> extraRecipients -> removeElement ( $ recipient ) ; } return $ this ; }
739	protected function saveAssignments ( ) { $ assignmentData = [ ] ; foreach ( $ this -> assignments as $ userId => $ assignments ) { foreach ( $ assignments as $ name => $ assignment ) { $ assignmentData [ $ userId ] [ ] = $ assignment -> roleName ; } } $ this -> saveToFile ( $ assignmentData , $ this -> assignmentFile ) ; }
12233	public function moveTo ( SimpleXMLElement $ dst ) { return simplexml_import_dom ( dom_import_simplexml ( $ dst ) , get_class ( $ this ) ) -> appendChild ( $ this -> removeSelf ( ) ) ; }
7257	public function urlAllowed ( $ url ) { if ( $ this -> _viewAuth ) { return $ this -> _viewAuth [ 'AuthActions' ] -> urlAllowed ( $ this -> user ( ) , $ url ) ; } return false ; }
12678	public function toJSON ( $ pretty = false ) { if ( $ pretty ) { return json_encode ( $ this -> scope -> results , JSON_PRETTY_PRINT ) ; } return json_encode ( $ this -> scope -> results ) ; }
8313	protected function beginPasswordReset ( ) { if ( ! $ this -> config [ "enabled" ] ) { return ; } $ this -> picoAuth -> addAllowed ( "password_reset" ) ; $ this -> picoAuth -> setRequestFile ( $ this -> picoAuth -> getPluginPath ( ) . '/content/pwbeginreset.md' ) ; if ( count ( $ this -> session -> getFlash ( '_pwresetsent' ) ) ) { $ this -> picoAuth -> addOutput ( "resetSent" , true ) ; return ; } $ post = $ this -> httpRequest -> request ; if ( $ post -> has ( "reset_email" ) ) { if ( ! $ this -> picoAuth -> isValidCSRF ( $ post -> get ( "csrf_token" ) ) ) { $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } $ email = trim ( $ post -> get ( "reset_email" ) ) ; if ( ! filter_var ( $ email , FILTER_VALIDATE_EMAIL ) ) { $ this -> session -> addFlash ( "error" , "Email address does not have a valid format." ) ; $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } if ( ! $ this -> limit -> action ( "passwordReset" , true , array ( "email" => $ email ) ) ) { $ this -> session -> addFlash ( "error" , $ this -> limit -> getError ( ) ) ; $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } if ( $ userData = $ this -> storage -> getUserByEmail ( $ email ) ) { $ this -> sendResetMail ( $ userData ) ; } $ this -> session -> addFlash ( "_pwresetsent" , true ) ; $ this -> session -> addFlash ( "success" , "Reset link sent via email." ) ; $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } }
8627	public function setGetCompetitivePricingForSKUResult ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GetCompetitivePricingForSKUResult' ] [ 'FieldValue' ] = $ value ; return $ this ; }
8710	public function where ( $ column , $ operator = null , $ value = null , $ boolean = 'and' ) { if ( is_array ( $ column ) ) { return $ this -> addArrayOfWheres ( $ column , $ boolean ) ; } if ( in_array ( $ column , $ this -> model -> translatableAttributes ( ) ) ) { return $ this -> whereTranslated ( $ column , $ operator , $ value , $ boolean ) ; } return parent :: where ( $ column , $ operator , $ value , $ boolean ) ; }
74	public function requestToken ( $ originUrl , $ consumerKey , $ consumerSecret ) { if ( ! empty ( $ this -> token ) || $ this -> getTokenFromConfig ( $ originUrl ) ) { return $ this -> token [ 'access_token' ] ; } $ this -> io -> setAuthentication ( $ originUrl , $ consumerKey , $ consumerSecret ) ; if ( ! $ this -> requestAccessToken ( $ originUrl ) ) { return '' ; } $ this -> storeInAuthConfig ( $ originUrl , $ consumerKey , $ consumerSecret ) ; return $ this -> token [ 'access_token' ] ; }
6237	private static function getOptions ( ) { return [ '1/6' => Craft :: t ( 'width-fieldtype' , '1/6' ) , '1/5' => Craft :: t ( 'width-fieldtype' , '1/5' ) , '1/4' => Craft :: t ( 'width-fieldtype' , '1/4' ) , '1/3' => Craft :: t ( 'width-fieldtype' , '1/3' ) , '2/5' => Craft :: t ( 'width-fieldtype' , '2/5' ) , '1/2' => Craft :: t ( 'width-fieldtype' , '1/2' ) , '3/5' => Craft :: t ( 'width-fieldtype' , '3/5' ) , '2/3' => Craft :: t ( 'width-fieldtype' , '2/3' ) , '3/4' => Craft :: t ( 'width-fieldtype' , '3/4' ) , '4/5' => Craft :: t ( 'width-fieldtype' , '4/5' ) , '5/6' => Craft :: t ( 'width-fieldtype' , '5/6' ) , 'full' => Craft :: t ( 'width-fieldtype' , 'Full' ) , ] ; }
7762	public function getContext ( $ exposedClassName ) { $ classes = $ this -> metadata -> getAllMetadata ( ) ; $ metadata = null ; foreach ( $ classes as $ class ) { if ( $ class -> getExposeAs ( ) === $ exposedClassName ) { $ metadata = $ class ; break ; } } if ( null === $ metadata ) { return null ; } $ context = array ( 'hydra' => 'http://www.w3.org/ns/hydra/core#' , 'vocab' => $ this -> vocabUrl . '#' ) ; $ context [ $ exposedClassName ] = ( $ metadata -> isExternalReference ( ) ) ? $ metadata -> getIri ( ) : 'vocab:' . $ metadata -> getIri ( ) ; foreach ( $ metadata -> getProperties ( ) as $ property ) { if ( 0 === strncmp ( $ property -> getExposeAs ( ) , '@' , 1 ) ) { continue ; } $ termDefinition = ( $ property -> isExternalReference ( ) ) ? $ property -> getIri ( ) : 'vocab:' . $ property -> getIri ( ) ; if ( $ property -> getRoute ( ) ) { $ termDefinition = array ( '@id' => $ termDefinition , '@type' => '@id' ) ; } elseif ( $ this -> hasNormalizer ( $ property -> getType ( ) ) ) { $ normalizer = $ this -> getNormalizer ( $ property -> getType ( ) ) ; $ termDefinition = array ( '@id' => $ termDefinition , '@type' => $ normalizer -> getTypeIri ( ) ) ; } $ context [ $ property -> getExposeAs ( ) ] = $ termDefinition ; } return array ( '@context' => $ context ) ; }
9818	private function polynomialRegression ( $ order , $ yValues , $ xValues ) { $ x_sum = array_sum ( $ xValues ) ; $ y_sum = array_sum ( $ yValues ) ; $ xx_sum = $ xy_sum = 0 ; for ( $ i = 0 ; $ i < $ this -> valueCount ; ++ $ i ) { $ xy_sum += $ xValues [ $ i ] * $ yValues [ $ i ] ; $ xx_sum += $ xValues [ $ i ] * $ xValues [ $ i ] ; $ yy_sum += $ yValues [ $ i ] * $ yValues [ $ i ] ; } for ( $ i = 0 ; $ i < $ this -> valueCount ; ++ $ i ) { for ( $ j = 0 ; $ j <= $ order ; ++ $ j ) { $ A [ $ i ] [ $ j ] = pow ( $ xValues [ $ i ] , $ j ) ; } } for ( $ i = 0 ; $ i < $ this -> valueCount ; ++ $ i ) { $ B [ $ i ] = [ $ yValues [ $ i ] ] ; } $ matrixA = new Matrix ( $ A ) ; $ matrixB = new Matrix ( $ B ) ; $ C = $ matrixA -> solve ( $ matrixB ) ; $ coefficients = [ ] ; for ( $ i = 0 ; $ i < $ C -> getRowDimension ( ) ; ++ $ i ) { $ r = $ C -> get ( $ i , 0 ) ; if ( abs ( $ r ) <= pow ( 10 , - 9 ) ) { $ r = 0 ; } $ coefficients [ ] = $ r ; } $ this -> intersect = array_shift ( $ coefficients ) ; $ this -> slope = $ coefficients ; $ this -> calculateGoodnessOfFit ( $ x_sum , $ y_sum , $ xx_sum , $ yy_sum , $ xy_sum ) ; foreach ( $ this -> xValues as $ xKey => $ xValue ) { $ this -> yBestFitValues [ $ xKey ] = $ this -> getValueOfYForX ( $ xValue ) ; } }
4466	private function normalizeCommandArgs ( string $ command , array $ args ) : array { $ arguments = array_merge ( [ $ command , microtime ( true ) ] , $ args ) ; array_unshift ( $ arguments , 0 ) ; array_unshift ( $ arguments , $ this -> sha ) ; return $ arguments ; }
9507	public function show ( Log $ log ) { $ this -> authorize ( LogViewerPolicy :: PERMISSION_SHOW ) ; $ levels = $ this -> logViewer -> levelsNames ( ) ; $ entries = $ log -> entries ( $ level = 'all' ) -> paginate ( $ this -> perPage ) ; $ this -> addBreadcrumbRoute ( trans ( 'foundation::log-viewer.titles.logs-list' ) , 'admin::foundation.system.log-viewer.logs.list' ) ; $ this -> setTitle ( $ title = "Log : {$log->date}" ) ; $ this -> addBreadcrumb ( $ title ) ; return $ this -> view ( 'admin.system.log-viewer.show' , compact ( 'log' , 'levels' , 'level' , 'search' , 'entries' ) ) ; }
4879	public function getPrettySize ( ) { $ size = $ this -> getLength ( ) ; if ( $ size >= 1073741824 ) { return round ( $ size / 1073741824 , 2 ) . ' GB' ; } if ( $ size >= 1048576 ) { return round ( $ size / 1048576 , 2 ) . ' MB' ; } if ( $ size >= 1024 ) { return round ( $ size / 1024 , 2 ) . ' kB' ; } return ( string ) $ size ; }
4806	protected function processMemberVar ( File $ phpcsFile , $ stackPtr ) { $ tokens = $ phpcsFile -> getTokens ( ) ; $ commentToken = [ T_COMMENT , T_DOC_COMMENT_CLOSE_TAG , ] ; $ commentEnd = $ phpcsFile -> findPrevious ( $ commentToken , $ stackPtr ) ; $ commentStart = $ tokens [ $ commentEnd ] [ 'comment_opener' ] ; if ( $ tokens [ $ commentEnd ] [ 'line' ] === $ tokens [ $ commentStart ] [ 'line' ] ) { $ phpcsFile -> addError ( 'Member variable comment should not be inline' , $ stackPtr , static :: ERROR_CODE ) ; } }
5974	public function filters ( ) { if ( ! $ this -> filters instanceof FiltersController ) { $ this -> filters = new FiltersController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> filters -> setLogger ( $ this -> logger ) ; } return $ this -> filters ; }
6802	public function installTaxGroups ( $ codes = [ 'US' ] ) { $ codes = ( array ) $ codes ; if ( empty ( $ codes ) ) { return ; } $ taxGroupRepository = $ this -> manager -> getRepository ( TaxGroup :: class ) ; $ taxRepository = $ this -> manager -> getRepository ( Tax :: class ) ; foreach ( $ codes as $ code ) { $ path = __DIR__ . '/data/' . $ code . '_tax_groups.yml' ; if ( ! ( file_exists ( $ path ) && is_readable ( $ path ) ) ) { call_user_func ( $ this -> log , 'Tax groups data' , 'not found' ) ; continue ; } $ data = Yaml :: parse ( file_get_contents ( $ path ) ) ; if ( ! is_array ( $ data ) || empty ( $ data ) ) { continue ; } foreach ( $ data as $ datum ) { $ name = $ datum [ 'name' ] ; $ result = 'already exists' ; if ( $ datum [ 'default' ] ) { $ taxGroup = $ this -> manager -> getRepository ( TaxGroup :: class ) -> findOneBy ( [ 'default' => true ] ) ; if ( null !== $ taxGroup ) { call_user_func ( $ this -> log , $ name , 'skipped' ) ; continue ; } } if ( null === $ taxGroupRepository -> findOneBy ( [ 'name' => $ name ] ) ) { $ taxGroup = new TaxGroup ( ) ; $ taxGroup -> setName ( $ name ) -> setDefault ( $ datum [ 'default' ] ) ; if ( ! empty ( $ taxNames = $ datum [ 'taxes' ] ) ) { $ taxGroup -> setTaxes ( $ taxRepository -> findBy ( [ 'name' => $ taxNames ] ) ) ; } $ this -> manager -> persist ( $ taxGroup ) ; $ result = 'done' ; } call_user_func ( $ this -> log , $ name , $ result ) ; } } $ this -> manager -> flush ( ) ; }
10697	public function send ( ResponseInterface $ response ) : ResponseInterface { $ response -> getBody ( ) -> write ( json_encode ( $ this -> toArray ( ) ) ) ; return $ response -> withHeader ( 'Content-Type' , self :: MIME_TYPE_JSON ) ; }
11183	public function getActions ( ) { if ( $ this -> useCache ( ) ) { if ( $ this -> getExtCache ( ) -> isCached ( ) ) { return $ this -> getExtCache ( ) -> getActions ( ) ; } } $ actions = $ this -> generateActions ( ) ; if ( $ this -> useCache ( ) ) { $ this -> getExtCache ( ) -> cacheActions ( $ actions ) ; } return $ actions ; }
12477	private function getTransformation ( ) { $ transforms = [ ] ; foreach ( $ this -> fields as $ field => $ extra ) { if ( is_int ( $ field ) ) { $ transforms [ $ extra ] = $ extra ; continue ; } $ transform = ( key_exists ( 'transform' , $ extra ) ) ? $ extra [ 'transform' ] : $ field ; if ( $ transform === false ) { continue ; } $ transforms [ $ field ] = $ transform ; } return $ transforms ; }
7359	public static function getDefaultPriceMapLoader ( ) { if ( null === self :: $ defaultPriceMapLoader ) { $ currencyDir = realpath ( __DIR__ . '/../../../data/prices' ) ; self :: $ defaultPriceMapLoader = new PhpFileLoader ( array ( $ currencyDir ) ) ; } return self :: $ defaultPriceMapLoader ; }
2189	public function unregister ( Model $ objModel ) { $ intObjectId = spl_object_hash ( $ objModel ) ; if ( ! isset ( $ this -> arrIdentities [ $ intObjectId ] ) ) { return ; } $ strTable = $ objModel -> getTable ( ) ; $ strPk = $ objModel -> getPk ( ) ; $ intPk = $ objModel -> $ strPk ; unset ( $ this -> arrIdentities [ $ intObjectId ] ) ; unset ( $ this -> arrRegistry [ $ strTable ] [ $ intPk ] ) ; $ objModel -> onUnregister ( $ this ) ; }
7361	protected function updateWeightTotal ( SaleInterface $ sale ) { $ weightTotal = $ this -> weightCalculator -> calculateSale ( $ sale ) ; if ( $ sale -> getWeightTotal ( ) != $ weightTotal ) { $ sale -> setWeightTotal ( $ weightTotal ) ; return true ; } return false ; }
12113	public function getUnmappedForeignKeys ( ) { $ mappedForeign = ArrayHelper :: getColumn ( $ this -> _map , 'foreignKey' ) ; $ u = array_diff ( array_keys ( $ this -> foreignModel -> meta -> schema -> columns ) , $ mappedForeign ) ; unset ( $ u [ $ this -> foreignPrimaryKeyName ] ) ; return $ u ; }
6218	public function getPeriodStart ( ) { if ( is_null ( $ this -> parsedPeriodStart ) ) { $ this -> parsedPeriodStart = strtotime ( $ this -> periodStart ) ; } return $ this -> parsedPeriodStart ; }
4886	public function plugin ( $ plugin , $ options = null ) { $ renderer = $ this -> getView ( ) ; if ( ! method_exists ( $ renderer , 'getHelperPluginManager' ) ) { return true === $ options ? false : new HelperProxy ( false ) ; } $ manager = $ renderer -> getHelperPluginManager ( ) ; $ hasPlugin = $ manager -> has ( $ plugin ) ; if ( true === $ options ) { return $ hasPlugin ; } if ( $ hasPlugin ) { $ pluginInstance = $ manager -> get ( $ plugin , $ options ) ; } else { $ pluginInstance = false ; } return new HelperProxy ( $ pluginInstance ) ; }
686	protected function sortModels ( $ models , $ sort ) { $ orders = $ sort -> getOrders ( ) ; if ( ! empty ( $ orders ) ) { ArrayHelper :: multisort ( $ models , array_keys ( $ orders ) , array_values ( $ orders ) ) ; } return $ models ; }
3699	private function parseListing ( ) { $ listing = $ this -> definition -> getListingConfig ( ) ; if ( null === $ listing -> getRootLabel ( ) ) { $ listing -> setRootLabel ( $ this -> metaModel -> get ( 'name' ) ) ; } if ( null === $ listing -> getRootIcon ( ) ) { $ listing -> setRootIcon ( $ this -> iconBuilder -> getBackendIcon ( $ this -> inputScreen [ 'meta' ] [ 'backendicon' ] ) ) ; } $ this -> parseListSorting ( $ listing ) ; $ this -> parseListLabel ( $ listing ) ; $ listing -> setShowColumns ( ( bool ) $ this -> inputScreen [ 'meta' ] [ 'showColumns' ] ) ; }
448	protected function renderPageButtons ( ) { $ pageCount = $ this -> pagination -> getPageCount ( ) ; if ( $ pageCount < 2 && $ this -> hideOnSinglePage ) { return '' ; } $ buttons = [ ] ; $ currentPage = $ this -> pagination -> getPage ( ) ; $ firstPageLabel = $ this -> firstPageLabel === true ? '1' : $ this -> firstPageLabel ; if ( $ firstPageLabel !== false ) { $ buttons [ ] = $ this -> renderPageButton ( $ firstPageLabel , 0 , $ this -> firstPageCssClass , $ currentPage <= 0 , false ) ; } if ( $ this -> prevPageLabel !== false ) { if ( ( $ page = $ currentPage - 1 ) < 0 ) { $ page = 0 ; } $ buttons [ ] = $ this -> renderPageButton ( $ this -> prevPageLabel , $ page , $ this -> prevPageCssClass , $ currentPage <= 0 , false ) ; } list ( $ beginPage , $ endPage ) = $ this -> getPageRange ( ) ; for ( $ i = $ beginPage ; $ i <= $ endPage ; ++ $ i ) { $ buttons [ ] = $ this -> renderPageButton ( $ i + 1 , $ i , null , $ this -> disableCurrentPageButton && $ i == $ currentPage , $ i == $ currentPage ) ; } if ( $ this -> nextPageLabel !== false ) { if ( ( $ page = $ currentPage + 1 ) >= $ pageCount - 1 ) { $ page = $ pageCount - 1 ; } $ buttons [ ] = $ this -> renderPageButton ( $ this -> nextPageLabel , $ page , $ this -> nextPageCssClass , $ currentPage >= $ pageCount - 1 , false ) ; } $ lastPageLabel = $ this -> lastPageLabel === true ? $ pageCount : $ this -> lastPageLabel ; if ( $ lastPageLabel !== false ) { $ buttons [ ] = $ this -> renderPageButton ( $ lastPageLabel , $ pageCount - 1 , $ this -> lastPageCssClass , $ currentPage >= $ pageCount - 1 , false ) ; } $ options = $ this -> options ; $ tag = ArrayHelper :: remove ( $ options , 'tag' , 'ul' ) ; return Html :: tag ( $ tag , implode ( "\n" , $ buttons ) , $ options ) ; }
9625	public function getById ( $ characterId ) { try { $ result = $ this -> client -> get ( $ this -> slug . '/' . $ characterId ) ; } catch ( RequestException $ e ) { $ return [ 'request' ] = $ e -> getRequest ( ) . "\n" ; if ( $ e -> hasResponse ( ) ) { return $ return [ 'response' ] = $ e -> getResponse ( ) . "\n" ; } } return $ result -> json ( ) ; }
4660	public function getConsoleLogger ( $ verbose = false ) { $ logger = new Logger ( "standalone-logger" ) ; $ handler = new StreamHandler ( "php://stdout" , $ verbose ? Logger :: DEBUG : Logger :: INFO ) ; $ simpleFormatter = new SimpleFormatter ( ) ; $ handler -> setFormatter ( $ simpleFormatter ) ; $ logger -> pushHandler ( $ handler ) ; if ( ! $ verbose ) { $ stdErrHandler = new StreamHandler ( "php://stderr" , Logger :: DEBUG ) ; $ fingerCrossedHandler = new FingersCrossedHandler ( $ stdErrHandler , new ErrorLevelActivationStrategy ( Logger :: ERROR ) , 10 ) ; $ logger -> pushHandler ( $ fingerCrossedHandler ) ; $ stdErrHandler -> setFormatter ( $ simpleFormatter ) ; } return $ logger ; }
3502	private function initializeCurlResource ( ) : void { if ( ! $ this -> resource ) { $ this -> resource = curl_init ( ) ; curl_setopt ( $ this -> resource , CURLOPT_RETURNTRANSFER , 1 ) ; curl_setopt ( $ this -> resource , CURLOPT_POST , 1 ) ; curl_setopt ( $ this -> resource , CURLOPT_HTTP_VERSION , 3 ) ; } }
12150	public function checkReservedCodes ( ) { $ reserved = $ this -> getReservedCodes ( ) ; foreach ( $ reserved as $ factoryClass => $ reservedForFactory ) { foreach ( $ reserved as $ checkInFactory => $ reservedInCheckFactory ) { if ( $ checkInFactory == $ factoryClass ) { continue ; } if ( $ reservedInCheckFactory [ 0 ] >= $ reservedForFactory [ 0 ] && $ reservedInCheckFactory [ 0 ] <= $ reservedForFactory [ 1 ] ) { throw new \ RuntimeException ( sprintf ( 'The reserved codes for factory "%s" [%d - %d] superimposed on "%s" factory [%d - %d].' , $ checkInFactory , $ reservedInCheckFactory [ 0 ] , $ reservedInCheckFactory [ 1 ] , $ factoryClass , $ reservedForFactory [ 0 ] , $ reservedForFactory [ 1 ] ) ) ; } if ( $ reservedInCheckFactory [ 1 ] >= $ reservedForFactory [ 0 ] && $ reservedInCheckFactory [ 1 ] <= $ reservedForFactory [ 1 ] ) { throw new \ RuntimeException ( sprintf ( 'The reserved codes for factory "%s" [%d - %d] superimposed on "%s" factory [%d - %d].' , $ checkInFactory , $ reservedInCheckFactory [ 0 ] , $ reservedInCheckFactory [ 1 ] , $ factoryClass , $ reservedForFactory [ 0 ] , $ reservedForFactory [ 1 ] ) ) ; } } } }
8459	public function getVersion ( ) { if ( empty ( $ this -> drushVersion ) ) { $ isPrinted = $ this -> isPrinted ; $ this -> isPrinted = false ; $ result = $ this -> executeCommand ( $ this -> executable . ' version' ) ; $ output = $ result -> getMessage ( ) ; $ this -> drushVersion = 'unknown' ; if ( preg_match ( '#[0-9.]+#' , $ output , $ matches ) ) { $ this -> drushVersion = $ matches [ 0 ] ; } $ this -> isPrinted = $ isPrinted ; } return $ this -> drushVersion ; }
1188	public function validatorClosure ( ) { return function ( $ attribute , $ value , $ parameters , BaseValidator $ validator ) { $ remoteValidator = new Validator ( $ validator ) ; $ remoteValidator -> validate ( $ value , $ parameters ) ; return $ attribute ; } ; }
12129	public function failed ( $ fail = true ) { if ( ! func_num_args ( ) ) { return $ this -> _failed ; } $ this -> _failed = $ fail ; return $ this ; }
1082	private function skip ( $ kind ) { $ match = $ this -> lexer -> token -> kind === $ kind ; if ( $ match ) { $ this -> lexer -> advance ( ) ; } return $ match ; }
11656	public function getShortName ( ) { preg_match ( '/Widget([A-Za-z]+)\\\Module/' , get_class ( $ this ) , $ matches ) ; if ( ! isset ( $ matches [ 1 ] ) ) { throw new Exception ( get_class ( $ this ) . " is not set up correctly!" ) ; } return $ matches [ 1 ] ; }
4139	protected function getOauthParameters ( ) { $ time = time ( ) ; return array ( 'oauth_consumer_key' => $ this -> getConsumerKey ( ) , 'oauth_nonce' => trim ( base64_encode ( $ time ) , '=' ) , 'oauth_signature_method' => 'HMAC-SHA1' , 'oauth_timestamp' => $ time , 'oauth_token' => $ this -> getAccessToken ( ) , 'oauth_version' => '1.0' ) ; }
3437	public function refreshFields ( ) { if ( $ this -> id === null ) { $ this -> original = [ ] ; return $ this -> fields = [ ] ; } $ sectionsBackup = isset ( $ this -> fields [ 'IBLOCK_SECTION' ] ) ? $ this -> fields [ 'IBLOCK_SECTION' ] : null ; $ this -> fields = static :: query ( ) -> getById ( $ this -> id ) -> fields ; if ( ! empty ( $ sectionsBackup ) ) { $ this -> fields [ 'IBLOCK_SECTION' ] = $ sectionsBackup ; } $ this -> fieldsAreFetched = true ; $ this -> original = $ this -> fields ; return $ this -> fields ; }
10116	private function writeHcenter ( ) { $ record = 0x0083 ; $ length = 0x0002 ; $ fHCenter = $ this -> phpSheet -> getPageSetup ( ) -> getHorizontalCentered ( ) ? 1 : 0 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ fHCenter ) ; $ this -> append ( $ header . $ data ) ; }
857	public function overrideRange ( $ indexStart , $ indexEnd , $ items ) { $ oldCode = $ this -> generatePartialCode ( $ indexStart , $ indexEnd ) ; $ newCode = '' ; foreach ( $ items as $ item ) { $ newCode .= $ item -> getContent ( ) ; } if ( $ oldCode === $ newCode ) { return ; } $ indexToChange = $ indexEnd - $ indexStart + 1 ; $ itemsCount = \ count ( $ items ) ; if ( $ itemsCount > $ indexToChange ) { $ placeholders = [ ] ; while ( $ itemsCount > $ indexToChange ) { $ placeholders [ ] = new Token ( '__PLACEHOLDER__' ) ; ++ $ indexToChange ; } $ this -> insertAt ( $ indexEnd + 1 , $ placeholders ) ; } foreach ( $ items as $ itemIndex => $ item ) { $ this [ $ indexStart + $ itemIndex ] = $ item ; } if ( $ itemsCount < $ indexToChange ) { $ this -> clearRange ( $ indexStart + $ itemsCount , $ indexEnd ) ; } }
3205	protected function get_docblock_tags ( $ comment_opener ) { $ tags = array ( ) ; $ opener = $ this -> tokens [ $ comment_opener ] ; if ( ! isset ( $ opener [ 'comment_tags' ] ) ) { return $ tags ; } $ closer = null ; if ( isset ( $ opener [ 'comment_closer' ] ) ) { $ closer = $ opener [ 'comment_closer' ] ; } $ tag_count = count ( $ opener [ 'comment_tags' ] ) ; for ( $ i = 0 ; $ i < $ tag_count ; $ i ++ ) { $ tag_token = $ opener [ 'comment_tags' ] [ $ i ] ; $ tag = trim ( $ this -> tokens [ $ tag_token ] [ 'content' ] , '@' ) ; $ search_end = $ closer ; if ( ( $ i + 1 ) < $ tag_count ) { $ search_end = $ opener [ 'comment_tags' ] [ ( $ i + 1 ) ] ; } $ value_token = $ this -> phpcsFile -> findNext ( T_DOC_COMMENT_STRING , ( $ tag_token + 1 ) , $ search_end ) ; $ tags [ $ tag ] = trim ( $ this -> tokens [ $ value_token ] [ 'content' ] ) ; unset ( $ tag_token , $ tag , $ search_end , $ value ) ; } return $ tags ; }
6865	protected function updateCustomerBalance ( InvoiceInterface $ invoice ) { if ( ! InvoiceTypes :: isCredit ( $ invoice ) ) { return ; } $ sale = $ this -> getSaleFromInvoice ( $ invoice ) ; if ( null === $ customer = $ sale -> getCustomer ( ) ) { return ; } $ methodCs = $ this -> persistenceHelper -> getChangeSet ( $ invoice , 'paymentMethod' ) ; $ amountCs = $ this -> persistenceHelper -> getChangeSet ( $ invoice , 'grandTotal' ) ; if ( $ this -> persistenceHelper -> isScheduledForRemove ( $ invoice ) ) { $ method = empty ( $ methodCs ) ? $ invoice -> getPaymentMethod ( ) : $ methodCs [ 0 ] ; $ amount = empty ( $ amountCs ) ? $ invoice -> getGrandTotal ( ) : $ amountCs [ 0 ] ; if ( $ method && $ method -> isCredit ( ) && 0 != Money :: compare ( $ amount , 0 , $ invoice -> getCurrency ( ) ) ) { $ this -> customerUpdater -> updateCreditBalance ( $ customer , - $ amount , true ) ; } return ; } if ( empty ( $ methodCs ) && empty ( $ amountCs ) ) { return ; } if ( ! empty ( $ methodCs ) && null !== $ method = $ methodCs [ 0 ] ) { $ amount = empty ( $ amountCs ) ? $ invoice -> getGrandTotal ( ) : $ amountCs [ 0 ] ; if ( $ method -> isCredit ( ) && 0 != Money :: compare ( $ amount , 0 , $ invoice -> getCurrency ( ) ) ) { $ this -> customerUpdater -> updateCreditBalance ( $ customer , - $ amount , true ) ; } } if ( empty ( $ methodCs ) ) { $ method = $ invoice -> getPaymentMethod ( ) ; $ amount = empty ( $ amountCs ) ? $ invoice -> getGrandTotal ( ) : $ amountCs [ 1 ] - $ amountCs [ 0 ] ; } else { $ method = $ methodCs [ 1 ] ; $ amount = empty ( $ amountCs ) ? $ invoice -> getGrandTotal ( ) : $ amountCs [ 1 ] ; } if ( $ method && $ method -> isCredit ( ) && 0 != Money :: compare ( $ amount , 0 , $ invoice -> getCurrency ( ) ) ) { $ this -> customerUpdater -> updateCreditBalance ( $ customer , $ amount , true ) ; } }
4996	public function getColumnMap ( ) { $ map = $ this -> getOption ( 'column_map' ) ; if ( null === $ map ) { $ map = [ ] ; foreach ( $ this as $ element ) { $ col = $ element -> getOption ( 'span' ) ; if ( null !== $ col ) { $ map [ $ element -> getName ( ) ] = $ col ; } } $ this -> setOption ( 'column_map' , $ map ) ; } return $ map ; }
7071	protected function updateMessage ( TicketMessageInterface $ message ) { $ message -> setUpdatedAt ( new \ DateTime ( ) ) ; $ this -> persistenceHelper -> persistAndRecompute ( $ message , true ) ; }
3450	public function getDirectChildren ( array $ filter = [ ] ) { return static :: query ( ) -> filter ( $ filter ) -> filter ( [ 'SECTION_ID' => $ this -> id ] ) -> select ( 'ID' ) -> getList ( ) -> transform ( function ( $ section ) { return ( int ) $ section [ 'ID' ] ; } ) -> all ( ) ; }
75	public function seek ( $ offset ) { $ this -> rewind ( ) ; for ( $ i = 0 ; $ i < $ offset ; $ i ++ , $ this -> next ( ) ) ; }
11609	public function actionDisconnect ( $ id ) { $ account = $ this -> finder -> findAccountById ( $ id ) ; if ( $ account === null ) { throw new NotFoundHttpException ; } if ( $ account -> user_id != \ Yii :: $ app -> user -> id ) { throw new ForbiddenHttpException ; } $ account -> delete ( ) ; return $ this -> redirect ( [ 'networks' ] ) ; }
4387	public function getConfigFE ( \ Aimeos \ MShop \ Order \ Item \ Base \ Iface $ basket ) { $ list = [ ] ; $ feconfig = $ this -> feConfig ; try { $ code = $ this -> getServiceItem ( ) -> getCode ( ) ; $ service = $ basket -> getService ( \ Aimeos \ MShop \ Order \ Item \ Base \ Service \ Base :: TYPE_PAYMENT , $ code ) ; foreach ( $ service -> getAttributeItems ( ) as $ item ) { if ( isset ( $ feconfig [ $ item -> getCode ( ) ] ) ) { $ feconfig [ $ item -> getCode ( ) ] [ 'default' ] = $ item -> getValue ( ) ; } } } catch ( \ Aimeos \ MShop \ Order \ Exception $ e ) { ; } $ addresses = $ basket -> getAddress ( \ Aimeos \ MShop \ Order \ Item \ Base \ Address \ Base :: TYPE_PAYMENT ) ; if ( ( $ address = current ( $ addresses ) ) !== false ) { if ( $ feconfig [ 'novalnetsepa.holder' ] [ 'default' ] == '' && ( $ fn = $ address -> getFirstname ( ) ) !== '' && ( $ ln = $ address -> getLastname ( ) ) !== '' ) { $ feconfig [ 'novalnetsepa.holder' ] [ 'default' ] = $ fn . ' ' . $ ln ; } } foreach ( $ feconfig as $ key => $ config ) { $ list [ $ key ] = new \ Aimeos \ MW \ Criteria \ Attribute \ Standard ( $ config ) ; } return $ list ; }
9303	public function setSuccessLogLifetime ( $ time ) { if ( ! is_numeric ( $ time ) ) { throw new \ InvalidArgumentException ( '`successLogLifetime` expects integer value!' ) ; } $ this -> options [ 'successLogLifetime' ] = ( int ) $ time ; return $ this ; }
1392	public function isJsonApi ( $ request , Exception $ e ) { if ( Helpers :: wantsJsonApi ( $ request ) ) { return true ; } $ route = app ( JsonApiService :: class ) -> currentRoute ( ) ; return $ route -> hasCodec ( ) && $ route -> getCodec ( ) -> willEncode ( ) ; }
9528	private function parseSingle ( & $ i , $ parameter , & $ results ) { if ( $ this -> prefixExists ( $ parameter ) ) { $ closure = $ this -> getClosure ( $ parameter ) ; if ( $ closure != null ) { $ prefix = $ this -> getPrefix ( $ parameter ) ; $ closure_arguments = [ ] ; $ rFunction = new ReflectionFunction ( $ closure ) ; if ( $ rFunction -> isVariadic ( ) ) { $ this -> parseVariadicParameter ( $ i , $ results , $ closure , $ closure_arguments , $ prefix , $ parameter ) ; } else { $ this -> parseUniadicParameter ( $ i , $ results , $ closure , $ closure_arguments , $ prefix , $ parameter , $ rFunction ) ; } $ result_key = $ this -> getRealName ( $ parameter ) ; $ result = $ results [ $ result_key ] ; if ( ! $ result instanceof ParameterResult ) { if ( $ result == self :: HALT_PARSE ) { $ this -> haltedBy = $ this -> getParameterClosure ( $ parameter ) ; unset ( $ results [ $ result_key ] ) ; return false ; } } else { if ( $ result -> shouldHalt ( ) ) { $ this -> haltedBy = $ this -> getParameterClosure ( $ parameter ) ; if ( $ result -> isHaltOnly ( ) ) { unset ( $ results [ $ result_key ] ) ; } else { $ results [ $ result_key ] = $ result -> getValue ( ) ; } return false ; } } } else { $ this -> respondDefault ( $ i , $ results , $ parameter ) ; } } else { $ this -> respondDefault ( $ i , $ results , $ parameter ) ; } return true ; }
3958	protected function registerAssets ( $ objSettings ) { if ( ! $ objSettings ) { return ; } $ arrCss = $ objSettings -> get ( 'additionalCss' ) ; foreach ( ( array ) $ arrCss as $ arrFile ) { if ( $ arrFile [ 'published' ] ) { $ GLOBALS [ 'TL_CSS' ] [ md5 ( $ arrFile [ 'file' ] ) ] = $ arrFile [ 'file' ] ; } } $ arrJs = $ objSettings -> get ( 'additionalJs' ) ; foreach ( ( array ) $ arrJs as $ arrFile ) { if ( $ arrFile [ 'published' ] ) { $ GLOBALS [ 'TL_JAVASCRIPT' ] [ md5 ( $ arrFile [ 'file' ] ) ] = $ arrFile [ 'file' ] ; } } }
5358	protected function createParameters ( Operation $ operation , $ queryParamDocumentation , Context $ context ) { $ documentationParams = [ ] ; $ methodParameters = [ ] ; if ( $ operation -> getOperation ( ) -> getParameters ( ) ) { foreach ( $ operation -> getOperation ( ) -> getParameters ( ) as $ key => $ parameter ) { if ( $ parameter instanceof Reference ) { $ parameter = $ this -> resolveParameter ( $ parameter ) ; } if ( $ parameter instanceof PathParameterSubSchema ) { $ methodParameters [ ] = $ this -> pathParameterGenerator -> generateMethodParameter ( $ parameter , $ context , $ operation -> getReference ( ) . '/parameters/' . $ key ) ; $ documentationParams [ ] = sprintf ( ' * @param %s' , $ this -> pathParameterGenerator -> generateDocParameter ( $ parameter , $ context , $ operation -> getReference ( ) . '/parameters/' . $ key ) ) ; } } foreach ( $ operation -> getOperation ( ) -> getParameters ( ) as $ key => $ parameter ) { if ( $ parameter instanceof Reference ) { $ parameter = $ this -> resolveParameter ( $ parameter ) ; } if ( $ parameter instanceof BodyParameter ) { $ methodParameters [ ] = $ this -> bodyParameterGenerator -> generateMethodParameter ( $ parameter , $ context , $ operation -> getReference ( ) . '/parameters/' . $ key ) ; $ documentationParams [ ] = sprintf ( ' * @param %s' , $ this -> bodyParameterGenerator -> generateDocParameter ( $ parameter , $ context , $ operation -> getReference ( ) . '/parameters/' . $ key ) ) ; } } } if ( ! empty ( $ queryParamDocumentation ) ) { $ documentationParams [ ] = " * @param array \$parameters {" ; $ documentationParams = array_merge ( $ documentationParams , array_map ( function ( $ doc ) { return " * " . $ doc ; } , $ queryParamDocumentation ) ) ; $ documentationParams [ ] = " * }" ; } else { $ documentationParams [ ] = " * @param array \$parameters List of parameters" ; } $ documentationParams [ ] = " * @param string \$fetch Fetch mode (object or response)" ; $ methodParameters [ ] = new Param ( 'parameters' , new Expr \ Array_ ( ) ) ; $ methodParameters [ ] = new Param ( 'fetch' , new Expr \ ConstFetch ( new Name ( 'self::FETCH_OBJECT' ) ) ) ; return [ $ documentationParams , $ methodParameters ] ; }
11032	protected function supports ( $ attribute , $ subject ) { if ( ! in_array ( $ attribute , array ( self :: MENU , self :: PERMISO ) ) ) { return false ; } if ( $ attribute == self :: MENU && ! is_null ( $ subject ) && ! $ subject instanceof Menu ) { return false ; } return true ; }
3974	protected function build ( IMetaModelDataDefinition $ container ) { $ inputScreen = $ this -> viewCombination -> getScreen ( $ container -> getName ( ) ) ; if ( ! $ inputScreen ) { return ; } $ meta = $ inputScreen [ 'meta' ] ; $ config = $ this -> getDataProviderDefinition ( $ container ) ; if ( ! $ config -> hasInformation ( $ container -> getName ( ) ) ) { $ providerInformation = new ContaoDataProviderInformation ( ) ; $ providerInformation -> setName ( $ container -> getName ( ) ) ; $ config -> addInformation ( $ providerInformation ) ; } else { $ providerInformation = $ config -> getInformation ( $ container -> getName ( ) ) ; } $ basicDefinition = $ container -> getBasicDefinition ( ) ; if ( $ providerInformation instanceof ContaoDataProviderInformation ) { $ providerInformation -> setTableName ( $ container -> getName ( ) ) -> setClassName ( Driver :: class ) -> setInitializationData ( [ 'source' => $ container -> getName ( ) ] ) -> setVersioningEnabled ( false ) ; $ basicDefinition -> setDataProvider ( $ container -> getName ( ) ) ; } if ( $ basicDefinition -> getMode ( ) == BasicDefinitionInterface :: MODE_HIERARCHICAL ) { $ basicDefinition -> setRootDataProvider ( $ container -> getName ( ) ) ; } if ( 'ctable' === $ meta [ 'rendertype' ] ) { $ parentTable = $ meta [ 'ptable' ] ; if ( ! $ config -> hasInformation ( $ parentTable ) ) { $ providerInformation = new ContaoDataProviderInformation ( ) ; $ providerInformation -> setName ( $ parentTable ) ; $ config -> addInformation ( $ providerInformation ) ; } else { $ providerInformation = $ config -> getInformation ( $ parentTable ) ; } if ( $ providerInformation instanceof ContaoDataProviderInformation ) { $ providerInformation -> setTableName ( $ parentTable ) -> setInitializationData ( [ 'source' => $ parentTable ] ) ; if ( in_array ( $ parentTable , $ this -> factory -> collectNames ( ) ) ) { $ providerInformation -> setClassName ( Driver :: class ) ; } $ basicDefinition -> setParentDataProvider ( $ parentTable ) ; } } }
4935	private function triggerEvent ( $ name , EntityInterface $ entity ) { $ params = $ this -> options ; $ params [ 'entity' ] = $ entity ; $ params [ 'repositories' ] = $ this -> repositories ; $ event = $ this -> entityEraserEvents -> getEvent ( $ name , $ this , $ params ) ; $ this -> entityEraserEvents -> triggerEvent ( $ event ) ; $ dependencies = $ event -> getDependencyResultCollection ( ) ; return $ dependencies ; }
3298	public static function isImage ( $ file ) { try { $ level = error_reporting ( E_ERROR | E_PARSE ) ; $ isImage = self :: isFile ( $ file ) && getimagesize ( $ file ) !== false ; error_reporting ( $ level ) ; return $ isImage ; } catch ( Exception $ e ) { return false ; } }
11052	public static function sprintt ( $ datatree , $ containers , $ entry = 'main' , $ hsr = _ETS_SOURCE_READ , $ hcr = _ETS_CACHE_READ , $ hcw = _ETS_CACHE_WRITE ) { $ ets = new _ets ( $ containers , $ hsr , $ hcr , $ hcw ) ; return $ ets -> build_all ( $ datatree , $ entry ) ; }
3278	public function getAll ( ) : array { $ data = [ ] ; $ file = $ this -> getDatabase ( ) -> readFromFile ( ) ; foreach ( $ file as $ line ) { $ data [ $ line -> getKey ( ) ] = $ this -> decodeData ( $ line -> getData ( ) ) ; } return $ data ; }
12679	public static function boot ( ConfigurationHandler $ configurationHandler ) { $ pluginDirs = $ configurationHandler -> pluginFolders ( ) ; foreach ( $ pluginDirs as $ pluginDir ) { self :: $ blocks += self :: parse ( $ pluginDir ) ; } }
219	public function asBoolean ( $ value ) { if ( $ value === null ) { return $ this -> nullDisplay ; } return $ value ? $ this -> booleanFormat [ 1 ] : $ this -> booleanFormat [ 0 ] ; }
11745	public function getShakeInfo ( $ ticket , $ needPoi = null ) { $ params = [ 'ticket' => $ ticket , ] ; if ( $ needPoi !== null ) { $ params [ 'need_poi' ] = intval ( $ needPoi ) ; } return $ this -> parseJSON ( 'json' , [ self :: API_GET_SHAKE_INFO , $ params ] ) ; }
10598	protected function initViewPanelRequestedUrlData ( ) { $ req = & $ this -> request ; $ this -> view -> requestedUrl = ( object ) [ 'method' => htmlSpecialChars ( $ req -> GetMethod ( ) , ENT_IGNORE , 'UTF-8' ) , 'baseUrl' => htmlSpecialChars ( $ req -> GetBaseUrl ( ) , ENT_IGNORE , 'UTF-8' ) , 'path' => htmlSpecialChars ( $ req -> GetRequestPath ( ) , ENT_IGNORE , 'UTF-8' ) , ] ; }
956	public function isActiveTrial ( ) { return $ this -> isTrial ( ) && Carbon :: today ( ) -> lte ( Carbon :: parse ( $ this -> trial_ends_on ) ) ; }
6141	public function checkPass ( $ password = null ) { if ( $ password === null ) { $ password = $ this -> pass ; } if ( strlen ( $ password ) == 0 ) { return true ; } $ pattern = "/^(" . $ this -> regex [ "alphanum" ] . "|" . $ this -> regex [ "mark" ] . "|" . $ this -> regex [ "escaped" ] . "|[;:&=+$,])+$/" ; $ status = @ preg_match ( $ pattern , $ password ) ; if ( $ status === false ) { throw new Ts3Exception ( "URI password validation failed" ) ; } return ( $ status == 1 ) ; }
4742	public function isReviewOptInValidationRequired ( ) { return ( bool ) \ OxidEsales \ Eshop \ Core \ Registry :: getConfig ( ) -> getConfigParam ( self :: REVIEW_OPTIN_PARAM ) ; }
746	protected function buildDefaultString ( ) { if ( $ this -> default === null ) { return $ this -> isNotNull === false ? ' DEFAULT NULL' : '' ; } $ string = ' DEFAULT ' ; switch ( gettype ( $ this -> default ) ) { case 'integer' : $ string .= ( string ) $ this -> default ; break ; case 'double' : $ string .= StringHelper :: floatToString ( $ this -> default ) ; break ; case 'boolean' : $ string .= $ this -> default ? 'TRUE' : 'FALSE' ; break ; case 'object' : $ string .= ( string ) $ this -> default ; break ; default : $ string .= "'{$this->default}'" ; } return $ string ; }
3140	public function hasFeedbacks ( RunnerServiceContext $ context , $ itemRef ) { $ hasFeedbacks = false ; $ displayFeedbacks = $ this -> displayFeedbacks ( $ context ) ; if ( $ displayFeedbacks ) { $ feedbacks = $ this -> getFeedbacks ( $ context , $ itemRef ) ; foreach ( $ feedbacks as $ entry ) { if ( isset ( $ entry [ 'feedbackRules' ] ) ) { if ( count ( $ entry [ 'feedbackRules' ] ) > 0 ) { $ hasFeedbacks = true ; } break ; } } } return $ hasFeedbacks ; }
7142	private function registerActions ( ContainerBuilder $ container ) { if ( class_exists ( 'Ekyna\Component\Payum\Payzen\PayzenGatewayFactory' ) ) { $ definition = new Definition ( 'Ekyna\Component\Commerce\Bridge\Payum\Payzen\Action\ConvertAction' ) ; $ definition -> addTag ( 'payum.action' , [ 'factory' => 'payzen' , 'prepend' => true ] ) ; $ container -> setDefinition ( 'ekyna_commerce.payum.action.payzen.convert_payment' , $ definition ) ; $ definition = new Definition ( 'Ekyna\Component\Commerce\Bridge\Payum\Payzen\Action\FraudLevelAction' ) ; $ definition -> addTag ( 'payum.action' , [ 'factory' => 'payzen' , 'prepend' => true ] ) ; $ container -> setDefinition ( 'ekyna_commerce.payum.action.payzen.fraud_level' , $ definition ) ; } if ( class_exists ( 'Ekyna\Component\Payum\Sips\SipsGatewayFactory' ) ) { $ definition = new Definition ( 'Ekyna\Component\Commerce\Bridge\Payum\Sips\Action\ConvertAction' ) ; $ definition -> addTag ( 'payum.action' , [ 'factory' => 'atos_sips' , 'prepend' => true ] ) ; $ container -> setDefinition ( 'ekyna_commerce.payum.action.sips.convert_payment' , $ definition ) ; } if ( class_exists ( 'Payum\Paypal\ExpressCheckout\Nvp\PaypalExpressCheckoutGatewayFactory' ) ) { $ definition = new Definition ( 'Ekyna\Component\Commerce\Bridge\Payum\Paypal\Action\EcNvpConvertAction' ) ; $ definition -> setArgument ( 0 , new Reference ( 'ekyna_commerce.common.amount_calculator' ) ) ; if ( $ container -> has ( 'ekyna_setting.manager' ) && class_exists ( 'Ekyna\Bundle\AdminBundle\Settings\GeneralSettingsSchema' ) ) { $ definition -> setArgument ( 1 , new Expression ( "service('ekyna_setting.manager').getParameter('general.site_name')" ) ) ; } $ definition -> addTag ( 'payum.action' , [ 'factory' => 'paypal_express_checkout' , 'prepend' => true ] ) ; $ container -> setDefinition ( 'ekyna_commerce.payum.action.paypal_ec_nvp.convert_payment' , $ definition ) ; } $ actions = [ 'capture_payment' => Action \ CaptureAction :: class , 'notify_payment' => Action \ NotifyAction :: class , 'status_payment' => Action \ StatusAction :: class , ] ; foreach ( $ actions as $ name => $ class ) { $ definition = new Definition ( $ class ) ; $ definition -> addTag ( 'payum.action' , [ 'all' => true , 'prepend' => true ] ) ; $ container -> setDefinition ( 'ekyna_commerce.payum.action.' . $ name , $ definition ) ; } }
8481	public static function getNameById ( $ id , $ attributeName = 'name' ) { $ model = static :: loadModel ( $ id ) ; return empty ( $ model [ $ attributeName ] ) === false ? $ model [ $ attributeName ] : \ Yii :: t ( 'app' , 'Unknown' ) ; }
6568	protected function createMigration ( ) { $ app = app ( ) ; $ migrationFiles = array ( $ this -> laravel -> path . "/database/migrations/*_create_countries_table.php" => 'countries::generators.migration' , ) ; $ seconds = 0 ; foreach ( $ migrationFiles as $ migrationFile => $ outputFile ) { if ( sizeof ( glob ( $ migrationFile ) ) == 0 ) { $ migrationFile = str_replace ( '*' , date ( 'Y_m_d_His' , strtotime ( '+' . $ seconds . ' seconds' ) ) , $ migrationFile ) ; $ fs = fopen ( $ migrationFile , 'x' ) ; if ( $ fs ) { $ output = "<?php\n\n" . $ app [ 'view' ] -> make ( $ outputFile ) -> with ( 'table' , 'countries' ) -> render ( ) ; fwrite ( $ fs , $ output ) ; fclose ( $ fs ) ; } else { return false ; } $ seconds ++ ; } } $ seeder_file = $ this -> laravel -> path . "/database/seeds/CountriesSeeder.php" ; $ output = "<?php\n\n" . $ app [ 'view' ] -> make ( 'countries::generators.seeder' ) -> render ( ) ; if ( ! file_exists ( $ seeder_file ) ) { $ fs = fopen ( $ seeder_file , 'x' ) ; if ( $ fs ) { fwrite ( $ fs , $ output ) ; fclose ( $ fs ) ; } else { return false ; } } return true ; }
10054	public function setDataValues ( $ dataValues ) { $ this -> dataValues = Functions :: flattenArray ( $ dataValues ) ; $ this -> pointCount = count ( $ dataValues ) ; return $ this ; }
10866	protected function createNewInst ( ) { $ classReflection = new \ ReflectionClass ( $ this -> instClass ) ; if ( $ this -> constructorArgs === null ) { return $ classReflection -> newInstance ( ) ; } else { return $ classReflection -> newInstanceArgs ( $ this -> concstructorArgs ) ; } }
11065	public function icon ( $ level , $ default = null ) { if ( array_key_exists ( $ level , $ this -> icons ) ) { return $ this -> icons [ $ level ] ; } return $ default ; }
2186	public function fetch ( $ strTable , $ varKey , $ strAlias = null ) { $ strClass = Model :: getClassFromTable ( $ strTable ) ; $ strPk = $ strClass :: getPk ( ) ; if ( $ strAlias === null || $ strAlias == $ strPk ) { if ( isset ( $ this -> arrRegistry [ $ strTable ] [ $ varKey ] ) ) { return $ this -> arrRegistry [ $ strTable ] [ $ varKey ] ; } return null ; } return $ this -> fetchByAlias ( $ strTable , $ strAlias , $ varKey ) ; }
12443	public function add ( InvokerInterface $ invoker , $ taskArgs = [ ] ) { $ taskArgs = ( is_array ( $ taskArgs ) ? $ taskArgs : array_slice ( func_get_args ( ) , 1 ) ) ; array_unshift ( $ this -> tasks , compact ( 'invoker' , 'taskArgs' ) ) ; return $ this ; }
4419	protected function checkPermissions ( ) { if ( $ this -> isGranted ( 'ROLE_NGBM_EDITOR' ) ) { return ; } if ( $ this -> isGranted ( 'nglayouts:ui:access' ) ) { return ; } $ exception = $ this -> createAccessDeniedException ( ) ; $ exception -> setAttributes ( 'nglayouts:ui:access' ) ; throw $ exception ; }
4913	public function add ( $ name , $ entities = null , array $ options = null ) { if ( $ name instanceof DependencyResult ) { return $ this -> addResult ( $ name ) ; } if ( $ name instanceof \ Traversable ) { return $ this -> addTraversable ( $ name ) ; } if ( is_array ( $ name ) ) { return $ this -> addArray ( $ name ) ; } if ( null === $ entities ) { throw new \ UnexpectedValueException ( '$entities must not be null.' ) ; } return $ this -> addArray ( [ 'name' => $ name , 'entities' => $ entities , 'options' => $ options , ] ) ; }
10312	function getRecipientsCount ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ excludeDeletedRecipients = false ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , null ) ; if ( isset ( $ excludeDeletedRecipients ) ) $ params [ 'exclude_deleted_recipients' ] = ( $ excludeDeletedRecipients == true ) ? "true" : "false" ; return $ this -> get ( 'reports/recipients/count' , $ params ) ; }
7332	private function configureStockUnitDiscriminatorMap ( LoadClassMetadataEventArgs $ eventArgs ) { $ metadata = $ eventArgs -> getClassMetadata ( ) ; if ( ! is_subclass_of ( $ metadata -> name , Stock \ StockUnitInterface :: class ) ) { return ; } $ this -> getStockUnitMapper ( $ eventArgs -> getEntityManager ( ) ) -> processClassMetadata ( $ metadata ) ; }
10175	public function getHighestColumn ( $ row = null ) { if ( $ row == null ) { $ colRow = $ this -> getHighestRowAndColumn ( ) ; return $ colRow [ 'column' ] ; } $ columnList = [ 1 ] ; foreach ( $ this -> getCoordinates ( ) as $ coord ) { sscanf ( $ coord , '%[A-Z]%d' , $ c , $ r ) ; if ( $ r != $ row ) { continue ; } $ columnList [ ] = Coordinate :: columnIndexFromString ( $ c ) ; } return Coordinate :: stringFromColumnIndex ( max ( $ columnList ) + 1 ) ; }
3971	public function getAttributeOptions ( GetPropertyOptionsEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ result = [ ] ; $ metaModel = $ this -> getMetaModel ( $ event -> getEnvironment ( ) ) ; $ conditionType = $ event -> getModel ( ) -> getProperty ( 'type' ) ; foreach ( $ metaModel -> getAttributes ( ) as $ attribute ) { if ( ! $ this -> conditionFactory -> supportsAttribute ( $ conditionType , $ attribute -> get ( 'type' ) ) ) { continue ; } $ typeName = $ attribute -> get ( 'type' ) ; $ strSelectVal = $ metaModel -> getTableName ( ) . '_' . $ attribute -> getColName ( ) ; $ result [ $ strSelectVal ] = $ attribute -> getName ( ) . ' [' . $ typeName . ']' ; } $ event -> setOptions ( $ result ) ; }
3624	public function temperatureInUserScale ( $ temperature_in_celsius , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ temp_scale = $ this -> getDeviceTemperatureScale ( $ serial_number ) ; if ( $ temp_scale == 'F' ) { return ( $ temperature_in_celsius * 1.8 ) + 32 ; } return $ temperature_in_celsius ; }
674	private function normalizeTableRowData ( $ table , $ columns ) { if ( $ columns instanceof Query ) { return $ columns ; } if ( ( $ tableSchema = $ this -> db -> getSchema ( ) -> getTableSchema ( $ table ) ) !== null ) { $ columnSchemas = $ tableSchema -> columns ; foreach ( $ columns as $ name => $ value ) { if ( isset ( $ columnSchemas [ $ name ] ) && $ columnSchemas [ $ name ] -> type === Schema :: TYPE_BINARY && is_string ( $ value ) ) { $ columns [ $ name ] = new PdoValue ( $ value , \ PDO :: PARAM_LOB ) ; } } } return $ columns ; }
3827	protected function getFrontendFilterValue ( $ arrWidget , $ arrFilterUrl , $ strKeyOption ) { if ( $ this -> isActiveFrontendFilterValue ( $ arrWidget , $ arrFilterUrl , $ strKeyOption ) ) { return '' ; } return $ strKeyOption ; }
4201	private function addMethodsMin ( Event $ abs ) { $ obj = $ abs -> getSubject ( ) ; if ( \ method_exists ( $ obj , '__toString' ) ) { $ abs [ 'methods' ] [ '__toString' ] = array ( 'returnValue' => \ call_user_func ( array ( $ obj , '__toString' ) ) , 'visibility' => 'public' , ) ; } if ( \ method_exists ( $ obj , '__get' ) ) { $ abs [ 'methods' ] [ '__get' ] = array ( 'visibility' => 'public' ) ; } if ( \ method_exists ( $ obj , '__set' ) ) { $ abs [ 'methods' ] [ '__set' ] = array ( 'visibility' => 'public' ) ; } return ; }
12253	public function dump ( ) { $ dom = new DOMDocument ( '1.0' ) ; $ dom -> preserveWhiteSpace = false ; $ dom -> formatOutput = true ; $ dom -> loadXML ( $ this -> asXML ( ) ) ; return $ dom -> saveXML ( ) ; }
271	protected function renderSeparator ( $ spanLeft , $ spanMid , $ spanMidMid , $ spanRight ) { $ separator = $ spanLeft ; foreach ( $ this -> _columnWidths as $ index => $ rowSize ) { if ( $ index !== 0 ) { $ separator .= $ spanMid ; } $ separator .= str_repeat ( $ spanMidMid , $ rowSize ) ; } $ separator .= $ spanRight . "\n" ; return $ separator ; }
1375	private function runCommandsWithParameters ( Collection $ commands , array $ parameters ) { foreach ( $ commands -> keys ( ) as $ command ) { if ( 0 !== $ this -> call ( $ command , $ parameters ) ) { return false ; } } return true ; }
11967	public function getPidByProgramName ( $ name ) { $ process = new Process ( sprintf ( 'supervisorctl pid %s' , $ name ) ) ; $ process -> run ( ) ; return $ process -> getOutput ( ) ; }
10582	protected function buildResponse ( APIResponse $ APIResponse , ResponseInterface $ response ) : ResponseInterface { $ response = $ response -> withStatus ( 200 , "200 OK" ) ; $ response = $ response -> withAddedHeader ( "Content-Type" , $ APIResponse -> getMIMEType ( ) ) ; $ response = $ response -> withAddedHeader ( "Content-Length" , $ APIResponse -> getAsDataStream ( ) -> getSize ( ) ) ; $ this -> logger -> debug ( "Responding to request successfully" ) ; return $ response -> withBody ( $ APIResponse -> getAsDataStream ( ) ) ; }
834	private function getFunctionyTokenKinds ( ) { static $ tokens = [ T_ARRAY , T_ECHO , T_EMPTY , T_EVAL , T_EXIT , T_INCLUDE , T_INCLUDE_ONCE , T_ISSET , T_LIST , T_PRINT , T_REQUIRE , T_REQUIRE_ONCE , T_UNSET , T_VARIABLE , ] ; return $ tokens ; }
12482	private function mapByGeneration ( $ mapByDepthDesc , $ mapById ) { $ result = [ ] ; foreach ( $ mapByDepthDesc as $ depth => $ ids ) { foreach ( $ ids as $ custId ) { $ entry = $ mapById [ $ custId ] ; $ path = $ entry -> getPath ( ) ; $ parents = $ this -> hlpTree -> getParentsFromPathReversed ( $ path ) ; $ level = 0 ; foreach ( $ parents as $ parentId ) { $ level += 1 ; if ( ! isset ( $ result [ $ parentId ] ) ) { $ result [ $ parentId ] = [ ] ; } if ( ! isset ( $ result [ $ parentId ] [ $ level ] ) ) { $ result [ $ parentId ] [ $ level ] = [ ] ; } $ result [ $ parentId ] [ $ level ] [ ] = $ custId ; } } } return $ result ; }
9536	private function prefixExists ( $ parameter ) { $ prefixExists = false ; foreach ( array_keys ( $ this -> parameterCluster -> prefixes ) as $ prefix ) { if ( substr ( $ parameter , 0 , strlen ( $ prefix ) ) == $ prefix ) { $ prefixExists = true ; break ; } } return $ prefixExists ; }
7545	function getNamespace ( ) { if ( $ this -> tag_ns === null ) { $ a = explode ( ':' , $ this -> tag , 2 ) ; if ( empty ( $ a [ 1 ] ) ) { $ this -> tag_ns = array ( '' , $ a [ 0 ] ) ; } else { $ this -> tag_ns = array ( $ a [ 0 ] , $ a [ 1 ] ) ; } } return $ this -> tag_ns [ 0 ] ; }
12019	function addProperties ( ) { $ requiredProperties = [ 'api' => '\\' . $ this -> apiClassname , 'parameters' => 'array' , 'response' => '\Amp\Artax\Response' , 'originalResponse' => '\Amp\Artax\Response' , ] ; foreach ( $ requiredProperties as $ propertyName => $ typehint ) { $ propertyGenerator = new PropertyGenerator ( $ propertyName , null ) ; $ docBlock = new DocBlockGenerator ( '@var ' . $ typehint ) ; $ propertyGenerator -> setDocBlock ( $ docBlock ) ; $ this -> classGenerator -> addPropertyFromGenerator ( $ propertyGenerator ) ; } $ docBlock = new DocBlockGenerator ( 'Get the last response.' ) ; $ body = 'return $this->response;' ; $ methodGenerator = $ this -> createMethodGenerator ( 'getResponse' , $ body , $ docBlock , [ ] , '\Amp\Artax\Response' ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; $ docBlock = new DocBlockGenerator ( 'Set the last response. This should only be used by the API class when the operation has been dispatched. Storing the response is required as some APIs store out-of-bound information in the headers e.g. rate-limit info, pagination that is not really part of the operation.' ) ; $ body = '$this->response = $response;' ; $ methodGenerator = $ this -> createMethodGenerator ( 'setResponse' , $ body , $ docBlock , [ [ 'response' , 'Amp\Artax\Response' ] ] ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
7392	public function serialize ( ) : string { $ toSerialize = [ '_arrayOptions' => $ this -> _arrayOptions , '_jsonOptions' => $ this -> _jsonOptions , ] ; foreach ( $ this -> _publicNames as $ k ) { $ toSerialize [ $ k ] = $ this -> { $ k } ; } return serialize ( $ toSerialize ) ; }
12330	public function get_source_to_enqueue ( $ relative_path , $ filename , $ filename_debug = null ) { $ source_file = $ filename ; if ( defined ( 'SCRIPT_DEBUG' ) && true === SCRIPT_DEBUG && ! empty ( $ filename_debug ) ) { $ source_file = $ filename_debug ; } $ path = realpath ( trailingslashit ( $ relative_path ) . $ source_file ) ; return WP_Url_Util :: get_instance ( ) -> convert_absolute_path_to_url ( $ path ) ; }
9370	public function handle ( ServerRequestInterface $ request ) { $ callback = new CallbackHandler ( self :: $ container ) ; if ( static :: $ container -> has ( self :: MIDDLEWARE ) ) { $ middleware = static :: $ container -> get ( self :: MIDDLEWARE ) ; $ delegate = new Delegate ( $ callback ) ; $ result = $ middleware -> process ( $ request , $ delegate ) ; } return isset ( $ result ) ? $ result : $ callback ( $ request ) ; }
9793	public function hasDataValidation ( ) { if ( ! isset ( $ this -> parent ) ) { throw new Exception ( 'Cannot check for data validation when cell is not bound to a worksheet' ) ; } return $ this -> getWorksheet ( ) -> dataValidationExists ( $ this -> getCoordinate ( ) ) ; }
2878	public function enableFPCDebugAction ( ) { try { $ this -> getService ( ) -> setFPCDebug ( 1 ) ; $ this -> getService ( ) -> flushCache ( ) ; $ message = $ this -> __ ( 'FPC debug was enabled' ) ; $ this -> getSession ( ) -> addSuccess ( $ message ) ; } catch ( Exception $ e ) { $ message = $ this -> __ ( 'FPC debug cannot be enabled: %s' , $ e -> getMessage ( ) ) ; $ this -> getSession ( ) -> addError ( $ message ) ; } $ this -> _redirectReferer ( ) ; }
2442	protected function getUser ( ) : BackendUser { if ( null === $ this -> tokenStorage ) { throw new \ RuntimeException ( 'No token storage provided' ) ; } $ token = $ this -> tokenStorage -> getToken ( ) ; if ( null === $ token ) { throw new \ RuntimeException ( 'No token provided' ) ; } $ user = $ token -> getUser ( ) ; if ( ! $ user instanceof BackendUser ) { throw new \ RuntimeException ( 'The token does not contain a back end user object' ) ; } return $ user ; }
11884	public function getModuleHandler ( ) { if ( is_null ( $ this -> _moduleHandler ) ) { $ stem = $ this -> field ; if ( ! isset ( self :: $ _moduleHandlers [ $ stem ] ) ) { self :: $ _moduleHandlers [ $ stem ] = [ ] ; } $ n = count ( self :: $ _moduleHandlers [ $ stem ] ) ; $ this -> _moduleHandler = $ this -> field . ':_' . $ n ; self :: $ _moduleHandlers [ $ stem ] [ ] = $ this -> _moduleHandler ; } return $ this -> _moduleHandler ; }
9310	protected function doPostAction ( $ uri , array $ data = [ ] ) { $ this -> setActionUri ( $ uri ) ; try { $ response = $ this -> client -> post ( $ this -> uri , [ 'json' => $ data ] ) ; } catch ( ClientException $ e ) { $ response = $ e -> getResponse ( ) ; } catch ( ServerException $ e ) { $ response = $ e -> getResponse ( ) ; } return $ this -> responseToJson ( $ response ) ; }
6340	public function SearchForm ( ) { if ( count ( Searchable :: config ( ) -> objects ) ) { $ searchText = "" ; if ( $ this -> owner -> request && $ this -> owner -> request -> getVar ( 'Search' ) ) { $ searchText = $ this -> owner -> request -> getVar ( 'Search' ) ; } $ fields = FieldList :: create ( TextField :: create ( 'Search' , false , $ searchText ) -> setAttribute ( "placeholder" , _t ( 'Searchable.Search' , 'Search' ) ) ) ; $ actions = FieldList :: create ( FormAction :: create ( 'results' , _t ( 'Searchable.Go' , 'Go' ) ) ) ; $ template_class = Searchable :: config ( ) -> template_class ; $ results_page = Injector :: inst ( ) -> create ( $ template_class ) ; $ form = Form :: create ( $ this -> owner , 'SearchForm' , $ fields , $ actions ) -> setFormMethod ( 'get' ) -> setFormAction ( $ results_page -> Link ( ) ) -> setTemplate ( 'ilateral\SilverStripe\Searchable\Includes\SearchForm' ) -> disableSecurityToken ( ) ; $ this -> owner -> extend ( "updateSearchForm" , $ form ) ; return $ form ; } }
1716	public function isAllowed ( $ int , $ row ) { if ( $ this -> isAdmin ) { return true ; } if ( ! $ row [ 'includeChmod' ] ) { $ pid = $ row [ 'pid' ] ; $ row [ 'chmod' ] = false ; $ row [ 'cuser' ] = false ; $ row [ 'cgroup' ] = false ; $ objParentPage = PageModel :: findById ( $ pid ) ; while ( $ objParentPage !== null && $ row [ 'chmod' ] === false && $ pid > 0 ) { $ pid = $ objParentPage -> pid ; $ row [ 'chmod' ] = $ objParentPage -> includeChmod ? $ objParentPage -> chmod : false ; $ row [ 'cuser' ] = $ objParentPage -> includeChmod ? $ objParentPage -> cuser : false ; $ row [ 'cgroup' ] = $ objParentPage -> includeChmod ? $ objParentPage -> cgroup : false ; $ objParentPage = PageModel :: findById ( $ pid ) ; } if ( $ row [ 'chmod' ] === false ) { $ row [ 'chmod' ] = Config :: get ( 'defaultChmod' ) ; } if ( $ row [ 'cuser' ] === false ) { $ row [ 'cuser' ] = ( int ) Config :: get ( 'defaultUser' ) ; } if ( $ row [ 'cgroup' ] === false ) { $ row [ 'cgroup' ] = ( int ) Config :: get ( 'defaultGroup' ) ; } } $ chmod = StringUtil :: deserialize ( $ row [ 'chmod' ] ) ; $ chmod = \ is_array ( $ chmod ) ? $ chmod : array ( $ chmod ) ; $ permission = array ( 'w' . $ int ) ; if ( \ in_array ( $ row [ 'cgroup' ] , $ this -> groups ) ) { $ permission [ ] = 'g' . $ int ; } if ( $ row [ 'cuser' ] == $ this -> id ) { $ permission [ ] = 'u' . $ int ; } return \ count ( array_intersect ( $ permission , $ chmod ) ) > 0 ; }
10653	protected function __propertyTraitHasProperty ( $ propertyName ) { if ( method_exists ( $ this , 'get' . $ propertyName ) || method_exists ( $ this , 'set' . $ propertyName ) ) { return true ; } try { $ classReflection = new \ ReflectionProperty ( get_class ( $ this ) , $ propertyName ) ; return $ classReflection -> isPublic ( ) ; } catch ( \ ReflectionException $ ex ) { return false ; } }
1454	protected function validateRelationship ( RelationshipInterface $ relationship , $ key = null ) { if ( ! $ relationship -> has ( RelationshipInterface :: DATA ) ) { $ this -> addError ( $ this -> errorFactory -> memberRequired ( RelationshipInterface :: DATA , $ key ? P :: relationship ( $ key ) : P :: data ( ) ) ) ; return false ; } if ( ! $ relationship -> isHasOne ( ) && ! $ relationship -> isHasMany ( ) ) { $ this -> addError ( $ this -> errorFactory -> memberRelationshipExpected ( RelationshipInterface :: DATA , $ key ? P :: relationship ( $ key ) : P :: data ( ) ) ) ; return false ; } if ( ! $ this -> validateEmpty ( $ relationship , $ key ) ) { return false ; } return true ; }
1044	private static function highlightSourceAtLocation ( Source $ source , SourceLocation $ location ) { $ line = $ location -> line ; $ lineOffset = $ source -> locationOffset -> line - 1 ; $ columnOffset = self :: getColumnOffset ( $ source , $ location ) ; $ contextLine = $ line + $ lineOffset ; $ contextColumn = $ location -> column + $ columnOffset ; $ prevLineNum = ( string ) ( $ contextLine - 1 ) ; $ lineNum = ( string ) $ contextLine ; $ nextLineNum = ( string ) ( $ contextLine + 1 ) ; $ padLen = strlen ( $ nextLineNum ) ; $ lines = preg_split ( '/\r\n|[\n\r]/' , $ source -> body ) ; $ lines [ 0 ] = self :: whitespace ( $ source -> locationOffset -> column - 1 ) . $ lines [ 0 ] ; $ outputLines = [ sprintf ( '%s (%s:%s)' , $ source -> name , $ contextLine , $ contextColumn ) , $ line >= 2 ? ( self :: lpad ( $ padLen , $ prevLineNum ) . ': ' . $ lines [ $ line - 2 ] ) : null , self :: lpad ( $ padLen , $ lineNum ) . ': ' . $ lines [ $ line - 1 ] , self :: whitespace ( 2 + $ padLen + $ contextColumn - 1 ) . '^' , $ line < count ( $ lines ) ? self :: lpad ( $ padLen , $ nextLineNum ) . ': ' . $ lines [ $ line ] : null , ] ; return implode ( "\n" , array_filter ( $ outputLines ) ) ; }
2612	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ dictionary = $ this -> api -> getAuthDictionary ( $ activeVersion ) ; if ( ( is_array ( $ dictionary ) && empty ( $ dictionary ) ) || ! isset ( $ dictionary -> id ) ) { return $ result -> setData ( [ 'status' => 'empty' , 'msg' => 'Authentication dictionary does not exist.' ] ) ; } $ user = $ this -> getRequest ( ) -> getParam ( 'auth_user' ) ; $ pass = $ this -> getRequest ( ) -> getParam ( 'auth_pass' ) ; $ key = base64_encode ( $ user . ':' . $ pass ) ; $ this -> api -> upsertDictionaryItem ( $ dictionary -> id , $ key , true ) ; return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
1923	public static function fromDimensions ( $ width , $ height ) { $ image = imagecreatetruecolor ( $ width , $ height ) ; $ arrGdInfo = gd_info ( ) ; $ strGdVersion = preg_replace ( '/[^0-9.]+/' , '' , $ arrGdInfo [ 'GD Version' ] ) ; if ( version_compare ( $ strGdVersion , '2.0' , '>=' ) ) { imagealphablending ( $ image , false ) ; imagefill ( $ image , 0 , 0 , imagecolorallocatealpha ( $ image , 0 , 0 , 0 , 127 ) ) ; imagesavealpha ( $ image , true ) ; } return new static ( $ image ) ; }
12916	protected function resultToModels ( $ result ) { $ models = array ( ) ; foreach ( $ result as $ r ) { $ pk = $ r -> { $ this -> pk } ; try { $ models [ ] = new $ this -> class ( $ pk , $ r ) ; } catch ( \ Exception $ e ) { } } return $ models ; }
9981	public function writeVMLComments ( \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Worksheet $ pWorksheet ) { $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ comments = $ pWorksheet -> getComments ( ) ; $ objWriter -> startElement ( 'xml' ) ; $ objWriter -> writeAttribute ( 'xmlns:v' , 'urn:schemas-microsoft-com:vml' ) ; $ objWriter -> writeAttribute ( 'xmlns:o' , 'urn:schemas-microsoft-com:office:office' ) ; $ objWriter -> writeAttribute ( 'xmlns:x' , 'urn:schemas-microsoft-com:office:excel' ) ; $ objWriter -> startElement ( 'o:shapelayout' ) ; $ objWriter -> writeAttribute ( 'v:ext' , 'edit' ) ; $ objWriter -> startElement ( 'o:idmap' ) ; $ objWriter -> writeAttribute ( 'v:ext' , 'edit' ) ; $ objWriter -> writeAttribute ( 'data' , '1' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'v:shapetype' ) ; $ objWriter -> writeAttribute ( 'id' , '_x0000_t202' ) ; $ objWriter -> writeAttribute ( 'coordsize' , '21600,21600' ) ; $ objWriter -> writeAttribute ( 'o:spt' , '202' ) ; $ objWriter -> writeAttribute ( 'path' , 'm,l,21600r21600,l21600,xe' ) ; $ objWriter -> startElement ( 'v:stroke' ) ; $ objWriter -> writeAttribute ( 'joinstyle' , 'miter' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'v:path' ) ; $ objWriter -> writeAttribute ( 'gradientshapeok' , 't' ) ; $ objWriter -> writeAttribute ( 'o:connecttype' , 'rect' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; foreach ( $ comments as $ key => $ value ) { $ this -> writeVMLComment ( $ objWriter , $ key , $ value ) ; } $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
9836	protected function openFile ( $ pFilename ) { File :: assertFile ( $ pFilename ) ; $ this -> fileHandle = fopen ( $ pFilename , 'r' ) ; if ( $ this -> fileHandle === false ) { throw new Exception ( 'Could not open file ' . $ pFilename . ' for reading.' ) ; } }
12782	public function getAll ( ) { if ( is_null ( $ this -> intersections ) ) { $ this -> intersections = [ ] ; if ( $ this -> arraysSize >= 2 ) { $ this -> createIntersections ( ) ; } } return $ this -> intersections ; }
10180	private function storeCurrentCell ( ) { if ( $ this -> currentCellIsDirty && ! empty ( $ this -> currentCoordinate ) ) { $ this -> currentCell -> detach ( ) ; $ stored = $ this -> cache -> set ( $ this -> cachePrefix . $ this -> currentCoordinate , $ this -> currentCell ) ; if ( ! $ stored ) { $ this -> __destruct ( ) ; throw new PhpSpreadsheetException ( "Failed to store cell {$this->currentCoordinate} in cache" ) ; } $ this -> currentCellIsDirty = false ; } $ this -> currentCoordinate = null ; $ this -> currentCell = null ; }
7190	private function copyAttachment ( Model \ SaleAttachmentInterface $ source , Model \ SaleAttachmentInterface $ target ) { $ this -> copy ( $ source , $ target , [ 'path' , 'title' , 'type' , 'size' , 'internal' , 'createdAt' , 'updatedAt' , ] ) ; }
6537	public function registerAssetFiles ( $ view ) { if ( \ Yii :: $ app -> request -> isPjax ) { return parent :: registerAssetFiles ( $ view ) ; } parent :: registerAssetFiles ( $ view ) ; }
7087	static public function loadFromPasswordRecoveryAccessKey ( string $ accessKey ) { try { $ data = \ Crypt :: decrypt ( $ accessKey ) ; } catch ( DecryptException $ exc ) { return false ; } if ( empty ( $ data ) ) { return false ; } $ data = json_decode ( $ data , true ) ; $ now = new \ DateTime ( 'now' , new \ DateTimeZone ( 'UTC' ) ) ; if ( empty ( $ data ) || ! is_array ( $ data ) || ! isset ( $ data [ 'added_keys' ] ) || ! is_array ( $ data [ 'added_keys' ] ) || empty ( $ data [ 'account_id' ] ) || empty ( $ data [ 'expires_at' ] ) || $ data [ 'expires_at' ] < $ now -> getTimestamp ( ) ) { return false ; } $ user = static :: newEmptyRecord ( ) ; $ conditions = [ $ user :: getPrimaryKeyColumnName ( ) => $ data [ 'account_id' ] , ] ; $ additionalColumns = $ data [ 'added_keys' ] ; foreach ( $ additionalColumns as $ columnName ) { if ( ! array_key_exists ( $ columnName , $ data ) ) { return false ; } $ fieldType = $ user :: getColumn ( $ columnName ) -> getType ( ) ; switch ( $ fieldType ) { case Column :: TYPE_DATE : $ conditions [ $ columnName . '::date' ] = DbExpr :: create ( "``$data[$columnName]``::date" ) ; break ; case Column :: TYPE_TIME : $ conditions [ $ columnName . '::time' ] = DbExpr :: create ( "``$data[$columnName]``::time" ) ; break ; case Column :: TYPE_TIMESTAMP : $ conditions [ ] = DbExpr :: create ( "`{$columnName}`::timestamp(0) = ``{$data[$columnName]}``::timestamp(0)" ) ; break ; default : $ conditions [ $ columnName ] = $ data [ $ columnName ] ; } } if ( ! $ user -> fromDb ( $ conditions ) -> existsInDb ( ) ) { return false ; } return $ user ; }
11266	public function library ( $ pathname , & $ caller = false , $ exposeToView = false ) { $ name = $ this -> getName ( $ pathname ) ; $ path = $ this -> getPath ( $ pathname ) ; if ( $ caller ) { if ( $ this -> getPathBackslash ( $ pathname ) == '' ) { $ lib = '\\Cora\\' . $ name ; } else { $ lib = $ pathname ; } $ libObj = new $ lib ( $ caller ) ; $ caller -> $ name = $ libObj ; if ( $ exposeToView ) $ caller -> setData ( $ name , $ libObj ) ; } }
5041	public function onBootstrap ( MvcEvent $ e ) { if ( ! DoctrineType :: hasType ( 'tz_date' ) ) { DoctrineType :: addType ( 'tz_date' , '\Core\Repository\DoctrineMongoODM\Types\TimezoneAwareDate' ) ; } $ sm = $ e -> getApplication ( ) -> getServiceManager ( ) ; $ translator = $ sm -> get ( 'translator' ) ; \ Zend \ Validator \ AbstractValidator :: setDefaultTranslator ( $ translator ) ; $ eventManager = $ e -> getApplication ( ) -> getEventManager ( ) ; $ sharedManager = $ eventManager -> getSharedManager ( ) ; if ( ! \ Zend \ Console \ Console :: isConsole ( ) ) { ( new ErrorHandlerListener ( ) ) -> attach ( $ eventManager ) ; $ languageRouteListener = new LanguageRouteListener ( $ sm -> get ( 'Core/Locale' ) , $ sm -> get ( 'Core/Options' ) ) ; $ languageRouteListener -> attach ( $ eventManager ) ; $ ajaxRenderListener = new AjaxRenderListener ( ) ; $ ajaxRenderListener -> attach ( $ eventManager ) ; $ ajaxRouteListener = $ sm -> get ( AjaxRouteListener :: class ) ; $ ajaxRouteListener -> attach ( $ eventManager ) ; $ xmlRenderListener = new XmlRenderListener ( ) ; $ xmlRenderListener -> attach ( $ eventManager ) ; $ enforceJsonResponseListener = new EnforceJsonResponseListener ( ) ; $ enforceJsonResponseListener -> attach ( $ eventManager ) ; $ stringListener = new StringListener ( ) ; $ stringListener -> attach ( $ eventManager ) ; } $ notificationListener = $ sm -> get ( 'Core/Listener/Notification' ) ; $ notificationListener -> attachShared ( $ sharedManager ) ; $ notificationAjaxHandler = new NotificationAjaxHandler ( ) ; $ eventManager -> attach ( MvcEvent :: EVENT_DISPATCH , array ( $ notificationAjaxHandler , 'injectView' ) , - 20 ) ; $ notificationListener -> attach ( NotificationEvent :: EVENT_NOTIFICATION_HTML , array ( $ notificationAjaxHandler , 'render' ) , - 20 ) ; $ eventManager -> attach ( MvcEvent :: EVENT_DISPATCH_ERROR , function ( $ event ) { if ( $ event instanceof MvcEvent ) { $ application = $ event -> getApplication ( ) ; if ( $ application :: ERROR_EXCEPTION == $ event -> getError ( ) ) { $ ex = $ event -> getParam ( 'exception' ) ; if ( 404 == $ ex -> getCode ( ) ) { $ event -> setError ( $ application :: ERROR_CONTROLLER_NOT_FOUND ) ; } } } } , 500 ) ; $ eventManager -> attach ( MvcEvent :: EVENT_DISPATCH , function ( $ event ) use ( $ eventManager ) { $ eventManager -> trigger ( 'postDispatch' , $ event ) ; } , - 150 ) ; $ sm -> get ( 'Tracy' ) -> startDebug ( ) ; }
2091	public function generate ( ) { if ( TL_MODE == 'BE' ) { $ objTemplate = new BackendTemplate ( 'be_wildcard' ) ; $ objTemplate -> wildcard = '### ' . Utf8 :: strtoupper ( $ GLOBALS [ 'TL_LANG' ] [ 'CTE' ] [ 'form' ] [ 0 ] ) . ' ###' ; $ objTemplate -> id = $ this -> id ; $ objTemplate -> link = $ this -> title ; $ objTemplate -> href = 'contao/main.php?do=form&amp;table=tl_form_field&amp;id=' . $ this -> id ; return $ objTemplate -> parse ( ) ; } if ( $ this -> customTpl != '' && TL_MODE == 'FE' ) { $ this -> strTemplate = $ this -> customTpl ; } return parent :: generate ( ) ; }
9064	public function attachShared ( SharedEventManagerInterface $ events ) { $ events -> attach ( 'Zend\Mvc\Application' , MvcEvent :: EVENT_BOOTSTRAP , array ( $ this , 'onMvcBootstrapLast' ) , - 100000 ) ; $ events -> attach ( 'Zend\Mvc\Application' , MvcEvent :: EVENT_RENDER , array ( $ this , 'onRenderAddPathStacks' ) , - 900 ) ; $ events -> attach ( 'Zend\Mvc\Application' , MvcEvent :: EVENT_RENDER , array ( $ this , 'onRenderSpecLayout' ) , - 1000 ) ; }
5942	public function readLine ( $ token = "\n" ) { $ this -> connect ( ) ; $ line = StringHelper :: factory ( "" ) ; while ( ! $ line -> endsWith ( $ token ) ) { $ this -> waitForReadyRead ( ) ; $ data = @ fgets ( $ this -> stream , 4096 ) ; Signal :: getInstance ( ) -> emit ( strtolower ( $ this -> getAdapterType ( ) ) . "DataRead" , $ data ) ; if ( $ data === false ) { if ( $ line -> count ( ) ) { $ line -> append ( $ token ) ; } else { throw new Ts3Exception ( "connection to server '" . $ this -> config [ "host" ] . ":" . $ this -> config [ "port" ] . "' lost" ) ; } } else { $ line -> append ( $ data ) ; } } return $ line -> trim ( ) ; }
9933	public function setRuleType ( $ pRuleType ) { if ( ! in_array ( $ pRuleType , self :: $ ruleTypes ) ) { throw new PhpSpreadsheetException ( 'Invalid rule type for column AutoFilter Rule.' ) ; } $ this -> ruleType = $ pRuleType ; return $ this ; }
12672	public static function emulate ( $ emulation , callable $ assertionCallable = null ) { if ( ( is_string ( $ emulation ) ) && ( class_exists ( $ emulation ) ) ) { $ emulation = new $ emulation ( $ assertionCallable ) ; } static :: $ emulation = $ emulation ; }
1889	protected function getPathNodes ( ) { if ( ! $ this -> varValue ) { return ; } if ( ! \ is_array ( $ this -> varValue ) ) { $ this -> varValue = array ( $ this -> varValue ) ; } foreach ( $ this -> varValue as $ id ) { $ arrPids = $ this -> Database -> getParentRecords ( $ id , 'tl_page' ) ; array_shift ( $ arrPids ) ; $ this -> arrNodes = array_merge ( $ this -> arrNodes , $ arrPids ) ; } }
1795	private function addFrontendRoute ( RouteCollection $ routes , array $ defaults ) : void { $ route = new Route ( '/{alias}' . $ this -> urlSuffix , $ defaults , [ 'alias' => '.+' ] ) ; $ this -> addLocaleToRoute ( $ route ) ; $ routes -> add ( 'contao_frontend' , $ route ) ; }
9565	public function addBeforeHook ( $ hook ) { if ( ! isset ( $ this -> options [ 'before' ] ) ) { $ this -> options [ 'before' ] = [ ] ; } $ this -> options [ 'before' ] [ ] = $ hook ; }
8078	protected function buildUri ( $ endpoint , $ options = [ ] ) { if ( $ this -> token !== '' ) { $ options [ 'auth' ] = $ this -> token ; } return $ this -> base . '/' . ltrim ( $ endpoint , '/' ) . '.json?' . http_build_query ( $ options , '' , '&' ) ; }
11603	public function align ( PagesCollectionParser $ pagesCollectionParser ) { $ themeSlots = $ this -> findSlotsInTemplates ( ) ; $ slots = $ this -> mergeSlotsByStatus ( $ themeSlots ) ; if ( ! array_key_exists ( "page" , $ slots ) ) { return ; } $ pageSlots = $ slots [ "page" ] ; unset ( $ slots [ "page" ] ) ; $ files = $ this -> removeCommonSlots ( $ slots ) ; $ files = array_merge ( $ files , $ this -> removePageSlots ( $ pagesCollectionParser , $ pageSlots ) ) ; if ( ! empty ( $ files ) ) { $ fs = new Filesystem ( ) ; $ fs -> remove ( $ files ) ; } }
4980	public function convertToDatabaseValue ( $ value ) { if ( ! $ value instanceof \ DateTime ) { return null ; } $ timezone = $ value -> getTimezone ( ) -> getName ( ) ; $ timestamp = $ value -> getTimestamp ( ) ; $ date = new \ MongoDate ( $ timestamp ) ; return array ( 'date' => $ date , 'tz' => $ timezone , ) ; }
811	private function fixSpaceBelowClassElement ( Tokens $ tokens , $ classEndIndex , $ elementEndIndex ) { for ( $ nextNotWhite = $ elementEndIndex + 1 ; ; ++ $ nextNotWhite ) { if ( ( $ tokens [ $ nextNotWhite ] -> isComment ( ) || $ tokens [ $ nextNotWhite ] -> isWhitespace ( ) ) && false === strpos ( $ tokens [ $ nextNotWhite ] -> getContent ( ) , "\n" ) ) { continue ; } break ; } if ( $ tokens [ $ nextNotWhite ] -> isWhitespace ( ) ) { $ nextNotWhite = $ tokens -> getNextNonWhitespace ( $ nextNotWhite ) ; } $ this -> correctLineBreaks ( $ tokens , $ elementEndIndex , $ nextNotWhite , $ nextNotWhite === $ classEndIndex ? 1 : 2 ) ; }
4402	protected function getProvider ( ) { $ config = $ this -> getServiceItem ( ) -> getConfig ( ) ; $ config [ 'apiKey' ] = $ this -> getServiceItem ( ) -> getConfigValue ( 'stripe.apiKey' ) ; if ( ! isset ( $ this -> provider ) ) { $ this -> provider = OPay :: create ( 'Stripe' ) ; $ this -> provider -> setTestMode ( ( bool ) $ this -> getValue ( 'testmode' , false ) ) ; $ this -> provider -> initialize ( $ config ) ; } return $ this -> provider ; }
12628	public function register ( Application $ app ) { if ( is_null ( $ this -> filename ) ) { throw new \ RuntimeException ( 'You must provide a valid config filename' ) ; } if ( ! file_exists ( $ this -> filename ) ) { throw new \ RuntimeException ( sprintf ( 'Config path \'%s\' is not valid' , $ this -> filename ) ) ; } if ( ! is_readable ( $ this -> filename ) ) { throw new \ RuntimeException ( sprintf ( 'Config path \'%s\' is not readable' , $ this -> filename ) ) ; } $ parser = new YamlParser ( ) ; $ config = $ parser -> parse ( file_get_contents ( $ this -> filename ) ) ; if ( is_array ( $ config ) && ! empty ( $ config ) ) { if ( isset ( $ app [ 'config' ] ) && is_array ( $ app [ 'config' ] ) ) { $ config = array_replace_recursive ( $ app [ 'config' ] , $ config ) ; } $ app [ 'config' ] = $ config ; } }
10804	public function getBackOfficeUsersAction ( ) { $ melisPageHistoricTable = $ this -> getServiceLocator ( ) -> get ( 'MelisPageHistoricTable' ) ; $ users = $ melisPageHistoricTable -> getUsers ( ) -> toArray ( ) ; return new JsonModel ( array ( 'users' => $ users , ) ) ; }
2718	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ snippet = $ this -> getRequest ( ) -> getParam ( 'snippet_id' ) ; $ read = $ this -> filesystem -> getDirectoryRead ( DirectoryList :: VAR_DIR ) ; $ snippetPath = $ read -> getRelativePath ( Config :: CUSTOM_SNIPPET_PATH . $ snippet ) ; if ( $ read -> isExist ( $ snippetPath ) ) { $ explodeId = explode ( '.' , $ snippet , - 1 ) ; $ snippetParts = explode ( '_' , $ explodeId [ 0 ] , 3 ) ; $ type = $ snippetParts [ 0 ] ; $ priority = $ snippetParts [ 1 ] ; $ name = $ snippetParts [ 2 ] ; $ content = $ read -> readFile ( $ snippetPath ) ; } else { throw new LocalizedException ( __ ( 'Custom snippet not found.' ) ) ; } return $ result -> setData ( [ 'status' => true , 'type' => $ type , 'priority' => $ priority , 'name' => $ name , 'content' => $ content , 'original' => $ snippet ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
4995	public function getActiveFormNext ( ) { $ key = null ; $ actualKey = $ this -> getActiveFormActual ( ) ; if ( isset ( $ actualKey ) ) { $ forms = array_keys ( $ this -> forms ) ; $ formsFlip = array_flip ( $ forms ) ; $ index = $ formsFlip [ $ actualKey ] ; if ( $ index < count ( $ forms ) - 1 ) { $ key = $ forms [ $ index + 1 ] ; } } return $ key ; }
9078	private static function parseContextPrefix ( Request & $ request , $ serverVars = array ( ) ) { if ( isset ( $ serverVars [ 'CONTEXT_PREFIX' ] ) && $ serverVars [ 'CONTEXT_PREFIX' ] != '' ) { $ request -> setContextPrefix ( $ serverVars [ 'CONTEXT_PREFIX' ] . '/' ) ; } elseif ( isset ( $ serverVars [ 'REDIRECT_BASE' ] ) ) { $ request -> setContextPrefix ( $ serverVars [ 'REDIRECT_BASE' ] ) ; } elseif ( isset ( $ serverVars [ 'SCRIPT_FILENAME' ] ) && isset ( $ serverVars [ 'SCRIPT_NAME' ] ) ) { if ( isset ( $ serverVars [ 'HTTP_HOST' ] ) ) { $ scriptName = preg_replace ( '/^.+[\\\\\\/]/' , '' , $ serverVars [ 'SCRIPT_FILENAME' ] ) ; $ request -> contextPrefix = str_replace ( $ scriptName , '' , $ serverVars [ 'SCRIPT_NAME' ] ) ; } } }
2726	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ dictionary = $ this -> api -> getSingleDictionary ( $ activeVersion , 'magentomodule_basic_auth' ) ; if ( ! $ dictionary || ( is_array ( $ dictionary ) && empty ( $ dictionary ) ) ) { return $ result -> setData ( [ 'status' => 'none' , 'msg' => 'Authentication dictionary does not exist.' ] ) ; } $ authItems = false ; if ( isset ( $ dictionary -> id ) ) { $ authItems = $ this -> api -> dictionaryItemsList ( $ dictionary -> id ) ; } if ( is_array ( $ authItems ) && empty ( $ authItems ) ) { return $ result -> setData ( [ 'status' => 'empty' , 'msg' => 'There are no dictionary items.' ] ) ; } if ( ! $ authItems ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to fetch dictionary items.' ] ) ; } foreach ( $ authItems as $ key => $ item ) { $ userData = explode ( ':' , base64_decode ( $ item -> item_key ) ) ; $ username = $ userData [ 0 ] ; $ item -> item_key_id = $ item -> item_key ; $ item -> item_key = $ username ; $ authItems [ $ key ] = $ item ; } return $ result -> setData ( [ 'status' => true , 'auths' => $ authItems ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
11727	public function setTaxonomy_id ( $ value ) { if ( ! is_array ( $ value ) ) { $ value = [ $ value ] ; } foreach ( $ value as $ k => $ v ) { if ( is_object ( $ v ) ) { $ value [ $ k ] = $ v -> primaryKey ; } elseif ( is_array ( $ v ) ) { unset ( $ value [ $ k ] ) ; if ( isset ( $ v [ 'systemId' ] ) && isset ( $ v [ 'taxonomyType' ] ) ) { $ taxonomyType = Yii :: $ app -> collectors [ 'taxonomies' ] -> getOne ( $ v [ 'taxonomyType' ] ) ; if ( isset ( $ taxonomyType ) && ( $ taxonomy = $ taxonomyType -> getTaxonomy ( $ v [ 'systemId' ] ) ) ) { $ value [ $ k ] = $ taxonomy -> primaryKey ; } } } } $ this -> _taxonomy_id = $ value ; }
5	private function buildDepPackageConstraints ( $ depItem , $ depType ) { if ( $ this -> isHash ( $ depItem ) ) { $ depItem = array ( $ depItem ) ; } $ result = array ( ) ; foreach ( $ depItem as $ subDepItem ) { if ( ! array_key_exists ( 'channel' , $ subDepItem ) ) { $ subDepItem [ 'channel' ] = $ subDepItem [ 'uri' ] ; } $ depChannelName = $ subDepItem [ 'channel' ] ; $ depPackageName = $ subDepItem [ 'name' ] ; $ depVersionConstraint = $ this -> parse20VersionConstraint ( $ subDepItem ) ; if ( isset ( $ subDepItem [ 'conflicts' ] ) ) { $ depType = 'conflicts' ; } $ result [ ] = new DependencyConstraint ( $ depType , $ depVersionConstraint , $ depChannelName , $ depPackageName ) ; } return $ result ; }
678	protected function detectSearchAttributeType ( Validator $ validator ) { if ( $ validator instanceof BooleanValidator ) { return self :: TYPE_BOOLEAN ; } if ( $ validator instanceof NumberValidator ) { return $ validator -> integerOnly ? self :: TYPE_INTEGER : self :: TYPE_FLOAT ; } if ( $ validator instanceof StringValidator ) { return self :: TYPE_STRING ; } if ( $ validator instanceof EachValidator ) { return self :: TYPE_ARRAY ; } if ( $ validator instanceof DateValidator ) { if ( $ validator -> type == DateValidator :: TYPE_DATETIME ) { return self :: TYPE_DATETIME ; } if ( $ validator -> type == DateValidator :: TYPE_TIME ) { return self :: TYPE_TIME ; } return self :: TYPE_DATE ; } }
6017	public function updateSite ( $ id , DeploymentSite $ deploymentSite ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'deploymentSite' => $ deploymentSite ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/deployment/' . $ id . '' , $ parameters ) ; $ result = new DeploymentSiteResponse ( $ result ) ; return $ result ; }
9197	public function getTag ( ) { if ( null !== $ this -> tag ) { return $ this -> tag ; } $ categoryId = $ this -> getEvent ( ) -> getRouteMatch ( ) -> getParam ( 'categoryid' ) ; if ( is_numeric ( $ categoryId ) ) { return $ this -> tag = $ this -> getDiscussService ( ) -> getCategoryById ( $ categoryId ) ; } $ topicId = $ this -> getEvent ( ) -> getRouteMatch ( ) -> getParam ( 'topicid' ) ; if ( is_numeric ( $ topicId ) ) { $ topic = $ this -> getDiscussService ( ) -> getTopicById ( $ topicId ) ; return $ this -> tag = $ this -> getDiscussService ( ) -> getCategoryById ( $ topic -> getforumCategoryId ( ) ) ; } return false ; }
1903	public function limit ( $ intRows , $ intOffset = 0 ) { if ( $ intRows <= 0 ) { $ intRows = 30 ; } if ( $ intOffset < 0 ) { $ intOffset = 0 ; } if ( strncasecmp ( $ this -> strQuery , 'SELECT' , 6 ) === 0 ) { $ this -> strQuery .= ' LIMIT ' . $ intOffset . ',' . $ intRows ; } else { $ this -> strQuery .= ' LIMIT ' . $ intRows ; } return $ this ; }
10886	protected function startSession ( Request $ request , $ sessionId ) { return tap ( $ this -> getSession ( $ sessionId ) , function ( $ session ) use ( $ request ) { $ session -> setRequestOnHandler ( $ request ) ; $ session -> start ( ) ; } ) ; }
2017	protected function resizeUploadedImage ( $ strImage ) { if ( Config :: get ( 'imageWidth' ) < 1 && Config :: get ( 'imageHeight' ) < 1 ) { return false ; } $ objFile = new File ( $ strImage ) ; if ( ! $ objFile -> isSvgImage && ! $ objFile -> isGdImage ) { return false ; } $ arrImageSize = $ objFile -> imageSize ; if ( $ objFile -> isGdImage && ( $ arrImageSize [ 0 ] > Config :: get ( 'gdMaxImgWidth' ) || $ arrImageSize [ 1 ] > Config :: get ( 'gdMaxImgHeight' ) ) ) { Message :: addInfo ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'fileExceeds' ] , $ objFile -> basename ) ) ; $ this -> log ( 'File "' . $ strImage . '" is too big to be resized automatically' , __METHOD__ , TL_FILES ) ; return false ; } $ blnResize = false ; if ( $ arrImageSize [ 0 ] > Config :: get ( 'imageWidth' ) ) { $ blnResize = true ; $ intWidth = Config :: get ( 'imageWidth' ) ; $ intHeight = round ( Config :: get ( 'imageWidth' ) * $ arrImageSize [ 1 ] / $ arrImageSize [ 0 ] ) ; $ arrImageSize = array ( $ intWidth , $ intHeight ) ; } if ( $ arrImageSize [ 1 ] > Config :: get ( 'imageHeight' ) ) { $ blnResize = true ; $ intWidth = round ( Config :: get ( 'imageHeight' ) * $ arrImageSize [ 0 ] / $ arrImageSize [ 1 ] ) ; $ intHeight = Config :: get ( 'imageHeight' ) ; $ arrImageSize = array ( $ intWidth , $ intHeight ) ; } if ( $ blnResize ) { $ container = System :: getContainer ( ) ; $ rootDir = $ container -> getParameter ( 'kernel.project_dir' ) ; $ container -> get ( 'contao.image.image_factory' ) -> create ( $ rootDir . '/' . $ strImage , array ( $ arrImageSize [ 0 ] , $ arrImageSize [ 1 ] ) , $ rootDir . '/' . $ strImage ) ; Message :: addInfo ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'fileResized' ] , $ objFile -> basename ) ) ; $ this -> log ( 'File "' . $ strImage . '" was scaled down to the maximum dimensions' , __METHOD__ , TL_FILES ) ; $ this -> blnHasResized = true ; return true ; } return false ; }
178	public static function filter ( $ array , $ filters ) { $ result = [ ] ; $ forbiddenVars = [ ] ; foreach ( $ filters as $ var ) { $ keys = explode ( '.' , $ var ) ; $ globalKey = $ keys [ 0 ] ; $ localKey = isset ( $ keys [ 1 ] ) ? $ keys [ 1 ] : null ; if ( $ globalKey [ 0 ] === '!' ) { $ forbiddenVars [ ] = [ substr ( $ globalKey , 1 ) , $ localKey , ] ; continue ; } if ( ! array_key_exists ( $ globalKey , $ array ) ) { continue ; } if ( $ localKey === null ) { $ result [ $ globalKey ] = $ array [ $ globalKey ] ; continue ; } if ( ! isset ( $ array [ $ globalKey ] [ $ localKey ] ) ) { continue ; } if ( ! array_key_exists ( $ globalKey , $ result ) ) { $ result [ $ globalKey ] = [ ] ; } $ result [ $ globalKey ] [ $ localKey ] = $ array [ $ globalKey ] [ $ localKey ] ; } foreach ( $ forbiddenVars as $ var ) { list ( $ globalKey , $ localKey ) = $ var ; if ( array_key_exists ( $ globalKey , $ result ) ) { unset ( $ result [ $ globalKey ] [ $ localKey ] ) ; } } return $ result ; }
12654	public function getText ( $ name , $ language ) { $ allTexts = $ this -> getPageTexts ( $ language ) ; if ( isset ( $ allTexts [ $ name ] ) ) { return $ allTexts [ $ name ] ; } else { return null ; } }
3276	public function flush ( ) { $ this -> getDatabase ( ) -> flushFile ( ) ; if ( $ cache = $ this -> getConfig ( ) -> getCache ( ) ) { $ cache -> flush ( ) ; } }
5871	protected static function rationalToDecimal ( array $ components ) { foreach ( $ components as $ key => $ value ) { $ rationalParts = explode ( '/' , $ value ) ; if ( ! empty ( $ rationalParts [ 1 ] ) ) { $ components [ $ key ] = $ rationalParts [ 0 ] / $ rationalParts [ 1 ] ; } else { $ components [ $ key ] = 0 ; } } list ( $ hours , $ minutes , $ seconds ) = $ components ; return $ hours + ( $ minutes / 60 ) + ( $ seconds / 3600 ) ; }
5664	private function collectFrames ( $ node ) { $ frames = array ( ) ; if ( $ node -> name === 'frame' ) { $ frames = array ( $ this -> tags ( ) -> createTag ( $ node -> name , ( array ) $ node -> attribute ) ) ; } elseif ( $ node -> hasChildren ( ) ) { $ frames = array ( ) ; foreach ( $ node -> child as $ child ) { $ frames = array_merge ( $ frames , $ this -> collectFrames ( $ child ) ) ; } } return $ frames ; }
5852	protected function processData ( ) { $ close = GeneralUtility :: _GP ( 'closeDoc' ) ; $ save = GeneralUtility :: _GP ( '_savedok' ) ; $ saveAndClose = GeneralUtility :: _GP ( '_saveandclosedok' ) ; if ( $ save || $ saveAndClose ) { $ table = static :: virtualTable ; $ id = static :: virtualRecordId ; $ field = 'rulesets' ; $ inputData_tmp = GeneralUtility :: _GP ( 'data' ) ; $ data = $ inputData_tmp [ $ table ] [ $ id ] ; if ( count ( $ inputData_tmp [ $ table ] ) > 1 ) { foreach ( $ inputData_tmp [ $ table ] as $ key => $ values ) { if ( $ key === $ id ) continue ; ArrayUtility :: mergeRecursiveWithOverrule ( $ data , $ values ) ; } } $ newConfig = $ this -> config ; ArrayUtility :: mergeRecursiveWithOverrule ( $ newConfig , $ data ) ; $ ffValue = & $ data [ $ field ] ; if ( $ ffValue ) { $ actionCMDs = GeneralUtility :: _GP ( '_ACTION_FLEX_FORMdata' ) ; if ( is_array ( $ actionCMDs [ $ table ] [ $ id ] [ $ field ] [ 'data' ] ) ) { $ dataHandler = new CustomDataHandler ( ) ; $ dataHandler -> _ACTION_FLEX_FORMdata ( $ ffValue [ 'data' ] , $ actionCMDs [ $ table ] [ $ id ] [ $ field ] [ 'data' ] ) ; } $ this -> persistFlexForm ( $ ffValue [ 'data' ] ) ; $ newConfig [ $ field ] = $ ffValue ; } $ localconfConfig = $ newConfig ; $ localconfConfig [ 'conversion_mapping' ] = implode ( ',' , GeneralUtility :: trimExplode ( LF , $ localconfConfig [ 'conversion_mapping' ] , true ) ) ; if ( $ this -> persistConfiguration ( $ localconfConfig ) ) { $ this -> config = $ newConfig ; } } if ( $ close || $ saveAndClose ) { $ closeUrl = BackendUtility :: getModuleUrl ( 'tools_ExtensionmanagerExtensionmanager' ) ; \ TYPO3 \ CMS \ Core \ Utility \ HttpUtility :: redirect ( $ closeUrl ) ; } }
446	public function detachBehaviors ( ) { $ this -> ensureBehaviors ( ) ; foreach ( $ this -> _behaviors as $ name => $ behavior ) { $ this -> detachBehavior ( $ name ) ; } }
8888	public function process ( ServerRequestInterface $ request , RequestHandlerInterface $ requestHandler ) : ResponseInterface { $ this -> container -> set ( ServerRequestInterface :: class , $ request ) ; $ result = $ this -> dispatch ( $ this -> route ( $ request ) ) ; if ( $ result instanceof ResponseInterface ) { return $ result ; } return $ response = ( new Response ( ) ) -> withProtocolVersion ( '1.1' ) -> withBody ( \ GuzzleHttp \ Psr7 \ stream_for ( $ result ) ) ; }
2141	public function onKernelResponse ( FilterResponseEvent $ event ) : void { if ( ! $ this -> scopeMatcher -> isContaoMasterRequest ( $ event ) ) { return ; } $ token = $ this -> tokenStorage -> getToken ( ) ; if ( null === $ token || $ this -> authenticationTrustResolver -> isAnonymous ( $ token ) ) { return ; } $ user = $ token -> getUser ( ) ; if ( ! $ user instanceof User ) { return ; } $ sessionBag = $ this -> getSessionBag ( $ event -> getRequest ( ) ) ; $ data = $ sessionBag -> all ( ) ; $ this -> connection -> update ( $ user -> getTable ( ) , [ 'session' => serialize ( $ data ) ] , [ 'id' => $ user -> id ] ) ; }
9653	public function addLoader ( $ extensions , $ loaderClass ) { foreach ( ( array ) $ extensions as $ extension ) { $ this -> extensions [ ] = $ extension ; if ( is_string ( $ loaderClass ) ) { $ this -> loaderClasses [ $ extension ] = $ loaderClass ; } elseif ( $ loaderClass instanceof LoaderInterface ) { $ this -> loaders [ $ extension ] = $ loaderClass ; } } }
4194	private function magicMethodInfo ( $ methods ) { if ( ! $ methods ) { return '' ; } foreach ( $ methods as $ i => $ method ) { $ methods [ $ i ] = '<code>' . $ method . '</code>' ; } $ methods = $ i == 0 ? 'a ' . $ methods [ 0 ] . ' method' : \ implode ( ' and ' , $ methods ) . ' methods' ; return '<dd class="magic info">This object has ' . $ methods . '</dd>' . "\n" ; }
2279	public static function get ( $ strKey ) { if ( isset ( static :: $ arrCache [ $ strKey ] ) ) { return static :: $ arrCache [ $ strKey ] ; } if ( \ in_array ( $ strKey , get_class_methods ( __CLASS__ ) ) ) { static :: $ arrCache [ $ strKey ] = static :: $ strKey ( ) ; } else { $ arrChunks = preg_split ( '/([A-Z][a-z]*)/' , $ strKey , - 1 , PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY ) ; $ strServerKey = strtoupper ( implode ( '_' , $ arrChunks ) ) ; static :: $ arrCache [ $ strKey ] = $ _SERVER [ $ strServerKey ] ; } return static :: $ arrCache [ $ strKey ] ; }
6291	private function loadTheme ( $ theme ) { if ( ! isset ( $ theme ) ) { return ; } $ th = $ this -> findThemeByDirectory ( $ theme ) ; if ( isset ( $ th ) ) { $ viewFinder = $ this -> view -> getFinder ( ) ; $ viewFinder -> prependPath ( $ th -> getPath ( ) ) ; if ( ! is_null ( $ th -> getParent ( ) ) ) { $ this -> loadTheme ( $ th -> getParent ( ) ) ; } $ this -> activeTheme = $ theme ; } }
4214	public static function keyValues ( $ row , $ keys , & $ objInfo ) { $ objInfo = array ( 'row' => false , 'cols' => array ( ) , ) ; $ rowIsAbstraction = Abstracter :: isAbstraction ( $ row ) ; if ( $ rowIsAbstraction ) { if ( $ row [ 'type' ] == 'object' ) { $ objInfo [ 'row' ] = array ( 'className' => $ row [ 'className' ] , 'phpDoc' => $ row [ 'phpDoc' ] , ) ; $ row = self :: objectValues ( $ row ) ; if ( ! \ is_array ( $ row ) ) { $ objInfo [ 'row' ] = false ; $ row = array ( self :: SCALAR => $ row ) ; } elseif ( Abstracter :: isAbstraction ( $ row ) ) { $ objInfo [ 'row' ] = false ; $ row = array ( self :: SCALAR => $ row ) ; } } else { $ row = array ( self :: SCALAR => $ row ) ; } } if ( ! \ is_array ( $ row ) ) { $ row = array ( self :: SCALAR => $ row ) ; } $ values = array ( ) ; foreach ( $ keys as $ key ) { if ( \ array_key_exists ( $ key , $ row ) ) { $ value = $ row [ $ key ] ; if ( $ value !== null ) { $ objInfo [ 'cols' ] [ $ key ] = false ; } if ( Abstracter :: isAbstraction ( $ value ) ) { if ( isset ( $ value [ 'stringified' ] ) ) { $ objInfo [ 'cols' ] [ $ key ] = $ value [ 'className' ] ; $ value = $ value [ 'stringified' ] ; } elseif ( isset ( $ value [ '__toString' ] [ 'returnValue' ] ) ) { $ objInfo [ 'cols' ] [ $ key ] = $ value [ 'className' ] ; $ value = $ value [ '__toString' ] [ 'returnValue' ] ; } } } else { $ value = Abstracter :: UNDEFINED ; } $ values [ $ key ] = $ value ; } return $ values ; }
5118	public function deleteAttachment ( string $ idArticle , string $ field , string $ order ) : string { return $ this -> delete ( $ this -> getAttachmentEndPoint ( $ idArticle , $ field ) . "/${order}" ) ; }
7814	private function _processRequest ( ) { $ this -> _isAjaxRequest = $ this -> request -> is ( 'ajax' ) ; if ( isset ( $ this -> request -> query [ 'length' ] ) && ! empty ( $ this -> request -> query [ 'length' ] ) ) { $ this -> config ( 'length' , $ this -> request -> query [ 'length' ] ) ; } if ( isset ( $ this -> request -> query [ 'start' ] ) && ! empty ( $ this -> request -> query [ 'start' ] ) ) { $ this -> config ( 'start' , ( int ) $ this -> request -> query [ 'start' ] ) ; } if ( isset ( $ this -> request -> query [ 'order' ] ) && ! empty ( $ this -> request -> query [ 'order' ] ) ) { $ order = $ this -> config ( 'order' ) ; foreach ( $ this -> request -> query [ 'order' ] as $ item ) { $ order [ $ this -> request -> query [ 'columns' ] [ $ item [ 'column' ] ] [ 'name' ] ] = $ item [ 'dir' ] ; } $ this -> config ( 'order' , $ order ) ; } if ( isset ( $ this -> request -> query [ 'draw' ] ) && ! empty ( $ this -> request -> query [ 'draw' ] ) ) { $ this -> _viewVars [ 'draw' ] = ( int ) $ this -> request -> query [ 'draw' ] ; } if ( ! isset ( $ this -> request -> query [ 'columns' ] ) || empty ( $ this -> request -> query [ 'columns' ] ) ) { return ; } $ globalSearch = ( isset ( $ this -> request -> query [ 'search' ] [ 'value' ] ) ? $ this -> request -> query [ 'search' ] [ 'value' ] : false ) ; foreach ( $ this -> request -> query [ 'columns' ] as $ column ) { if ( $ globalSearch && $ column [ 'searchable' ] == 'true' ) { $ this -> _addCondition ( $ column [ 'name' ] , $ globalSearch , 'or' ) ; } $ localSearch = $ column [ 'search' ] [ 'value' ] ; if ( ! empty ( $ localSearch ) && ( $ localSearch !== $ globalSearch ) ) { $ this -> _addCondition ( $ column [ 'name' ] , $ column [ 'search' ] [ 'value' ] ) ; } } }
10267	public function setEndColor ( Color $ pValue ) { $ color = $ pValue -> getIsSupervisor ( ) ? $ pValue -> getSharedComponent ( ) : $ pValue ; if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getEndColor ( ) -> getStyleArray ( [ 'argb' => $ color -> getARGB ( ) ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> endColor = $ color ; } return $ this ; }
6430	public function completeLogin ( $ extrainputs = array ( ) ) { $ facebook = $ this -> getFacebookObject ( ) ; $ old_GET = $ _GET ; $ _GET = $ extrainputs ; $ helper = $ facebook -> getRedirectLoginHelper ( ) ; $ accessToken = $ helper -> getAccessToken ( ) ; $ _GET = $ old_GET ; if ( ! isset ( $ accessToken ) ) { if ( $ helper -> getError ( ) ) { throw new \ Exception ( $ helper -> getError ( ) . ' ' . $ helper -> getErrorCode ( ) . ' ' . $ helper -> getErrorReason ( ) . ' ' . $ helper -> getErrorDescription ( ) ) ; } else { throw new \ Exception ( 'Unknown error from Facebook' ) ; } } $ this -> accesstoken = $ accessToken ; return $ this -> getUserProfile ( ) ; }
8879	private function isValidHomeDirectory ( string $ path ) : bool { $ valid = false ; if ( '~/' === substr ( $ path , 0 , 2 ) ) { $ valid = $ this -> isValidFullPath ( $ this -> expandHomeDirectory ( $ path ) ) ; } return $ valid ; }
309	public function export ( ) { if ( empty ( $ this -> message [ 'subject' ] ) ) { $ this -> message [ 'subject' ] = 'Application Log' ; } $ messages = array_map ( [ $ this , 'formatMessage' ] , $ this -> messages ) ; $ body = wordwrap ( implode ( "\n" , $ messages ) , 70 ) ; $ message = $ this -> composeMessage ( $ body ) ; if ( ! $ message -> send ( $ this -> mailer ) ) { throw new LogRuntimeException ( 'Unable to export log through email!' ) ; } }
4245	private function logPhpInfo ( ) { if ( ! $ this -> debug -> getCfg ( 'logEnvInfo.phpInfo' ) ) { return ; } $ this -> debug -> log ( 'PHP Version' , PHP_VERSION ) ; $ this -> debug -> log ( 'ini location' , \ php_ini_loaded_file ( ) ) ; $ this -> debug -> log ( 'memory_limit' , $ this -> debug -> utilities -> getBytes ( $ this -> debug -> utilities -> memoryLimit ( ) ) ) ; $ this -> debug -> log ( 'session.cache_limiter' , \ ini_get ( 'session.cache_limiter' ) ) ; if ( \ session_module_name ( ) === 'files' ) { $ this -> debug -> log ( 'session_save_path' , \ session_save_path ( ) ? : \ sys_get_temp_dir ( ) ) ; } $ extensionsCheck = array ( 'curl' , 'mbstring' ) ; $ extensionsCheck = \ array_filter ( $ extensionsCheck , function ( $ extension ) { return ! \ extension_loaded ( $ extension ) ; } ) ; if ( $ extensionsCheck ) { $ this -> debug -> warn ( 'These common extensions are not loaded:' , $ extensionsCheck ) ; } $ this -> logPhpInfoEr ( ) ; }
11961	public function each ( Closure $ fn ) { foreach ( $ this -> elements as $ key => $ element ) { if ( $ fn ( $ element , $ key ) === false ) { return false ; } } return true ; }
333	public function add ( $ key , $ value , $ duration = 0 , $ dependency = null ) { if ( $ dependency !== null && $ this -> serializer !== false ) { $ dependency -> evaluateDependency ( $ this ) ; } if ( $ this -> serializer === null ) { $ value = serialize ( [ $ value , $ dependency ] ) ; } elseif ( $ this -> serializer !== false ) { $ value = call_user_func ( $ this -> serializer [ 0 ] , [ $ value , $ dependency ] ) ; } $ key = $ this -> buildKey ( $ key ) ; return $ this -> addValue ( $ key , $ value , $ duration ) ; }
3542	public static function getExtensionOptions ( $ optionName ) { if ( isset ( Yii :: $ app -> params [ 'yii2-adldap-extension-Options' ] ) && is_array ( Yii :: $ app -> params [ 'yii2-adldap-extension-Options' ] ) && array_key_exists ( $ optionName , Yii :: $ app -> params [ 'yii2-adldap-extension-Options' ] ) ) { return Yii :: $ app -> params [ 'yii2-adldap-extension-Options' ] [ $ optionName ] ; } else if ( array_key_exists ( $ optionName , static :: EXTENSION_OPTIONS_DEFAULT ) ) { return static :: EXTENSION_OPTIONS_DEFAULT [ $ optionName ] ; } else { throw new \ yii \ base \ Exception ( 'Extension-Option ' . $ optionName . ' not found. Please define settings in the config/params.php of the yii2 framework as described on top of the UserDbLdap.php' ) ; } }
2219	public static function countPublishedByPids ( $ arrPids , $ blnFeatured = null , array $ arrOptions = array ( ) ) { if ( empty ( $ arrPids ) || ! \ is_array ( $ arrPids ) ) { return 0 ; } $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrPids ) ) . ")" ) ; if ( $ blnFeatured === true ) { $ arrColumns [ ] = "$t.featured='1'" ; } elseif ( $ blnFeatured === false ) { $ arrColumns [ ] = "$t.featured=''" ; } if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: countBy ( $ arrColumns , null , $ arrOptions ) ; }
10850	protected function getMapping ( string $ clazz ) : array { if ( isset ( $ this -> cachedMapping [ $ clazz ] ) ) { return $ this -> cachedMapping [ $ clazz ] ; } $ ref = new \ ReflectionClass ( $ clazz ) ; $ mapping = array ( ) ; foreach ( $ this -> mapping as $ className => $ config ) { if ( $ clazz === $ className || $ ref -> isSubclassOf ( $ className ) ) { $ mapping = \ array_merge ( $ mapping , $ config ) ; } } $ this -> cachedMapping [ $ clazz ] = $ mapping ; return $ mapping ; }
10437	public function inject_template ( midgardmvc_core_request $ request ) { $ route = $ request -> get_route ( ) ; $ route -> template_aliases [ 'content-sidebar' ] = 'cmp-show-sidebar' ; $ route -> template_aliases [ 'main-menu' ] = 'cmp-show-main_menu' ; midgardmvc_core :: get_instance ( ) -> head -> add_link ( array ( 'rel' => 'stylesheet' , 'type' => 'text/css' , 'href' => MIDGARDMVC_STATIC_URL . '/com_meego_planet/planet.css' ) ) ; }
356	public function init ( ) { parent :: init ( ) ; if ( $ this -> enableCoreCommands ) { foreach ( $ this -> coreCommands ( ) as $ id => $ command ) { if ( ! isset ( $ this -> controllerMap [ $ id ] ) ) { $ this -> controllerMap [ $ id ] = $ command ; } } } if ( ! isset ( $ this -> controllerMap [ 'help' ] ) ) { $ this -> controllerMap [ 'help' ] = 'yii\console\controllers\HelpController' ; } }
9411	protected function exceptions ( \ Exception $ exception , $ uri ) { $ interface = 'Phroute\Phroute\Exception\HttpRouteNotFoundException' ; $ message = ( string ) $ exception -> getMessage ( ) ; is_a ( $ exception , $ interface ) && $ message = 'Route "' . $ uri . '" not found' ; throw new \ UnexpectedValueException ( ( string ) $ message ) ; }
3568	public function replicate ( ) { return function ( $ next , $ copy , $ args ) { $ metaAttributes = $ args -> get ( 'original' ) -> getMetaAttributes ( ) -> replicate ( $ args -> get ( 'except' ) ) ; $ copy -> setRelation ( 'metaAttributes' , $ metaAttributes ) ; return $ next ( $ copy , $ args ) ; } ; }
11827	public function getBom ( $ encoding = 'UTF-8' ) { $ boms = array ( 'UTF-8' => pack ( 'CCC' , 0xef , 0xbb , 0xbf ) , 'UTF-16 Big Endian' => pack ( 'CC' , 0xfe , 0xff ) , 'UTF-16 Little Endian' => pack ( 'CC' , 0xff , 0xfe ) , 'UTF-32 Big Endian' => pack ( 'CCCC' , 0x00 , 0x00 , 0xfe , 0xff ) , 'UTF-32 Little Endian' => pack ( 'CCCC' , 0xff , 0xfe , 0x00 , 0x00 ) , 'SCSU' => pack ( 'CCC' , 0x0e , 0xfe , 0xff ) , 'UTF-7 (1)' => pack ( 'CCCC' , 0x2b , 0x2f , 0x76 , 0x38 ) , 'UTF-7 (2)' => pack ( 'CCCC' , 0x2b , 0x2f , 0x76 , 0x39 ) , 'UTF-7 (3)' => pack ( 'CCCC' , 0x2b , 0x2f , 0x76 , 0x2b ) , 'UTF-7 (4)' => pack ( 'CCCC' , 0x2b , 0x2f , 0x76 , 0x2f ) , 'UTF-7 (5)' => pack ( 'CCCCC' , 0x2b , 0x2f , 0x76 , 0x38 , 0x2d ) , 'UTF-1' => pack ( 'CCC' , 0xF7 , 0x64 , 0x4c ) , 'UTF-EBCDIC' => pack ( 'CCCC' , 0xdd , 0x73 , 0x66 , 0x73 ) , 'BOCU-1' => pack ( 'CCC' , 0xfb , 0xee , 0x28 ) , 'GB-18030' => pack ( 'CCCC' , 0x84 , 0x31 , 0x95 , 0x33 ) , ) ; if ( 'all' == $ encoding ) { return $ boms ; } return $ boms [ $ encoding ] ; }
9281	public function getPending ( array $ options = array ( ) ) { $ where = new Where ( ) ; $ where -> equalTo ( "{$this->tableName}.status" , JobEntity :: STATUS_PENDING ) ; return $ this -> fetchByWhere ( $ where , $ options ) ; }
9797	public function getHyperlink ( ) { if ( ! isset ( $ this -> parent ) ) { throw new Exception ( 'Cannot get hyperlink for cell that is not bound to a worksheet' ) ; } return $ this -> getWorksheet ( ) -> getHyperlink ( $ this -> getCoordinate ( ) ) ; }
9781	private function setFlag ( string $ name , bool $ value = true ) : self { $ this -> flags [ $ name ] = $ value ; return $ this ; }
474	public function update ( $ table , $ columns , $ condition = '' , $ params = [ ] ) { $ time = $ this -> beginCommand ( "update $table" ) ; $ this -> db -> createCommand ( ) -> update ( $ table , $ columns , $ condition , $ params ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
4714	public function replaceString ( $ search , $ replace ) { $ this -> text = str_replace ( $ search , $ replace , $ this -> text ) ; return $ this ; }
12709	public static function parse ( string $ word ) : array { $ word = ltrim ( rtrim ( trim ( $ word ) , '}' ) , '{' ) ; if ( $ separatorPosition = strpos ( $ word , '=' ) ) { $ key = substr ( $ word , 0 , $ separatorPosition ) ; $ defaultValue = substr ( $ word , $ separatorPosition + 1 ) ; return [ $ key , $ defaultValue ] ; } return [ $ word , null ] ; }
7993	public function getDiskUsage ( $ diskId , $ type ) { return json_decode ( self :: getClient ( ) -> getDiskUsage ( $ this -> getDomain ( ) , $ diskId , $ type ) ) ; }
3723	public function addMetaModelNames ( $ metaModelNames ) { $ this -> metaModelNames = array_unique ( array_merge ( $ this -> metaModelNames , $ metaModelNames ) ) ; return $ this ; }
5409	public function selectAsPairs ( $ url ) { $ pairs = array ( ) ; foreach ( $ this -> cookies as $ cookie ) { if ( $ this -> isMatch ( $ cookie , $ url -> getHost ( ) , $ url -> getPath ( ) , $ cookie -> getName ( ) ) ) { $ pairs [ ] = $ cookie -> getName ( ) . '=' . $ cookie -> getValue ( ) ; } } return $ pairs ; }
676	public function setPage ( $ value , $ validatePage = false ) { if ( $ value === null ) { $ this -> _page = null ; } else { $ value = ( int ) $ value ; if ( $ validatePage && $ this -> validatePage ) { $ pageCount = $ this -> getPageCount ( ) ; if ( $ value >= $ pageCount ) { $ value = $ pageCount - 1 ; } } if ( $ value < 0 ) { $ value = 0 ; } $ this -> _page = $ value ; } }
208	public static function select ( $ prompt , $ options = [ ] ) { top : static :: stdout ( "$prompt [" . implode ( ',' , array_keys ( $ options ) ) . ',?]: ' ) ; $ input = static :: stdin ( ) ; if ( $ input === '?' ) { foreach ( $ options as $ key => $ value ) { static :: output ( " $key - $value" ) ; } static :: output ( ' ? - Show help' ) ; goto top ; } elseif ( ! array_key_exists ( $ input , $ options ) ) { goto top ; } return $ input ; }
3504	private function createByReason ( string $ reason , array $ json ) : SendNotificationException { $ reason = strtolower ( $ reason ) ; switch ( $ reason ) { case 'badcollapseid' : return new BadCollapseIdException ( ) ; case 'baddevicetoken' : return new BadDeviceTokenException ( ) ; case 'badexpirationdate' : return new BadExpirationDateException ( ) ; case 'badmessageid' : return new BadMessageIdException ( ) ; case 'badpriority' : return new BadPriorityException ( ) ; case 'badtopic' : return new BadTopicException ( ) ; case 'devicetokennotfortopic' : return new DeviceTokenNotForTopicException ( ) ; case 'duplicateheaders' : return new DuplicateHeadersException ( ) ; case 'idletimeout' : return new IdleTimeoutException ( ) ; case 'missingdevicetoken' : return new MissingDeviceTokenException ( ) ; case 'missingtopic' : return new MissingTopicException ( ) ; case 'payloadempty' : return new PayloadEmptyException ( ) ; case 'topicdisallowed' : return new TopicDisallowedException ( ) ; case 'badcertificate' : return new BadCertificateException ( ) ; case 'badcertificateenvironment' : return new BadCertificateEnvironmentException ( ) ; case 'expiredprovidertoken' : return new ExpiredProviderTokenException ( ) ; case 'forbidden' : return new ForbiddenException ( ) ; case 'invalidprovidertoken' : return new InvalidProviderTokenException ( ) ; case 'missingprovidertoken' : return new MissingProviderTokenException ( ) ; case 'badpath' : return new BadPathException ( ) ; case 'methodnotallowed' : return new MethodNotAllowedException ( ) ; case 'unregistered' : $ timestamp = array_key_exists ( 'timestamp' , $ json ) ? $ json [ 'timestamp' ] : 0 ; $ lastConfirmed = new \ DateTime ( 'now' , new \ DateTimeZone ( 'UTC' ) ) ; $ lastConfirmed -> setTimestamp ( $ timestamp ) ; return new UnregisteredException ( $ lastConfirmed ) ; case 'payloadtoolarge' : return new PayloadTooLargeException ( ) ; case 'toomanyprovidertokenupdates' : return new TooManyProviderTokenUpdatesException ( ) ; case 'toomanyrequests' : return new TooManyRequestsException ( ) ; case 'internalservererror' : return new InternalServerErrorException ( ) ; case 'serviceunavailable' : return new ServiceUnavailableException ( ) ; case 'shutdown' : return new ShutdownException ( ) ; default : return new UndefinedErrorException ( ) ; } }
2938	public function deleteBackups ( $ filePaths = [ ] ) { if ( empty ( $ filePaths ) ) { $ allBackups = $ this -> getBackups ( ) ; foreach ( $ allBackups as $ backup ) { $ filePaths [ ] = $ backup [ 'filepath' ] ; } } foreach ( $ filePaths as $ filePath ) { if ( is_file ( $ filePath ) ) { unlink ( $ filePath ) ; } } return $ this ; }
8217	public static function getRefererQueryParam ( $ url , $ key ) { if ( ! $ url ) { return null ; } $ query = [ ] ; parse_str ( parse_url ( $ url , PHP_URL_QUERY ) , $ query ) ; if ( isset ( $ query [ $ key ] ) ) { return $ query [ $ key ] ; } return null ; }
875	private function convertToNowdoc ( Token $ token ) { return new Token ( [ $ token -> getId ( ) , Preg :: replace ( '/^([Bb]?<<<)([ \t]*)"?([^\s"]+)"?/' , '$1$2\'$3\'' , $ token -> getContent ( ) ) , ] ) ; }
10017	public function addNamedRange ( NamedRange $ namedRange ) { if ( $ namedRange -> getScope ( ) == null ) { $ this -> namedRanges [ $ namedRange -> getName ( ) ] = $ namedRange ; } else { $ this -> namedRanges [ $ namedRange -> getScope ( ) -> getTitle ( ) . '!' . $ namedRange -> getName ( ) ] = $ namedRange ; } return true ; }
10007	public function getRibbonBinObjects ( $ what = 'all' ) { $ ReturnData = null ; $ what = strtolower ( $ what ) ; switch ( $ what ) { case 'all' : return $ this -> ribbonBinObjects ; break ; case 'names' : case 'data' : if ( is_array ( $ this -> ribbonBinObjects ) && isset ( $ this -> ribbonBinObjects [ $ what ] ) ) { $ ReturnData = $ this -> ribbonBinObjects [ $ what ] ; } break ; case 'types' : if ( is_array ( $ this -> ribbonBinObjects ) && isset ( $ this -> ribbonBinObjects [ 'data' ] ) && is_array ( $ this -> ribbonBinObjects [ 'data' ] ) ) { $ tmpTypes = array_keys ( $ this -> ribbonBinObjects [ 'data' ] ) ; $ ReturnData = array_unique ( array_map ( [ $ this , 'getExtensionOnly' ] , $ tmpTypes ) ) ; } else { $ ReturnData = [ ] ; } break ; } return $ ReturnData ; }
2662	public function getBackends ( $ version ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/backend' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; }
7868	private function replaceUtf8 ( & $ original , $ replacement , $ position ) { $ start = mb_substr ( $ original , 0 , $ position , "UTF-8" ) ; $ end = mb_substr ( $ original , $ position + 1 , mb_strlen ( $ original , 'UTF-8' ) , "UTF-8" ) ; $ original = $ start . $ replacement . $ end ; }
10258	public function getCompanyName ( $ base_name = null ) { $ suffixes = [ 'Corporation' , 'Company' , 'Company, Limited' , 'Computer Repair' , 'Incorporated' , 'and Sons' , 'Group' , 'Group, PLC' , 'Furniture' , 'Flowers' , 'Sales' , 'Systems' , 'Tire' , 'Auto' , 'Plumbing' , 'Roofing' , 'Realty' , 'Foods' , 'Books' ] ; if ( empty ( $ base_name ) ) { $ base_name = $ this -> getLastName ( ) ; } return $ base_name . ' ' . $ this -> fromArray ( $ suffixes ) ; }
3209	function createOAuth2AccessToken ( $ oauth1AccessToken ) { OAuth1AccessToken :: checkArg ( "oauth1AccessToken" , $ oauth1AccessToken ) ; $ response = self :: doPost ( $ oauth1AccessToken , "1/oauth2/token_from_oauth1" ) ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; $ parts = RequestUtil :: parseResponseJson ( $ response -> body ) ; if ( ! array_key_exists ( 'token_type' , $ parts ) || ! is_string ( $ parts [ 'token_type' ] ) ) { throw new Exception_BadResponse ( "Missing \"token_type\" field." ) ; } $ tokenType = $ parts [ 'token_type' ] ; if ( ! array_key_exists ( 'access_token' , $ parts ) || ! is_string ( $ parts [ 'access_token' ] ) ) { throw new Exception_BadResponse ( "Missing \"access_token\" field." ) ; } $ accessToken = $ parts [ 'access_token' ] ; if ( $ tokenType !== "Bearer" && $ tokenType !== "bearer" ) { throw new Exception_BadResponse ( "Unknown \"token_type\"; expecting \"Bearer\", got " . Util :: q ( $ tokenType ) ) ; } return $ accessToken ; }
7683	function Ext_GetMainIdx ( ) { if ( ( $ this -> ExtInfo !== false ) && isset ( $ this -> ExtInfo [ 'main' ] ) ) { return $ this -> FileGetIdx ( $ this -> ExtInfo [ 'main' ] ) ; } else { return false ; } }
8912	protected function _fetch_primary_key ( ) { if ( $ this -> is_base_model_instance ( ) ) { return ; } if ( $ this -> primary_key == NULL && $ this -> _database ) { $ this -> primary_key = $ this -> execute_query ( "SHOW KEYS FROM `" . $ this -> _database -> dbprefix ( $ this -> _table ) . "` WHERE Key_name = 'PRIMARY'" ) -> row ( ) -> Column_name ; } }
10133	public function insertBitmap ( $ row , $ col , $ bitmap , $ x = 0 , $ y = 0 , $ scale_x = 1 , $ scale_y = 1 ) { $ bitmap_array = ( is_resource ( $ bitmap ) ? $ this -> processBitmapGd ( $ bitmap ) : $ this -> processBitmap ( $ bitmap ) ) ; list ( $ width , $ height , $ size , $ data ) = $ bitmap_array ; $ width *= $ scale_x ; $ height *= $ scale_y ; $ this -> positionImage ( $ col , $ row , $ x , $ y , $ width , $ height ) ; $ record = 0x007f ; $ length = 8 + $ size ; $ cf = 0x09 ; $ env = 0x01 ; $ lcb = $ size ; $ header = pack ( 'vvvvV' , $ record , $ length , $ cf , $ env , $ lcb ) ; $ this -> append ( $ header . $ data ) ; }
1994	public static function indexPageIfApplicable ( Response $ objResponse ) { global $ objPage ; if ( $ objPage === null ) { return ; } if ( Config :: get ( 'enableSearch' ) && $ objResponse -> getStatusCode ( ) == 200 && ! BE_USER_LOGGED_IN && ! $ objPage -> noSearch ) { if ( Config :: get ( 'indexProtected' ) || ( ! FE_USER_LOGGED_IN && ! $ objPage -> protected ) ) { $ blnIndex = true ; foreach ( array_keys ( $ _GET ) as $ key ) { if ( \ in_array ( $ key , $ GLOBALS [ 'TL_NOINDEX_KEYS' ] ) || strncmp ( $ key , 'page_' , 5 ) === 0 ) { $ blnIndex = false ; break ; } } if ( $ blnIndex ) { $ arrData = array ( 'url' => Environment :: get ( 'base' ) . Environment :: get ( 'relativeRequest' ) , 'content' => $ objResponse -> getContent ( ) , 'title' => $ objPage -> pageTitle ? : $ objPage -> title , 'protected' => ( $ objPage -> protected ? '1' : '' ) , 'groups' => $ objPage -> groups , 'pid' => $ objPage -> id , 'language' => $ objPage -> language ) ; Search :: indexPage ( $ arrData ) ; } } } }
1757	public static function getReadableSize ( $ intSize , $ intDecimals = 1 ) { for ( $ i = 0 ; $ intSize >= 1024 ; $ i ++ ) { $ intSize /= 1024 ; } return static :: getFormattedNumber ( $ intSize , $ intDecimals ) . ' ' . $ GLOBALS [ 'TL_LANG' ] [ 'UNITS' ] [ $ i ] ; }
8455	protected function argsForNextCommand ( $ args ) { if ( ! is_array ( $ args ) ) { $ args = func_get_args ( ) ; } $ this -> argumentsForNextCommand .= ' ' . implode ( ' ' , $ args ) ; return $ this ; }
4181	public function getResources ( ) { return $ this -> resources ? : $ this -> resources = Resource :: instance ( clone $ this -> getFiles ( ) , $ this -> console ) ; }
8214	protected function getTubeStats ( $ tube ) { try { $ stats = $ this -> getPheanstalk ( ) -> statsTube ( $ tube ) ; } catch ( ServerException $ e ) { if ( $ this -> isNotFoundException ( $ e ) ) { throw new \ RuntimeException ( "Tube '$tube' doesn't exist." ) ; } throw $ e ; } return $ stats ; }
1149	protected function setDefaults ( $ options ) { $ this -> selector = empty ( $ options [ 'selector' ] ) ? 'form' : $ options [ 'selector' ] ; $ this -> view = empty ( $ options [ 'view' ] ) ? 'jsvalidation::bootstrap' : $ options [ 'view' ] ; $ this -> remote = isset ( $ options [ 'remote' ] ) ? $ options [ 'remote' ] : true ; }
4489	public function registerDevice ( string $ deviceId , string $ platform , ? string $ userData = null ) : string { if ( ! isset ( $ this -> arns [ $ platform ] ) ) { throw new PlatformNotConfiguredException ( "There is no configured ARN for $platform" ) ; } try { $ args = [ 'PlatformApplicationArn' => $ this -> arns [ $ platform ] , 'Token' => $ deviceId , 'Attributes' => [ 'Enabled' => 'true' , ] , ] ; if ( $ userData ) { $ args [ 'CustomUserData' ] = $ userData ; } $ res = $ this -> sns -> createPlatformEndpoint ( $ args ) ; } catch ( SnsException $ e ) { preg_match ( '/Endpoint (.+?) already/' , $ e -> getMessage ( ) , $ matches ) ; if ( isset ( $ matches [ 1 ] ) ) { $ this -> sns -> setEndpointAttributes ( [ 'EndpointArn' => $ matches [ 1 ] , 'Attributes' => [ 'Enabled' => 'true' , ] , ] ) ; return $ matches [ 1 ] ; } else { throw $ e ; } } return $ res [ 'EndpointArn' ] ; }
9828	public function getCreateAssociationName ( $ modelName , $ otherModelName ) { return sprintf ( 'auja.%s.%s.create' , $ this -> toUrlName ( $ modelName ) , $ this -> toUrlName ( $ otherModelName ) ) ; }
1487	public function merge ( DecodingList $ decodings ) : self { $ copy = new self ( ) ; $ copy -> stack = collect ( $ this -> stack ) -> merge ( $ decodings -> stack ) -> all ( ) ; return $ copy ; }
12220	public function exceptionHandler ( $ exception ) { $ request = ( isset ( $ this -> container [ 'latestRequest' ] ) ? $ this -> container [ 'latestRequest' ] : $ this -> container [ 'request' ] ) ; $ response = ( isset ( $ this -> container [ 'latestResponse' ] ) ? $ this -> container [ 'latestResponse' ] : $ this -> container [ 'response' ] ) ; if ( ! ( $ exception instanceof Exception ) ) { $ exception = new InternalServerError ( $ exception -> getMessage ( ) , $ exception -> getCode ( ) , $ exception -> getPrevious ( ) ) ; } $ this -> logException ( $ exception ) ; $ response = $ response -> withBody ( new Stream ( 'php://memory' , 'w+' ) ) ; $ response = $ response -> withStatus ( $ exception -> getStatusCode ( ) ) ; $ body = $ this -> prepareErrorBody ( $ exception ) ; $ response = $ response -> withUnserializedBody ( $ body ) ; $ this -> container [ 'pipeline' ] -> prepareErrorQueue ( ) ; $ this -> container [ 'pipeline' ] ( $ request , $ response ) ; }
8100	protected function validate ( $ name , $ limit , $ regEx = false ) { $ Name = ucfirst ( $ name ) ; $ value = $ this -> _updates -> $ name ; $ length = explode ( '-' , $ limit ) ; $ min = intval ( $ length [ 0 ] ) ; $ max = intval ( $ length [ 1 ] ) ; if ( ! $ max and ! $ min ) { $ this -> log -> error ( "Invalid second parameter for the $name validation" ) ; return false ; } if ( ! $ value ) { if ( is_null ( $ value ) ) { $ this -> log -> report ( "Missing index $name from the input" ) ; } if ( strlen ( $ value ) == $ min ) { $ this -> log -> report ( "$Name is blank and optional - skipped" ) ; return true ; } $ this -> log -> formError ( $ name , "$Name is required." ) ; return false ; } if ( strlen ( $ value ) > $ max ) { $ this -> log -> formError ( $ name , "The $Name is larger than $max characters." ) ; return false ; } if ( strlen ( $ value ) < $ min ) { $ this -> log -> formError ( $ name , "The $Name is too short. It should at least be $min characters long" ) ; return false ; } if ( $ regEx ) { preg_match ( $ regEx , $ value , $ match ) ; if ( preg_match ( $ regEx , $ value , $ match ) === 0 ) { $ this -> log -> formError ( $ name , "The $Name \"{$value}\" is not valid" ) ; return false ; } } $ this -> log -> report ( "The $name is Valid" ) ; return true ; }
5684	public function getUrlById ( $ id ) { foreach ( $ this -> links as $ link ) { if ( $ link -> getAttribute ( 'id' ) === ( string ) $ id ) { return $ this -> getUrlFromLink ( $ link ) ; } } return false ; }
2677	public function deleteAclItem ( $ aclId , $ aclItemId ) { $ url = $ this -> _getApiServiceUri ( ) . 'acl/' . $ aclId . '/entry/' . $ aclItemId ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: DELETE ) ; return $ result ; }
11956	function addQueue ( $ channel , $ queue , $ weight = 1 ) { $ orig = $ channel ; $ channel = $ this -> _normalizeQueueName ( $ channel ) ; if ( ! $ queue instanceof iQueueDriver ) throw new \ Exception ( sprintf ( 'Queue must be instance of iQueueDriver; given: (%s).' , \ Poirot \ Std \ flatten ( $ queue ) ) ) ; if ( isset ( $ this -> channels_queue [ $ channel ] ) ) throw new \ RuntimeException ( sprintf ( 'Channel (%s) is currently filled with (%s) and is not empty.' , $ orig , get_class ( $ this -> channels_queue [ $ channel ] ) ) ) ; $ this -> channels_queue [ $ channel ] = $ queue ; $ this -> channels_weight [ $ channel ] = $ weight ; return $ this ; }
3845	protected static function upgradeDcaSettingsPublished ( ) { $ objDB = self :: DB ( ) ; if ( $ objDB -> tableExists ( 'tl_metamodel_dcasetting' , null , true ) && ! $ objDB -> fieldExists ( 'published' , 'tl_metamodel_dcasetting' , true ) ) { TableManipulation :: createColumn ( 'tl_metamodel_dcasetting' , 'published' , 'char(1) NOT NULL default \'\'' ) ; $ objDB -> execute ( 'UPDATE tl_metamodel_dcasetting SET published=1;' ) ; } }
2499	private function getAlwaysAvailableFilter ( array $ languageCodes ) { $ conditions = array ( new CustomField ( self :: FIELD_IS_ALWAYS_AVAILABLE , Operator :: EQ , true ) , new LogicalNot ( new CustomField ( self :: FIELD_LANGUAGES , Operator :: IN , $ languageCodes ) ) , ) ; if ( $ this -> hasMainLanguagesEndpoint ) { $ conditions [ ] = new CustomField ( self :: FIELD_IS_MAIN_LANGUAGES_INDEX , Operator :: EQ , true ) ; } return new LogicalAnd ( $ conditions ) ; }
11705	public function synchronizeEntity ( $ sSynchronizeEntity , $ iId = null ) { if ( $ iId !== null ) { $ this -> _iIdEntity = $ iId ; } $ this -> _sSynchronizeEntity = $ sSynchronizeEntity ; return $ this ; }
9059	public function addUnique ( string ... $ name ) : self { $ key = new Index ( ... $ name ) ; $ key -> setUnique ( ) ; $ this -> keys [ $ key -> name ] = $ key ; return $ this ; }
1373	public function all ( ) { if ( is_array ( $ this -> data ) ) { return $ this -> data ; } return $ this -> data = $ this -> route -> getCodec ( ) -> all ( $ this -> request ) ; }
3007	public function setLayout ( $ layout ) { if ( $ layout === "" || $ layout === null ) { $ this -> layout = null ; } else { $ layoutPath = $ this -> templatePath . $ layout ; if ( ! is_file ( $ layoutPath ) ) { throw new \ RuntimeException ( "Layout template `$layout` does not exist" ) ; } $ this -> layout = $ layoutPath ; } }
12878	public function setValue ( $ value ) { $ this -> value = $ value ; if ( is_array ( $ value ) && array_key_exists ( 'start' , $ value ) && array_key_exists ( 'end' , $ value ) ) { $ start = ( float ) $ value [ 'start' ] ; $ end = ( float ) $ value [ 'end' ] ; if ( $ start <= $ end ) { $ this -> startElement -> setValue ( $ start ) ; $ this -> endElement -> setValue ( $ end ) ; } } return $ this ; }
8445	public function getUser ( IncomingMessage $ matchingMessage ) { $ sender_id = $ matchingMessage -> getRecipient ( ) ; $ user = Collection :: make ( $ this -> payload -> get ( 'users' ) ) -> first ( function ( $ user ) use ( $ sender_id ) { return $ user [ 'id' ] === $ sender_id ; } ) ; return new User ( $ user [ 'id' ] , null , null , $ user [ 'name' ] , $ user ) ; }
8048	public function receive ( ) { $ hdr = '' ; do { $ read = socket_read ( $ this -> socket , 4 - strlen ( $ hdr ) ) ; if ( $ read === FALSE ) { throw new SimpleSocketException ( 'Reception failed with: ' . socket_strerror ( socket_last_error ( $ this -> socket ) ) ) ; } elseif ( $ read === '' || $ read === NULL ) { return NULL ; } $ hdr .= $ read ; } while ( strlen ( $ hdr ) < 4 ) ; list ( $ len ) = array_values ( unpack ( "N" , $ hdr ) ) ; $ buffer = '' ; do { $ read = socket_read ( $ this -> socket , $ len - strlen ( $ buffer ) ) ; if ( $ read === FALSE || $ read == '' ) { throw new SimpleSocketException ( 'Reception failed with: ' . socket_strerror ( socket_last_error ( $ this -> socket ) ) ) ; } elseif ( $ read == '' ) { return NULL ; } $ buffer .= $ read ; } while ( strlen ( $ buffer ) < $ len ) ; $ data = unserialize ( $ buffer ) ; return $ data ; }
5526	protected function createCodeForSubclass ( $ methods ) { $ code = "" ; if ( ! empty ( $ this -> namespace ) ) { $ code .= 'namespace ' . $ this -> namespace . ";\n" ; } $ code .= 'class ' . $ this -> mock_class . ' extends ' . $ this -> class . " {\n" ; $ code .= " public \$mock;\n" ; $ code .= $ this -> addMethodList ( array_merge ( $ methods , $ this -> reflection -> getMethods ( ) ) ) ; $ code .= "\n" ; $ code .= " function __construct() {\n" ; $ code .= ' $this->mock = new \\' . $ this -> mock_base . "();\n" ; $ code .= " \$this->mock->disableExpectationNameChecks();\n" ; $ code .= " }\n" ; $ code .= $ this -> createCodeForConstructor ( ) ; $ code .= $ this -> chainMockReturns ( ) ; $ code .= $ this -> chainMockExpectations ( ) ; $ code .= $ this -> chainThrowMethods ( ) ; $ code .= $ this -> createCodeForOverridenMethods ( $ this -> reflection -> getMethods ( ) ) ; $ code .= $ this -> createCodeForNewMethod ( $ methods ) ; $ code .= "}\n" ; return $ code ; }
5702	public function isCustomActionAllowed ( $ action ) { $ actions = $ this -> owner -> config ( ) -> better_buttons_actions ; if ( $ actions ) { return in_array ( $ action , $ actions ) ; } return false ; }
5991	public function setDeploymentDateRange ( $ deploymentDateRange ) { if ( $ deploymentDateRange instanceof DateTimeRange ) { $ this -> deploymentDateRange = $ deploymentDateRange ; } elseif ( is_array ( $ deploymentDateRange ) ) { $ this -> deploymentDateRange = new DateTimeRange ( $ deploymentDateRange ) ; } else { $ this -> deploymentDateRange = null ; trigger_error ( 'Argument must be an object of class DateTimeRange. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
10122	private function writePrintHeaders ( ) { $ record = 0x002a ; $ length = 0x0002 ; $ fPrintRwCol = $ this -> printHeaders ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ fPrintRwCol ) ; $ this -> append ( $ header . $ data ) ; }
9712	private function writeSupbookInternal ( ) { $ record = 0x01AE ; $ length = 0x0004 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vv' , $ this -> spreadsheet -> getSheetCount ( ) , 0x0401 ) ; return $ this -> writeData ( $ header . $ data ) ; }
10883	public function reportException ( \ Exception $ ex ) { $ report = new ErrorStreamReport ( ) ; $ report -> error_group = $ ex -> getMessage ( ) . ':' . $ ex -> getLine ( ) ; $ report -> line_number = $ ex -> getLine ( ) ; $ report -> file_name = $ ex -> getFile ( ) ; $ report -> message = $ ex -> getMessage ( ) ; $ report -> stack_trace = $ ex -> getTraceAsString ( ) ; $ report -> severity = 3 ; return $ this -> report ( $ report ) ; }
8518	public function setSelectionRecommendations ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'SelectionRecommendations' ] [ 'FieldValue' ] = $ value ; return $ this ; }
3271	public function writeTempToFile ( SplTempFileObject & $ tmpFile ) { $ file = $ this -> openFile ( static :: FILE_WRITE ) ; foreach ( $ tmpFile as $ line ) { $ file -> fwrite ( $ line ) ; } $ this -> closeFile ( $ file ) ; $ tmpFile = null ; }
11154	public function getArrayKeyByPowers ( array $ powers ) { if ( empty ( $ powers ) ) { throw new InvalidArgumentException ( 'Empty powers set' ) ; } $ powersSum = 0 ; foreach ( $ powers as $ power ) { if ( $ power < 0 ) { throw new InvalidArgumentException ( 'Negative power found' ) ; } $ powersSum += $ power ; } if ( $ powersSum <= 0 ) { throw new InvalidArgumentException ( 'The sum of powers must be positive' ) ; } $ randomValue = $ this -> generator -> getFloat ( 0 , $ powersSum ) ; $ currentSum = 0 ; $ result = null ; foreach ( $ powers as $ key => $ power ) { $ currentSum += $ power ; if ( $ currentSum >= $ randomValue ) { $ result = $ key ; break ; } } return $ key ; }
3545	protected function write ( $ file , $ file_path ) { if ( ! is_dir ( dirname ( $ file_path ) ) ) { mkdir ( dirname ( $ file_path ) , 0755 , true ) ; } file_put_contents ( $ file_path , file_get_contents ( dirname ( __FILE__ ) . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . 'templates' . DIRECTORY_SEPARATOR . $ file . '.txt' ) ) ; }
11519	protected function GenerateAndroidPinicon ( SiteConfig $ config , SiteTree $ owner , & $ metadata ) { $ metadata .= $ owner -> MarkupComment ( 'Android Pinned Icon' ) ; if ( $ config -> fetchAndroidPiniconThemeColor ( ) ) { $ metadata .= $ owner -> MarkupMeta ( 'theme-color' , $ config -> fetchAndroidPiniconThemeColor ( ) ) ; } $ metadata .= $ owner -> MarkupLink ( 'manifest' , '/manifest.json' ) ; }
2595	public static function findMessage ( $ code ) { $ message = null ; if ( array_key_exists ( $ code , self :: $ errorList ) ) { $ message = self :: $ errorList [ $ code ] ; } return $ message ; }
7433	public function export ( Defender $ defender ) { $ content = json_encode ( $ defender -> dangerFiles ) ; $ name = 'defender/defender-' . $ this -> date . '.json' ; if ( $ this -> storage -> exists ( $ name ) ) { $ this -> storage -> delete ( $ name ) ; } $ this -> storage -> put ( $ name , $ content ) ; }
9318	public function rotate ( $ angle , $ background = 'FFFFFF' ) { $ angle = intval ( $ angle ) ; if ( ! is_int ( $ angle ) || ( $ angle < 0 ) || ( $ angle > 360 ) ) { throw new ezcBaseValueException ( 'height' , $ height , 'angle < 0 or angle > 360' ) ; } $ angle = 360 - $ angle ; $ background = "#{$background}" ; $ this -> addFilterOption ( $ this -> getActiveReference ( ) , '-background' , $ background ) ; $ this -> addFilterOption ( $ this -> getActiveReference ( ) , '-rotate' , $ angle ) ; }
11913	public function current ( ) { $ current = current ( $ this -> storage ) ; if ( $ this -> useMapEntries ) { return new MapEntry ( $ current [ 0 ] , $ current [ 1 ] ) ; } return $ current [ 1 ] ; }
2184	protected function getAllEvents ( $ arrCalendars , $ intStart , $ intEnd ) { if ( ! \ is_array ( $ arrCalendars ) ) { return array ( ) ; } $ this -> arrEvents = array ( ) ; foreach ( $ arrCalendars as $ id ) { $ objEvents = CalendarEventsModel :: findCurrentByPid ( $ id , $ intStart , $ intEnd ) ; if ( $ objEvents === null ) { continue ; } while ( $ objEvents -> next ( ) ) { $ this -> addEvent ( $ objEvents , $ objEvents -> startTime , $ objEvents -> endTime , $ intStart , $ intEnd , $ id ) ; if ( $ objEvents -> recurring ) { $ arrRepeat = StringUtil :: deserialize ( $ objEvents -> repeatEach ) ; if ( ! \ is_array ( $ arrRepeat ) || ! isset ( $ arrRepeat [ 'unit' ] ) || ! isset ( $ arrRepeat [ 'value' ] ) || $ arrRepeat [ 'value' ] < 1 ) { continue ; } $ count = 0 ; $ intStartTime = $ objEvents -> startTime ; $ intEndTime = $ objEvents -> endTime ; $ strtotime = '+ ' . $ arrRepeat [ 'value' ] . ' ' . $ arrRepeat [ 'unit' ] ; while ( $ intEndTime < $ intEnd ) { if ( $ objEvents -> recurrences > 0 && $ count ++ >= $ objEvents -> recurrences ) { break ; } $ intStartTime = strtotime ( $ strtotime , $ intStartTime ) ; $ intEndTime = strtotime ( $ strtotime , $ intEndTime ) ; if ( $ intStartTime === false || $ intEndTime === false ) { break ; } if ( $ intEndTime < $ intStart || $ intStartTime > $ intEnd ) { continue ; } $ this -> addEvent ( $ objEvents , $ intStartTime , $ intEndTime , $ intStart , $ intEnd , $ id ) ; } } } } foreach ( array_keys ( $ this -> arrEvents ) as $ key ) { ksort ( $ this -> arrEvents [ $ key ] ) ; } if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getAllEvents' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getAllEvents' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getAllEvents' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> arrEvents = $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ this -> arrEvents , $ arrCalendars , $ intStart , $ intEnd , $ this ) ; } } return $ this -> arrEvents ; }
12619	protected function loadForeignDataItems ( ) { if ( ! $ this -> fileSource ) { \ d ( "boom" ) ; return false ; } $ foreignModelClass = $ this -> foreignModelClass ; $ lines = $ this -> fileSource -> getLines ( $ this -> lazyForeign ) ; $ lineCount = 0 ; foreach ( $ lines as $ id => $ line ) { if ( $ this -> lazyForeign ) { $ this -> createForeignDataItem ( null , [ 'deferredModel' => $ line ] ) ; } else { $ model = $ this -> createModel ( $ line -> id , $ line -> attributes ) ; $ this -> createForeignDataItem ( $ model , [ 'deferredModel' => $ line ] ) ; } $ lineCount ++ ; } $ this -> task -> addInfo ( "Processed {$lineCount} lines from {$this->fileSource->id}" ) ; }
4868	protected function parseOptionsToDateTime ( $ options ) { $ time = microtime ( true ) ; $ micro = sprintf ( "%06d" , ( $ time - floor ( $ time ) ) * 1000000 ) ; $ this -> now = new \ DateTime ( date ( 'Y-m-d H:i:s.' . $ micro , $ time ) , new \ DateTimeZone ( date_default_timezone_get ( ) ) ) ; $ scheduled = isset ( $ options [ 'scheduled' ] ) ? Utils :: createDateTime ( $ options [ 'scheduled' ] ) : clone ( $ this -> now ) ; if ( isset ( $ options [ 'delay' ] ) ) { $ delay = Utils :: createDateInterval ( $ options [ 'delay' ] ) ; $ scheduled -> add ( $ delay ) ; } return $ scheduled ; }
7609	public function process ( ServerRequestInterface $ request , RequestHandlerInterface $ handler ) : ResponseInterface { $ requestHandler = $ request -> getAttribute ( $ this -> handlerAttribute ) ; if ( empty ( $ requestHandler ) ) { if ( $ this -> continueOnEmpty ) { return $ handler -> handle ( $ request ) ; } throw new RuntimeException ( 'Empty request handler' ) ; } if ( is_string ( $ requestHandler ) ) { $ requestHandler = $ this -> container -> get ( $ requestHandler ) ; } if ( is_array ( $ requestHandler ) && count ( $ requestHandler ) === 2 && is_string ( $ requestHandler [ 0 ] ) ) { $ requestHandler [ 0 ] = $ this -> container -> get ( $ requestHandler [ 0 ] ) ; } if ( $ requestHandler instanceof MiddlewareInterface ) { return $ requestHandler -> process ( $ request , $ handler ) ; } if ( $ requestHandler instanceof RequestHandlerInterface ) { return $ requestHandler -> handle ( $ request ) ; } if ( is_callable ( $ requestHandler ) ) { return ( new CallableHandler ( $ requestHandler ) ) -> process ( $ request , $ handler ) ; } throw new RuntimeException ( sprintf ( 'Invalid request handler: %s' , gettype ( $ requestHandler ) ) ) ; }
5136	public static function handleShutdown ( ) { if ( ! empty ( $ error = error_get_last ( ) ) ) { self :: handleException ( new FatalException ( $ error [ 'message' ] , $ error [ 'type' ] , 0 , $ error [ 'file' ] , $ error [ 'line' ] ) ) ; } }
10000	public function setSoftEdgesSize ( $ size ) { if ( $ size !== null ) { $ this -> activateObject ( ) ; $ softEdges [ 'size' ] = ( string ) $ this -> getExcelPointsWidth ( $ size ) ; } }
3516	public function setLocale ( $ locale ) { if ( $ this -> useCookies ) { Cookie :: queue ( $ this -> cookiePrefix . 'lang_locale' , $ locale ) ; } parent :: setLocale ( $ locale ) ; }
7205	public function getBase ( bool $ ati = false ) : float { return $ ati ? $ this -> ati ( $ this -> base ) : $ this -> base ; }
8524	public function setItemList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ItemList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
997	public function offsetUnset ( $ offset ) { if ( $ offset === true ) { $ this -> trueValue = null ; $ this -> trueValueIsSet = false ; } elseif ( $ offset === false ) { $ this -> falseValue = null ; $ this -> falseValueIsSet = false ; } elseif ( is_int ( $ offset ) || is_string ( $ offset ) ) { unset ( $ this -> standardStore [ $ offset ] ) ; } elseif ( is_float ( $ offset ) ) { unset ( $ this -> floatStore [ ( string ) $ offset ] ) ; } elseif ( is_object ( $ offset ) ) { $ this -> objectStore -> offsetUnset ( $ offset ) ; } elseif ( is_array ( $ offset ) ) { $ index = array_search ( $ offset , $ this -> arrayKeys , true ) ; if ( $ index !== false ) { array_splice ( $ this -> arrayKeys , $ index , 1 ) ; array_splice ( $ this -> arrayValues , $ index , 1 ) ; } } elseif ( $ offset === null ) { $ this -> nullValue = null ; $ this -> nullValueIsSet = false ; } }
7664	function AttachAll ( ) { $ mime = array ( ) ; for ( $ i = 0 ; $ i < count ( $ this -> attachment ) ; $ i ++ ) { $ bString = $ this -> attachment [ $ i ] [ 5 ] ; if ( $ bString ) $ string = $ this -> attachment [ $ i ] [ 0 ] ; else $ path = $ this -> attachment [ $ i ] [ 0 ] ; $ filename = $ this -> attachment [ $ i ] [ 1 ] ; $ name = $ this -> attachment [ $ i ] [ 2 ] ; $ encoding = $ this -> attachment [ $ i ] [ 3 ] ; $ type = $ this -> attachment [ $ i ] [ 4 ] ; $ disposition = $ this -> attachment [ $ i ] [ 6 ] ; $ cid = $ this -> attachment [ $ i ] [ 7 ] ; $ mime [ ] = sprintf ( "--%s%s" , $ this -> boundary [ 1 ] , $ this -> LE ) ; $ mime [ ] = sprintf ( "Content-Type: %s; name=\"%s\"%s" , $ type , $ name , $ this -> LE ) ; $ mime [ ] = sprintf ( "Content-Transfer-Encoding: %s%s" , $ encoding , $ this -> LE ) ; if ( $ disposition == "inline" ) $ mime [ ] = sprintf ( "Content-ID: <%s>%s" , $ cid , $ this -> LE ) ; $ mime [ ] = sprintf ( "Content-Disposition: %s; filename=\"%s\"%s" , $ disposition , $ name , $ this -> LE . $ this -> LE ) ; if ( $ bString ) { $ mime [ ] = $ this -> EncodeString ( $ string , $ encoding ) ; if ( $ this -> IsError ( ) ) { return "" ; } $ mime [ ] = $ this -> LE . $ this -> LE ; } else { $ mime [ ] = $ this -> EncodeFile ( $ path , $ encoding ) ; if ( $ this -> IsError ( ) ) { return "" ; } $ mime [ ] = $ this -> LE . $ this -> LE ; } } $ mime [ ] = sprintf ( "--%s--%s" , $ this -> boundary [ 1 ] , $ this -> LE ) ; return join ( "" , $ mime ) ; }
11856	public function isAjax ( ) : bool { $ param = $ this -> getServerParam ( 'HTTP_X_REQUESTED_WITH' , \ FILTER_SANITIZE_STRING ) ; return ! is_null ( $ param ) && strtolower ( $ param ) === 'xmlhttprequest' ; }
10052	private function resolvePath ( $ path_alias , $ file_name ) { $ path = \ Yii :: getAlias ( $ path_alias , false ) ; $ path = $ path ? realpath ( $ path ) : $ path ; $ file_name = ! preg_match ( '/\.php$/i' , $ file_name ) ? $ file_name . '.php' : $ file_name ; if ( ! $ path || ! is_dir ( $ path ) || ! file_exists ( $ path . '/' . $ file_name ) ) { throw new Exception ( "Faker template \"{$path}/{$file_name}\" not found" ) ; } return $ path . '/' . $ file_name ; }
8015	protected function execute ( Command $ command ) { $ command -> setJar ( $ this -> getPathToPdfBox ( ) ) ; $ command -> setOptions ( $ this -> _options ) ; exec ( ( string ) $ command . ' 2>&1' , $ stdErr , $ exitCode ) ; if ( $ command -> getPdfFileIsTemp ( ) ) { unlink ( $ command -> getPdfFile ( ) ) ; } if ( $ exitCode > 0 ) { throw new \ RuntimeException ( join ( "\n" , $ stdErr ) , $ exitCode ) ; } $ resultFile = $ command -> getTextFile ( ) ; $ result = file_get_contents ( $ resultFile ) ; if ( $ command -> getTextFileIsTemp ( ) ) { unlink ( $ resultFile ) ; } return $ result ; }
6485	private function isUsingStandardPort ( ) : bool { return $ this -> port === null || ( ( $ this -> scheme === 'http' && $ this -> port === 80 ) || ( $ this -> scheme === 'https' && $ this -> port === 443 ) ) ; }
11894	public function encrypt ( $ data ) { if ( $ this -> iv === null ) { $ dataEncrypted = mcrypt_encrypt ( $ this -> cipher , $ this -> key , $ data , $ this -> mode ) ; } else { $ dataEncrypted = mcrypt_encrypt ( $ this -> cipher , $ this -> key , $ data , $ this -> mode , $ this -> iv ) ; } return bin2hex ( $ dataEncrypted ) ; }
716	public function decimal ( $ precision = null , $ scale = null ) { $ length = [ ] ; if ( $ precision !== null ) { $ length [ ] = $ precision ; } if ( $ scale !== null ) { $ length [ ] = $ scale ; } return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_DECIMAL , $ length ) ; }
4718	public function processStandardUrl ( Text $ text ) { $ hashes = array ( ) ; $ text -> replace ( '{<code>.*?</code>}m' , function ( Text $ w ) use ( & $ hashes ) { $ md5 = md5 ( $ w ) ; $ hashes [ $ md5 ] = $ w ; return "{gfm-extraction-$md5}" ; } ) ; $ text -> replace ( '{(?<!]\(|"|<|\[)((?:https?|ftp)://[^\'">\s]+)(?!>|\"|\])}' , '<\1>' ) ; $ text -> replace ( '/\{gfm-extraction-([0-9a-f]{32})\}/m' , function ( Text $ w , Text $ md5 ) use ( & $ hashes ) { return $ hashes [ ( string ) $ md5 ] ; } ) ; }
4122	private function getProxyFileName ( $ className , $ baseDir = null ) { $ proxyDir = $ baseDir ? : $ this -> proxyDir ; return $ proxyDir . DIRECTORY_SEPARATOR . '__CG__' . str_replace ( '\\' , '' , $ className ) . '.php' ; }
8290	protected function checkLogoutSubmission ( ) { $ post = $ this -> request -> request ; if ( $ post -> has ( "logout" ) ) { if ( ! $ this -> isValidCSRF ( $ post -> get ( "csrf_token" ) , self :: LOGOUT_CSRF_ACTION ) ) { $ this -> redirectToPage ( "logout" ) ; } $ this -> logout ( ) ; } }
6118	public function serverCreate ( array $ properties = array ( ) ) { $ this -> serverListReset ( ) ; $ detail = $ this -> execute ( "servercreate" , $ properties ) -> toList ( ) ; $ server = new Server ( $ this , array ( "virtualserver_id" => intval ( $ detail [ "sid" ] ) ) ) ; Signal :: getInstance ( ) -> emit ( "notifyServercreated" , $ this , $ detail [ "sid" ] ) ; Signal :: getInstance ( ) -> emit ( "notifyTokencreated" , $ server , $ detail [ "token" ] ) ; return $ detail ; }
7680	function TbsSheetSlide_DeleteDisplay ( $ id_or_name , $ ok , $ delete ) { if ( is_null ( $ ok ) ) $ ok = true ; $ ext = $ this -> ExtEquiv ; $ ok = ( boolean ) $ ok ; if ( ! is_array ( $ id_or_name ) ) $ id_or_name = array ( $ id_or_name ) ; foreach ( $ id_or_name as $ item => $ action ) { if ( ! is_bool ( $ action ) ) { $ item = $ action ; $ action = $ ok ; } $ item_ref = ( is_string ( $ item ) ) ? 'n:' . htmlspecialchars ( $ item ) : 'i:' . $ item ; if ( $ delete ) { if ( $ ok ) { $ this -> OtbsSheetSlidesDelete [ $ item_ref ] = $ item ; } else { unset ( $ this -> OtbsSheetSlidesVisible [ $ item_ref ] ) ; } } else { $ this -> OtbsSheetSlidesVisible [ $ item_ref ] = $ ok ; } } }
3087	public function validateAdaptiveAssessmentSection ( SectionPartCollection $ sectionsParts , $ ref , $ testAdminId ) { $ engine = $ this -> getEngine ( $ ref ) ; $ adaptSection = $ engine -> setupSection ( $ testAdminId ) ; if ( method_exists ( $ adaptSection , 'getItemReferences' ) ) { $ itemReferences = $ adaptSection -> getItemReferences ( ) ; $ dependencies = $ sectionsParts -> getKeys ( ) ; if ( $ catDiff = array_diff ( $ dependencies , $ itemReferences ) ) { throw new AdaptiveSectionInjectionException ( 'Missed some CAT service items: ' . implode ( ', ' , $ catDiff ) , $ catDiff ) ; } if ( $ packageDiff = array_diff ( $ dependencies , $ itemReferences ) ) { throw new AdaptiveSectionInjectionException ( 'Missed some package items: ' . implode ( ', ' , $ packageDiff ) , $ packageDiff ) ; } } }
11363	public static function mailListTagger ( array $ list ) { $ str = '' ; foreach ( $ list as $ name => $ mail ) { if ( is_string ( $ mail ) ) { $ str .= self :: mailTagger ( $ mail , $ name ) . Mailer :: $ ADDERSSES_SEPARATOR ; } elseif ( is_array ( $ mail ) ) { foreach ( $ mail as $ subname => $ submail ) { $ str .= self :: mailTagger ( $ submail , $ subname ) . Mailer :: $ ADDERSSES_SEPARATOR ; } } } return $ str ; }
4369	public function buildTable ( $ rows , $ options = array ( ) ) { $ options = \ array_merge ( array ( 'attribs' => array ( ) , 'caption' => null , 'columns' => array ( ) , 'totalCols' => array ( ) , ) , $ options ) ; if ( \ is_string ( $ options [ 'attribs' ] ) ) { $ options [ 'attribs' ] = array ( 'class' => $ options [ 'attribs' ] , ) ; } if ( $ this -> debug -> abstracter -> isAbstraction ( $ rows ) && $ rows [ 'traverseValues' ] ) { $ options [ 'caption' ] .= ' (' . $ this -> markupClassname ( $ rows [ 'className' ] , 'span' , array ( 'title' => $ rows [ 'phpDoc' ] [ 'summary' ] ? : null , ) ) . ')' ; $ options [ 'caption' ] = \ trim ( $ options [ 'caption' ] ) ; $ rows = $ rows [ 'traverseValues' ] ; } $ keys = $ options [ 'columns' ] ? : $ this -> debug -> methodTable -> colKeys ( $ rows ) ; $ this -> tableInfo = array ( 'colClasses' => \ array_fill_keys ( $ keys , null ) , 'haveObjRow' => false , 'totals' => \ array_fill_keys ( $ options [ 'totalCols' ] , null ) , ) ; $ tBody = '' ; foreach ( $ rows as $ k => $ row ) { $ tBody .= $ this -> buildTableRow ( $ row , $ keys , $ k ) ; } if ( ! $ this -> tableInfo [ 'haveObjRow' ] ) { $ tBody = \ str_replace ( '<td class="t_classname"></td>' , '' , $ tBody ) ; } return $ this -> debug -> utilities -> buildTag ( 'table' , $ options [ 'attribs' ] , "\n" . ( $ options [ 'caption' ] ? '<caption>' . $ options [ 'caption' ] . '</caption>' . "\n" : '' ) . $ this -> buildTableHeader ( $ keys ) . '<tbody>' . "\n" . $ tBody . '</tbody>' . "\n" . $ this -> buildTableFooter ( $ keys ) ) ; }
539	protected function serializePagination ( $ pagination ) { return [ $ this -> linksEnvelope => Link :: serialize ( $ pagination -> getLinks ( true ) ) , $ this -> metaEnvelope => [ 'totalCount' => $ pagination -> totalCount , 'pageCount' => $ pagination -> getPageCount ( ) , 'currentPage' => $ pagination -> getPage ( ) + 1 , 'perPage' => $ pagination -> getPageSize ( ) , ] , ] ; }
1319	private function cleanUpParameters ( array $ parameters ) { foreach ( $ parameters as $ key => $ value ) { if ( is_bool ( $ value ) ) { $ parameters [ $ key ] = var_export ( $ value , true ) ; } } return $ parameters ; }
9108	protected function attainThemeName ( ) { $ themeName = $ this -> getResolverObject ( 'resolver_adapter_service' ) -> getName ( ) ; return ( empty ( $ themeName ) && ! ( $ themeName === '0' ) ) ? false : $ themeName ; }
350	public static function getAttributeValue ( $ model , $ attribute ) { if ( ! preg_match ( static :: $ attributeRegex , $ attribute , $ matches ) ) { throw new InvalidArgumentException ( 'Attribute name must contain word characters only.' ) ; } $ attribute = $ matches [ 2 ] ; $ value = $ model -> $ attribute ; if ( $ matches [ 3 ] !== '' ) { foreach ( explode ( '][' , trim ( $ matches [ 3 ] , '[]' ) ) as $ id ) { if ( ( is_array ( $ value ) || $ value instanceof \ ArrayAccess ) && isset ( $ value [ $ id ] ) ) { $ value = $ value [ $ id ] ; } else { return null ; } } } if ( is_array ( $ value ) ) { foreach ( $ value as $ i => $ v ) { if ( $ v instanceof ActiveRecordInterface ) { $ v = $ v -> getPrimaryKey ( false ) ; $ value [ $ i ] = is_array ( $ v ) ? json_encode ( $ v ) : $ v ; } } } elseif ( $ value instanceof ActiveRecordInterface ) { $ value = $ value -> getPrimaryKey ( false ) ; return is_array ( $ value ) ? json_encode ( $ value ) : $ value ; } return $ value ; }
10139	private function writeCFHeader ( ) { $ record = 0x01B0 ; $ length = 0x0016 ; $ numColumnMin = null ; $ numColumnMax = null ; $ numRowMin = null ; $ numRowMax = null ; $ arrConditional = [ ] ; foreach ( $ this -> phpSheet -> getConditionalStylesCollection ( ) as $ cellCoordinate => $ conditionalStyles ) { foreach ( $ conditionalStyles as $ conditional ) { if ( $ conditional -> getConditionType ( ) == Conditional :: CONDITION_EXPRESSION || $ conditional -> getConditionType ( ) == Conditional :: CONDITION_CELLIS ) { if ( ! in_array ( $ conditional -> getHashCode ( ) , $ arrConditional ) ) { $ arrConditional [ ] = $ conditional -> getHashCode ( ) ; } $ arrCoord = Coordinate :: coordinateFromString ( $ cellCoordinate ) ; if ( ! is_numeric ( $ arrCoord [ 0 ] ) ) { $ arrCoord [ 0 ] = Coordinate :: columnIndexFromString ( $ arrCoord [ 0 ] ) ; } if ( $ numColumnMin === null || ( $ numColumnMin > $ arrCoord [ 0 ] ) ) { $ numColumnMin = $ arrCoord [ 0 ] ; } if ( $ numColumnMax === null || ( $ numColumnMax < $ arrCoord [ 0 ] ) ) { $ numColumnMax = $ arrCoord [ 0 ] ; } if ( $ numRowMin === null || ( $ numRowMin > $ arrCoord [ 1 ] ) ) { $ numRowMin = $ arrCoord [ 1 ] ; } if ( $ numRowMax === null || ( $ numRowMax < $ arrCoord [ 1 ] ) ) { $ numRowMax = $ arrCoord [ 1 ] ; } } } } $ needRedraw = 1 ; $ cellRange = pack ( 'vvvv' , $ numRowMin - 1 , $ numRowMax - 1 , $ numColumnMin - 1 , $ numColumnMax - 1 ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vv' , count ( $ arrConditional ) , $ needRedraw ) ; $ data .= $ cellRange ; $ data .= pack ( 'v' , 0x0001 ) ; $ data .= $ cellRange ; $ this -> append ( $ header . $ data ) ; }
8098	protected function toCollection ( $ data ) { if ( is_array ( $ data ) ) { return new Collection ( $ data ) ; } else { if ( ! ( $ data instanceof Collection ) ) { $ data = new Collection ( ) ; } } return $ data ; }
11611	public function move ( $ path , $ filename = null ) { $ newFilename = ( $ filename != null ) ? $ filename : $ this -> filename ; $ lastSlash = substr ( $ path , strlen ( $ path ) , 1 ) ; if ( $ lastSlash !== '/' ) { $ path .= '/' ; } $ result = move_uploaded_file ( $ this -> realPath , $ path . $ newFilename ) ; return $ result ; }
550	public function actionIndex ( ) { $ caches = $ this -> findCaches ( ) ; if ( ! empty ( $ caches ) ) { $ this -> notifyCachesCanBeFlushed ( $ caches ) ; } else { $ this -> notifyNoCachesFound ( ) ; } }
6422	public function getMenu ( $ level = 1 ) { if ( class_exists ( ContentController :: class ) ) { $ controller = ContentController :: singleton ( ) ; return $ controller -> getMenu ( $ level ) ; } }
8995	protected function addActions ( SymfonyController $ controller , Resource $ resource , $ chainName = '' ) { $ actions = array ( ) ; $ chainName = $ chainName . '_' . strtolower ( str_replace ( array ( '{' , '}' ) , '' , $ resource -> getDisplayName ( ) ) ) ; foreach ( $ resource -> getMethods ( ) as $ method ) { $ actionName = strtolower ( $ method -> getType ( ) ) . str_replace ( ' ' , '' , ucwords ( str_replace ( '_' , ' ' , $ chainName ) ) ) . 'Action' ; $ route = new SymfonyRoute ( $ resource -> getUri ( ) , strtolower ( $ method -> getType ( ) . $ chainName ) ) ; $ action = new SymfonyAction ( $ actionName , $ route , $ method -> getType ( ) , $ method -> getDescription ( ) ) ; preg_match_all ( '/\{[a-zA-Z]+\}/' , $ resource -> getUri ( ) , $ parameters ) ; foreach ( $ parameters [ 0 ] as $ parameter ) { $ action -> addParameter ( substr ( $ parameter , 1 , strlen ( $ parameter ) - 2 ) ) ; } if ( $ method -> getResponses ( ) ) { foreach ( $ method -> getResponses ( ) as $ code => $ response ) { $ headers = array ( ) ; foreach ( $ response -> getHeaders ( ) as $ key => $ value ) { if ( isset ( $ value [ 'required' ] ) && $ value [ 'required' ] ) { $ headers [ $ key ] = isset ( $ value [ 'example' ] ) ? $ value [ 'example' ] : '' ; } } $ _response = new SymfonyResponse ( $ code , $ headers ) ; foreach ( $ this -> config [ 'allowed_response_types' ] as $ allowedResponsetype ) { if ( null !== $ example = $ response -> getExampleByType ( $ allowedResponsetype ) ) { $ _response -> addContent ( new SymfonyResponseContent ( $ allowedResponsetype , str_replace ( array ( "\r\n" , "\n" , "\r" , "\t" , " " ) , '' , $ example ) ) ) ; } } $ action -> addResponse ( $ _response ) ; } } $ controller -> addAction ( $ action ) ; } foreach ( $ resource -> getResources ( ) as $ subresource ) { $ this -> addActions ( $ controller , $ subresource , $ chainName ) ; } }
4562	public function getProperties ( Translatable $ model ) : array { $ class = get_class ( $ model ) ; if ( substr ( $ class , 0 , 15 ) === 'Proxies\\__CG__\\' ) { $ class = substr ( $ class , 15 ) ; } $ properties = [ ] ; $ reflection = new ReflectionClass ( $ class ) ; foreach ( $ reflection -> getProperties ( ) as $ property ) { $ annotation = $ this -> annotationReader -> getPropertyAnnotation ( $ property , Translate :: class ) ; if ( ! $ annotation ) { continue ; } $ properties [ ] = $ property ; } return $ properties ; }
3669	public function getCurrentFilterUrl ( $ options = null ) : FilterUrl { $ this -> addFromCurrentRequest ( $ filterUrl = new FilterUrl ( ) , $ options ) ; return $ filterUrl ; }
2326	public static function createFromDbResult ( Result $ objResult , $ strTable ) { $ arrModels = array ( ) ; $ strClass = Model :: getClassFromTable ( $ strTable ) ; while ( $ objResult -> next ( ) ) { $ objModel = Registry :: getInstance ( ) -> fetch ( $ strTable , $ objResult -> { $ strClass :: getPk ( ) } ) ; if ( $ objModel !== null ) { $ objModel -> mergeRow ( $ objResult -> row ( ) ) ; $ arrModels [ ] = $ objModel ; } else { $ arrModels [ ] = new $ strClass ( $ objResult ) ; } } return new static ( $ arrModels , $ strTable ) ; }
4580	public function encrypt ( Encryptable $ model ) : EncryptionService { if ( $ model -> getEncrypted ( ) ) { return $ this ; } $ properties = $ this -> getProperties ( $ model ) ; foreach ( $ properties as $ property ) { $ property -> setAccessible ( true ) ; $ property -> setValue ( $ model , $ this -> cipherService -> encrypt ( $ property -> getValue ( $ model ) ) ) ; } $ model -> setEncrypted ( true ) ; return $ this ; }
4335	public function onOutput ( Event $ event ) { if ( ! $ event [ 'isTarget' ] ) { return ; } $ this -> data = $ this -> debug -> getData ( ) ; $ this -> closeOpenGroups ( ) ; foreach ( $ this -> data [ 'logSummary' ] as & $ log ) { $ this -> removeHideIfEmptyGroups ( $ log ) ; $ this -> uncollapseErrors ( $ log ) ; } $ this -> removeHideIfEmptyGroups ( $ this -> data [ 'log' ] ) ; $ this -> uncollapseErrors ( $ this -> data [ 'log' ] ) ; $ this -> debug -> setData ( $ this -> data ) ; }
12903	private function createCacheAdapter ( ) { $ extraData = & $ this -> extraData ; return new CallbackAdapter ( function ( Request $ request ) use ( & $ extraData ) { $ poolName = 'default' ; if ( isset ( $ this -> source [ 'cache' ] [ 'pool' ] ) ) { $ poolName = $ this -> source [ 'cache' ] [ 'pool' ] ; } $ adapter = new CacheAdapter ( $ this -> registry -> getCachePool ( $ poolName ) , new HttpApiAdapter ( ) , function ( Request $ request ) { $ data = $ request -> getData ( ) ; return $ this -> registry -> generateCacheItemKey ( sprintf ( '%s.%s.%s' , $ data [ 'service' ] , $ data [ 'group' ] , $ data [ 'action' ] ) , $ data [ 'arguments' ] ) ; } ) ; $ response = $ adapter -> receive ( $ request ) ; $ extraData = $ response -> getHeaders ( ) ; return $ response ; } ) ; }
1976	public static function findMultipleFoldersByFolder ( $ strPath , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ strPath = str_replace ( array ( '\\' , '%' , '_' ) , array ( '\\\\' , '\\%' , '\\_' ) , $ strPath ) ; return static :: findBy ( array ( "$t.type='folder' AND $t.path LIKE ? AND $t.path NOT LIKE ?" ) , array ( $ strPath . '/%' , $ strPath . '/%/%' ) , $ arrOptions ) ; }
10626	public static function docroot ( ) { if ( ! empty ( $ _SERVER [ 'DOCUMENT_ROOT' ] ) ) { $ docroot = str_replace ( '\\' , '/' , $ _SERVER [ 'DOCUMENT_ROOT' ] ) ; } else { $ docroot = str_replace ( '\\' , '/' , dirname ( __FILE__ ) ) ; } return $ docroot ; }
2094	private function isScope ( string $ scope ) : bool { if ( null === $ this -> container || null === ( $ request = $ this -> container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ) ) { return false ; } $ matcher = $ this -> container -> get ( 'contao.routing.scope_matcher' ) ; if ( ContaoCoreBundle :: SCOPE_BACKEND === $ scope ) { return $ matcher -> isBackendRequest ( $ request ) ; } if ( ContaoCoreBundle :: SCOPE_FRONTEND === $ scope ) { return $ matcher -> isFrontendRequest ( $ request ) ; } return false ; }
10500	public function lte ( $ value ) { $ value = Cast :: Float ( $ value ) ; if ( $ this -> value !== null && $ this -> value <= $ value ) { return true ; } return false ; }
2179	private function generateSymlinks ( ) : void { $ fs = new Filesystem ( ) ; $ fs -> remove ( $ this -> rootDir . '/' . $ this -> webDir . '/' . $ this -> uploadPath ) ; $ fs -> remove ( $ this -> rootDir . '/' . $ this -> webDir . '/system/modules' ) ; $ fs -> remove ( $ this -> rootDir . '/' . $ this -> webDir . '/vendor' ) ; $ this -> symlinkFiles ( $ this -> uploadPath ) ; $ this -> symlinkModules ( ) ; $ this -> symlinkThemes ( ) ; $ this -> symlink ( 'assets' , $ this -> webDir . '/assets' ) ; $ this -> symlink ( 'system/themes' , $ this -> webDir . '/system/themes' ) ; $ this -> symlink ( $ this -> getRelativePath ( $ this -> logsDir ) , 'system/logs' ) ; $ this -> triggerSymlinkEvent ( ) ; }
8126	protected function getSchemaResponse ( $ schemaID , $ form = null , ValidationResult $ errors = null , $ extraData = [ ] ) { $ parts = $ this -> owner -> getRequest ( ) -> getHeader ( LeftAndMain :: SCHEMA_HEADER ) ; $ data = $ this -> owner -> getFormSchema ( ) -> getMultipartSchema ( $ parts , $ schemaID , $ form , $ errors ) ; if ( $ extraData ) { $ data = array_merge ( $ data , $ extraData ) ; } $ response = HTTPResponse :: create ( Convert :: raw2json ( $ data ) ) ; $ response -> addHeader ( 'Content-Type' , 'application/json' ) ; return $ response ; }
4655	protected function getJobFromImage ( ImageItem $ image , $ imageName , $ strategy , $ project ) { $ tag = explode ( ':' , $ imageName ) [ 1 ] ; list ( $ uniq , $ timestamp ) = explode ( '-' , $ tag ) ; return new Job ( $ project , $ strategy , $ uniq , array ( 'image' => $ image ) , "" , \ DateTime :: createFromFormat ( 'U' , $ timestamp ) ) ; }
3707	protected function renderWidget ( $ widget , $ filterOptions ) { $ filter = $ widget ; $ templateName = $ filter [ 'raw' ] [ 'eval' ] [ 'template' ] ; $ template = new \ FrontendTemplate ( $ templateName ? $ templateName : 'mm_filteritem_default' ) ; $ template -> setData ( $ filter ) ; $ template -> submit = $ filterOptions -> isAutoSubmit ( ) ; $ filter [ 'value' ] = $ template -> parse ( ) ; return $ filter ; }
3266	public function getPath ( ) : string { return $ this -> config -> getDir ( ) . $ this -> getName ( ) . $ this -> config -> getExt ( ) ; }
2337	private function setLegacyOptions ( Table $ table ) : void { if ( ! $ table -> hasOption ( 'engine' ) ) { $ table -> addOption ( 'engine' , 'MyISAM' ) ; } if ( ! $ table -> hasOption ( 'charset' ) ) { $ table -> addOption ( 'charset' , 'utf8' ) ; } if ( ! $ table -> hasOption ( 'collate' ) ) { $ table -> addOption ( 'collate' , 'utf8_general_ci' ) ; } }
5015	public function logFinish ( FinishEvent $ event ) : void { $ this -> getLogger ( ) -> info ( sprintf ( $ this -> tmpl [ 'queue' ] , 'Stop' , $ event -> getQueue ( ) -> getName ( ) ) ) ; $ this -> injectLoggerInEvent ( $ event ) ; }
5320	public function waitReady ( ) { $ x = 0 ; while ( $ x ++ < 100 ) { usleep ( self :: WAIT_IDLE ) ; if ( $ this [ self :: STARTED_MARKER ] === true ) { return $ this ; } } throw new \ RuntimeException ( 'Wait process running timeout for child pid ' . $ this -> getPid ( ) ) ; }
6531	protected function applyAnalyzer ( array $ mapping , Field $ field , \ stdClass $ rootObject , $ path = null ) { if ( null === $ this -> defaultAnalyzer ) { return $ mapping ; } if ( ! isset ( $ mapping [ 'type' ] ) || 'text' !== $ mapping [ 'type' ] ) { return $ mapping ; } if ( isset ( $ mapping [ 'index' ] ) && false === $ mapping [ 'index' ] ) { return $ mapping ; } if ( isset ( $ mapping [ 'analyzer' ] ) ) { return $ mapping ; } $ mapping [ 'analyzer' ] = $ this -> defaultAnalyzer ; return $ mapping ; }
9608	public function angleBetween ( self $ b ) { $ denominator = $ this -> length ( ) * $ b -> length ( ) ; if ( $ denominator == 0 ) { throw new Exception ( 'Cannot divide by zero' ) ; } return acos ( $ this -> dotProduct ( $ b ) / $ denominator ) ; }
2986	protected function generateForm ( $ bundle , $ entity , $ metadata , $ forceOverwrite = false ) { $ this -> getFormGenerator ( $ bundle ) -> generate ( $ bundle , $ entity , $ metadata [ 0 ] , $ forceOverwrite ) ; }
9577	protected function registerMaterializePlugin ( $ name ) { $ view = $ this -> getView ( ) ; if ( $ this -> materializeAsset ) { MaterializeAsset :: register ( $ view ) ; } if ( $ this -> customAsset ) { MaterializeCustomAsset :: register ( $ view ) ; } $ id = $ this -> options [ 'id' ] ; if ( $ this -> clientOptions !== false && is_array ( $ this -> clientOptions ) ) { $ options = empty ( $ this -> clientOptions ) ? '' : Json :: htmlEncode ( $ this -> clientOptions ) ; $ js = "Materialize.$name.apply(null, $options);" ; $ view -> registerJs ( $ js ) ; } $ this -> registerClientEvents ( ) ; }
9274	public function getServiceConfig ( ) { return array ( 'factories' => array ( 'CronHelper\Service\CronService' => function ( $ serviceManager ) { $ mainConfig = $ serviceManager -> get ( 'config' ) ; $ serviceConfig = array ( ) ; if ( is_array ( $ mainConfig ) ) { if ( array_key_exists ( 'cron_helper' , $ mainConfig ) ) { $ serviceConfig = $ mainConfig [ 'cron_helper' ] ; } } $ cronService = new CronService ( $ serviceConfig ) ; return $ cronService ; } , ) , ) ; }
5428	public function getInterfaceMethods ( ) { $ methods = array ( ) ; $ interfaces = $ this -> getInterfaces ( ) ; foreach ( $ interfaces as $ interface ) { $ methods = array_merge ( $ methods , get_class_methods ( $ interface ) ) ; } return array_unique ( $ methods ) ; }
8139	public function load ( $ name ) { if ( $ name instanceof Twig_TemplateWrapper ) { return $ name ; } if ( $ name instanceof Twig_Template ) { return new Twig_TemplateWrapper ( $ this , $ name ) ; } return new Twig_TemplateWrapper ( $ this , $ this -> loadTemplate ( $ name ) ) ; }
7192	private function copyItem ( Model \ SaleItemInterface $ source , Model \ SaleItemInterface $ target ) { $ this -> copy ( $ source , $ target , [ 'designation' , 'description' , 'reference' , 'taxGroup' , 'netPrice' , 'weight' , 'quantity' , 'position' , 'compound' , 'immutable' , 'configurable' , 'private' , 'data' , ] ) ; $ this -> copy ( $ source -> getSubjectIdentity ( ) , $ target -> getSubjectIdentity ( ) , [ 'provider' , 'identifier' , ] ) ; foreach ( $ source -> getAdjustments ( ) as $ sourceAdjustment ) { $ targetAdjustment = $ this -> saleFactory -> createAdjustmentForItem ( $ target ) ; $ target -> addAdjustment ( $ targetAdjustment ) ; $ this -> copyAdjustment ( $ sourceAdjustment , $ targetAdjustment ) ; } foreach ( $ source -> getChildren ( ) as $ sourceChild ) { $ targetChild = $ this -> saleFactory -> createItemForSale ( $ target -> getSale ( ) ) ; $ target -> addChild ( $ targetChild ) ; $ this -> copyItem ( $ sourceChild , $ targetChild ) ; } }
9358	public function getModulePath ( $ moduleName ) { if ( array_key_exists ( $ moduleName , $ this -> loadedModules ) ) { $ module = $ this -> loadedModules [ $ moduleName ] ; $ moduleConfig = $ module -> getAutoloaderConfig ( ) ; return $ moduleConfig [ self :: STANDARD_AUTOLOLOADER ] [ self :: NAMESPACE_KEY ] [ $ moduleName ] ; } return null ; }
10315	function getUniqueClicksCount ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ excludeAnonymousClicks = false ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , null ) ; if ( isset ( $ excludeAnonymousClicks ) ) $ params [ 'exclude_anonymous_clicks' ] = ( $ excludeAnonymousClicks == true ) ? "true" : "false" ; return $ this -> get ( 'reports/clicks/unique/count' , $ params ) ; }
4112	public function searchFullPath ( $ filename ) { $ paths = explode ( PATH_SEPARATOR , get_include_path ( ) ) ; foreach ( $ paths as $ path ) { $ fullPath = $ path . DIRECTORY_SEPARATOR . $ filename ; if ( file_exists ( $ fullPath ) ) { return $ fullPath ; } } return false ; }
11886	public function addChild ( $ structureName , $ prefix = '' , $ suffix = '' ) { if ( isset ( $ this -> children [ $ structureName ] ) ) { throw new DefinitionDuplicateException ( sprintf ( 'Child structure with same name "%s" already exists' , $ structureName ) ) ; } $ this -> children [ $ structureName ] = array ( 'name' => $ structureName , 'prefix' => ( string ) $ prefix , 'suffix' => ( string ) $ suffix ) ; }
3208	public static function encode ( $ string ) { if ( strlen ( $ string ) == 0 ) { return '' ; } $ binaryString = '' ; foreach ( str_split ( $ string ) as $ s ) { $ binaryString .= sprintf ( '%08b' , ord ( $ s ) ) ; } $ binaryArray = self :: chunk ( $ binaryString , 5 ) ; while ( count ( $ binaryArray ) % 8 !== 0 ) { $ binaryArray [ ] = null ; } $ base32String = '' ; foreach ( $ binaryArray as $ bin ) { $ char = 32 ; if ( ! is_null ( $ bin ) ) { $ bin = str_pad ( $ bin , 5 , 0 , STR_PAD_RIGHT ) ; $ char = bindec ( $ bin ) ; } $ base32String .= self :: $ alphabet [ $ char ] ; } return $ base32String ; }
9016	public function markAllNotificationsAsRead ( ) { $ object = Auth :: user ( ) ; $ object -> unreadNotifications -> markAsRead ( ) ; \ Cache :: tags ( 'response' ) -> flush ( ) ; return $ this -> successJsonResponse ( ) ; }
5464	public function isWithin ( $ url ) { if ( $ this -> isIn ( $ this -> root , $ url -> getBasePath ( ) ) ) { return true ; } if ( $ this -> isIn ( $ this -> root , $ url -> getBasePath ( ) . $ url -> getPage ( ) . '/' ) ) { return true ; } return false ; }
6306	private function register ( array $ providers , array $ values ) { foreach ( $ providers as $ provider ) { $ factories = $ provider -> getFactories ( ) ; foreach ( $ factories as $ key => $ callable ) { $ this [ $ key ] = function ( ContainerInterface $ c ) use ( $ callable ) { return call_user_func ( $ callable , $ c ) ; } ; } } foreach ( $ providers as $ provider ) { $ extensions = $ provider -> getExtensions ( ) ; foreach ( $ extensions as $ key => $ callable ) { if ( isset ( $ this -> keys [ $ key ] ) ) { $ this [ $ key ] = $ this -> extend ( $ key , function ( $ previous , ContainerInterface $ c ) use ( $ callable ) { return call_user_func ( $ callable , $ c , $ previous ) ; } ) ; } else { $ this [ $ key ] = function ( ContainerInterface $ c ) use ( $ callable ) { return call_user_func ( $ callable , $ c ) ; } ; } } } foreach ( $ values as $ key => $ value ) { $ this [ $ key ] = $ value ; } }
9193	public function init ( ) { if ( $ this -> isInitialized ( ) ) return $ this ; if ( ! $ this -> getThemesPath ( ) || ! $ this -> getName ( ) ) throw new \ Exception ( 'Theme Cant initialize because theme name or theme paths not present.' ) ; $ themePathname = $ this -> getThemesPath ( ) . DS . $ this -> getName ( ) ; if ( ! is_dir ( $ themePathname ) ) throw new \ Exception ( sprintf ( 'Theme "%s" not found in "%s".' , $ this -> getName ( ) , $ themePathname ) ) ; $ bootstrap = $ themePathname . DS . 'theme.bootstrap.php' ; if ( file_exists ( $ bootstrap ) ) { ob_start ( ) ; set_error_handler ( function ( $ errno , $ errstr ) { throw new \ ErrorException ( $ errstr , $ errno ) ; } , E_ALL ) ; include $ bootstrap ; restore_error_handler ( ) ; ob_get_clean ( ) ; } $ this -> initialized = true ; return $ this ; }
9473	public function deleteFaild ( $ message = null ) { if ( is_null ( $ message ) ) $ message = $ this -> config [ 'fail' ] [ 'delete' ] ; return $ this -> setStatusCode ( 447 ) -> setStatusText ( 'fail' ) -> setErrorCode ( 5447 ) -> respondWithMessage ( $ message ) ; }
4381	protected function visualWhiteSpaceCallback ( $ matches ) { $ strBr = $ this -> debug -> getCfg ( 'addBR' ) ? '<br />' : '' ; $ search = array ( "\r" , "\n" ) ; $ replace = array ( '<span class="ws_r"></span>' , '<span class="ws_n"></span>' . $ strBr . "\n" ) ; return \ str_replace ( $ search , $ replace , $ matches [ 1 ] ) ; }
2738	private function setToken ( $ token ) { $ this -> configWriter -> save ( Config :: XML_FASTLY_API_KEY , $ token ) ; $ this -> output -> writeln ( '<info>Token updated.</info>' , OutputInterface :: OUTPUT_NORMAL ) ; }
6057	public function removeMediaFromFolder ( $ folderId , $ mediaId ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> delete ( 'v1/folders/' . $ folderId . '/media/' . $ mediaId . '' , $ parameters ) ; return $ result ; }
374	public function getPassedOptionValues ( ) { $ properties = [ ] ; foreach ( $ this -> _passedOptions as $ property ) { $ properties [ $ property ] = $ this -> $ property ; } return $ properties ; }
8860	public function onBeforePublish ( ) { if ( $ this -> dbObject ( 'PublishDate' ) -> InPast ( ) && ! $ this -> isPublished ( ) ) { $ this -> setCastedField ( "PublishDate" , time ( ) ) ; $ this -> write ( ) ; } }
12151	public function getRelatedType ( $ name ) { list ( $ relationship , $ role ) = $ this -> getRelationship ( $ name ) ; if ( $ relationship ) { return $ relationship -> roleType ( $ role ) ; } return false ; }
10802	public function savePageHistoricAction ( ) { $ responseData = $ this -> params ( ) -> fromRoute ( 'datas' , $ this -> params ( ) -> fromQuery ( 'datas' , '' ) ) ; $ idPage = isset ( $ responseData [ 'idPage' ] ) ? $ responseData [ 'idPage' ] : ( ! empty ( $ responseData [ 0 ] [ 'idPage' ] ) ? ( $ responseData [ 0 ] [ 'idPage' ] ) : 0 ) ; $ isNew = isset ( $ responseData [ 'isNew' ] ) ? $ responseData [ 'isNew' ] : ( ! empty ( $ responseData [ 0 ] [ 'isNew' ] ) ? ( $ responseData [ 0 ] [ 'isNew' ] ) : 0 ) ; $ response = array ( 'idPage' => $ idPage , 'isNew' => $ isNew ) ; $ this -> getEventManager ( ) -> trigger ( 'meliscmspagehistoric_historic_save_start' , $ this , $ response ) ; $ melisCoreAuth = $ this -> getServiceLocator ( ) -> get ( 'MelisCoreAuth' ) ; $ melisPageHistoricTable = $ this -> getServiceLocator ( ) -> get ( 'MelisPageHistoricTable' ) ; $ pageAction = $ this -> params ( ) -> fromRoute ( 'pageActionUsed' , $ this -> params ( ) -> fromQuery ( 'pageActionUsed' , '' ) ) ; $ histDatas = array ( ) ; $ container = new Container ( 'meliscms' ) ; $ datas = array ( ) ; if ( isset ( $ container [ 'action-page-tmp' ] [ 'success' ] ) && $ container [ 'action-page-tmp' ] [ 'success' ] == 0 ) return ; if ( ! empty ( $ container [ 'action-page-tmp' ] ) ) { if ( ! empty ( $ container [ 'action-page-tmp' ] [ 'datas' ] ) ) $ datas = $ container [ 'action-page-tmp' ] [ 'datas' ] ; } $ description = '' ; switch ( $ pageAction ) { case 'Save' : if ( $ isNew ) { $ description = 'tr_melispagehistoric_description_text_new' ; } else { $ description = 'tr_melispagehistoric_description_text_save' ; } break ; case 'Publish' : $ description = 'tr_melispagehistoric_description_text_publish' ; break ; case 'Unpublish' : $ description = 'tr_melispagehistoric_description_text_unpublished' ; break ; } if ( $ idPage ) { $ userId = ( int ) null ; $ userAuthDatas = $ melisCoreAuth -> getStorage ( ) -> read ( ) ; if ( $ userAuthDatas ) $ userId = $ userAuthDatas -> usr_id ; $ histDatas = array ( 'hist_page_id' => $ idPage , 'hist_action' => $ pageAction , 'hist_date' => date ( 'Y-m-d H:i:s' ) , 'hist_user_id' => $ userId , 'hist_description' => $ description ) ; $ melisPageHistoricTable -> save ( $ histDatas ) ; } $ this -> getEventManager ( ) -> trigger ( 'meliscmspagehistoric_historic_save_end' , $ this , $ histDatas ) ; }
12357	public function updateEntryName ( ContentfulEntry $ entry ) { $ displayField = $ this -> getDisplayField ( ) ; $ values = array_values ( ( array ) $ entry -> { $ displayField } ) ; $ entry -> setName ( isset ( $ values [ 0 ] ) ? $ values [ 0 ] : 'Untitled' ) ; }
2911	public function xml2array ( $ xml , array & $ arr , $ parentKey = '' ) { if ( ! $ xml ) { return ; } if ( count ( $ xml -> children ( ) ) == 0 ) { $ arr [ $ parentKey ] = ( string ) $ xml ; } else { foreach ( $ xml -> children ( ) as $ key => $ item ) { $ key = $ parentKey ? $ parentKey . DS . $ key : $ key ; $ this -> xml2array ( $ item , $ arr , $ key ) ; } } return $ arr ; }
10424	public function parseXml ( $ xml ) { if ( is_null ( $ xml ) ) { return null ; } $ xml = new QuiteSimpleXMLElement ( $ xml ) ; $ xml -> registerXPathNamespaces ( $ this -> namespaces ) ; return $ xml ; }
1769	public function __isset ( $ strKey ) { switch ( $ strKey ) { case 'id' : return isset ( $ this -> strId ) ; break ; case 'name' : return isset ( $ this -> strName ) ; break ; case 'label' : return isset ( $ this -> strLabel ) ; break ; case 'value' : return isset ( $ this -> varValue ) ; break ; case 'class' : return isset ( $ this -> strClass ) ; break ; case 'template' : return isset ( $ this -> strTemplate ) ; break ; case 'wizard' : return isset ( $ this -> strWizard ) ; break ; case 'required' : return isset ( $ this -> arrConfiguration [ $ strKey ] ) ; break ; case 'forAttribute' : return isset ( $ this -> blnForAttribute ) ; break ; case 'dataContainer' : return isset ( $ this -> objDca ) ; break ; case 'activeRecord' : return isset ( $ this -> objDca -> activeRecord ) ; break ; default : return isset ( $ this -> arrAttributes [ $ strKey ] ) || isset ( $ this -> arrConfiguration [ $ strKey ] ) ; break ; } }
6870	protected function buildPaymentList ( PM \ PaymentSubjectInterface $ subject ) { $ payments = array_filter ( $ subject -> getPayments ( ) -> toArray ( ) , function ( PM \ PaymentInterface $ p ) { if ( $ p -> getMethod ( ) -> isOutstanding ( ) ) { return false ; } if ( ! PM \ PaymentStates :: isPaidState ( $ p -> getState ( ) ) ) { return false ; } return true ; } ) ; usort ( $ payments , function ( PM \ PaymentInterface $ a , PM \ PaymentInterface $ b ) { return $ a -> getCompletedAt ( ) -> getTimestamp ( ) - $ b -> getCompletedAt ( ) -> getTimestamp ( ) ; } ) ; return array_map ( function ( PM \ PaymentInterface $ payment ) { return [ 'payment' => $ payment , 'amount' => $ payment -> getAmount ( ) , ] ; } , $ payments ) ; }
4576	public function get ( $ id , Parameters $ parameters = null ) { if ( null !== $ id ) { $ resource = str_replace ( '{id}' , $ id , static :: RESOURCE_OBJECT ) ; } else { $ key = $ parameters -> getKey ( ) ; $ tenantId = $ parameters -> getTenantId ( ) ; switch ( true ) { case null !== $ key && null !== $ tenantId : $ resource = str_replace ( [ '{key}' , '{tenant-id}' ] , [ $ key , $ tenantId ] , static :: RESOURCE_OBJECT_BY_KEY_AND_TENANT_ID ) ; break ; case null !== $ key : $ resource = str_replace ( '{key}' , $ key , static :: RESOURCE_OBJECT_BY_KEY ) ; break ; default : throw new LogicException ( '"Key" and/or "TenantId" parameters are not defined.' ) ; } } $ options = [ 'headers' => [ 'Accept' => 'application/json' ] ] ; $ object = $ this -> execute ( 'GET' , $ resource , $ options ) ; $ model = static :: toModel ( $ object ) ; return $ model ; }
5927	public function retrieveCategory ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/categories/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new CategoryResponse ( $ result ) ; return $ result ; }
10916	private function logScriptOutput ( ) { $ output_buffers = array ( ) ; $ ob_cnt = 0 ; while ( ob_get_level ( ) > $ this -> output_buffer_level ) { $ output = trim ( ob_get_contents ( ) ) ; ++ $ ob_cnt ; ob_end_clean ( ) ; if ( ! empty ( $ output ) ) { $ lines = explode ( "\n" , $ output ) ; foreach ( $ lines as $ n => $ line ) self :: $ logger -> debug ( "Script output: {0}/{1}: {2}" , [ $ ob_cnt , $ n + 1 , $ line ] ) ; } } }
7923	private function extractFilename ( \ ZipArchive $ zipArchive , $ fileIndex ) { $ entry = $ zipArchive -> statIndex ( $ fileIndex ) ; $ filename = str_replace ( '\\' , '/' , $ entry [ 'name' ] ) ; if ( $ this -> isValidPath ( $ filename ) ) { return $ filename ; } throw new \ Exception ( 'Invalid filename path in zip archive' ) ; }
1520	public function removeFromRelationship ( StoreInterface $ store , UpdateRelationship $ request ) { $ result = $ this -> transaction ( function ( ) use ( $ store , $ request ) { return $ this -> doRemoveFromRelationship ( $ store , $ request ) ; } ) ; if ( $ this -> isResponse ( $ result ) ) { return $ result ; } return $ this -> reply ( ) -> noContent ( ) ; }
11903	public function getDescriptor ( ) { $ logModel = $ this -> getLogModel ( true ) ; if ( empty ( $ logModel ) || ! isset ( $ logModel -> dataInterface ) ) { return 'Unknown Data Interface' ; } return 'Interface: ' . $ logModel -> dataInterface -> name ; }
4936	protected function getEntities ( $ args ) { $ dm = $ args -> getDocumentManager ( ) ; $ resource = $ args -> getDocument ( ) ; $ repositoryName = $ this -> getRepositoryName ( ) ; $ resourceId = $ resource -> getPermissionsResourceId ( ) ; $ repository = $ dm -> getRepository ( $ repositoryName ) ; $ criteria = array ( 'permissions.assigned.' . $ resourceId => array ( '$exists' => true ) ) ; $ entities = $ repository -> findBy ( $ criteria ) ; return $ entities ; }
6850	public static function years ( $ start = false , $ end = false ) { $ start = ( $ start === false ) ? ( date ( 'Y' ) - 5 ) : ( int ) $ start ; $ end = ( $ end === false ) ? ( date ( 'Y' ) + 5 ) : ( int ) $ end ; $ years = array ( ) ; for ( $ i = $ start ; $ i <= $ end ; $ i ++ ) { $ years [ $ i ] = ( string ) $ i ; } return $ years ; }
1683	public function getModules ( ) { $ arrModules = array ( ) ; foreach ( $ GLOBALS [ 'BE_MOD' ] as $ k => $ v ) { if ( ! empty ( $ v ) ) { if ( $ k == 'accounts' ) { unset ( $ v [ 'login' ] ) ; } if ( $ k == 'system' ) { unset ( $ v [ 'undo' ] ) ; } $ arrModules [ $ k ] = array_keys ( $ v ) ; } } return $ arrModules ; }
7876	protected function generateRequestIfGuarded ( ) { if ( ! $ this -> option ( 'unguard' ) ) { $ name = $ this -> inflector -> getRequest ( ) ; $ this -> call ( 'make:request' , compact ( 'name' ) ) ; } }
8441	public function updateAction ( string $ production_slug , int $ id , Request $ request , TokenStorageInterface $ token , AuthorizationCheckerInterface $ auth ) : Response { list ( $ post , $ production ) = $ this -> lookupEntity ( Post :: class , $ id , $ production_slug ) ; if ( ! $ auth -> isGranted ( 'edit' , $ post ) ) { throw new AccessDeniedException ( ) ; } $ user = $ token -> getToken ( ) -> getUser ( ) ; if ( null !== $ post -> getParent ( ) ) { $ form = $ this -> form -> create ( ReplyType :: class , $ post ) ; } else { $ form = $ this -> form -> create ( PostType :: class , $ post ) ; } $ form -> handleRequest ( $ request ) ; if ( $ form -> isSubmitted ( ) && $ form -> isValid ( ) ) { $ this -> em -> flush ( ) ; $ this -> session -> getFlashBag ( ) -> add ( 'success' , $ this -> translator -> trans ( 'post.updated' , [ ] , BkstgNoticeBoardBundle :: TRANSLATION_DOMAIN ) ) ; return new RedirectResponse ( $ this -> url_generator -> generate ( 'bkstg_board_show' , [ 'production_slug' => $ production -> getSlug ( ) ] ) ) ; } return new Response ( $ this -> templating -> render ( '@BkstgNoticeBoard/Post/update.html.twig' , [ 'form' => $ form -> createView ( ) , 'post' => $ post , 'production' => $ production , ] ) ) ; }
1094	public function roots ( ) { return $ this -> node -> newQuery ( ) -> whereNull ( $ this -> node -> getQualifiedParentColumnName ( ) ) -> orderBy ( $ this -> node -> getQualifiedLeftColumnName ( ) ) -> orderBy ( $ this -> node -> getQualifiedRightColumnName ( ) ) -> orderBy ( $ this -> node -> getQualifiedKeyName ( ) ) -> get ( ) ; }
7556	function getChildrenByAttribute ( $ attribute , $ value , $ mode = 'equals' , $ compare = 'total' , $ recursive = true ) { if ( $ this -> childCount ( ) < 1 ) { return array ( ) ; } $ mode = explode ( ' ' , strtolower ( $ mode ) ) ; $ match = ( ( isset ( $ mode [ 1 ] ) && ( $ mode [ 1 ] === 'not' ) ) ? 'false' : 'true' ) ; return $ this -> getChildrenByMatch ( array ( 'attributes' => array ( $ attribute => array ( 'operator_value' => $ mode [ 0 ] , 'value' => $ value , 'match' => $ match , 'compare' => $ compare ) ) ) , $ recursive ) ; }
5189	private function createVideo ( string $ body , string $ source , int $ order , string $ cover , string $ lead ) : \ One \ Model \ Video { return new Video ( $ body , $ source , $ order , $ cover , $ lead ) ; }
866	public function isType ( $ types ) { if ( ! \ is_array ( $ types ) ) { $ types = [ $ types ] ; } return \ in_array ( $ this -> getType ( ) , $ types , true ) ; }
10738	public function search ( $ query ) { $ results = new ResultCollection ( ) ; foreach ( $ this -> engines as $ eachEngine ) { if ( ! $ eachEngine -> supports ( $ query ) ) { continue ; } if ( $ more = $ eachEngine -> search ( $ query ) ) { if ( ! is_array ( $ more ) and ! $ more instanceof \ Traversable ) { throw new DomainException ( 'The returned result set is not traversable.' ) ; } foreach ( $ more as $ eachResult ) { $ results -> add ( $ eachResult ) ; } } } return $ results ; }
8676	public function flip ( ) { if ( ! $ this -> items ) { return $ this -> createFrom ( [ ] ) ; } try { return $ this -> createFrom ( Thrower :: call ( 'array_flip' , $ this -> items ) ) ; } catch ( ErrorException $ e ) { throw new LogicException ( 'Only string and integer values can be flipped' ) ; } }
8906	public function count_by ( ) { $ where = func_get_args ( ) ; $ this -> _set_where ( $ where ) ; $ this -> apply_soft_delete_filter ( ) ; return $ this -> _database -> count_all_results ( $ this -> _table ) ; }
3550	protected function registerParser ( ) { $ this -> app -> singleton ( EmojiParser :: class , function ( Container $ app ) { return new EmojiParser ( $ app -> make ( RepositoryInterface :: class ) ) ; } ) ; }
7112	public function isAuthorized ( $ user , $ plugin , $ controller , $ action ) { $ isAuthorized = false ; if ( $ plugin ) { $ plugin = Inflector :: camelize ( $ plugin ) ; } if ( $ this -> isPublicAction ( $ plugin , $ controller , $ action ) ) { $ isAuthorized = true ; } elseif ( isset ( $ user [ 'role' ] ) && ! empty ( $ controller ) && ! empty ( $ action ) ) { if ( $ this -> _options [ 'camelizedControllerNames' ] ) { $ controller = Inflector :: camelize ( $ controller ) ; } else { $ controller = Inflector :: underscore ( $ controller ) ; } $ key = $ controller ; if ( ! empty ( $ plugin ) ) { $ key = $ plugin . '.' . $ key ; } if ( isset ( $ this -> _rightsConfig [ $ key ] [ '*' ] ) && $ this -> _rightsConfig [ $ key ] [ '*' ] == '*' ) { $ isAuthorized = true ; } elseif ( isset ( $ this -> _rightsConfig [ $ key ] [ '*' ] ) && in_array ( $ user [ 'role' ] , $ this -> _rightsConfig [ $ key ] [ '*' ] ) ) { $ isAuthorized = true ; } elseif ( isset ( $ this -> _rightsConfig [ $ key ] [ $ action ] ) && in_array ( $ user [ 'role' ] , $ this -> _rightsConfig [ $ key ] [ $ action ] ) ) { $ isAuthorized = true ; } } return $ isAuthorized ; }
4111	public function findFileAndLine ( $ className ) { $ result = false ; $ fullPath = $ this -> searchFullPath ( $ this -> getFileFromClassName ( $ className ) ) ; if ( $ fullPath ) { $ result = array ( 'file' => $ fullPath , 'line' => 0 ) ; $ lineNumber = $ this -> getLineNumber ( $ fullPath , '/class\s+' . $ className . '/' ) ; if ( $ lineNumber ) { $ result [ 'line' ] = $ lineNumber ; } } return $ result ; }
5420	protected function parseCookie ( $ cookie_line ) { $ parts = explode ( ';' , $ cookie_line ) ; $ cookie = array ( ) ; preg_match ( '/\s*(.*?)\s*=(.*)/' , array_shift ( $ parts ) , $ cookie ) ; foreach ( $ parts as $ part ) { if ( preg_match ( '/\s*(.*?)\s*=(.*)/' , $ part , $ matches ) ) { $ cookie [ $ matches [ 1 ] ] = trim ( $ matches [ 2 ] ) ; } } return new SimpleCookie ( $ cookie [ 1 ] , trim ( $ cookie [ 2 ] ) , isset ( $ cookie [ 'path' ] ) ? $ cookie [ 'path' ] : '' , isset ( $ cookie [ 'expires' ] ) ? $ cookie [ 'expires' ] : false ) ; }
7905	public function renderToggleButton ( ) { if ( $ this -> toggleButton !== false ) { $ tag = ArrayHelper :: remove ( $ this -> toggleButton , 'tag' , 'div' ) ; $ label = ArrayHelper :: remove ( $ this -> toggleButton , 'label' , Html :: tag ( 'i' , '' , [ 'class' => 'content icon' ] ) ) ; Html :: addCssClass ( $ this -> toggleButton , 'ui' ) ; Html :: addCssClass ( $ this -> toggleButton , 'launch-sidebar icon' ) ; Html :: addCssClass ( $ this -> toggleButton , 'button' ) ; Html :: addCssClass ( $ this -> toggleButton , 'fixed' ) ; Html :: addCssClass ( $ this -> toggleButton , 'attached' ) ; if ( $ this -> position === static :: POS_LEFT ) { $ position = static :: POS_RIGHT ; } else { $ position = static :: POS_LEFT ; } Html :: addCssClass ( $ this -> toggleButton , $ position ) ; $ view = $ this -> getView ( ) ; DosAmigosAsset :: register ( $ view ) ; $ view -> registerJs ( 'dosamigos.semantic.init();' ) ; return Html :: tag ( $ tag , $ label , $ this -> toggleButton ) ; } else { return null ; } }
2245	public static function getPageStatusIcon ( $ objPage ) { $ sub = 0 ; $ image = $ objPage -> type . '.svg' ; if ( ! $ objPage -> published || ( $ objPage -> start != '' && $ objPage -> start > time ( ) ) || ( $ objPage -> stop != '' && $ objPage -> stop < time ( ) ) ) { ++ $ sub ; } if ( $ objPage -> hide && ! \ in_array ( $ objPage -> type , array ( 'root' , 'error_401' , 'error_403' , 'error_404' ) ) ) { $ sub += 2 ; } if ( $ objPage -> protected && ! \ in_array ( $ objPage -> type , array ( 'root' , 'error_401' , 'error_403' , 'error_404' ) ) ) { $ sub += 4 ; } if ( $ sub > 0 ) { $ image = $ objPage -> type . '_' . $ sub . '.svg' ; } if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageStatusIcon' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageStatusIcon' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageStatusIcon' ] as $ callback ) { $ image = static :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ objPage , $ image ) ; } } return $ image ; }
6325	public function stop ( ) { $ fp = @ fopen ( $ this -> _file , 'w' ) ; fwrite ( $ fp , ob_get_contents ( ) ) ; fclose ( $ fp ) ; ob_end_flush ( ) ; }
3807	protected function translateLegend ( $ legend , $ metaModel ) { $ arrLegend = StringUtil :: deserialize ( $ legend [ 'legendtitle' ] ) ; if ( is_array ( $ arrLegend ) ) { $ strLegend = $ arrLegend [ $ GLOBALS [ 'TL_LANGUAGE' ] ] ; if ( ! $ strLegend ) { $ strLegend = $ arrLegend [ $ metaModel -> getFallbackLanguage ( ) ] ; if ( ! $ strLegend ) { $ strLegend = 'legend' . ( count ( $ this -> legends ) + 1 ) ; } } } else { $ strLegend = $ legend [ 'legendtitle' ] ? $ legend [ 'legendtitle' ] : 'legend' ; } $ legendName = StringUtil :: standardize ( $ strLegend ) ; $ this -> legends [ $ legendName ] = array ( 'name' => $ strLegend , 'visible' => ! ( isset ( $ legend [ 'legendhide' ] ) && ( bool ) $ legend [ 'legendhide' ] ) , 'properties' => array ( ) ) ; return $ legendName ; }
4154	protected function getBearerTokenCredentials ( ) { $ signingKey = rawurlencode ( $ this -> getConsumerKey ( ) ) . ':' . rawurlencode ( $ this -> getConsumerSecret ( ) ) ; return base64_encode ( $ signingKey ) ; }
10531	public function count ( ) { if ( is_array ( $ this -> items ) && $ this -> items !== null ) { return count ( $ this -> items ) ; } return 0 ; }
11842	private function getBind ( ) { [ $ dsBegin , $ treeType ] = $ this -> extractInput ( ) ; $ calcId = $ this -> getCalcId ( $ dsBegin , $ treeType ) ; $ bind = [ QGrid :: BND_CALC_ID => $ calcId ] ; return $ bind ; }
1543	protected function cursor ( EncodingParametersInterface $ parameters ) { return Cursor :: create ( ( array ) $ parameters -> getPaginationParameters ( ) , $ this -> before , $ this -> after , $ this -> limit ) ; }
10929	public function getCountOf ( string $ strSQL , ? array $ parans = null ) : int { $ r = $ this -> getDataColumn ( $ strSQL , $ parans , "int" ) ; return ( ( $ r === null ) ? 0 : $ r ) ; }
8919	protected function parseAuthority ( $ authority , & $ out ) { if ( ! empty ( $ authority ) ) { $ out [ 'id' ] = $ authority ; if ( preg_match ( '/\((.*?)\)(.*)/' , $ authority , $ matches ) ) { $ out [ 'vocabulary' ] = $ matches [ 1 ] ; $ out [ 'id' ] = $ matches [ 2 ] ; } } }
10997	public function read ( int $ offset = 0 ) { if ( $ this -> test ( \ sndsgd \ Fs :: EXISTS | \ sndsgd \ Fs :: READABLE ) === false ) { $ this -> error = "failed to read file; {$this->error}" ; return false ; } return $ this -> readFile ( $ offset ) ; }
10493	public function mul ( $ value ) { $ value = Cast :: Float ( $ value ) ; if ( $ this -> value === null ) { return new FloatType ( $ this -> value ) ; } return new FloatType ( $ this -> value * $ value ) ; }
4082	public function getInputScreen ( $ metaModel ) { $ inputScreen = $ this -> getInputScreenDetails ( $ metaModel ) ; return $ inputScreen ? $ inputScreen -> getId ( ) : null ; }
8945	public function replacePreferences ( $ preferences ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'user/preferences' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ preferenceList = '' ; if ( ! empty ( $ preferences ) ) { foreach ( $ preferences as $ key => $ value ) { $ preferenceList .= '<preference k="' . $ key . '" v="' . $ value . '"/>' ; } } $ xml = '<?xml version="1.0" encoding="UTF-8"?> <osm version="0.6" generator="JoomlaOpenStreetMap"> <preferences>' . $ preferenceList . '</preferences> </osm>' ; $ header [ 'Content-Type' ] = 'text/xml' ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters , $ xml , $ header ) ; return $ response -> body ; }
5061	public function calculateWidth ( $ text , $ size = self :: TEXT_SIZE ) { $ size = $ this -> convertToPt ( $ size ) ; $ box = imagettfbbox ( $ size , 0 , $ this -> fontPath , $ text ) ; return round ( abs ( $ box [ 2 ] - $ box [ 0 ] ) + self :: SHIELD_PADDING_EXTERNAL + self :: SHIELD_PADDING_INTERNAL , 1 ) ; }
7506	function setDoc ( $ doc , $ pos = 0 ) { $ this -> doc = $ doc ; $ this -> size = strlen ( $ doc ) ; $ this -> setPos ( $ pos ) ; }
108	private function addExtension ( $ name , $ prettyVersion ) { $ extraDescription = null ; try { $ version = $ this -> versionParser -> normalize ( $ prettyVersion ) ; } catch ( \ UnexpectedValueException $ e ) { $ extraDescription = ' (actual version: ' . $ prettyVersion . ')' ; if ( preg_match ( '{^(\d+\.\d+\.\d+(?:\.\d+)?)}' , $ prettyVersion , $ match ) ) { $ prettyVersion = $ match [ 1 ] ; } else { $ prettyVersion = '0' ; } $ version = $ this -> versionParser -> normalize ( $ prettyVersion ) ; } $ packageName = $ this -> buildPackageName ( $ name ) ; $ ext = new CompletePackage ( $ packageName , $ version , $ prettyVersion ) ; $ ext -> setDescription ( 'The ' . $ name . ' PHP extension' . $ extraDescription ) ; $ this -> addPackage ( $ ext ) ; }
292	public function hasAttribute ( $ name ) { return isset ( $ this -> _attributes [ $ name ] ) || in_array ( $ name , $ this -> attributes ( ) , true ) ; }
3683	private function getFilterUrlBuilder ( ) : FilterUrlBuilder { if ( null === $ this -> filterUrlBuilder ) { return $ this -> filterUrlBuilder = System :: getContainer ( ) -> get ( 'metamodels.filter_url' ) ; } return $ this -> filterUrlBuilder ; }
8119	public function submitReview ( $ record , $ data ) { if ( ! $ this -> canSubmitReview ( $ record ) ) { throw new ValidationException ( _t ( __CLASS__ . '.ErrorReviewPermissionDenied' , 'It seems you don\'t have the necessary permissions to submit a content review' ) ) ; } $ notes = ( ! empty ( $ data [ 'Review' ] ) ? $ data [ 'Review' ] : _t ( __CLASS__ . '.NoComments' , '(no comments)' ) ) ; $ record -> addReviewNote ( Security :: getCurrentUser ( ) , $ notes ) ; $ record -> advanceReviewDate ( ) ; $ request = $ this -> controller -> getRequest ( ) ; $ message = _t ( __CLASS__ . '.Success' , 'Review successfully added' ) ; if ( $ request -> getHeader ( 'X-Formschema-Request' ) ) { return $ message ; } elseif ( Director :: is_ajax ( ) ) { $ response = HTTPResponse :: create ( $ message , 200 ) ; $ response -> addHeader ( 'Content-Type' , 'text/html; charset=utf-8' ) ; return $ response ; } return $ this -> controller -> redirectBack ( ) ; }
8154	public function addFunction ( $ name , $ function = null ) { if ( ! $ name instanceof Twig_SimpleFunction && ! ( $ function instanceof Twig_SimpleFunction || $ function instanceof Twig_FunctionInterface ) ) { throw new LogicException ( 'A function must be an instance of Twig_FunctionInterface or Twig_SimpleFunction.' ) ; } if ( $ name instanceof Twig_SimpleFunction ) { $ function = $ name ; $ name = $ function -> getName ( ) ; } else { @ trigger_error ( sprintf ( 'Passing a name as a first argument to the %s method is deprecated since version 1.21. Pass an instance of "Twig_SimpleFunction" instead when defining function "%s".' , __METHOD__ , $ name ) , E_USER_DEPRECATED ) ; } if ( $ this -> extensionInitialized ) { throw new LogicException ( sprintf ( 'Unable to add function "%s" as extensions have already been initialized.' , $ name ) ) ; } $ this -> staging -> addFunction ( $ name , $ function ) ; }
2910	public function runSql ( $ query , $ queryParams = array ( ) ) { $ connection = Mage :: getSingleton ( 'core/resource' ) -> getConnection ( 'core_write' ) ; $ statement = $ connection -> query ( $ query , $ queryParams ) ; return $ statement -> fetchAll ( PDO :: FETCH_ASSOC ) ; }
784	protected function validateCache ( $ lastModified , $ etag ) { if ( Yii :: $ app -> request -> headers -> has ( 'If-None-Match' ) ) { return $ etag !== null && in_array ( $ etag , Yii :: $ app -> request -> getETags ( ) , true ) ; } elseif ( Yii :: $ app -> request -> headers -> has ( 'If-Modified-Since' ) ) { return $ lastModified !== null && @ strtotime ( Yii :: $ app -> request -> headers -> get ( 'If-Modified-Since' ) ) >= $ lastModified ; } return false ; }
11401	public function startAt ( $ startAt = 0 ) { if ( ! is_numeric ( $ startAt ) || $ startAt < 0 ) { throw new Exception ( "startAt: bad value" , 10 ) ; } $ this -> startAt = $ startAt ; return $ this ; }
11148	public function getMultipleDisplayObjects ( $ areas ) { $ out = array ( ) ; foreach ( $ areas as $ v ) { if ( ! ( $ v instanceof Neuron_GameServer_Map_Area ) ) { throw new Neuron_Exceptions_InvalidParameter ( "Parameters must be an array of area objects." ) ; } foreach ( $ this -> getDisplayObjects ( $ v ) as $ v ) { if ( ! $ v instanceof Neuron_GameServer_Map_MapObject ) { throw new Neuron_Core_Error ( "All map objects MUST implement Neuron_GameServer_Map_MapObject" ) ; } $ out [ ] = $ v ; } } return $ out ; }
8406	private function getModelName ( ) { if ( isset ( $ this -> class ) ) { return $ this -> class ; } if ( isset ( $ this -> model ) ) { $ rClass = new \ ReflectionClass ( $ this -> model ) ; return $ rClass -> getShortName ( ) ; } return 'Icon' ; }
6252	protected function createUngroupedGroupPresence ( $ id = null ) { $ id = $ id ? : 'automatic-ungrouped-permissions' ; return new AclPresence ( [ 'type' => AclPresenceType :: GROUP , 'id' => $ id , 'label' => 'acl.ungrouped-permissions' , 'translated' => true , ] ) ; }
10280	public static function absoluteReference ( $ pCoordinateString ) { if ( self :: coordinateIsRange ( $ pCoordinateString ) ) { throw new Exception ( 'Cell coordinate string can not be a range of cells' ) ; } $ worksheet = '' ; $ cellAddress = explode ( '!' , $ pCoordinateString ) ; if ( count ( $ cellAddress ) > 1 ) { list ( $ worksheet , $ pCoordinateString ) = $ cellAddress ; } if ( $ worksheet > '' ) { $ worksheet .= '!' ; } if ( ctype_digit ( $ pCoordinateString ) ) { return $ worksheet . '$' . $ pCoordinateString ; } elseif ( ctype_alpha ( $ pCoordinateString ) ) { return $ worksheet . '$' . strtoupper ( $ pCoordinateString ) ; } return $ worksheet . self :: absoluteCoordinate ( $ pCoordinateString ) ; }
7972	public function deleteIncoming ( $ domain , $ id ) { if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; if ( ! $ id ) throw new BadMethodCallException ( 'Parameter $id is missing.' ) ; try { $ this -> delete ( 'sms/' . $ domain . '/incoming/' . $ id ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new SmsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return true ; }
2324	public static function validate ( $ strToken ) { if ( Config :: get ( 'disableRefererCheck' ) || \ defined ( 'BYPASS_TOKEN_CHECK' ) ) { return true ; } if ( Config :: get ( 'requestTokenWhitelist' ) ) { $ strHostname = gethostbyaddr ( $ _SERVER [ 'REMOTE_ADDR' ] ) ; foreach ( Config :: get ( 'requestTokenWhitelist' ) as $ strDomain ) { if ( $ strDomain == $ strHostname || preg_match ( '/\.' . preg_quote ( $ strDomain , '/' ) . '$/' , $ strHostname ) ) { return true ; } } } $ container = System :: getContainer ( ) ; return $ container -> get ( 'contao.csrf.token_manager' ) -> isTokenValid ( new CsrfToken ( $ container -> getParameter ( 'contao.csrf_token_name' ) , $ strToken ) ) ; }
10190	public function getAllSpContainers ( ) { $ allSpContainers = [ ] ; foreach ( $ this -> children as $ child ) { if ( $ child instanceof self ) { $ allSpContainers = array_merge ( $ allSpContainers , $ child -> getAllSpContainers ( ) ) ; } else { $ allSpContainers [ ] = $ child ; } } return $ allSpContainers ; }
577	protected static function normalizeRoute ( $ route ) { $ route = Yii :: getAlias ( ( string ) $ route ) ; if ( strncmp ( $ route , '/' , 1 ) === 0 ) { return ltrim ( $ route , '/' ) ; } if ( Yii :: $ app -> controller === null ) { throw new InvalidArgumentException ( "Unable to resolve the relative route: $route. No active controller is available." ) ; } if ( strpos ( $ route , '/' ) === false ) { return $ route === '' ? Yii :: $ app -> controller -> getRoute ( ) : Yii :: $ app -> controller -> getUniqueId ( ) . '/' . $ route ; } return ltrim ( Yii :: $ app -> controller -> module -> getUniqueId ( ) . '/' . $ route , '/' ) ; }
7989	public function getTemplateProperties ( $ domain , $ templateId ) { $ domain = ( string ) $ domain ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; $ templateId = ( string ) $ templateId ; if ( ! $ templateId ) throw new BadMethodCallException ( "Parameter $templateId is missing" ) ; try { $ r = $ this -> get ( 'vps/' . $ domain . '/templates/' . $ templateId ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new VpsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( ) ; }
9610	public function getRouteUrl ( $ name , array $ params = array ( ) , $ relative = false ) { $ route = $ this -> router -> getRoute ( $ name ) ; $ routeParams = [ ] ; $ query = [ ] ; foreach ( $ params as $ key => $ value ) { if ( is_int ( $ key ) ) { $ routeParams [ ] = $ value ; } else { $ query [ $ key ] = $ value ; } } $ path = $ this -> routePathGenerator -> getRoutePath ( $ route , $ routeParams ) ; if ( $ query ) { $ path .= '?' . http_build_query ( $ query ) ; } if ( $ relative ) { $ root = $ this -> requests -> getCurrentRequest ( ) -> getBaseUrl ( ) ; } else { $ root = $ this -> getRootUrl ( ) ; } return $ root . $ path ; }
4917	public function setParams ( array $ params ) { foreach ( $ params as $ key => $ value ) { $ this -> setParam ( $ key , $ value ) ; } return $ this ; }
3834	public function hookAdditionalFormatters ( $ arrBaseFormatted , $ arrRowData , $ strOutputFormat , $ objSettings ) { $ arrResult = $ arrBaseFormatted ; if ( isset ( $ GLOBALS [ 'METAMODEL_HOOKS' ] [ 'parseValue' ] ) && is_array ( $ GLOBALS [ 'METAMODEL_HOOKS' ] [ 'parseValue' ] ) ) { foreach ( $ GLOBALS [ 'METAMODEL_HOOKS' ] [ 'parseValue' ] as $ callback ) { list ( $ strClass , $ strMethod ) = $ callback ; $ objCallback = ( in_array ( 'getInstance' , get_class_methods ( $ strClass ) ) ) ? call_user_func ( array ( $ strClass , 'getInstance' ) ) : new $ strClass ( ) ; $ arrResult = $ objCallback -> $ strMethod ( $ this , $ arrResult , $ arrRowData , $ strOutputFormat , $ objSettings ) ; } } return $ arrResult ; }
566	public function setScriptFile ( $ value ) { $ scriptFile = realpath ( Yii :: getAlias ( $ value ) ) ; if ( $ scriptFile !== false && is_file ( $ scriptFile ) ) { $ this -> _scriptFile = $ scriptFile ; } else { throw new InvalidConfigException ( 'Unable to determine the entry script file path.' ) ; } }
9088	public function slurp ( ) : string { $ str = "" ; while ( $ this -> ready ( ) ) { $ str .= $ this -> read ( $ this -> count ( ) ) ; } return $ str ; }
4712	public function escapeHtml ( $ option = ENT_QUOTES ) { $ this -> text = htmlspecialchars ( $ this -> text , $ option , 'UTF-8' , false ) ; return $ this ; }
4730	public static function transcode ( $ source , $ fromEncoding , $ toEncoding ) { if ( \ is_string ( $ source ) ) { switch ( ICONV_IMPL ) { case 'glibc' : return @ iconv ( $ fromEncoding , $ toEncoding . '//TRANSLIT,IGNORE' , $ source ) ; case 'libiconv' : default : return iconv ( $ fromEncoding , $ toEncoding . '//IGNORE//TRANSLIT' , $ source ) ; } } }
10574	public function remove ( $ key ) { $ this -> open ( ) ; if ( isset ( $ _SESSION [ $ key ] ) ) { $ value = $ _SESSION [ $ key ] ; unset ( $ _SESSION [ $ key ] ) ; return $ value ; } else { return null ; } }
11001	public function setLocale ( $ locale ) { $ locale = WF :: cast_array ( $ locale ) ; foreach ( $ locale as $ l ) $ this -> locales [ ] = new Locale ( $ l ) ; $ this -> locales = array_unique ( $ this -> locales ) ; return $ this ; }
8584	public function setASIN ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ASIN' ] [ 'FieldValue' ] = $ value ; return $ this ; }
9480	public function setErrorCode ( $ errorCode ) { $ this -> error = $ this -> config [ $ errorCode ] ; $ this -> errorCode = $ errorCode ; return $ this ; }
3879	public function addSubProcedure ( FilterBuilderSql $ subProcedure ) { $ this -> procedures [ ] = $ subProcedure -> getProcedure ( ) ; $ this -> parameter = array_merge ( $ this -> parameter , $ subProcedure -> getParameters ( ) ) ; return $ this ; }
2851	public function searchConfig ( $ query ) { $ configArray = array ( ) ; $ configArray = Mage :: helper ( 'sheep_debug' ) -> xml2array ( $ this -> getConfig ( ) -> getNode ( ) , $ configArray ) ; $ results = array ( ) ; $ configKeys = array_keys ( $ configArray ) ; foreach ( $ configKeys as $ configKey ) { if ( strpos ( $ configKey , $ query ) !== FALSE ) { $ results [ $ configKey ] = $ configArray [ $ configKey ] ; } } return $ results ; }
4414	public function onKernelRequest ( GetResponseEvent $ event ) { if ( ! $ event -> isMasterRequest ( ) ) { return ; } if ( ! $ this -> isAdminSiteAccess ) { return ; } $ currentRoute = $ event -> getRequest ( ) -> attributes -> get ( '_route' ) ; if ( mb_stripos ( $ currentRoute , 'netgen_information_collection' ) !== 0 ) { return ; } $ this -> globalVariable -> setPageLayoutTemplate ( $ this -> pageLayoutTemplate ) ; }
12171	public static function getDefaultForClass ( $ class , array $ params = array ( ) ) { $ reflectionClass = new ReflectionClass ( $ class ) ; if ( ! $ reflectionClass -> isInstantiable ( ) ) { throw new NotInstantiableException ( "Class $class is not instantiable" ) ; } $ factory = new static ( [ $ reflectionClass , 'newInstance' ] , "$class::__construct" ) ; if ( $ reflectionClass -> hasMethod ( '__construct' ) ) { static :: addReflectionArguments ( $ factory , $ reflectionClass -> getMethod ( '__construct' ) ) ; } return $ factory -> getFactory ( $ params ) ; }
5391	public function getValue ( ) { $ widgets = $ this -> getWidgets ( ) ; for ( $ i = 0 , $ count = count ( $ widgets ) ; $ i < $ count ; $ i ++ ) { if ( $ widgets [ $ i ] -> getValue ( ) !== false ) { return $ widgets [ $ i ] -> getValue ( ) ; } } return false ; }
12095	public function shortText ( $ text , $ length ) { $ text = trim ( $ text ) ; $ charset = mb_detect_encoding ( $ text ) ; if ( mb_strlen ( $ text , $ charset ) > $ length ) { $ text = mb_substr ( $ text , 0 , $ length , $ charset ) . '...' ; } else { $ text = $ text ; } return $ text ; }
9695	private function applyInlineStyle ( & $ sheet , $ row , $ column , $ attributeArray ) { if ( ! isset ( $ attributeArray [ 'style' ] ) ) { return ; } $ supported_styles = [ 'background-color' , 'color' ] ; $ styles = explode ( ';' , $ attributeArray [ 'style' ] ) ; foreach ( $ styles as $ st ) { $ value = explode ( ':' , $ st ) ; if ( empty ( trim ( $ value [ 0 ] ) ) || ! in_array ( trim ( $ value [ 0 ] ) , $ supported_styles ) ) { continue ; } if ( substr ( trim ( $ value [ 1 ] ) , 0 , 1 ) == '#' ) { $ style_color = substr ( trim ( $ value [ 1 ] ) , 1 ) ; } if ( empty ( $ style_color ) ) { continue ; } switch ( trim ( $ value [ 0 ] ) ) { case 'background-color' : $ sheet -> getStyle ( $ column . $ row ) -> applyFromArray ( [ 'fill' => [ 'fillType' => Fill :: FILL_SOLID , 'color' => [ 'rgb' => "{$style_color}" ] ] ] ) ; break ; case 'color' : $ sheet -> getStyle ( $ column . $ row ) -> applyFromArray ( [ 'font' => [ 'color' => [ 'rgb' => "$style_color}" ] ] ] ) ; break ; } } }
3972	public function decodeAttributeValue ( DecodePropertyValueForWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ metaModel = $ this -> getMetaModel ( $ event -> getEnvironment ( ) ) ; $ value = $ event -> getValue ( ) ; if ( ! ( $ metaModel && $ value ) ) { return ; } $ attribute = $ metaModel -> getAttributeById ( $ value ) ; if ( $ attribute ) { $ event -> setValue ( $ metaModel -> getTableName ( ) . '_' . $ attribute -> getColName ( ) ) ; } }
5955	public function channelPermList ( $ cid , $ permsid = false ) { return $ this -> execute ( "channelpermlist" , array ( "cid" => $ cid , $ permsid ? "-permsid" : null ) ) -> toAssocArray ( $ permsid ? "permsid" : "permid" ) ; }
6999	public function getCssClassesForContainer ( ) { $ colsXl = $ this -> getWidth ( ) >= 100 ? 12 : ceil ( 12 * ( $ this -> getWidth ( ) / 100 ) ) ; $ colsXlLeft = floor ( ( 12 - $ colsXl ) / 2 ) ; $ colsLg = $ colsXl >= 10 ? 12 : $ colsXl + 2 ; $ colsLgLeft = floor ( ( 12 - $ colsLg ) / 2 ) ; return "col-xs-12 col-xl-{$colsXl} col-lg-{$colsLg} col-xl-offset-{$colsXlLeft} col-lg-offset-{$colsLgLeft}" ; }
5315	protected function generateBlocks ( ) { $ blocks = [ ] ; foreach ( range ( 1 , $ this -> getBlocks ( ) ) as $ counter ) { $ blocks [ ] = $ this -> generateChars ( ) ; } return implode ( $ this -> blockSeparator , $ blocks ) ; }
255	public function beforeRun ( ) { $ event = new WidgetEvent ( ) ; $ this -> trigger ( self :: EVENT_BEFORE_RUN , $ event ) ; return $ event -> isValid ; }
6523	public function isCompatibleForOverride ( Field $ other ) { if ( ! $ this -> overridable ) { return false ; } if ( $ this -> name !== $ other -> name ) { return false ; } if ( $ this -> type !== $ other -> type ) { return false ; } if ( $ this -> rule !== $ other -> rule ) { return false ; } if ( $ this -> required !== $ other -> required ) { return false ; } return true ; }
887	private function needFixing ( Tokens $ tokens , $ index ) { if ( $ this -> isStrictOrNullableReturnTypeFunction ( $ tokens , $ index ) ) { return false ; } $ content = '' ; while ( ! $ tokens [ $ index ] -> equals ( ';' ) ) { $ index = $ tokens -> getNextMeaningfulToken ( $ index ) ; $ content .= $ tokens [ $ index ] -> getContent ( ) ; } $ content = ltrim ( $ content , '(' ) ; $ content = rtrim ( $ content , ');' ) ; return 'null' === strtolower ( $ content ) ; }
7912	protected function renderToggleButton ( ) { if ( $ this -> toggleButton !== false ) { $ tag = ArrayHelper :: remove ( $ this -> toggleButton , 'tag' , 'div' ) ; $ label = ArrayHelper :: remove ( $ this -> toggleButton , 'label' , 'Show' ) ; if ( $ tag === 'button' && ! isset ( $ this -> toggleButton [ 'type' ] ) ) { $ this -> toggleButton [ 'type' ] = 'button' ; } if ( $ tag === 'div' ) { Html :: addCssClass ( $ this -> toggleButton , 'ui' ) ; Html :: addCssClass ( $ this -> toggleButton , 'button' ) ; } $ view = $ this -> getView ( ) ; DosAmigosAsset :: register ( $ view ) ; $ view -> registerJs ( 'dosamigos.semantic.init();' ) ; return Html :: tag ( $ tag , $ label , $ this -> toggleButton ) ; } else { return null ; } }
9250	public function boot ( ) { if ( $ this -> booted ) { return ; } $ this -> container = $ this -> initializeContainer ( ) ; $ this -> kernel = $ this -> container -> get ( 'http_kernel' ) ; $ this -> booted = true ; }
10028	function getContactsByExternalId ( $ externalId , $ standard_fields = array ( ) , $ custom_fields = array ( ) ) { $ queryParameters = array ( 'standard_field' => $ standard_fields ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'custom_field' , $ custom_fields ) ; return $ this -> get ( 'contacts/externalid/' . utf8_encode ( $ externalId ) , $ queryParameters ) ; }
12931	public function createRouter ( $ debug = false ) { if ( null === $ this -> routesFile ) { throw new LogicException ( 'The derived class must define the string variable "routesFile"' ) ; } if ( ! is_string ( $ this -> routesFile ) ) { throw new LogicException ( '"routesFile" variable must be a string value' ) ; } $ isProduction = $ this -> configurationHandler -> isProduction ( ) ; $ cacheDir = null ; if ( ! $ debug && $ isProduction ) { $ cacheDir = $ this -> configurationHandler -> siteCacheDir ( ) . '/routes' ; } $ this -> router = new Router ( new YamlFileLoader ( $ this -> fileLocator ) , $ this -> routesFile , array ( 'cache_dir' => $ cacheDir ) ) ; return $ this -> router ; }
2912	public function formatNumber ( $ number , $ precision = 2 ) { $ locale = Mage :: app ( ) -> getLocale ( ) -> getLocale ( ) ; return Zend_Locale_Format :: toNumber ( $ number , array ( 'locale' => $ locale , 'precision' => $ precision ) ) ; }
3198	protected function checkTimestampCoherence ( $ points , $ timestamp ) { foreach ( $ points as $ point ) { if ( $ point -> getTimestamp ( ) > $ timestamp ) { throw new InconsistentRangeException ( 'A new TimePoint cannot be set before an existing one!' ) ; } } }
10374	public static function remove ( $ type , $ name ) { if ( isset ( self :: $ data [ $ type ] [ $ name ] ) ) { unset ( self :: $ data [ $ type ] [ $ name ] ) ; } return true ; }
7867	protected function drawBorder ( $ left , $ middle , $ right ) { $ width = $ this -> geometry -> getWidthButBorders ( ) ; $ border = str_repeat ( static :: BORDER_Y , $ width ) ; $ this -> replaceUtf8 ( $ border , $ left , 0 ) ; $ this -> replaceUtf8 ( $ border , $ middle , floor ( $ width / 2 ) ) ; $ this -> replaceUtf8 ( $ border , $ right , $ width - 1 ) ; $ this -> drawBordered ( $ border ) ; }
2211	public function fetchEach ( $ strKey ) { $ this -> reset ( ) ; $ arrReturn = array ( ) ; while ( ( $ arrRow = $ this -> fetchAssoc ( ) ) !== false ) { if ( $ strKey != 'id' && isset ( $ arrRow [ 'id' ] ) ) { $ arrReturn [ $ arrRow [ 'id' ] ] = $ arrRow [ $ strKey ] ; } else { $ arrReturn [ ] = $ arrRow [ $ strKey ] ; } } return $ arrReturn ; }
11168	public function getApiAsArray ( ) { if ( $ this -> useCache ( ) ) { if ( $ this -> getExtCache ( ) -> isApiCached ( ) ) { return $ this -> getExtCache ( ) -> getApi ( ) ; } } $ api = $ this -> generateApi ( ) ; if ( $ this -> useCache ( ) ) { $ this -> getExtCache ( ) -> cacheApi ( $ api ) ; } return $ api ; }
721	public function money ( $ precision = null , $ scale = null ) { $ length = [ ] ; if ( $ precision !== null ) { $ length [ ] = $ precision ; } if ( $ scale !== null ) { $ length [ ] = $ scale ; } return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_MONEY , $ length ) ; }
4846	public static function register ( array $ aliases ) { if ( ! $ aliases ) { return ; } if ( ! isset ( self :: $ autoloadFn ) ) { $ classAliases = & self :: $ aliases ; self :: $ autoloadFn = function ( $ className ) use ( & $ classAliases ) { if ( isset ( $ classAliases [ $ className ] ) ) { if ( strtolower ( $ classAliases [ $ className ] ) === strtolower ( $ className ) ) { throw new \ LogicException ( "Class alias is referencing the alias itself" ) ; } $ facadeClass = $ classAliases [ $ className ] ; class_alias ( $ facadeClass , $ className ) ; } } ; spl_autoload_register ( self :: $ autoloadFn ) ; } self :: $ aliases = array_merge ( self :: $ aliases , $ aliases ) ; }
12124	public function getLanguages ( ) { $ languages = array ( ) ; foreach ( $ this -> getAliases ( ) as $ siteAlias ) { $ language = $ siteAlias -> getLanguage ( ) ; if ( ! in_array ( $ language , $ languages ) ) { $ languages [ ] = $ language ; } } return $ languages ; }
5277	public function where ( $ column , $ param1 = null , $ param2 = null , $ type = 'and' ) { if ( ! in_array ( $ type , array ( 'and' , 'or' , 'where' ) ) ) { throw new \ Exception ( 'Invalid where type "' . $ type . '"' ) ; } $ sub_type = is_null ( $ param1 ) ? $ type : $ param1 ; if ( empty ( $ this -> statements [ 'wheres' ] ) ) { $ type = 'where' ; } if ( is_array ( $ column ) ) { $ subquery = array ( ) ; foreach ( $ column as $ value ) { if ( ! isset ( $ value [ 2 ] ) ) { $ value [ 2 ] = $ value [ 1 ] ; $ value [ 1 ] = '=' ; } $ subquery [ ] = $ this -> generateWhere ( $ value [ 0 ] , $ value [ 1 ] , $ value [ 2 ] , empty ( $ subquery ) ? '' : $ sub_type ) ; } $ this -> statements [ 'wheres' ] [ ] = $ type . ' ( ' . trim ( join ( ' ' , $ subquery ) ) . ' )' ; return $ this ; } $ this -> statements [ 'wheres' ] [ ] = $ this -> generateWhere ( $ column , $ param1 , $ param2 , $ type ) ; return $ this ; }
6087	public function retrieveTemplate ( $ templateId , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/moodboards/templates/' . $ templateId . '' , $ parameters , $ cachePolicy ) ; $ result = new MoodboardTemplateResponse ( $ result ) ; return $ result ; }
2645	public function checkServiceDetails ( $ test = false , $ serviceId = null , $ apiKey = null ) { if ( ! $ test ) { $ uri = rtrim ( $ this -> _getApiServiceUri ( ) , '/' ) ; $ result = $ this -> _fetch ( $ uri ) ; } else { $ uri = $ this -> config -> getApiEndpoint ( ) . 'service/' . $ serviceId ; $ result = $ this -> _fetch ( $ uri , \ Zend_Http_Client :: GET , null , true , $ apiKey ) ; } if ( ! $ result ) { throw new LocalizedException ( __ ( 'Failed to check Service details.' ) ) ; } return $ result ; }
9670	private function writeBorder ( XMLWriter $ objWriter , Borders $ pBorders ) { $ objWriter -> startElement ( 'border' ) ; switch ( $ pBorders -> getDiagonalDirection ( ) ) { case Borders :: DIAGONAL_UP : $ objWriter -> writeAttribute ( 'diagonalUp' , 'true' ) ; $ objWriter -> writeAttribute ( 'diagonalDown' , 'false' ) ; break ; case Borders :: DIAGONAL_DOWN : $ objWriter -> writeAttribute ( 'diagonalUp' , 'false' ) ; $ objWriter -> writeAttribute ( 'diagonalDown' , 'true' ) ; break ; case Borders :: DIAGONAL_BOTH : $ objWriter -> writeAttribute ( 'diagonalUp' , 'true' ) ; $ objWriter -> writeAttribute ( 'diagonalDown' , 'true' ) ; break ; } $ this -> writeBorderPr ( $ objWriter , 'left' , $ pBorders -> getLeft ( ) ) ; $ this -> writeBorderPr ( $ objWriter , 'right' , $ pBorders -> getRight ( ) ) ; $ this -> writeBorderPr ( $ objWriter , 'top' , $ pBorders -> getTop ( ) ) ; $ this -> writeBorderPr ( $ objWriter , 'bottom' , $ pBorders -> getBottom ( ) ) ; $ this -> writeBorderPr ( $ objWriter , 'diagonal' , $ pBorders -> getDiagonal ( ) ) ; $ objWriter -> endElement ( ) ; }
12365	public function init ( ) { $ config = new Zend_Config_Ini ( $ this -> config_path == null ? APPLICATION_PATH . DS . "configs" . DS . "secret.ini" : $ config_path , APPLICATION_ENV ) ; $ this -> setConsumer ( new Zend_Oauth_Consumer ( array ( 'callbackUrl' => $ config -> oauth -> callback , 'siteUrl' => $ config -> oauth -> siteurl , 'consumerKey' => $ config -> oauth -> consumerkey , 'consumerSecret' => $ config -> oauth -> consumersecret ) ) ) ; }
12692	public function synchronize ( Page $ page , array $ pages ) { if ( ! $ this -> configurationHandler -> isTheme ( ) ) { return ; } foreach ( $ pages as $ pageValues ) { $ tokens = explode ( "_" , $ pageValues [ "seo" ] [ 0 ] [ "language" ] ) ; $ pageOptions = array ( 'page' => $ pageValues [ "name" ] , 'language' => $ tokens [ 0 ] , 'country' => $ tokens [ 1 ] , ) ; $ page -> render ( $ this -> configurationHandler -> siteDir ( ) , $ pageOptions ) ; $ this -> saveTemplateSlots ( $ page -> getPageSlots ( ) , $ pageValues [ "template" ] ) ; } $ this -> saveTemplateSlots ( $ page -> getCommonSlots ( ) , 'base' ) ; }
7475	private function configureEmailHelper ( ContainerBuilder $ container ) { if ( ! class_exists ( 'Swift_Mailer' ) ) { $ definition = $ container -> getDefinition ( 'orkestra.application.helper.email' ) ; $ definition -> setClass ( 'Orkestra\Bundle\ApplicationBundle\Helper\EmailHelper\MisconfiguredEmailHelper' ) ; $ definition -> setArguments ( array ( ) ) ; } }
3106	public function getEvents ( ) { if ( isset ( $ this -> state [ self :: VAR_EVENTS_QUEUE ] ) ) { $ events = $ this -> state [ self :: VAR_EVENTS_QUEUE ] ; } else { $ events = [ ] ; } return $ events ; }
10421	public function addToUpdateFields ( $ updateField , $ updateType = null ) { $ this -> updateFields [ $ updateField ] = [ 'priority' => isset ( $ updateType ) ? $ updateType : $ this -> defaultJobType ] ; }
3069	protected function endItemTimer ( $ timestamp = null ) { if ( $ this -> getRequestParameter ( 'itemDuration' ) ) { $ serviceContext = $ this -> getServiceContext ( ) ; $ itemDuration = $ this -> getRequestParameter ( 'itemDuration' ) ; return $ this -> getRunnerService ( ) -> endTimer ( $ serviceContext , $ itemDuration , $ timestamp ) ; } return false ; }
9738	public function setFitToHeight ( $ pValue , $ pUpdate = true ) { $ this -> fitToHeight = $ pValue ; if ( $ pUpdate ) { $ this -> fitToPage = true ; } return $ this ; }
11730	public function validatePassword ( ) { $ user = User :: findByEmail ( $ this -> email ) ; if ( ! $ user || ! $ user -> validatePassword ( $ this -> password ) ) { $ this -> addError ( 'password' , 'Incorrect username or password.' ) ; } }
6634	public function parseProfileResponse ( Response $ response , AccessTokenInterface $ access_token ) { $ profile = $ response -> json ( ) ; if ( gettype ( $ profile ) !== 'object' ) { throw new InvalidProfileException ( ) ; } if ( isset ( $ profile -> error ) ) { $ error = $ profile -> error ; throw new InvalidProfileException ( $ error -> type . ': ' . $ error -> message , $ error -> code ) ; } $ profile -> access_token = $ access_token -> token ( ) ; return $ this -> profile -> instantiate ( $ profile , $ this -> name ) ; }
10829	public static function dir ( string $ path ) : fs \ entity \ DirEntity { return ( new fs \ entity \ DirEntity ( $ path ) ) -> normalize ( ) ; }
6029	public function addDeploymentFile ( $ item ) { if ( ! ( $ item instanceof DeploymentFile ) ) { if ( is_array ( $ item ) ) { try { $ item = new DeploymentFile ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate DeploymentFile. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "DeploymentFile"!' , E_USER_WARNING ) ; } } $ this -> deployedFiles [ ] = $ item ; return $ this ; }
7233	protected function assertSaleClass ( Common \ SaleInterface $ sale ) { if ( ! $ sale instanceof Model \ CartInterface ) { throw new InvalidArgumentException ( "Expected instance of " . Model \ CartInterface :: class ) ; } }
11925	public function generate ( string $ outputDir ) : array { $ generatedFiles = [ ] ; foreach ( $ this -> generators as $ generator ) { $ this -> logger -> info ( 'Running generator ' . get_class ( $ generator ) ) ; $ result = $ generator -> generate ( ) ; foreach ( $ result -> all ( ) as $ phpFile ) { $ path = str_replace ( [ '/' , "\\" ] , DIRECTORY_SEPARATOR , $ outputDir . '/' . $ phpFile -> getFqcn ( ) -> getNamespace ( ) ) ; BaseUtil :: ensureDirectory ( $ path , 0711 ) ; $ filePath = $ path . DIRECTORY_SEPARATOR . $ phpFile -> getFqcn ( ) -> getName ( ) . '.php' ; $ this -> logger -> info ( 'Writing to file ' . $ filePath ) ; file_put_contents ( $ filePath , $ phpFile -> getText ( ) ) ; $ generatedFiles [ ] = new GeneratedFile ( $ filePath , $ phpFile ) ; } } return $ generatedFiles ; }
11589	public function matrix ( ) { if ( $ this -> _matrix ) { return $ this -> _matrix ; } $ this -> _matrix = new Matrix ( $ this -> tasks ( ) ) ; $ this -> _matrix -> process ( ) ; return $ this -> _matrix ; }
12784	protected function isNoResultMask ( $ mask ) { foreach ( $ this -> noResultMasks as $ noresultMask ) { if ( $ mask === $ noresultMask ) { return TRUE ; } if ( ( $ mask & $ noresultMask ) === $ noresultMask ) { $ this -> noResultMasks [ ] = $ mask ; return TRUE ; } } return FALSE ; }
4729	public function isSingular ( $ word ) { $ inflection = $ this -> getCachedPlural ( $ word ) ; if ( $ inflection !== false ) { return true ; } $ pluralWord = $ this -> toPlural ( $ word ) ; if ( $ pluralWord === false ) { return false ; } return $ this -> toSingular ( $ pluralWord ) == $ word ; }
8761	public function writeLogLine ( Tick $ tick ) { $ lineSegs = array ( ) ; switch ( $ tick -> getStatus ( ) ) { case Tick :: SUCCESS : $ lineSegs [ ] = sprintf ( "<fg=green>%s</fg=green>" , $ this -> linePrefixMap [ Tick :: SUCCESS ] ) ; break ; case Tick :: FAIL : $ lineSegs [ ] = sprintf ( "<fg=red>%s</fg=red>" , $ this -> linePrefixMap [ Tick :: FAIL ] ) ; break ; case Tick :: SKIP : default : $ lineSegs [ ] = $ this -> linePrefixMap [ Tick :: SKIP ] ; } $ lineSegs [ ] = sprintf ( "[%s%s]" , $ tick -> getReport ( ) -> getNumItemsProcessed ( ) , $ tick -> getReport ( ) -> getTotalItemCount ( ) != Tracker :: UNKNOWN ? "/" . $ tick -> getReport ( ) -> getTotalItemCount ( ) : '' ) ; if ( $ this -> output -> getVerbosity ( ) >= OutputInterface :: VERBOSITY_VERBOSE ) { $ lineSegs [ ] = $ this -> formatSeconds ( $ tick -> getReport ( ) -> getTimeElapsed ( ) ) ; $ lineSegs [ ] = sprintf ( '(<fg=green>%s</fg=green>/%s/<fg=red>%s</fg=red>)' , $ tick -> getReport ( ) -> getNumItemsSuccess ( ) , $ tick -> getReport ( ) -> getNumItemsSkip ( ) , $ tick -> getReport ( ) -> getNumItemsFail ( ) ) ; } if ( $ this -> output -> getVerbosity ( ) >= OutputInterface :: VERBOSITY_VERY_VERBOSE ) { $ lineSegs [ ] = sprintf ( "{%s/%s}" , $ this -> bytesToHuman ( $ tick -> getReport ( ) -> getMemUsage ( ) ) , $ this -> bytesToHuman ( $ tick -> getReport ( ) -> getMemPeakUsage ( ) ) ) ; } $ lineSegs [ ] = $ tick -> getMessage ( ) ? : sprintf ( "Processing item %s" , number_format ( $ tick -> getReport ( ) -> getNumItemsProcessed ( ) , 0 ) ) ; $ this -> output -> writeln ( implode ( ' ' , $ lineSegs ) ) ; }
12471	protected function setDatabaseFactoryNamespaces ( ) { $ this -> replaceIn ( $ this -> laravel -> databasePath ( ) . '/factories/ModelFactory.php' , $ this -> currentRoot , $ this -> argument ( 'name' ) ) ; }
2781	public function getCommandLine ( ) { if ( $ this -> executeRaw ) { return $ this -> getCommand ( ) ; } $ command = array_merge ( [ $ this -> getCommand ( ) ] , $ this -> buildOptions ( ) , $ this -> args ) ; return array_filter ( $ command , 'strlen' ) ; }
12918	protected function findContentType ( $ spaceId , $ contentTypeName ) { $ contentTypes = $ this -> contentTypeRepo -> findNewestByName ( $ spaceId , $ contentTypeName ) ; if ( $ contentTypes -> isEmpty ( ) ) { throw new InvalidArgumentException ( sprintf ( 'Content type "%s" in space "%s" not found!' , $ contentTypeName , $ spaceId ) ) ; } if ( $ contentTypes -> count ( ) > 1 ) { throw new InvalidArgumentException ( sprintf ( 'Multiple content types with name "%s" found in space "%s"!' , $ contentTypeName , $ spaceId ) ) ; } $ contentType = $ contentTypes -> first ( ) ; return $ contentType ; }
8347	public function canEdit ( GroupableInterface $ post , TokenInterface $ token ) : bool { $ user = $ token -> getUser ( ) ; if ( $ post -> getAuthor ( ) == $ user -> getUsername ( ) ) { return true ; } foreach ( $ post -> getGroups ( ) as $ group ) { if ( $ this -> decision_manager -> decide ( $ token , [ 'GROUP_ROLE_ADMIN' ] , $ group ) ) { return true ; } } return false ; }
24	public function copy ( $ originUrl , $ fileUrl , $ fileName , $ progress = true , $ options = array ( ) ) { return $ this -> get ( $ originUrl , $ fileUrl , $ options , $ fileName , $ progress ) ; }
520	protected function migrateUp ( $ class ) { if ( $ class === self :: BASE_MIGRATION ) { return true ; } $ this -> stdout ( "*** applying $class\n" , Console :: FG_YELLOW ) ; $ start = microtime ( true ) ; $ migration = $ this -> createMigration ( $ class ) ; if ( $ migration -> up ( ) !== false ) { $ this -> addMigrationHistory ( $ class ) ; $ time = microtime ( true ) - $ start ; $ this -> stdout ( "*** applied $class (time: " . sprintf ( '%.3f' , $ time ) . "s)\n\n" , Console :: FG_GREEN ) ; return true ; } $ time = microtime ( true ) - $ start ; $ this -> stdout ( "*** failed to apply $class (time: " . sprintf ( '%.3f' , $ time ) . "s)\n\n" , Console :: FG_RED ) ; return false ; }
12690	protected function merge ( array $ configs ) { $ objects = array_filter ( $ configs , 'is_object' ) ; if ( ! empty ( $ objects ) ) { $ listConfigs = [ ] ; foreach ( $ configs as $ config ) { if ( ! is_object ( $ config ) ) { throw new RuntimeException ( 'Cannot merge object with other types' ) ; } $ listConfigs [ ] = ( array ) $ config ; } $ result = ( object ) $ this -> merge ( $ listConfigs ) ; } else { foreach ( $ configs as $ config ) { foreach ( $ config as $ key => $ value ) { $ existed = isset ( $ result [ $ key ] ) ; switch ( true ) { case ( $ existed && ( is_object ( $ result [ $ key ] ) || is_object ( $ value ) ) ) : case ( $ existed && ( is_array ( $ result [ $ key ] ) && is_array ( $ value ) ) ) : $ result [ $ key ] = $ this -> merge ( array ( $ result [ $ key ] , $ value ) ) ; break ; default : $ result [ $ key ] = $ value ; } } } } return $ result ; }
1313	public function setRetries ( $ maxRetries , $ retriesDelay ) { $ this -> maxRetries = ( int ) $ maxRetries ; $ this -> retriesDelay = ( int ) $ retriesDelay ; }
6484	private static function filterQueryString ( ? string $ queryString ) : ? string { if ( $ queryString === null ) { return null ; } return preg_replace_callback ( '/(?:[^a-zA-Z0-9_\-\.~!\$&\'\(\)\*\+,;=%:@\/\?]+|%(?![A-Fa-f0-9]{2}))/' , function ( $ match ) { return rawurlencode ( $ match [ 0 ] ) ; } , $ queryString ) ; }
9645	public function makePdo ( array $ config , $ connection = null ) { if ( ! isset ( $ config [ 'driver' ] ) && ! isset ( $ config [ 'dsn' ] ) ) { throw new InvalidArgumentException ( 'DSN or driver must be set' ) ; } $ options = isset ( $ config [ 'pdo_options' ] ) ? $ config [ 'pdo_options' ] : [ ] ; unset ( $ config [ 'pdo_options' ] ) ; $ options = array_replace ( $ this -> defaultPdoOptions , $ options ) ; $ initCommands = isset ( $ config [ 'pdo_init_commands' ] ) ? $ config [ 'pdo_init_commands' ] : [ ] ; unset ( $ config [ 'pdo_init_commands' ] ) ; if ( isset ( $ config [ 'driver' ] ) && $ config [ 'driver' ] == 'sqlite' ) { $ this -> validate ( $ config , 'path' , $ connection ) ; $ dsn = $ this -> makeSqliteDsn ( $ config [ 'path' ] ) ; return $ this -> makePdoInner ( $ dsn , null , null , $ options , $ initCommands ) ; } elseif ( isset ( $ config [ 'dsn' ] ) && strpos ( $ config [ 'dsn' ] , 'sqlite:' ) === 0 ) { return $ this -> makePdoInner ( $ config [ 'dsn' ] , null , null , $ options , $ initCommands ) ; } $ this -> validate ( $ config , 'username' , $ connection , false ) ; $ username = $ config [ 'username' ] ; unset ( $ config [ 'username' ] ) ; $ this -> validate ( $ config , 'password' , $ connection , true ) ; $ password = $ config [ 'password' ] ; unset ( $ config [ 'password' ] ) ; if ( isset ( $ config [ 'dsn' ] ) ) { $ dsn = $ config [ 'dsn' ] ; } else { $ driver = $ config [ 'driver' ] ; unset ( $ config [ 'driver' ] ) ; $ this -> validate ( $ config , 'host' , $ connection ) ; $ this -> validate ( $ config , 'dbname' , $ connection ) ; $ dsn = $ this -> makeDsn ( $ driver , $ config ) ; } return $ this -> makePdoInner ( $ dsn , $ username , $ password , $ options , $ initCommands ) ; }
9308	public function register ( ) { $ app = $ this -> app ; $ app -> bind ( 'Germanazo\CkanApi\CkanApiClient' , function ( ) { $ config = [ 'base_uri' => config ( 'ckan_api.url' ) , 'headers' => [ 'Authorization' => config ( 'ckan_api.api_key' ) ] , ] ; return new CkanApiClient ( new Client ( $ config ) ) ; } ) ; $ app -> alias ( 'Germanazo\CkanApi\CkanApiClient' , 'CkanApi' ) ; }
6185	public function clear ( $ type = 'all' ) { if ( $ type === 'all' ) { $ this -> driver -> remove ( 'flash_messages' ) ; } else { $ flashMessages = $ this -> driver -> get ( 'flash_messages' ) ; unset ( $ flashMessages [ $ type ] ) ; $ this -> driver -> set ( 'flash_messages' , $ flashMessages ) ; } return true ; }
3892	public function getFilterParameterNames ( \ DC_Table $ objDc ) { $ return = array ( ) ; $ filter = $ objDc -> activeRecord -> metamodel_filtering ; if ( ! $ filter ) { return $ return ; } $ collection = $ this -> filterFactory -> createCollection ( $ filter ) ; return $ collection -> getParameterFilterNames ( ) ; }
4043	public function addAdditionalParentHeaderFields ( GetParentHeaderEvent $ event ) { $ parentModel = $ event -> getModel ( ) ; if ( ! $ parentModel instanceof Model ) { return ; } $ environment = $ event -> getEnvironment ( ) ; $ definition = $ environment -> getDataDefinition ( ) ; $ item = $ parentModel -> getItem ( ) ; $ metaModel = $ item -> getMetaModel ( ) ; $ renderSetting = $ this -> renderSettingFactory -> createCollection ( $ metaModel , $ definition -> getMetaModelDefinition ( ) -> getActiveRenderSetting ( ) ) ; $ additional = array ( ) ; foreach ( $ renderSetting -> getSettingNames ( ) as $ name ) { $ parsed = $ item -> parseAttribute ( $ name , 'text' , $ renderSetting ) ; $ name = $ item -> getAttribute ( $ name ) -> getName ( ) ; $ additional [ $ name ] = $ parsed [ 'text' ] ; } $ additional = array_merge ( $ additional , $ event -> getAdditional ( ) ) ; $ event -> setAdditional ( $ additional ) ; }
1803	protected function getPickerInputField ( $ value , $ attributes = '' ) { $ id = is_numeric ( $ value ) ? $ value : md5 ( $ value ) ; switch ( $ this -> strPickerFieldType ) { case 'checkbox' : return ' <input type="checkbox" name="picker[]" id="picker_' . $ id . '" class="tl_tree_checkbox" value="' . StringUtil :: specialchars ( \ call_user_func ( $ this -> objPickerCallback , $ value ) ) . '" onfocus="Backend.getScrollOffset()"' . Widget :: optionChecked ( $ value , $ this -> arrPickerValue ) . $ attributes . '>' ; case 'radio' : return ' <input type="radio" name="picker" id="picker_' . $ id . '" class="tl_tree_radio" value="' . StringUtil :: specialchars ( \ call_user_func ( $ this -> objPickerCallback , $ value ) ) . '" onfocus="Backend.getScrollOffset()"' . Widget :: optionChecked ( $ value , $ this -> arrPickerValue ) . $ attributes . '>' ; } return '' ; }
10817	public static function info ( $ messages , $ linebreak = true , $ length = 0 ) { $ separator = $ linebreak ? "\n" : '' ; self :: write ( $ messages , 'info' , $ length , $ separator ) ; }
11495	public function showAction ( Request $ request , Application $ app ) { $ options = array ( "request" => $ request , "configuration_handler" => $ app [ "red_kite_cms.configuration_handler" ] , "page_collection_manager" => $ app [ "red_kite_cms.page_collection_manager" ] , 'form_factory' => $ app [ "form.factory" ] , "pages_collection_parser" => $ app [ "red_kite_cms.pages_collection_parser" ] , "username" => $ this -> fetchUsername ( $ app [ "security" ] , $ app [ "red_kite_cms.configuration_handler" ] ) , 'theme' => $ app [ "red_kite_cms.theme" ] , 'template_assets' => $ app [ "red_kite_cms.template_assets" ] , 'twig' => $ app [ "twig" ] , ) ; return parent :: show ( $ options ) ; }
725	public function render ( $ view , $ params = [ ] ) { $ content = $ this -> getView ( ) -> render ( $ view , $ params , $ this ) ; return $ this -> renderContent ( $ content ) ; }
10630	public static function memory ( ) { $ memory = new \ StdClass ( ) ; $ memory -> real = new \ StdClass ( ) ; $ memory -> swap = new \ StdClass ( ) ; if ( false !== ( $ data = @ file ( '/proc/meminfo' ) ) ) { $ data = implode ( "" , $ data ) ; preg_match_all ( "/MemTotal\s{0,}\:+\s{0,}([\d\.]+).+?MemFree\s{0,}\:+\s{0,}([\d\.]+).+?Cached\s{0,}\:+\s{0,}([\d\.]+).+?SwapTotal\s{0,}\:+\s{0,}([\d\.]+).+?SwapFree\s{0,}\:+\s{0,}([\d\.]+)/s" , $ data , $ meminfo ) ; preg_match_all ( "/Buffers\s{0,}\:+\s{0,}([\d\.]+)/s" , $ data , $ buffers ) ; $ memory -> total = $ meminfo [ 1 ] [ 0 ] * 1024 ; $ memory -> free = $ meminfo [ 2 ] [ 0 ] * 1024 ; $ memory -> used = $ memory -> total - $ memory -> free ; $ memory -> cached = $ meminfo [ 3 ] [ 0 ] * 1024 ; $ memory -> buffers = $ buffers [ 1 ] [ 0 ] * 1024 ; $ memory -> real -> used = $ memory -> total - $ memory -> free - $ memory -> cached - $ memory -> buffers ; $ memory -> real -> free = $ memory -> total - $ memory -> real -> used ; $ memory -> swap -> free = $ meminfo [ 5 ] [ 0 ] * 1024 ; $ memory -> swap -> used = $ meminfo [ 4 ] [ 0 ] * 1024 - $ memory -> swap -> free ; } return $ memory ; }
6442	public function getAllResources ( $ name , $ full = false , array $ filters = [ ] , array $ fields = [ ] ) { $ this -> lastRequest = new Request ; $ this -> lastRequest -> setMode ( Request :: MODE_READ ) ; $ this -> lastRequest -> setResourceName ( $ name ) ; if ( $ full ) { $ this -> lastRequest -> enableFullResults ( ) ; } $ this -> lastRequest -> setFilters ( $ filters ) ; $ this -> lastRequest -> setFields ( $ fields ) ; $ data = [ ] ; $ page = 1 ; do { $ this -> lastRequest -> setCurrentPage ( $ page ) ; $ response = $ this -> proceed ( ) ; $ data = ArrayUtils :: merge ( $ data , $ response -> getData ( ) -> getData ( ) ) ; $ page ++ ; } while ( $ response -> getPagination ( ) -> getPage ( ) != $ response -> getPagination ( ) -> getPages ( ) ) ; return $ data ; }
2638	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ aclId = $ this -> getRequest ( ) -> getParam ( 'acl_id' ) ; $ aclItems = $ this -> api -> aclItemsList ( $ aclId ) ; if ( is_array ( $ aclItems ) && empty ( $ aclItems ) ) { return $ result -> setData ( [ 'status' => 'empty' , 'aclItems' => [ ] ] ) ; } if ( ! $ aclItems ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to fetch acl items.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'aclItems' => $ aclItems ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
3977	private function addEditMultipleCommand ( Contao2BackendViewDefinitionInterface $ view ) { $ definition = $ this -> container -> getBasicDefinition ( ) ; if ( ! $ definition -> isEditable ( ) && ! $ definition -> isDeletable ( ) && ! $ definition -> isCreatable ( ) ) { return ; } $ commands = $ view -> getGlobalCommands ( ) ; $ command = new SelectCommand ( ) ; $ command -> setName ( 'all' ) -> setLabel ( 'MSC.all.0' ) -> setDescription ( 'MSC.all.1' ) ; $ parameters = $ command -> getParameters ( ) ; $ parameters [ 'act' ] = 'select' ; $ extra = $ command -> getExtra ( ) ; $ extra [ 'class' ] = 'header_edit_all' ; $ commands -> addCommand ( $ command ) ; }
5480	protected function addCheckbox ( $ tag ) { if ( ! isset ( $ this -> checkboxes [ $ tag -> getName ( ) ] ) ) { $ this -> widgets [ ] = $ tag ; $ this -> checkboxes [ $ tag -> getName ( ) ] = count ( $ this -> widgets ) - 1 ; } else { $ index = $ this -> checkboxes [ $ tag -> getName ( ) ] ; if ( ! is_a ( $ this -> widgets [ $ index ] , 'SimpleCheckboxGroup' ) ) { $ previous = $ this -> widgets [ $ index ] ; $ this -> widgets [ $ index ] = new SimpleCheckboxGroup ( ) ; $ this -> widgets [ $ index ] -> addWidget ( $ previous ) ; } $ this -> widgets [ $ index ] -> addWidget ( $ tag ) ; } }
4278	public function stream_read ( $ count ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ buffer = \ fread ( $ this -> handle , $ count ) ; $ bufferLen = \ strlen ( $ buffer ) ; $ backtrace = \ debug_backtrace ( DEBUG_BACKTRACE_IGNORE_ARGS , 2 ) ; $ isRequire = ! \ in_array ( $ backtrace [ 1 ] [ 'function' ] , array ( 'file_get_contents' ) ) ; if ( ! $ this -> declaredTicks && $ isRequire ) { foreach ( self :: $ pathsExclude as $ excludePath ) { if ( \ strpos ( $ this -> filepath , $ excludePath . DIRECTORY_SEPARATOR ) === 0 ) { $ this -> declaredTicks = true ; } } } if ( ! $ this -> declaredTicks && $ isRequire ) { $ buffer = \ preg_replace ( '/^(<\?php\s*)$/m' , '$0 declare(ticks=1);' , $ buffer , 1 ) ; $ this -> declaredTicks = true ; self :: $ filesModified [ ] = $ this -> filepath ; } $ buffer = $ this -> bufferPrepend . $ buffer ; $ bufferLenAfter = \ strlen ( $ buffer ) ; $ diff = $ bufferLenAfter - $ bufferLen ; $ this -> bufferPrepend = '' ; if ( $ diff ) { $ this -> bufferPrepend = \ substr ( $ buffer , $ count ) ; $ buffer = \ substr ( $ buffer , 0 , $ count ) ; } self :: register ( ) ; return $ buffer ; }
7936	public function getSeeOffers ( $ countryDestination , $ countryCurrencyPrice , $ quantity ) { return json_decode ( self :: getClient ( ) -> getSeeOffers ( $ this -> domain , $ countryDestination , $ countryCurrencyPrice , $ quantity ) ) ; }
10786	public function run ( $ query , array $ params = array ( ) ) { $ statement = $ this -> pdo -> prepare ( $ query ) ; $ statement -> execute ( $ params ) ; return $ statement ; }
4049	public function fetchInputScreens ( $ idList ) : array { $ idList = array_filter ( $ idList ) ; $ builder = $ this -> connection -> createQueryBuilder ( ) ; $ screens = $ builder -> select ( 'd.*' ) -> from ( 'tl_metamodel_dca' , 'd' ) -> leftJoin ( 'd' , 'tl_metamodel' , 'm' , 'm.id=d.pid' ) -> where ( $ builder -> expr ( ) -> in ( 'd.id' , ':idList' ) ) -> setParameter ( 'idList' , $ idList , Connection :: PARAM_STR_ARRAY ) -> orderBy ( 'm.sorting' ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; $ result = [ ] ; $ keys = array_flip ( $ idList ) ; foreach ( $ screens as $ screen ) { $ metaModelName = $ keys [ $ screen [ 'id' ] ] ; $ result [ $ metaModelName ] = $ this -> prepareInputScreen ( $ metaModelName , $ screen ) ; } return $ result ; }
87	private function getDefaultNormalizer ( ) { $ default = $ this -> getDefault ( ) ; $ trueRegex = $ this -> trueAnswerRegex ; $ falseRegex = $ this -> falseAnswerRegex ; return function ( $ answer ) use ( $ default , $ trueRegex , $ falseRegex ) { if ( is_bool ( $ answer ) ) { return $ answer ; } if ( empty ( $ answer ) && ! empty ( $ default ) ) { return $ default ; } if ( preg_match ( $ trueRegex , $ answer ) ) { return true ; } if ( preg_match ( $ falseRegex , $ answer ) ) { return false ; } return null ; } ; }
7571	public function get ( $ url = "" ) { try { $ this -> guzzleResponse = $ this -> _client -> request ( 'GET' , $ url ) ; $ this -> _setLinks ( ) ; } catch ( RequestException $ e ) { throw new GreenhouseAPIResponseException ( $ e -> getMessage ( ) , 0 , $ e ) ; } return ( string ) $ this -> guzzleResponse -> getBody ( ) ; }
11945	protected function handleEventMessage ( array $ message ) { Log :: debug ( 'OpenPlatform Event Message detail:' , $ message ) ; $ message = new Collection ( $ message ) ; $ infoType = $ message -> get ( 'InfoType' ) ; if ( $ handler = $ this -> getHandler ( $ infoType ) ) { $ handler -> handle ( $ message ) ; } else { Log :: notice ( "No existing handler for '{$infoType}'." ) ; } if ( $ messageHandler = $ this -> getMessageHandler ( ) ) { call_user_func_array ( $ messageHandler , [ $ message ] ) ; } }
2410	public function getDbInstallerArray ( ) { $ return = array ( ) ; foreach ( $ this -> arrFields as $ k => $ v ) { if ( \ is_array ( $ v ) ) { if ( ! isset ( $ v [ 'name' ] ) ) { $ v [ 'name' ] = $ k ; } $ return [ 'SCHEMA_FIELDS' ] [ $ k ] = $ v ; } else { $ return [ 'TABLE_FIELDS' ] [ $ k ] = '`' . $ k . '` ' . $ v ; } } $ quote = function ( $ item ) { return '`' . $ item . '`' ; } ; foreach ( $ this -> arrKeys as $ k => $ v ) { if ( strpos ( $ k , ',' ) !== false ) { $ f = array_map ( $ quote , StringUtil :: trimsplit ( ',' , $ k ) ) ; $ k = str_replace ( ',' , '_' , $ k ) ; } else { $ f = array ( $ quote ( $ k ) ) ; } if ( $ v == 'primary' ) { $ k = 'PRIMARY' ; $ v = 'PRIMARY KEY (' . implode ( ', ' , $ f ) . ')' ; } elseif ( $ v == 'index' ) { $ v = 'KEY `' . $ k . '` (' . implode ( ', ' , $ f ) . ')' ; } else { $ v = strtoupper ( $ v ) . ' KEY `' . $ k . '` (' . implode ( ', ' , $ f ) . ')' ; } $ return [ 'TABLE_CREATE_DEFINITIONS' ] [ $ k ] = $ v ; } $ return [ 'TABLE_OPTIONS' ] = '' ; foreach ( $ this -> arrMeta as $ k => $ v ) { if ( $ k == 'engine' ) { $ return [ 'TABLE_OPTIONS' ] .= ' ENGINE=' . $ v ; } elseif ( $ k == 'charset' ) { $ return [ 'TABLE_OPTIONS' ] .= ' DEFAULT CHARSET=' . $ v ; } elseif ( $ k == 'collate' ) { $ return [ 'TABLE_OPTIONS' ] .= ' COLLATE ' . $ v ; } } return $ return ; }
2767	public function pushTag ( string $ tag , string $ repository = 'origin' , array $ options = [ ] ) : string { return $ this -> push ( $ repository , 'tag' , $ tag , $ options ) ; }
6144	public function hasQueryVar ( $ key ) { if ( ! $ this -> hasQuery ( ) ) { return false ; } parse_str ( $ this -> query , $ queryArray ) ; return array_key_exists ( $ key , $ queryArray ) ? true : false ; }
8146	public function parse ( Twig_TokenStream $ stream ) { if ( null === $ this -> parser ) { $ this -> parser = new Twig_Parser ( $ this ) ; } return $ this -> parser -> parse ( $ stream ) ; }
4867	public function fail ( JobInterface $ job , array $ options = [ ] ) { $ envelope = $ this -> createEnvelope ( $ job , $ options ) ; unset ( $ envelope [ 'created' ] ) ; unset ( $ envelope [ 'scheduled' ] ) ; $ envelope [ 'status' ] = self :: STATUS_FAILED ; $ this -> mongoCollection -> findOneAndUpdate ( [ '_id' => new \ MongoDB \ BSON \ ObjectId ( $ job -> getId ( ) ) ] , [ '$set' => $ envelope ] ) ; }
10903	public function delete ( ) : bool { return ( bool ) $ this -> medoo -> delete ( $ this -> getTable ( ) , [ 'id' => $ this -> getId ( ) ] ) ; }
10788	protected function getSearchFacets ( SessionInterface $ session ) { $ facets = $ session -> get ( $ this -> getSessionPrefix ( ) . '_facets' , false ) ; return $ facets ? \ json_decode ( $ facets , true ) : $ this -> getDefaultFacets ( ) ; }
7857	public function register ( ) { $ this -> registerPipelineRepository ( ) ; $ this -> registerInflector ( ) ; $ this -> registerDispatcher ( ) ; $ this -> registerWorkflow ( ) ; $ this -> registerWorkflowRunnersHook ( ) ; $ this -> registerCommands ( ) ; }
6624	public function process ( Request $ request ) : Response { $ router = $ request -> attributes -> get ( 'router' ) ; $ next = next ( $ this -> middlewareStack ) ; if ( $ next instanceof Middleware ) { $ router -> log ( "Router: Calling Middleware: %s" , get_class ( $ next ) ) ; $ response = $ next -> process ( $ request , $ this ) ; $ router -> log ( "Router: Leaving Middleware: %s" , get_class ( $ next ) ) ; return $ response ; } elseif ( is_string ( $ next ) ) { $ router -> log ( "Router: Calling Middleware: %s" , $ next ) ; $ response = $ router -> getMiddleware ( $ next ) -> process ( $ request , $ this ) ; $ router -> log ( "Router: Leaving Middleware: %s" , $ next ) ; return $ response ; } else { $ params = $ request -> attributes -> get ( 'controller' ) ; $ router -> log ( "Router: Calling Controller: %s@%s" , $ params -> className , $ params -> method ) ; $ return = ( new $ params -> className ( $ params -> container ) ) -> { $ params -> method } ( $ request , ... array_values ( $ params -> args ) ) ; $ router -> log ( "Router: Controller Left" ) ; if ( $ return instanceof Response ) { return $ return ; } if ( is_array ( $ return ) or is_object ( $ return ) ) { return new JsonResponse ( $ return , Response :: HTTP_OK , array ( 'content-type' => 'application/json' ) ) ; } return new Response ( $ return , Response :: HTTP_OK , array ( 'content-type' => 'text/html' ) ) ; } }
9245	private function parseDynamicGroup ( $ group ) { $ regex = $ group [ 'regex' ] ; $ parts = explode ( '|' , $ regex ) ; $ data = array ( ) ; foreach ( $ group [ 'routeMap' ] as $ matchIndex => $ routeData ) { if ( ! is_array ( $ routeData [ 0 ] ) || ! isset ( $ routeData [ 0 ] [ 'name' ] ) || ! isset ( $ parts [ $ matchIndex - 1 ] ) ) { continue ; } $ parameters = $ routeData [ 1 ] ; $ path = $ parts [ $ matchIndex - 1 ] ; foreach ( $ parameters as $ parameter ) { $ path = $ this -> replaceOnce ( '([^/]+)' , '{' . $ parameter . '}' , $ path ) ; } $ path = rtrim ( $ path , '()$~' ) ; $ data [ $ routeData [ 0 ] [ 'name' ] ] = array ( 'path' => $ path , 'params' => $ parameters , ) ; } return $ data ; }
6542	public function current ( ) { if ( true === $ this -> wantNewModel ) { return $ this -> entityManager -> load ( $ this -> modelClassName , $ this -> selector -> current ( ) ) ; } else { $ this -> initializeModel ( $ this -> selector -> current ( ) , $ this -> selector -> currentShardingKey ( ) ) ; $ this -> entityManager -> resetModel ( $ this -> model , $ this -> selector -> current ( ) ) ; return $ this -> model ; } }
5786	private function databaseRecordNotFound ( Response $ response , $ primaryKey , TableMapper $ tableMapper , string $ routeAction , ? string $ title = null ) { if ( $ routeAction != 'update' && $ routeAction != 'delete' ) { throw new \ Exception ( "routeAction $routeAction must be update or delete" ) ; } $ this -> events -> insertWarning ( EVENT_QUERY_NO_RESULTS , [ $ tableMapper -> getPrimaryKeyColumnName ( ) => $ primaryKey , 'table' => $ tableMapper -> getTableName ( ) ] ) ; $ noticeTitle = ( $ title != null ) ? $ title : 'Record' ; SlimPostgres :: setAdminNotice ( "$noticeTitle $primaryKey Not Found" , 'failure' ) ; return $ response -> withRedirect ( $ this -> router -> pathFor ( SlimPostgres :: getRouteName ( true , $ this -> routePrefix , 'index' ) ) ) ; }
8596	public function listMarketplaceParticipations ( $ request ) { if ( ! ( $ request instanceof MarketplaceWebServiceSellers_Model_ListMarketplaceParticipationsRequest ) ) { $ request = new MarketplaceWebServiceSellers_Model_ListMarketplaceParticipationsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListMarketplaceParticipations' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = MarketplaceWebServiceSellers_Model_ListMarketplaceParticipationsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
5803	public function whitelist ( array $ whitelist ) { $ this -> _definitions = array ( ) ; foreach ( $ whitelist as $ definition ) { if ( is_object ( $ definition ) ) { if ( $ definition instanceof Definition \ IDefinition ) $ definitionObject = $ definition ; else throw new \ InvalidArgumentException ( 'Definition objects must implement IDefinition' ) ; } elseif ( preg_match ( '/[a-z:\/]/' , $ definition ) === 0 ) $ definitionObject = new Definition \ IPv4Address ( $ definition ) ; elseif ( preg_match ( '/[a-z:]/' , $ definition ) === 0 ) $ definitionObject = new Definition \ IPv4CIDR ( $ definition ) ; elseif ( preg_match ( '/^[0-9a-f:]+$/' , $ definition ) ) $ definitionObject = new Definition \ IPv6Address ( $ definition ) ; elseif ( preg_match ( '/^[0-9a-f:\/]+$/' , $ definition ) ) $ definitionObject = new Definition \ IPv6CIDR ( $ definition ) ; elseif ( preg_match ( '/^\*\.[\w\.\-]+$/' , $ definition ) ) $ definitionObject = new Definition \ WildcardDomain ( $ definition ) ; elseif ( preg_match ( '/^[\w\.\-]+$/' , $ definition ) ) $ definitionObject = new Definition \ Domain ( $ definition ) ; else throw new \ InvalidArgumentException ( 'Unable to parse definition "' . $ definition . '"' ) ; $ this -> _definitions [ ] = $ definitionObject ; } }
6799	public function installCountries ( $ code = 'US' ) { $ countryNames = Intl :: getRegionBundle ( ) -> getCountryNames ( ) ; if ( ! isset ( $ countryNames [ $ code ] ) ) { throw new InvalidArgumentException ( "Invalid default country code '$code'." ) ; } asort ( $ countryNames ) ; $ this -> generate ( Country :: class , $ countryNames , $ code ) ; }
8325	public function deletePingback ( $ uri ) { $ response = $ this -> getHttpClient ( ) -> request ( 'GET' , "/res.php?key={$this->apiKey}&action=del_pingback&addr={$uri}" ) ; $ responseText = $ response -> getBody ( ) -> __toString ( ) ; if ( $ responseText === self :: STATUS_OK ) { return true ; } throw new ErrorResponseException ( $ this -> getErrorMessage ( $ responseText ) ? : $ responseText , $ this -> getErrorCode ( $ responseText ) ? : 0 ) ; }
4015	protected function makeMandatory ( $ field , $ row , $ key ) { $ field [ 'eval' ] [ 'required' ] = false ; if ( empty ( $ field [ 'eval' ] [ 'mandatory' ] ) ) { return $ field ; } if ( is_array ( $ this -> varValue [ $ row ] [ $ key ] ) ) { if ( empty ( $ this -> varValue [ $ row ] [ $ key ] ) ) { $ field [ 'eval' ] [ 'required' ] = true ; } } else { if ( ! strlen ( $ this -> varValue [ $ row ] [ $ key ] ) ) { $ field [ 'eval' ] [ 'required' ] = true ; } } return $ field ; }
7034	protected function saveMigration ( array $ tables ) { try { $ tables = serialize ( $ tables ) ; return Db :: query ( "insert into migrations(host, tables) values(?, ?)" , [ gethostname ( ) , $ tables ] , $ this -> dbName , false ) ; } catch ( PDOException $ e ) { error_log ( $ e -> getMessage ( ) ) ; return false ; } }
1813	public function setRteSyntax ( $ varValue , Contao \ DataContainer $ dc ) { switch ( $ dc -> activeRecord -> highlight ) { case 'C' : case 'CSharp' : $ syntax = 'c_cpp' ; break ; case 'CSS' : case 'Diff' : case 'Groovy' : case 'HTML' : case 'Java' : case 'JavaScript' : case 'Perl' : case 'PHP' : case 'PowerShell' : case 'Python' : case 'Ruby' : case 'Scala' : case 'SQL' : case 'Text' : case 'YAML' : $ syntax = strtolower ( $ dc -> activeRecord -> highlight ) ; break ; case 'VB' : $ syntax = 'vbscript' ; break ; case 'XML' : case 'XHTML' : $ syntax = 'xml' ; break ; default : $ syntax = 'text' ; break ; } if ( $ dc -> activeRecord -> type == 'markdown' ) { $ syntax = 'markdown' ; } $ GLOBALS [ 'TL_DCA' ] [ 'tl_content' ] [ 'fields' ] [ 'code' ] [ 'eval' ] [ 'rte' ] = 'ace|' . $ syntax ; return $ varValue ; }
3065	protected function convertCatVariables ( array $ variables ) { $ runnerService = $ this -> getServiceLocator ( ) -> get ( QtiRunnerService :: SERVICE_ID ) ; $ convertedVariables = [ ] ; foreach ( $ variables as $ variable ) { switch ( $ variable -> getVariableType ( ) ) { case ResultVariable :: TRACE_VARIABLE : $ getVariableMethod = 'getTraceVariable' ; break ; case ResultVariable :: RESPONSE_VARIABLE : $ getVariableMethod = 'getResponseVariable' ; break ; case ResultVariable :: OUTCOME_VARIABLE : $ getVariableMethod = 'getOutcomeVariable' ; break ; case ResultVariable :: TEMPLATE_VARIABLE : default : $ getVariableMethod = null ; break ; } if ( is_null ( $ getVariableMethod ) ) { \ common_Logger :: w ( 'Variable of type ' . $ variable -> getVariableType ( ) . ' is not implemented in ' . __METHOD__ ) ; throw new \ common_exception_NotImplemented ( ) ; } $ convertedVariables [ ] = call_user_func_array ( array ( $ runnerService , $ getVariableMethod ) , array ( $ variable -> getId ( ) , $ variable -> getValue ( ) ) ) ; } return $ convertedVariables ; }
11490	public function destroyWithCookie ( ) : ? bool { if ( $ this -> isStarted ( ) ) { $ this -> destroy ( ) ; return setcookie ( $ this -> getName ( ) , '' , time ( ) - 1 , '/' ) ; } return null ; }
679	protected function validateCondition ( $ condition ) { if ( ! is_array ( $ condition ) ) { $ this -> addError ( $ this -> filterAttributeName , $ this -> parseErrorMessage ( 'invalidFilter' ) ) ; return ; } if ( empty ( $ condition ) ) { return ; } foreach ( $ condition as $ key => $ value ) { $ method = 'validateAttributeCondition' ; if ( isset ( $ this -> filterControls [ $ key ] ) ) { $ controlKey = $ this -> filterControls [ $ key ] ; if ( isset ( $ this -> conditionValidators [ $ controlKey ] ) ) { $ method = $ this -> conditionValidators [ $ controlKey ] ; } } $ this -> $ method ( $ key , $ value ) ; } }
12304	public function adminIndex ( ) { $ config = [ 'title' => trans ( 'HCLanguages::languages.page_title' ) , 'listURL' => route ( 'admin.api.languages' ) , 'newFormUrl' => route ( 'admin.api.form-manager' , [ 'languages-new' ] ) , 'editFormUrl' => route ( 'admin.api.form-manager' , [ 'languages-edit' ] ) , 'imagesUrl' => route ( 'resource.get' , [ '/' ] ) , 'headers' => $ this -> getAdminListHeader ( ) , ] ; $ config [ 'actions' ] [ ] = 'search' ; return hcview ( 'HCCoreUI::admin.content.list' , [ 'config' => $ config ] ) ; }
7373	public function updatePasswordAction ( Request $ request ) { $ user = $ this -> getUser ( ) ; $ form = $ this -> createForm ( ChangePasswordType :: class ) ; $ form -> bind ( $ request ) ; $ data = $ form -> getData ( ) ; $ factory = $ this -> get ( 'security.encoder_factory' ) ; $ encoder = $ factory -> getEncoder ( $ user ) ; $ current = $ encoder -> encodePassword ( $ data [ 'current' ] , $ user -> getSalt ( ) ) ; if ( $ current !== $ user -> getPassword ( ) ) { $ form -> get ( 'current' ) -> addError ( new FormError ( 'Current password is not correct' ) ) ; } if ( $ form -> isValid ( ) ) { $ user -> setPassword ( $ encoder -> encodePassword ( $ data [ 'password' ] , $ user -> getSalt ( ) ) ) ; $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ user ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'success' , 'Your password has been changed.' ) ; return new JsonReloadResponse ( ) ; } return new JsonErrorResponse ( $ form ) ; }
4465	public function run ( string $ command , array $ args ) { if ( empty ( $ this -> sha ) ) { $ this -> reload ( ) ; } $ arguments = $ this -> normalizeCommandArgs ( $ command , $ args ) ; try { return call_user_func_array ( [ $ this -> redis , 'evalsha' ] , $ arguments ) ; } catch ( \ Exception $ exception ) { throw ExceptionFactory :: fromErrorMessage ( $ exception -> getMessage ( ) ) ; } }
8112	public static function merge_owners ( SS_List $ groups , SS_List $ members ) { $ contentReviewOwners = new ArrayList ( ) ; if ( $ groups -> count ( ) ) { $ groupIDs = [ ] ; foreach ( $ groups as $ group ) { $ familyIDs = $ group -> collateFamilyIDs ( ) ; if ( is_array ( $ familyIDs ) ) { $ groupIDs = array_merge ( $ groupIDs , array_values ( $ familyIDs ) ) ; } } array_unique ( $ groupIDs ) ; if ( count ( $ groupIDs ) ) { $ groupMembers = DataObject :: get ( Member :: class ) -> where ( "\"Group\".\"ID\" IN (" . implode ( "," , $ groupIDs ) . ")" ) -> leftJoin ( "Group_Members" , "\"Member\".\"ID\" = \"Group_Members\".\"MemberID\"" ) -> leftJoin ( 'Group' , "\"Group_Members\".\"GroupID\" = \"Group\".\"ID\"" ) ; $ contentReviewOwners -> merge ( $ groupMembers ) ; } } $ contentReviewOwners -> merge ( $ members ) ; $ contentReviewOwners -> removeDuplicates ( ) ; return $ contentReviewOwners ; }
4395	public function isImplemented ( $ what ) { $ provider = $ this -> getProvider ( ) ; switch ( $ what ) { case \ Aimeos \ MShop \ Service \ Provider \ Payment \ Base :: FEAT_CAPTURE : return $ provider -> supportsCapture ( ) ; case \ Aimeos \ MShop \ Service \ Provider \ Payment \ Base :: FEAT_CANCEL : return $ provider -> supportsVoid ( ) ; case \ Aimeos \ MShop \ Service \ Provider \ Payment \ Base :: FEAT_REFUND : return $ provider -> supportsRefund ( ) ; case \ Aimeos \ MShop \ Service \ Provider \ Payment \ Base :: FEAT_REPAY : return method_exists ( $ provider , 'createCard' ) ; } return false ; }
3614	public function setTargetTemperatures ( $ temp_low , $ temp_high , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ temp_low = $ this -> temperatureInCelsius ( $ temp_low , $ serial_number ) ; $ temp_high = $ this -> temperatureInCelsius ( $ temp_high , $ serial_number ) ; $ data = json_encode ( array ( 'target_change_pending' => TRUE , 'target_temperature_low' => $ temp_low , 'target_temperature_high' => $ temp_high ) ) ; return $ this -> doPOST ( "/v2/put/shared." . $ serial_number , $ data ) ; }
9655	public function override ( $ name , array $ routeData ) { if ( ! isset ( $ this -> routes [ $ name ] ) ) { throw new \ InvalidArgumentException ( "No route for name $name defined" ) ; } $ this -> routes [ $ name ] = $ routeData + $ this -> routes [ $ name ] ; }
9105	protected function parse_time ( ) { if ( ! empty ( $ this -> args [ 'time' ] ) ) { $ date_query = new \ WP_Date_Query ( $ this -> args [ 'time' ] , 'q.time' ) ; return new Where_Date ( $ date_query ) ; } else { return null ; } }
7390	private function set404 ( ) { $ this -> response -> setStatusCode ( 404 ) ; $ content = '404 Not Found' ; if ( file_exists ( $ this -> packageRoot . '/view/404.html.php' ) ) { $ content = ( new Native ( $ this -> packageRoot ) ) -> getContent ( '404.html.php' ) ; } $ this -> response -> setContent ( $ content ) ; }
12453	static function run_generate_sample_package_xml ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { pake_copy ( self :: getResourceDir ( ) . '/package_master.xml' , 'package.xml' ) ; $ tokens = array ( '$summary' => '[Summary]' , '$description' => '[Description]' , '$vendor' => '' , '$maintainers' => '' , '$documents' => '' , '$changelog' => '' , '$simple-files' => '' , '$state' => '[State]' , '$requires' => '' ) ; pake_replace_tokens ( 'package.xml' , '.' , '{' , '}' , $ tokens ) ; pake_echo ( "File package.xml generated. Please replace all tokens in square brackets in it (but do not replace values in curly brackets) then commit it to sources in the top dir of the extension" ) ; }
1252	private function normalizeElementName ( $ name ) { $ nsElement = explode ( '@' , $ name ) ; if ( count ( $ nsElement ) > 1 ) { array_shift ( $ nsElement ) ; return $ nsElement [ 0 ] ; } else { return $ name ; } }
7745	private function findGetter ( ) { $ reflClass = new \ ReflectionClass ( $ this -> class ) ; $ camelProp = $ this -> camelize ( $ this -> name ) ; $ getter = 'get' . $ camelProp ; $ isser = 'is' . $ camelProp ; $ hasser = 'has' . $ camelProp ; $ classHasProperty = $ reflClass -> hasProperty ( $ this -> name ) ; if ( $ reflClass -> hasMethod ( $ this -> name ) && $ reflClass -> getMethod ( $ this -> name ) -> isPublic ( ) ) { $ this -> getter = $ this -> name ; $ this -> getterType = self :: GETTER_SETTER_METHOD ; } elseif ( $ reflClass -> hasMethod ( $ getter ) && $ reflClass -> getMethod ( $ getter ) -> isPublic ( ) ) { $ this -> getter = $ getter ; $ this -> getterType = self :: GETTER_SETTER_METHOD ; } elseif ( $ reflClass -> hasMethod ( $ isser ) && $ reflClass -> getMethod ( $ isser ) -> isPublic ( ) ) { $ this -> getter = $ isser ; $ this -> getterType = self :: GETTER_SETTER_METHOD ; } elseif ( $ reflClass -> hasMethod ( $ hasser ) && $ reflClass -> getMethod ( $ hasser ) -> isPublic ( ) ) { $ this -> getter = $ hasser ; $ this -> getterType = self :: GETTER_SETTER_METHOD ; } elseif ( ( $ reflClass -> hasMethod ( '__get' ) && $ reflClass -> getMethod ( '__get' ) -> isPublic ( ) ) || ( $ classHasProperty && $ reflClass -> getProperty ( $ this -> name ) -> isPublic ( ) ) ) { $ this -> getter = $ this -> name ; $ this -> getterType = self :: GETTER_SETTER_PROPERTY ; } }
2411	public function exportTheme ( DataContainer $ dc ) { $ objTheme = $ this -> Database -> prepare ( "SELECT * FROM tl_theme WHERE id=?" ) -> limit ( 1 ) -> execute ( $ dc -> id ) ; if ( $ objTheme -> numRows < 1 ) { return ; } $ strName = Utf8 :: toAscii ( $ objTheme -> name ) ; $ strName = strtolower ( str_replace ( ' ' , '_' , $ strName ) ) ; $ strName = preg_replace ( '/[^A-Za-z0-9._-]/' , '' , $ strName ) ; $ strName = basename ( $ strName ) ; $ xml = new \ DOMDocument ( '1.0' , 'UTF-8' ) ; $ xml -> formatOutput = true ; $ tables = $ xml -> createElement ( 'tables' ) ; $ tables = $ xml -> appendChild ( $ tables ) ; $ this -> addTableTlTheme ( $ xml , $ tables , $ objTheme ) ; $ this -> addTableTlStyleSheet ( $ xml , $ tables , $ objTheme ) ; $ this -> addTableTlImageSize ( $ xml , $ tables , $ objTheme ) ; $ this -> addTableTlModule ( $ xml , $ tables , $ objTheme ) ; $ this -> addTableTlLayout ( $ xml , $ tables , $ objTheme ) ; $ strTmp = md5 ( uniqid ( mt_rand ( ) , true ) ) ; $ objArchive = new ZipWriter ( 'system/tmp/' . $ strTmp ) ; $ this -> addTableTlFiles ( $ xml , $ tables , $ objTheme , $ objArchive ) ; $ this -> addTemplatesToArchive ( $ objArchive , $ objTheme -> templates ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'exportTheme' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'exportTheme' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'exportTheme' ] as $ callback ) { System :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ xml , $ objArchive , $ objTheme -> id ) ; } } $ objArchive -> addString ( $ xml -> saveXML ( ) , 'theme.xml' ) ; $ objArchive -> close ( ) ; $ objFile = new File ( 'system/tmp/' . $ strTmp ) ; $ objFile -> sendToBrowser ( $ strName . '.cto' ) ; }
2943	public function hasRoleWithPermission ( $ permission ) { return $ this -> roles -> contains ( function ( $ role ) use ( $ permission ) { return $ role -> getPermissions -> contains ( 'permission_slug' , $ permission ) ; } ) ; }
3503	private function prepareCurlResourceByRequest ( Request $ request ) : void { curl_setopt ( $ this -> resource , CURLOPT_URL , $ request -> getUrl ( ) ) ; curl_setopt ( $ this -> resource , CURLOPT_POSTFIELDS , $ request -> getContent ( ) ) ; if ( $ request -> getCertificate ( ) ) { curl_setopt ( $ this -> resource , CURLOPT_SSLCERT , $ request -> getCertificate ( ) ) ; curl_setopt ( $ this -> resource , CURLOPT_SSLCERTPASSWD , $ request -> getCertificatePassPhrase ( ) ) ; } $ inlineHeaders = [ ] ; foreach ( $ request -> getHeaders ( ) as $ name => $ value ) { $ inlineHeaders [ ] = sprintf ( '%s: %s' , $ name , $ value ) ; } curl_setopt ( $ this -> resource , CURLOPT_HTTPHEADER , $ inlineHeaders ) ; }
12860	public function getDispatcher ( ) : Dispatcher { if ( $ this -> forceReload || ! file_exists ( $ this -> cacheFile ) ) { $ dispatchData = $ this -> buildCache ( ) ; } else { $ dispatchData = require $ this -> cacheFile ; } return call_user_func ( $ this -> dispatcherFactory , $ dispatchData ) ; }
7663	function AddAttachment ( $ path , $ name = "" , $ encoding = "base64" , $ type = "application/octet-stream" ) { if ( ! @ is_file ( $ path ) ) { $ this -> SetError ( $ this -> Lang ( "file_access" ) . $ path ) ; return false ; } $ filename = basename ( $ path ) ; if ( $ name == "" ) $ name = $ filename ; $ cur = count ( $ this -> attachment ) ; $ this -> attachment [ $ cur ] [ 0 ] = $ path ; $ this -> attachment [ $ cur ] [ 1 ] = $ filename ; $ this -> attachment [ $ cur ] [ 2 ] = $ name ; $ this -> attachment [ $ cur ] [ 3 ] = $ encoding ; $ this -> attachment [ $ cur ] [ 4 ] = $ type ; $ this -> attachment [ $ cur ] [ 5 ] = false ; $ this -> attachment [ $ cur ] [ 6 ] = "attachment" ; $ this -> attachment [ $ cur ] [ 7 ] = 0 ; return true ; }
4174	public function build ( ) { $ providers = $ this -> getProviders ( ) -> search ( ) ; $ facades = $ this -> getFacades ( ) -> search ( ) ; if ( ! ConfigFile :: instance ( $ providers , $ facades ) -> make ( ) ) { throw new ErrorException ( 'Unable to register providers and facades. Please report this incident at Qafeen/Manager' ) ; } $ this -> getResources ( ) -> publish ( $ providers [ 0 ] ) ; return $ this ; }
6454	private function createNotAcceptableException ( string $ type ) : HttpException { $ headers = new HttpHeaders ( ) ; $ headers -> add ( 'Content-Type' , 'application/json' ) ; $ body = new StringBody ( json_encode ( $ this -> contentNegotiator -> getAcceptableResponseMediaTypes ( $ type ) ) ) ; $ response = new Response ( HttpStatusCodes :: HTTP_NOT_ACCEPTABLE , $ headers , $ body ) ; return new HttpException ( $ response ) ; }
8453	protected function determineFilename ( $ originalFilename , array $ mediaFileInfo ) { if ( is_null ( $ originalFilename ) || ! isset ( $ originalFilename ) || is_file ( sys_get_temp_dir ( ) . '/' . $ originalFilename ) ) { $ uniqueFilename = tempnam ( sys_get_temp_dir ( ) , 'tg' ) ; rename ( $ uniqueFilename , $ uniqueFilename . '.' . $ mediaFileInfo [ 'fileextension' ] ) ; $ mediaFileInfo [ 'filepath' ] = $ uniqueFilename . '.' . $ mediaFileInfo [ 'fileextension' ] ; } else { $ mediaFileInfo [ 'filepath' ] = sys_get_temp_dir ( ) . '/' . $ originalFilename ; } return $ mediaFileInfo ; }
8563	private function _convertCreateShipment ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'CreateShipment' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetShipmentRequestDetails ( ) ) { $ ShipmentRequestDetailsCreateShipmentRequest = $ request -> getShipmentRequestDetails ( ) ; foreach ( $ ShipmentRequestDetailsCreateShipmentRequest -> getAmazonOrderId ( ) as $ AmazonOrderIdShipmentRequestDetailsIndex => $ AmazonOrderIdShipmentRequestDetails ) { $ parameters [ 'ShipmentRequestDetails' . '.' . 'AmazonOrderId' . '.' . ( $ AmazonOrderIdShipmentRequestDetailsIndex + 1 ) ] = $ AmazonOrderIdShipmentRequestDetails ; } } if ( $ request -> isSetShippingServiceId ( ) ) { $ parameters [ 'ShippingServiceId' ] = $ request -> getShippingServiceId ( ) ; } if ( $ request -> isSetShippingServiceOfferId ( ) ) { $ parameters [ 'ShippingServiceOfferId' ] = $ request -> getShippingServiceOfferId ( ) ; } return $ parameters ; }
1737	public function loadFromPlugins ( ) : RouteCollection { $ collection = array_reduce ( $ this -> pluginLoader -> getInstancesOf ( PluginLoader :: ROUTING_PLUGINS , true ) , function ( RouteCollection $ collection , RoutingPluginInterface $ plugin ) : RouteCollection { $ routes = $ plugin -> getRouteCollection ( $ this -> loader -> getResolver ( ) , $ this -> kernel ) ; if ( $ routes instanceof RouteCollection ) { $ collection -> addCollection ( $ routes ) ; } return $ collection ; } , new RouteCollection ( ) ) ; if ( file_exists ( $ configFile = $ this -> rootDir . '/app/config/routing.yml' ) ) { $ routes = $ this -> loader -> getResolver ( ) -> resolve ( $ configFile ) -> load ( $ configFile ) ; if ( $ routes instanceof RouteCollection ) { $ collection -> addCollection ( $ routes ) ; } } foreach ( [ 'contao_frontend' , 'contao_index' , 'contao_root' , 'contao_catch_all' ] as $ name ) { if ( $ route = $ collection -> get ( $ name ) ) { $ collection -> add ( $ name , $ route ) ; } } return $ collection ; }
6780	protected function updateExchangeRate ( SaleInterface $ sale ) { if ( null !== $ sale -> getExchangeRate ( ) ) { return false ; } $ date = $ sale -> getExchangeDate ( ) ?? new \ DateTime ( ) ; $ rate = $ this -> currencyConverter -> getRate ( $ this -> currencyConverter -> getDefaultCurrency ( ) , $ sale -> getCurrency ( ) -> getCode ( ) , $ date ) ; $ sale -> setExchangeRate ( $ rate ) -> setExchangeDate ( $ date ) ; return true ; }
5530	protected function chainMockExpectations ( ) { $ code = " function expect(\$method, \$args = false, \$msg = '%s') {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->expect(\$method, \$args, \$msg);\n" ; $ code .= " }\n" ; $ code .= " function expectAt(\$timing, \$method, \$args = false, \$msg = '%s') {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->expectAt(\$timing, \$method, \$args, \$msg);\n" ; $ code .= " }\n" ; $ code .= " function expectCallCount(\$method, \$count) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->expectCallCount(\$method, \$count, \$msg = '%s');\n" ; $ code .= " }\n" ; $ code .= " function expectMaximumCallCount(\$method, \$count, \$msg = '%s') {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->expectMaximumCallCount(\$method, \$count, \$msg = '%s');\n" ; $ code .= " }\n" ; $ code .= " function expectMinimumCallCount(\$method, \$count, \$msg = '%s') {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->expectMinimumCallCount(\$method, \$count, \$msg = '%s');\n" ; $ code .= " }\n" ; $ code .= " function expectNever(\$method) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->expectNever(\$method);\n" ; $ code .= " }\n" ; $ code .= " function expectOnce(\$method, \$args = false, \$msg = '%s') {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->expectOnce(\$method, \$args, \$msg);\n" ; $ code .= " }\n" ; $ code .= " function expectAtLeastOnce(\$method, \$args = false, \$msg = '%s') {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->expectAtLeastOnce(\$method, \$args, \$msg);\n" ; $ code .= " }\n" ; return $ code ; }
6163	public function getMemUsage ( $ realmem = false ) { if ( $ this -> isRunning ( ) ) { $ this -> stop ( ) ; $ this -> start ( ) ; } return ( $ realmem !== false ) ? $ this -> data [ "realmem" ] : $ this -> data [ "emalloc" ] ; }
8948	public function downloadTraceMetadetails ( $ id , $ username , $ password ) { $ base = 'gpx/' . $ id . '/details' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; return $ this -> sendRequest ( $ path , 'GET' , array ( 'Authorization' => 'Basic ' . base64_encode ( $ username . ':' . $ password ) ) ) ; }
8463	public static function getProtocol ( $ url = false ) { if ( $ url ) { return ( preg_match ( '/^https/' , $ url ) ) ? 'https' : 'http' ; } $ protocol = strtolower ( $ _SERVER [ 'SERVER_PROTOCOL' ] ) ; $ protocol = substr ( $ protocol , 0 , strpos ( $ protocol , '/' ) ) ; $ ssl = ( isset ( $ _SERVER [ 'HTTPS' ] ) && $ _SERVER [ 'HTTPS' ] == 'on' ) ; return ( $ ssl ) ? $ protocol . 's' : $ protocol ; }
5153	public function addConfiguration ( $ configuration , $ configure = true ) { if ( ! $ configuration instanceof ConfigurationInterface ) { $ configuration = new Configuration ( $ configuration ) ; } $ config = $ this -> getConfiguration ( ) ; if ( $ config instanceof ConfigurationInterface ) { $ config -> merge ( $ configuration ) ; } if ( $ config === null ) { $ config = $ configuration ; } $ this -> setConfiguration ( $ config , $ configure ) ; }
7991	public function setSshKey ( $ pp , $ pca , $ key ) { if ( ! $ pp ) throw new BadMethodCallException ( 'Missing parameter $pp (OVH cloud passport).' ) ; if ( ! $ pca ) throw new BadMethodCallException ( 'Missing parameter $pca (PCA ServiceName).' ) ; if ( ! $ key ) throw new BadMethodCallException ( 'Missing parameter $key (Public key for this pca).' ) ; $ payload = array ( 'sshkey' => $ key ) ; try { $ this -> put ( 'cloud/' . $ pp . '/pca/' . $ pca , array ( 'Content-Type' => 'application/json;charset=UTF-8' ) , json_encode ( $ payload ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new CloudException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } }
8601	private function _convertDeleteSubscription ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'DeleteSubscription' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetMarketplaceId ( ) ) { $ parameters [ 'MarketplaceId' ] = $ request -> getMarketplaceId ( ) ; } if ( $ request -> isSetNotificationType ( ) ) { $ parameters [ 'NotificationType' ] = $ request -> getNotificationType ( ) ; } if ( $ request -> isSetDestination ( ) ) { $ DestinationDeleteSubscriptionInput = $ request -> getDestination ( ) ; foreach ( $ DestinationDeleteSubscriptionInput -> getDeliveryChannel ( ) as $ DeliveryChannelDestinationIndex => $ DeliveryChannelDestination ) { $ parameters [ 'Destination' . '.' . 'DeliveryChannel' . '.' . ( $ DeliveryChannelDestinationIndex + 1 ) ] = $ DeliveryChannelDestination ; } } return $ parameters ; }
4966	public function fromHeader ( $ header = null , $ default = null ) { if ( $ header === null ) { return $ this -> event -> getRequest ( ) -> getHeaders ( $ header , $ default ) -> toArray ( ) ; } return $ this -> event -> getRequest ( ) -> getHeaders ( $ header , $ default ) ; }
4437	public function set ( string $ name , $ value ) : void { $ this -> client -> call ( 'config.set' , $ name , $ value ) ; }
4510	public function created ( JWTCreatedEvent $ event ) { $ data = $ event -> getData ( ) ; $ user = $ event -> getUser ( ) ; $ this -> accessor -> setValue ( $ data , $ this -> property , $ user -> getUuid ( ) ) ; $ event -> setData ( $ data ) ; }
3404	public function lock ( Output $ output ) { if ( ! $ this -> lock ) { return ; } $ this -> lock = $ this -> getApplication ( ) -> getLockFactory ( ) -> createLock ( $ this -> getName ( ) ) ; if ( ! $ this -> lock -> acquire ( ) ) { $ output -> error ( "Another instance of this command (" . $ this -> getName ( ) . ") is currently running" ) ; exit ( Application :: STATUS_LOCKED ) ; } }
6226	public function isValid ( ) { if ( $ this -> service_code == 2106 ) { if ( $ this -> getSpecifier ( 'pickup_point_id' ) === null ) return false ; } if ( $ this -> service_code == 3101 ) { $ expected_params = array ( 'amount' , 'account' , 'reference' , 'codbic' ) ; foreach ( $ expected_params as $ param ) { if ( $ this -> getSpecifier ( $ param ) === null ) return false ; } } if ( $ this -> service_code == 3102 ) { if ( $ this -> getSpecifier ( 'count' ) === null ) return false ; if ( ! is_numeric ( $ this -> getSpecifier ( 'count' ) ) ) return false ; } if ( $ this -> service_code == 3111 ) { if ( $ this -> getSpecifier ( 'insurancevalue' ) === null ) return false ; } if ( $ this -> service_code == 3120 ) { if ( $ this -> getSpecifier ( 'deliverytime' ) ) return false ; } if ( $ this -> service_code == 3143 ) { if ( $ this -> getSpecifier ( 'lqweight' ) === null or $ this -> getSpecifier ( 'lqcount' ) === null ) return false ; } if ( ! is_numeric ( $ this -> service_code ) ) { return false ; } return true ; }
2532	protected function loadOptionalSegmentInformation ( $ options ) { if ( ! empty ( $ options -> operatingCompany ) ) { $ this -> segmentInformation -> companyDetails -> operatingCompany = $ options -> operatingCompany ; } if ( $ options -> arrivalDate instanceof \ DateTime ) { $ this -> segmentInformation -> flightDate -> setArrivalDate ( $ options -> arrivalDate ) ; } if ( ! empty ( $ options -> groupNumber ) ) { $ this -> segmentInformation -> flightTypeDetails = new FlightTypeDetails ( $ options -> groupNumber ) ; } $ this -> loadAdditionalSegmentDetails ( $ options -> airplaneCode , $ options -> nrOfStops ) ; }
10960	private function prepareFilePathTo ( \ SplFileInfo $ file ) { if ( $ this -> currentCommand -> isUsePathReplace ( ) ) { $ fileWhereToMovePath = $ file -> getPath ( ) . DIRECTORY_SEPARATOR ; if ( $ this -> direction === self :: DIRECTION_FORWARD ) { $ filePathTo = $ this -> currentCommand -> replacePath ( $ fileWhereToMovePath ) ; } elseif ( $ this -> direction === self :: DIRECTION_BACK ) { $ filePathTo = $ this -> currentCommand -> replacePathBack ( $ fileWhereToMovePath ) ; } else { throw new \ Exception ( __METHOD__ . " wrong direction" ) ; } $ this -> currentCommand -> setToDirectory ( $ filePathTo ) ; } else { $ filePathTo = $ this -> currentCommand -> getToDirectory ( ) ; } if ( ! file_exists ( $ filePathTo ) && ! is_dir ( $ filePathTo ) ) { mkdir ( $ filePathTo , $ this -> defaultDirMod , TRUE ) ; } else { chmod ( $ filePathTo , $ this -> defaultDirMod ) ; } if ( $ this -> currentCommand -> getDestinationFileName ( ) ) { $ fileName = $ this -> currentCommand -> getDestinationFileName ( ) ; } else { $ fileName = $ file -> getFilename ( ) ; } $ filePathTo .= $ fileName ; return $ filePathTo ; }
443	public function off ( $ name , $ handler = null ) { $ this -> ensureBehaviors ( ) ; if ( empty ( $ this -> _events [ $ name ] ) && empty ( $ this -> _eventWildcards [ $ name ] ) ) { return false ; } if ( $ handler === null ) { unset ( $ this -> _events [ $ name ] , $ this -> _eventWildcards [ $ name ] ) ; return true ; } $ removed = false ; if ( isset ( $ this -> _events [ $ name ] ) ) { foreach ( $ this -> _events [ $ name ] as $ i => $ event ) { if ( $ event [ 0 ] === $ handler ) { unset ( $ this -> _events [ $ name ] [ $ i ] ) ; $ removed = true ; } } if ( $ removed ) { $ this -> _events [ $ name ] = array_values ( $ this -> _events [ $ name ] ) ; return $ removed ; } } if ( isset ( $ this -> _eventWildcards [ $ name ] ) ) { foreach ( $ this -> _eventWildcards [ $ name ] as $ i => $ event ) { if ( $ event [ 0 ] === $ handler ) { unset ( $ this -> _eventWildcards [ $ name ] [ $ i ] ) ; $ removed = true ; } } if ( $ removed ) { $ this -> _eventWildcards [ $ name ] = array_values ( $ this -> _eventWildcards [ $ name ] ) ; if ( empty ( $ this -> _eventWildcards [ $ name ] ) ) { unset ( $ this -> _eventWildcards [ $ name ] ) ; } } } return $ removed ; }
743	private function initializeEventHandlers ( ) { $ this -> owner -> on ( Widget :: EVENT_BEFORE_RUN , [ $ this , 'beforeRun' ] ) ; $ this -> owner -> on ( Widget :: EVENT_AFTER_RUN , [ $ this , 'afterRun' ] ) ; }
1665	public function getListForSelect ( $ display = 'name' ) { foreach ( $ this -> getList ( $ display ) as $ key => $ value ) { $ countries [ $ key ] = $ value [ $ display ] ; } return $ countries ; }
5233	public function handleException ( \ Exception $ exception ) { if ( $ this -> loggingEnabled ) { $ this -> exceptionLogger -> log ( $ exception ) ; } if ( 'cgi' === $ this -> sapi ) { $ this -> header ( 'Status: 500 Internal Server Error' ) ; } else { $ this -> header ( 'HTTP/1.1 500 Internal Server Error' ) ; } $ this -> writeBody ( $ this -> createResponseBody ( $ exception ) ) ; }
7706	function _ApplyDiffFromStart ( $ Diff ) { $ this -> pST_PosEnd += $ Diff ; $ this -> pST_Src = false ; if ( $ this -> pET_PosBeg !== false ) $ this -> pET_PosBeg += $ Diff ; $ this -> PosEnd += $ Diff ; }
9801	public static function setLibXmlLoaderOptions ( $ options ) { if ( $ options === null && defined ( 'LIBXML_DTDLOAD' ) ) { $ options = LIBXML_DTDLOAD | LIBXML_DTDATTR ; } self :: $ libXmlLoaderOptions = $ options ; }
4591	public function setOwnerUuid ( ? string $ ownerUuid ) { if ( null !== $ ownerUuid ) { if ( ! preg_match ( '/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i' , $ ownerUuid ) ) { throw new InvalidArgumentException ( 'Owner uuid is not valid.' ) ; } } $ this -> ownerUuid = $ ownerUuid ; return $ this ; }
4354	protected function setFile ( $ file ) { if ( $ file == $ this -> file ) { return ; } if ( $ this -> fileHandle ) { \ fclose ( $ this -> fileHandle ) ; $ this -> fileHandle = null ; } $ this -> file = $ file ; if ( empty ( $ file ) ) { return ; } $ fileExists = \ file_exists ( $ file ) ; $ this -> fileHandle = \ fopen ( $ file , 'a' ) ; if ( $ this -> fileHandle ) { \ fwrite ( $ this -> fileHandle , '***** ' . \ date ( 'Y-m-d H:i:s' ) . ' *****' . "\n" ) ; if ( ! $ fileExists ) { \ chmod ( $ file , 0660 ) ; } } }
2385	public function addLegend ( string $ name , $ parent , string $ position = self :: POSITION_AFTER , $ hide = false ) : self { $ this -> validatePosition ( $ position ) ; $ this -> legends [ ] = [ 'name' => $ name , 'parents' => ( array ) $ parent , 'position' => $ position , 'hide' => ( bool ) $ hide , ] ; return $ this ; }
4101	public function map ( $ mapping , array $ config = array ( ) ) { if ( is_array ( $ mapping ) ) $ mapping = new Mapping ( $ mapping ) ; $ mapping -> config ( $ config ) ; try { $ type = $ mapping -> config ( 'type' ) ; } catch ( \ Exception $ e ) { } if ( isset ( $ type ) && ! $ this -> passesTypeConstraint ( $ type ) ) { throw new Exception ( "Cant create mapping due to type constraint mismatch" ) ; } return $ this -> request ( '_mapping' , 'PUT' , $ mapping -> export ( ) , true ) ; }
4239	public function onBootstrap ( ) { if ( $ this -> debug -> parentInstance ) { return ; } $ collectWas = $ this -> debug -> setCfg ( 'collect' , true ) ; $ this -> debug -> groupSummary ( ) ; $ this -> debug -> group ( 'environment' , $ this -> debug -> meta ( array ( 'hideIfEmpty' => true , 'level' => 'info' , ) ) ) ; $ this -> logPhpInfo ( ) ; $ this -> logServerVals ( ) ; $ this -> logRequest ( ) ; $ this -> debug -> groupEnd ( ) ; $ this -> debug -> groupEnd ( ) ; $ this -> debug -> setCfg ( 'collect' , $ collectWas ) ; }
1071	private function subfieldConflicts ( array $ conflicts , $ responseName , FieldNode $ ast1 , FieldNode $ ast2 ) { if ( count ( $ conflicts ) === 0 ) { return null ; } return [ [ $ responseName , array_map ( static function ( $ conflict ) { return $ conflict [ 0 ] ; } , $ conflicts ) , ] , array_reduce ( $ conflicts , static function ( $ allFields , $ conflict ) { return array_merge ( $ allFields , $ conflict [ 1 ] ) ; } , [ $ ast1 ] ) , array_reduce ( $ conflicts , static function ( $ allFields , $ conflict ) { return array_merge ( $ allFields , $ conflict [ 2 ] ) ; } , [ $ ast2 ] ) , ] ; }
2576	protected function mergeOptions ( $ existingOptions , $ newOptions ) { if ( ! empty ( $ newOptions ) ) { $ existingOptions = array_merge ( $ existingOptions , $ newOptions ) ; } return $ existingOptions ; }
9227	public function post ( $ path , $ data = array ( ) , $ headers = array ( ) ) { return $ this -> postprocessResponse ( parent :: post ( $ path , $ this -> preprocessData ( $ data ) , $ headers ) ) ; }
5600	public static function getSeverityAsString ( $ severity ) { static $ map = array ( E_ERROR => 'E_ERROR' , E_WARNING => 'E_WARNING' , E_PARSE => 'E_PARSE' , E_NOTICE => 'E_NOTICE' , E_CORE_ERROR => 'E_CORE_ERROR' , E_CORE_WARNING => 'E_CORE_WARNING' , E_COMPILE_ERROR => 'E_COMPILE_ERROR' , E_COMPILE_WARNING => 'E_COMPILE_WARNING' , E_USER_ERROR => 'E_USER_ERROR' , E_USER_WARNING => 'E_USER_WARNING' , E_USER_NOTICE => 'E_USER_NOTICE' , E_STRICT => 'E_STRICT' , E_RECOVERABLE_ERROR => 'E_RECOVERABLE_ERROR' , E_DEPRECATED => 'E_DEPRECATED' , E_USER_DEPRECATED => 'E_USER_DEPRECATED' , E_ALL => 'E_ALL' ) ; return $ map [ $ severity ] ; }
8968	protected function load ( ) { $ this -> rates = array ( ) ; $ this -> latest = array ( ) ; $ handle = fopen ( $ this -> pathToFile , 'rb' ) ; if ( ! $ handle ) { throw new RuntimeException ( sprintf ( 'Error opening file on path "%s".' , $ this -> pathToFile ) ) ; } while ( ( $ line = fgets ( $ handle ) ) !== false ) { $ rate = $ this -> fromJson ( $ line ) ; $ this -> rates [ $ this -> getRateKey ( $ rate -> getCurrencyCode ( ) , $ rate -> getDate ( ) , $ rate -> getRateType ( ) , $ rate -> getSourceName ( ) ) ] = $ rate ; $ latestKey = sprintf ( '%s_%s_%s' , $ rate -> getCurrencyCode ( ) , $ rate -> getRateType ( ) , $ rate -> getSourceName ( ) ) ; if ( ! isset ( $ this -> latest [ $ latestKey ] ) || ( $ this -> latest [ $ latestKey ] -> getDate ( ) < $ rate -> getDate ( ) ) ) { $ this -> latest [ $ latestKey ] = $ rate ; } } fclose ( $ handle ) ; return $ this -> rates ; }
10641	public function andWhere ( $ column , $ op , $ value , $ isParam = true ) { $ this -> clauses [ ] = array ( "AND" , $ column , $ op , $ value , $ isParam ) ; return $ this ; }
11094	public static function getDateFromBirthNumber ( $ no ) { if ( ! preg_match ( '#^\s*(\d\d)(\d\d)(\d\d)[ /]*(\d\d\d)(\d?)\s*$#' , $ no , $ matches ) ) { return null ; } list ( , $ year , $ month , $ day , $ ext , $ c ) = $ matches ; if ( $ c === '' ) { $ year += $ year < 54 ? 1900 : 1800 ; } else { $ mod = ( $ year . $ month . $ day . $ ext ) % 11 ; if ( $ mod === 10 ) { $ mod = 0 ; } if ( $ mod !== ( int ) $ c ) { return null ; } $ year += $ year < 54 ? 2000 : 1900 ; } if ( $ year > 2003 ) { if ( $ month > 70 ) { $ month -= 70 ; } if ( $ month > 20 && $ month < 50 ) { $ month -= 20 ; } } if ( $ month > 50 ) { $ month -= 50 ; } return new DateTime ( sprintf ( '%04d-%02d-%02d' , $ year , $ month , $ day ) ) ; }
4527	public function prePersist ( LifecycleEventArgs $ args ) { $ entity = $ args -> getEntity ( ) ; if ( ! $ entity instanceof Identitiable ) { return ; } $ this -> identityService -> generateIdentity ( $ entity ) ; }
7497	public function createMessageFromTemplateFile ( $ template , $ params , $ subject , $ recipient , $ sender = null ) { $ body = $ this -> templating -> render ( $ template , $ params ) ; if ( ! $ sender ) { $ sender = $ this -> defaultSender ; } $ message = new \ Swift_Message ( ) ; $ message -> setFrom ( $ sender ) -> setReplyTo ( $ sender ) -> setTo ( $ recipient ) -> setSubject ( $ subject ) -> setBody ( $ body , 'text/html' ) ; return $ message ; }
12697	static function getOpts ( $ extname = '' , $ version = '' , $ cliopts = array ( ) ) { self :: setConfigDir ( $ cliopts ) ; if ( $ version == '' && self :: isValidVersion ( $ extname ) ) { $ version = $ extname ; $ extname = '' ; } if ( $ version != '' && ! self :: isValidVersion ( $ version ) ) { throw new PakeException ( "'$version' is not a valid version number" ) ; } if ( $ extname == '' ) { $ extname = self :: getDefaultExtName ( ) ; } if ( ! isset ( self :: $ options [ $ extname ] ) || ! is_array ( self :: $ options [ $ extname ] ) ) { if ( isset ( $ cliopts [ 'config-file' ] ) ) { $ cfgfile = $ cliopts [ 'config-file' ] ; } else { $ cfgfile = self :: getOptionsDir ( ) . "/options-$extname.yaml" ; } if ( isset ( $ cliopts [ 'user-config-file' ] ) ) { $ usercfgfile = $ cliopts [ 'user-config-file' ] ; if ( ! is_file ( $ cliopts [ 'user-config-file' ] ) ) { throw new PakeException ( "Could not find user-configuration-file {$cliopts['user-config-file']}" ) ; } } else { $ usercfgfile = self :: getOptionsDir ( ) . "/options-user.yaml" ; } foreach ( $ cliopts as $ opt => $ val ) { if ( substr ( $ opt , 0 , 7 ) == 'option.' ) { unset ( $ cliopts [ $ opt ] ) ; $ work = array_reverse ( explode ( '.' , substr ( $ opt , 7 ) ) ) ; $ built = array ( array_shift ( $ work ) => $ val ) ; foreach ( $ work as $ key ) { $ built = array ( $ key => $ built ) ; } self :: recursivemerge ( $ cliopts , $ built ) ; } } self :: loadConfiguration ( $ cfgfile , $ extname , $ version , $ usercfgfile , $ cliopts ) ; } pake_echo ( "Building extension $extname ( " . self :: $ options [ $ extname ] [ 'extension' ] [ 'name' ] . " ) version " . self :: $ options [ $ extname ] [ 'version' ] [ 'alias' ] . self :: $ options [ $ extname ] [ 'releasenr' ] [ 'separator' ] . self :: $ options [ $ extname ] [ 'version' ] [ 'release' ] ) ; return self :: $ options [ $ extname ] ; }
184	public function init ( ) { parent :: init ( ) ; $ this -> cache = $ this -> enabled ? Instance :: ensure ( $ this -> cache , 'yii\caching\CacheInterface' ) : null ; if ( $ this -> cache instanceof CacheInterface && $ this -> getCachedContent ( ) === false ) { $ this -> getView ( ) -> pushDynamicContent ( $ this ) ; ob_start ( ) ; ob_implicit_flush ( false ) ; } }
5221	public function sourcePathes ( ) { $ vendorPathes = [ ] ; foreach ( array_merge ( $ this -> loadPsr0Pathes ( ) , $ this -> loadPsr4Pathes ( ) ) as $ pathes ) { if ( is_array ( $ pathes ) ) { $ vendorPathes = array_merge ( $ vendorPathes , $ pathes ) ; } else { $ vendorPathes [ ] = $ pathes ; } } return $ vendorPathes ; }
7496	public function createMessageFromTemplateEntity ( EmailTemplate $ template , array $ parameters = array ( ) ) { $ subject = $ this -> renderStringTemplate ( $ template -> getSubject ( ) , $ parameters ) ; $ recipient = $ this -> renderStringTemplate ( $ template -> getRecipient ( ) , $ parameters ) ; $ body = $ this -> renderStringTemplate ( $ template -> getBody ( ) , $ parameters ) ; $ sender = $ template -> getSender ( ) ? : $ this -> defaultSender ; $ message = new \ Swift_Message ( $ subject , $ body , $ template -> getMimeType ( ) ) ; $ message -> setFrom ( $ sender ) -> setSender ( $ sender ) -> setTo ( $ recipient ) ; if ( $ template -> hasCc ( ) ) { $ message -> setCc ( $ template -> getCc ( ) ) ; } if ( $ template -> hasAltBody ( ) ) { $ altBody = $ this -> renderStringTemplate ( $ template -> getAltBody ( ) , $ parameters ) ; $ message -> addPart ( $ altBody , $ template -> getAltMimeType ( ) ) ; } return $ message ; }
7491	public function setLength ( $ newLength , $ padding = ' ' ) { $ newLength = ( int ) $ newLength ; $ currentLength = $ this -> length ( ) ; if ( $ newLength != $ currentLength ) { while ( $ newLength > $ this -> length ( ) ) { $ this -> string .= $ padding ; } if ( $ newLength < $ this -> length ( ) ) { $ this -> string = mb_substr ( $ this -> string , 0 , $ newLength , $ this -> encoding ) ; } } return $ this ; }
12349	public function getTaxonomy ( $ system_id ) { foreach ( $ this -> getTaxonomies ( ) as $ taxonomy ) { if ( $ taxonomy -> system_id === $ system_id ) { return $ taxonomy ; } } return false ; }
3521	public static function login ( $ email , $ password , $ challenge = '' , $ code = '' ) { $ requestParams = [ 'includePerms' => 'false' , 'token_type' => 'eg1' ] ; if ( empty ( $ challenge ) && empty ( $ code ) ) { $ requestParams = array_merge ( $ requestParams , [ 'grant_type' => 'password' , 'username' => $ email , 'password' => $ password , ] ) ; } else { $ requestParams = array_merge ( $ requestParams , [ 'grant_type' => 'otp' , 'otp' => $ code , 'challenge' => $ challenge , ] ) ; } $ data = FortniteClient :: sendUnrealClientPostRequest ( FortniteClient :: EPIC_OAUTH_TOKEN_ENDPOINT , $ requestParams ) ; if ( ! isset ( $ data -> access_token ) ) { if ( $ data -> errorCode === 'errors.com.epicgames.common.two_factor_authentication.required' ) { throw new TwoFactorAuthRequiredException ( $ data -> challenge ) ; } throw new \ Exception ( $ data -> errorMessage ) ; } $ data = FortniteClient :: sendUnrealClientGetRequest ( FortniteClient :: EPIC_OAUTH_EXCHANGE_ENDPOINT , $ data -> access_token , true ) ; if ( ! isset ( $ data -> code ) ) { throw new \ Exception ( $ data -> errorMessage ) ; } $ data = FortniteClient :: sendUnrealClientPostRequest ( FortniteClient :: EPIC_OAUTH_TOKEN_ENDPOINT , [ 'grant_type' => 'exchange_code' , 'exchange_code' => $ data -> code , 'includePerms' => false , 'token_type' => 'eg1' ] , FortniteClient :: FORTNITE_AUTHORIZATION ) ; if ( ! isset ( $ data -> access_token ) ) { throw new \ Exception ( $ data -> errorMessage ) ; } return new self ( $ data -> access_token , $ data -> in_app_id , $ data -> refresh_token , $ data -> account_id , $ data -> expires_in ) ; }
11025	public function __isset ( $ name ) : bool { if ( strrpos ( $ name , 'facet_' , - strlen ( $ name ) ) !== false ) { return true ; } return false ; }
1470	public function createResolver ( $ apiName , array $ config ) { $ factoryName = isset ( $ config [ 'resolver' ] ) ? $ config [ 'resolver' ] : ResolverFactory :: class ; $ factory = $ this -> container -> make ( $ factoryName ) ; if ( $ factory instanceof ResolverInterface ) { return $ factory ; } if ( ! is_callable ( $ factory ) ) { throw new RuntimeException ( "Factory {$factoryName} cannot be invoked." ) ; } $ resolver = $ factory ( $ apiName , $ config ) ; if ( ! $ resolver instanceof ResolverInterface ) { throw new RuntimeException ( "Factory {$factoryName} did not create a resolver instance." ) ; } return $ resolver ; }
165	public static function serialize ( array $ links ) { foreach ( $ links as $ rel => $ link ) { if ( is_array ( $ link ) ) { foreach ( $ link as $ i => $ l ) { $ link [ $ i ] = $ l instanceof self ? array_filter ( ( array ) $ l ) : [ 'href' => $ l ] ; } $ links [ $ rel ] = $ link ; } elseif ( ! $ link instanceof self ) { $ links [ $ rel ] = [ 'href' => $ link ] ; } } return $ links ; }
7800	protected function splitStatements ( $ text ) { $ chunks = preg_split ( '/^:20:/m' , $ text , - 1 ) ; $ chunks = array_filter ( array_map ( 'trim' , array_slice ( $ chunks , 1 ) ) ) ; return array_map ( function ( $ statement ) { return ':20:' . $ statement ; } , $ chunks ) ; }
9850	public function stringToStream ( string $ input ) : StreamInterface { $ stream = \ fopen ( 'php://temp' , 'w+' ) ; if ( ! \ is_resource ( $ stream ) ) { throw new \ Error ( 'Could not create stream' ) ; } \ fwrite ( $ stream , $ input ) ; \ rewind ( $ stream ) ; return new Stream ( $ stream ) ; }
7275	protected function encodeValue ( $ column ) { $ val = in_array ( $ column , static :: $ jsons ) ? to_json ( $ this -> $ column ) : $ this -> $ column ; if ( isset ( static :: $ casts [ $ column ] ) && ( static :: $ casts [ $ column ] === "object" || static :: $ casts [ $ column ] === "array" ) ) $ val = to_json ( $ this -> $ column ) ; if ( is_bool ( $ val ) ) $ val = ( int ) $ val ; return $ val ; }
11995	public function getCatalog ( array $ catalogData ) { $ skuIndex = [ ] ; $ slugIndex = [ ] ; $ index = 1 ; $ products = [ ] ; foreach ( $ catalogData as $ catalogItem ) { try { $ product = $ this -> productMapper -> getProduct ( $ catalogItem ) ; $ sku = strtolower ( $ product -> getSku ( ) -> __toString ( ) ) ; if ( array_key_exists ( $ sku , $ skuIndex ) ) { throw new CatalogException ( sprintf ( "Cannot add a second product with the SKU '%s' to the catalog" , $ sku ) ) ; } $ skuIndex [ $ sku ] = 1 ; $ slug = strtolower ( $ product -> getSlug ( ) -> __toString ( ) ) ; if ( array_key_exists ( $ slug , $ slugIndex ) ) { throw new CatalogException ( sprintf ( "Cannot add a second product with the Slug '%s' to the catalog" , $ slug ) ) ; } $ slugIndex [ $ slug ] = 1 ; $ products [ ] = $ product ; } catch ( \ Exception $ productException ) { throw new CatalogException ( sprintf ( "Cannot convert catalog item %s into a product: %s" , $ index , $ productException -> getMessage ( ) ) , $ productException ) ; } $ index ++ ; } return new Catalog ( $ products ) ; }
1723	protected function getPreviewImage ( File $ objFile , $ strInfo , $ strClass = 'gimage' ) { if ( ( $ objFile -> isSvgImage || ( $ objFile -> height <= Config :: get ( 'gdMaxImgHeight' ) && $ objFile -> width <= Config :: get ( 'gdMaxImgWidth' ) ) ) && $ objFile -> viewWidth && $ objFile -> viewHeight ) { if ( $ objFile -> height !== null && $ objFile -> height <= 75 && $ objFile -> width !== null && $ objFile -> width <= 100 ) { $ image = $ objFile -> dataUri ; } else { $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; $ image = System :: getContainer ( ) -> get ( 'contao.image.image_factory' ) -> create ( $ rootDir . '/' . $ objFile -> path , array ( 100 , 75 , ResizeConfiguration :: MODE_BOX ) ) -> getUrl ( $ rootDir ) ; } } else { $ image = Image :: getPath ( 'placeholder.svg' ) ; } if ( strncmp ( $ image , 'data:' , 5 ) === 0 ) { return '<img src="' . $ objFile -> dataUri . '" width="' . $ objFile -> width . '" height="' . $ objFile -> height . '" alt="" class="' . $ strClass . '" title="' . StringUtil :: specialchars ( $ strInfo ) . '">' ; } return Image :: getHtml ( $ image , '' , 'class="' . $ strClass . '" title="' . StringUtil :: specialchars ( $ strInfo ) . '"' ) ; }
5593	protected function fetch ( $ url , $ encoding ) { $ request = $ this -> createRequest ( $ url , $ encoding ) ; return $ request -> fetch ( $ this -> connection_timeout ) ; }
1558	protected function doesRequireOrdering ( $ query ) { if ( ! $ this -> primaryKey ) { return false ; } $ query = ( $ query instanceof Relation ) ? $ query -> getBaseQuery ( ) : $ query -> getQuery ( ) ; return ! collect ( $ query -> orders ? : [ ] ) -> contains ( function ( array $ order ) { $ col = $ order [ 'column' ] ?? '' ; return $ this -> primaryKey === $ col ; } ) ; }
8747	public function select ( ) { $ read = [ $ this -> stream ] ; $ write = null ; $ except = null ; $ this -> selected = @ stream_select ( $ read , $ write , $ except , 0 , $ this -> timeout ) ; return $ this ; }
8722	public function translate ( $ locale ) { $ found = $ this -> translations -> where ( $ this -> getLocaleKey ( ) , $ locale ) -> first ( ) ; if ( ! $ found && $ this -> shouldFallback ( $ locale ) ) { return $ this -> translate ( $ this -> getFallbackLocale ( ) ) ; } return $ found ; }
10535	protected function _getData ( $ key ) { $ store = $ this -> _getDataStore ( ) ; try { $ result = $ this -> _containerGet ( $ store , $ key ) ; } catch ( OutOfRangeException $ e ) { throw $ this -> _createInvalidArgumentException ( $ this -> __ ( 'Invalid key' ) , null , $ e , $ key ) ; } return $ result ; }
8840	public function setExitCode ( $ exitCode ) { \ Assert \ that ( $ exitCode ) -> integer ( ) -> min ( 0 ) ; $ this -> exitCode = $ exitCode ; return $ this ; }
7237	protected function fixInvoiceDefault ( CustomerAddressInterface $ address ) { if ( ! $ this -> persistenceHelper -> isChanged ( $ address , [ 'invoiceDefault' ] ) ) { return ; } $ customer = $ address -> getCustomer ( ) ; if ( $ address -> isInvoiceDefault ( ) ) { foreach ( $ customer -> getAddresses ( ) as $ a ) { if ( $ a === $ address ) { continue ; } if ( $ a -> isInvoiceDefault ( ) ) { $ a -> setInvoiceDefault ( false ) ; $ this -> persistenceHelper -> persistAndRecompute ( $ a , false ) ; } } } elseif ( null === $ customer -> getDefaultInvoiceAddress ( true ) ) { $ address -> setInvoiceDefault ( true ) ; $ this -> persistenceHelper -> persistAndRecompute ( $ address , false ) ; } }
8404	public static function registerApp ( string $ namespace , string $ path = null ) { $ namespace = rtrim ( $ namespace , '\\' ) ; if ( $ path == null ) { $ path = constant ( 'STRAY_PATH_APPS' ) . str_replace ( '_' , DIRECTORY_SEPARATOR , str_replace ( '\\' , DIRECTORY_SEPARATOR , $ namespace ) ) ; } self :: $ namespaces [ $ namespace ] = $ path ; self :: $ applications [ ] = $ namespace ; }
9746	public function setQuarter ( $ quarter ) { if ( ! $ quarter ) { return $ this ; } if ( ! ( $ quarter instanceof Quarter ) ) { $ quarter = new Quarter ( $ quarter ) ; } if ( $ quarter -> isEmpty ( ) ) { $ this -> invalidArguments ( '10005' ) ; } return $ this -> setParameter ( 'quarter' , $ quarter ) ; }
11565	private function getApp ( ) { if ( is_null ( $ this -> app ) ) { $ this -> app = \ Concrete \ Core \ Support \ Facade \ Application :: getFacadeApplication ( ) ; } return $ this -> app ; }
9851	public static function hashPassword ( $ pPassword ) { $ password = 0x0000 ; $ charPos = 1 ; $ chars = preg_split ( '//' , $ pPassword , - 1 , PREG_SPLIT_NO_EMPTY ) ; foreach ( $ chars as $ char ) { $ value = ord ( $ char ) << $ charPos ++ ; $ rotated_bits = $ value >> 15 ; $ value &= 0x7fff ; $ password ^= ( $ value | $ rotated_bits ) ; } $ password ^= strlen ( $ pPassword ) ; $ password ^= 0xCE4B ; return strtoupper ( dechex ( $ password ) ) ; }
6578	public function parse ( $ url ) { $ parts = $ this -> _parse_url ( $ url ) ; foreach ( array ( 'user' , 'pass' , 'fragment' ) as $ part ) if ( isset ( $ parts [ $ part ] ) ) $ parts [ $ part ] = urldecode ( $ parts [ $ part ] ) ; if ( isset ( $ parts [ 'host' ] ) ) $ parts [ 'host' ] = idn_to_utf8 ( $ parts [ 'host' ] ) ; if ( isset ( $ parts [ 'path' ] ) ) $ parts [ 'path' ] = rawurldecode ( str_ireplace ( '%2F' , '%252F' , $ parts [ 'path' ] ) ) ; return $ this -> setParts ( $ parts ) ; }
1341	public function find ( ResourceIdentifierInterface $ identifier ) { $ record = $ this -> lookup ( $ identifier ) ; if ( false === $ record ) { return false ; } return is_object ( $ record ) ? $ record : null ; }
2470	public function getMaxDepthForContent ( ContentType $ contentType ) : int { if ( isset ( $ this -> contentTypeMap [ $ contentType -> identifier ] ) ) { return $ this -> contentTypeMap [ $ contentType -> identifier ] ; } return $ this -> defaultIndexingDepth ; }
8871	public function on ( $ eventName , callable $ callable ) { \ Assert \ that ( $ eventName ) -> string ( ) -> notEmpty ( ) ; $ this -> eventDispatcher -> addListener ( $ eventName , $ callable ) ; return $ this ; }
4131	public function createLuceneQuery ( $ designDocName , $ viewName ) { $ luceneHandlerName = $ this -> config -> getLuceneHandlerName ( ) ; $ designDoc = $ this -> config -> getDesignDocument ( $ designDocName ) ; if ( $ designDoc ) { $ designDoc = new $ designDoc [ 'className' ] ( $ designDoc [ 'options' ] ) ; } $ query = new ODMLuceneQuery ( $ this -> couchDBClient -> getHttpClient ( ) , $ this -> couchDBClient -> getDatabase ( ) , $ luceneHandlerName , $ designDocName , $ viewName , $ designDoc ) ; $ query -> setDocumentManager ( $ this ) ; return $ query ; }
7838	public function create ( string $ name , array $ numbers ) : ? array { $ body = Body :: json ( [ [ 'name' => $ name , 'phone_numbers' => $ numbers , ] , ] ) ; $ response = Request :: post ( $ this -> baseUrl . 'contact' , [ ] , $ body ) ; if ( $ response -> code != 200 ) { if ( ! empty ( $ response -> body -> message ) ) { Log :: error ( $ response -> body -> message ) ; } } return [ 'code' => $ response -> code , 'message' => ( $ response -> code == 200 ) ? 'OK' : $ response -> body -> message ?? '' , 'data' => $ response -> body , ] ; }
2320	public static function create ( $ image , $ size = null ) { @ trigger_error ( 'Using Image::create() has been deprecated and will no longer work in Contao 5.0. Use the contao.image.image_factory service instead.' , E_USER_DEPRECATED ) ; if ( \ is_string ( $ image ) ) { $ image = new File ( rawurldecode ( $ image ) ) ; } $ imageObj = new static ( $ image ) ; if ( \ is_array ( $ size ) && ! empty ( $ size [ 2 ] ) && is_numeric ( $ size [ 2 ] ) ) { $ size = ( int ) $ size [ 2 ] ; } if ( \ is_array ( $ size ) ) { $ size += array ( 0 , 0 , 'crop' ) ; $ imageObj -> setTargetWidth ( $ size [ 0 ] ) -> setTargetHeight ( $ size [ 1 ] ) -> setResizeMode ( $ size [ 2 ] ) ; } elseif ( ( $ imageSize = ImageSizeModel :: findByPk ( $ size ) ) !== null ) { $ imageObj -> setTargetWidth ( $ imageSize -> width ) -> setTargetHeight ( $ imageSize -> height ) -> setResizeMode ( $ imageSize -> resizeMode ) -> setZoomLevel ( $ imageSize -> zoom ) ; } $ fileRecord = FilesModel :: findByPath ( $ image -> path ) ; if ( $ fileRecord !== null && $ fileRecord -> importantPartWidth && $ fileRecord -> importantPartHeight ) { $ imageObj -> setImportantPart ( array ( 'x' => ( int ) $ fileRecord -> importantPartX , 'y' => ( int ) $ fileRecord -> importantPartY , 'width' => ( int ) $ fileRecord -> importantPartWidth , 'height' => ( int ) $ fileRecord -> importantPartHeight , ) ) ; } return $ imageObj ; }
891	public function setTypes ( array $ types ) { $ pattern = '/' . preg_quote ( $ this -> getTypesContent ( ) , '/' ) . '/' ; $ this -> lines [ 0 ] -> setContent ( Preg :: replace ( $ pattern , implode ( '|' , $ types ) , $ this -> lines [ 0 ] -> getContent ( ) , 1 ) ) ; $ this -> clearCache ( ) ; }
10556	public function make ( Log $ log , $ trans = true ) { $ items = [ ] ; $ route = 'dashboard.systems.logs.show' ; foreach ( $ log -> tree ( $ trans ) as $ level => $ item ) { $ items [ $ level ] = array_merge ( $ item , [ 'url' => route ( $ route , [ $ log -> date , $ level ] ) , 'icon' => $ this -> styler -> icon ( $ level ) ? : '' , ] ) ; } return $ items ; }
8798	public function registerDirectives ( BladeCompiler $ blade ) { $ keywords = [ "namespace" , "use" , ] ; foreach ( $ keywords as $ keyword ) { $ blade -> directive ( $ keyword , function ( $ parameter ) use ( $ keyword ) { $ parameter = trim ( $ parameter , "()" ) ; return "<?php {$keyword} {$parameter} ?>" ; } ) ; } $ assetify = function ( $ file , $ type ) { $ file = trim ( $ file , "()" ) ; if ( in_array ( substr ( $ file , 0 , 1 ) , [ "'" , '"' ] , true ) ) { $ file = trim ( $ file , "'\"" ) ; } else { return "{{ {$file} }}" ; } if ( substr ( $ file , 0 , 1 ) !== "/" ) { $ file = "/{$type}/{$file}" ; } if ( substr ( $ file , ( strlen ( $ type ) + 1 ) * - 1 ) !== ".{$type}" ) { $ file .= ".{$type}" ; } return $ file ; } ; $ blade -> directive ( "css" , function ( $ parameter ) use ( $ assetify ) { $ file = $ assetify ( $ parameter , "css" ) ; return '<link rel="stylesheet" type="text/css" href="' . $ file . '"/>' ; } ) ; $ blade -> directive ( "js" , function ( $ parameter ) use ( $ assetify ) { $ file = $ assetify ( $ parameter , "js" ) ; return '<script type="text/javascript" src="' . $ file . '"></script>' ; } ) ; }
3149	public function getItemPublicUrl ( RunnerServiceContext $ context , $ itemRef ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ directoryIds = explode ( '|' , $ itemRef ) ; $ userDataLang = \ common_session_SessionManager :: getSession ( ) -> getDataLanguage ( ) ; $ directory = \ tao_models_classes_service_FileStorage :: singleton ( ) -> getDirectoryById ( $ directoryIds [ 1 ] ) ; if ( $ userDataLang != DEFAULT_LANG && ! $ directory -> has ( $ userDataLang ) && $ directory -> has ( DEFAULT_LANG ) ) { $ userDataLang = DEFAULT_LANG ; } return $ directory -> getPublicAccessUrl ( ) . $ userDataLang . '/' ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'getItemPublicUrl' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } }
7419	protected function setRedirect ( string $ url = '' , int $ statusCode = 303 ) { $ this -> response -> redirect ( $ url , $ statusCode ) ; }
7409	public function & offsetGet ( $ offset ) { if ( ! $ this -> offsetExists ( $ offset ) ) { $ this -> offsetSet ( $ offset , null ) ; if ( null === $ offset ) { end ( $ this -> _container ) ; $ offset = key ( $ this -> _container ) ; } } return $ this -> _container [ $ offset ] ; }
4653	public function getJobsToRemove ( $ projectPath , $ keep = 1 ) { $ currentJobs = $ this -> strategy -> getJobs ( $ projectPath ) ; $ existingJobs = $ this -> getJobs ( $ projectPath ) ; $ uniqList = array ( ) ; $ removes = array ( ) ; $ ordered = array ( ) ; foreach ( $ currentJobs as $ job ) { $ uniqList [ ] = $ job -> getUniq ( ) ; } foreach ( $ existingJobs as $ job ) { if ( ! in_array ( $ job -> getUniq ( ) , $ uniqList ) ) { $ removes [ ] = $ job ; } else { $ ordered [ $ job -> getUniq ( ) ] [ $ job -> getCreated ( ) -> format ( 'U' ) ] = $ job ; } } foreach ( $ ordered as $ jobs ) { ksort ( $ jobs ) ; $ keeped = count ( $ jobs ) ; while ( $ keeped > $ keep ) { $ removes [ ] = array_shift ( $ jobs ) ; $ keeped -- ; } } return $ removes ; }
10814	protected function _setDataStore ( $ dataStore ) { if ( ! is_null ( $ dataStore ) ) { $ dataStore = $ this -> _normalizeContainer ( $ dataStore ) ; } $ this -> dataStore = $ dataStore ; }
4105	public function beginBulk ( ) { if ( ! $ this -> bulk ) { $ this -> bulk = $ this -> createBulk ( $ this ) ; } return $ this -> bulk ; }
3876	private function getMetaModelsPages ( $ config , $ rootPage = null , $ language = null ) { $ metaModelsIdentifier = $ config [ 'pid' ] ; $ filterIdentifier = $ config [ 'filter' ] ; $ presetParams = StringUtil :: deserialize ( $ config [ 'filterparams' ] , true ) ; $ renderSettingId = $ config [ 'rendersetting' ] ; $ metaModels = $ this -> getMetaModel ( $ metaModelsIdentifier , false ) ; $ availableLanguages = $ this -> getLanguage ( $ language , $ metaModels ) ; $ currentLanguage = $ GLOBALS [ 'TL_LANGUAGE' ] ; foreach ( $ availableLanguages as $ newLanguage ) { $ GLOBALS [ 'TL_LANGUAGE' ] = $ newLanguage ; $ view = $ this -> getView ( $ metaModelsIdentifier , $ renderSettingId ) ; $ jumpTos = $ view -> get ( 'jumpTo' ) ; $ processed = $ this -> setFilterParameters ( $ filterIdentifier , $ presetParams , array ( ) ) ; $ filter = $ metaModels -> getEmptyFilter ( ) ; $ filterSetting = $ this -> getFilterSettings ( $ filterIdentifier ) ; $ filterSetting -> addRules ( $ filter , $ processed ) ; $ newEntries = $ this -> getJumpTosFor ( $ metaModels , $ filter , $ view , $ rootPage ) ; $ this -> removeEmptyDetailPages ( $ jumpTos ) ; $ GLOBALS [ 'TL_LANGUAGE' ] = $ currentLanguage ; $ this -> foundPages = array_merge ( $ this -> foundPages , $ newEntries ) ; } $ GLOBALS [ 'TL_LANGUAGE' ] = $ currentLanguage ; }
1907	protected function escapeParams ( $ arrValues ) { foreach ( $ arrValues as $ k => $ v ) { switch ( \ gettype ( $ v ) ) { case 'string' : $ arrValues [ $ k ] = $ this -> resConnection -> quote ( $ v ) ; break ; case 'boolean' : $ arrValues [ $ k ] = ( $ v === true ) ? 1 : 0 ; break ; case 'object' : $ arrValues [ $ k ] = $ this -> resConnection -> quote ( serialize ( $ v ) ) ; break ; case 'array' : $ arrValues [ $ k ] = $ this -> resConnection -> quote ( serialize ( $ v ) ) ; break ; default : $ arrValues [ $ k ] = $ v ?? 'NULL' ; break ; } } return $ arrValues ; }
10204	public function setShrinkToFit ( $ pValue ) { if ( $ pValue == '' ) { $ pValue = false ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'shrinkToFit' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> shrinkToFit = $ pValue ; } return $ this ; }
4757	protected function transformIterable ( $ value ) { $ params = array ( ) ; foreach ( $ value as $ key => $ val ) { if ( ! empty ( $ val ) ) { $ params [ $ key ] = $ this -> transform ( $ val ) ; } } return $ params ; }
11439	public function getErrors ( $ echoable = false ) { if ( true === $ echoable ) { return join ( "\n<br />" , $ this -> errors ) ; } else { return $ this -> errors ; } }
11749	public function material ( ) { if ( is_null ( $ this -> material ) ) { $ this -> material = new Material ( $ this -> accessToken ) ; } return $ this -> material ; }
7143	private function sortAssignments ( array $ assignments , $ direction = SORT_DESC ) { usort ( $ assignments , function ( StockAssignmentInterface $ a , StockAssignmentInterface $ b ) use ( $ direction ) { $ aDate = $ a -> getSaleItem ( ) -> getSale ( ) -> getCreatedAt ( ) ; $ bDate = $ b -> getSaleItem ( ) -> getSale ( ) -> getCreatedAt ( ) ; if ( $ aDate == $ bDate ) { return 0 ; } if ( $ direction === SORT_ASC ) { return $ aDate < $ bDate ? - 1 : 1 ; } return $ aDate > $ bDate ? - 1 : 1 ; } ) ; return $ assignments ; }
1223	public function resolve ( $ uri , $ version , $ resource , array $ paramDefs , array $ paramValues ) { foreach ( $ paramValues as $ param => $ value ) { if ( ! array_key_exists ( $ param , $ paramDefs ) ) { throw new \ InvalidArgumentException ( "Unknown uri parameter \"$param\" provided" ) ; } } foreach ( $ paramDefs as $ key => $ def ) { if ( ! isset ( $ paramValues [ $ key ] ) ) { if ( isset ( $ def [ 'default' ] ) ) { $ paramValues [ $ key ] = is_callable ( $ def [ 'default' ] ) ? $ def [ 'default' ] ( $ paramValues ) : $ def [ 'default' ] ; } elseif ( empty ( $ def [ 'required' ] ) ) { continue ; } else { $ this -> throwRequired ( $ paramDefs , $ paramValues ) ; } } $ this -> checkType ( $ def [ 'valid' ] , $ key , $ paramValues [ $ key ] ) ; if ( isset ( $ def [ 'fn' ] ) ) { $ def [ 'fn' ] ( $ paramValues [ $ key ] , $ paramValues ) ; } } return ( "$uri/" . "$version/" . $ this -> fillPathParams ( $ resource , $ paramValues ) . $ this -> buildQueryParameters ( $ paramValues ) ) ; }
7687	function Misc_CellRef ( $ Col , $ Row ) { $ r = '' ; $ x = $ Col ; do { $ x = $ x - 1 ; $ c = ( $ x % 26 ) ; $ x = ( $ x - $ c ) / 26 ; $ r = chr ( 65 + $ c ) . $ r ; } while ( $ x > 0 ) ; return $ r . $ Row ; }
9461	public function appendValueFilter ( $ key , $ value ) { if ( ! empty ( $ value ) ) { if ( $ this -> getValues ( $ key ) ) { return $ this -> append ( $ key , $ value ) ; } else { return $ this -> addValuesFilter ( $ key , [ $ value ] ) ; } } else { return $ this ; } }
2412	protected function addTableTlTheme ( \ DOMDocument $ xml , \ DOMNode $ tables , Result $ objTheme ) { $ table = $ xml -> createElement ( 'table' ) ; $ table -> setAttribute ( 'name' , 'tl_theme' ) ; $ table = $ tables -> appendChild ( $ table ) ; $ this -> loadDataContainer ( 'tl_theme' ) ; $ objDcaExtractor = DcaExtractor :: getInstance ( 'tl_theme' ) ; $ arrOrder = $ objDcaExtractor -> getOrderFields ( ) ; $ this -> addDataRow ( $ xml , $ table , $ objTheme -> row ( ) , $ arrOrder ) ; }
9716	private function writeCountry ( ) { $ record = 0x008C ; $ length = 4 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vv' , $ this -> countryCode , $ this -> countryCode ) ; return $ this -> writeData ( $ header . $ data ) ; }
8129	public function actionIndex ( ) { $ profile = Profile :: findOne ( [ 'uid' => Yii :: $ app -> user -> id ] ) ; if ( $ profile == NULL ) throw new NotFoundHttpException ; return $ this -> render ( 'index' , [ 'profile' => $ profile ] ) ; }
5004	protected function createEventManager ( $ services , $ config ) { if ( $ services -> has ( $ config [ 'service' ] ) ) { $ events = $ services -> get ( $ config [ 'service' ] ) ; } else { if ( ! class_exists ( $ config [ 'service' ] , true ) ) { throw new \ UnexpectedValueException ( sprintf ( 'Class or service %s does not exists. Cannot create event manager instance.' , $ config [ 'service' ] ) ) ; } $ events = new $ config [ 'service' ] ( ) ; } if ( false === $ config [ 'configure' ] ) { return $ events ; } $ events -> setIdentifiers ( $ config [ 'identifiers' ] ) ; $ event = $ services -> has ( $ config [ 'event' ] ) ? $ services -> get ( $ config [ 'event' ] ) : new $ config [ 'event' ] ( ) ; $ events -> setEventPrototype ( $ event ) ; if ( 'EventManager' != $ config [ 'service' ] && method_exists ( $ events , 'setSharedManager' ) && $ services -> has ( 'SharedEventManager' ) ) { $ sharedEvents = $ services -> get ( 'SharedEventManager' ) ; $ events -> setSharedManager ( $ sharedEvents ) ; } return $ events ; }
621	protected function splitCondition ( InCondition $ condition , & $ params ) { $ operator = $ condition -> getOperator ( ) ; $ values = $ condition -> getValues ( ) ; $ column = $ condition -> getColumn ( ) ; if ( $ values instanceof \ Traversable ) { $ values = iterator_to_array ( $ values ) ; } if ( ! is_array ( $ values ) ) { return null ; } $ maxParameters = 1000 ; $ count = count ( $ values ) ; if ( $ count <= $ maxParameters ) { return null ; } $ slices = [ ] ; for ( $ i = 0 ; $ i < $ count ; $ i += $ maxParameters ) { $ slices [ ] = $ this -> queryBuilder -> createConditionFromArray ( [ $ operator , $ column , array_slice ( $ values , $ i , $ maxParameters ) ] ) ; } array_unshift ( $ slices , ( $ operator === 'IN' ) ? 'OR' : 'AND' ) ; return $ this -> queryBuilder -> buildCondition ( $ slices , $ params ) ; }
8537	public function setRentalFeeList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'RentalFeeList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
12845	protected function processTextType ( $ value , \ Symfony \ Component \ Form \ FormInterface $ form , \ Chill \ CustomFieldsBundle \ Entity \ CustomField $ cf ) { $ form -> submit ( array ( $ cf -> getSlug ( ) => $ value ) ) ; $ value = $ form -> getData ( ) [ $ cf -> getSlug ( ) ] ; $ this -> logger -> debug ( sprintf ( "Found value : %s for custom field with question " . "'%s'" , $ value , $ this -> helper -> localize ( $ cf -> getName ( ) ) ) ) ; return $ value ; }
10214	public function setColor ( Color $ pValue ) { $ color = $ pValue -> getIsSupervisor ( ) ? $ pValue -> getSharedComponent ( ) : $ pValue ; if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getColor ( ) -> getStyleArray ( [ 'argb' => $ color -> getARGB ( ) ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> color = $ color ; } return $ this ; }
12614	public function have_required_properties ( ) { return ( ! empty ( $ this -> handle ) && ! empty ( $ this -> relative_path ) && ! empty ( $ this -> filename ) ) ; }
9940	public function calculateColumnWidths ( ) { $ autoSizes = [ ] ; foreach ( $ this -> getColumnDimensions ( ) as $ colDimension ) { if ( $ colDimension -> getAutoSize ( ) ) { $ autoSizes [ $ colDimension -> getColumnIndex ( ) ] = - 1 ; } } if ( ! empty ( $ autoSizes ) ) { $ isMergeCell = [ ] ; foreach ( $ this -> getMergeCells ( ) as $ cells ) { foreach ( Coordinate :: extractAllCellReferencesInRange ( $ cells ) as $ cellReference ) { $ isMergeCell [ $ cellReference ] = true ; } } foreach ( $ this -> getCoordinates ( false ) as $ coordinate ) { $ cell = $ this -> getCell ( $ coordinate , false ) ; if ( $ cell !== null && isset ( $ autoSizes [ $ this -> cellCollection -> getCurrentColumn ( ) ] ) ) { $ isMerged = isset ( $ isMergeCell [ $ this -> cellCollection -> getCurrentCoordinate ( ) ] ) ; $ isMergedButProceed = false ; if ( $ isMerged && $ cell -> isMergeRangeValueCell ( ) ) { $ range = $ cell -> getMergeRange ( ) ; $ rangeBoundaries = Coordinate :: rangeDimension ( $ range ) ; if ( $ rangeBoundaries [ 0 ] == 1 ) { $ isMergedButProceed = true ; } } if ( ! $ isMerged || $ isMergedButProceed ) { $ cellValue = NumberFormat :: toFormattedString ( $ cell -> getCalculatedValue ( ) , $ this -> getParent ( ) -> getCellXfByIndex ( $ cell -> getXfIndex ( ) ) -> getNumberFormat ( ) -> getFormatCode ( ) ) ; $ autoSizes [ $ this -> cellCollection -> getCurrentColumn ( ) ] = max ( ( float ) $ autoSizes [ $ this -> cellCollection -> getCurrentColumn ( ) ] , ( float ) Shared \ Font :: calculateColumnWidth ( $ this -> getParent ( ) -> getCellXfByIndex ( $ cell -> getXfIndex ( ) ) -> getFont ( ) , $ cellValue , $ this -> getParent ( ) -> getCellXfByIndex ( $ cell -> getXfIndex ( ) ) -> getAlignment ( ) -> getTextRotation ( ) , $ this -> getParent ( ) -> getDefaultStyle ( ) -> getFont ( ) ) ) ; } } } foreach ( $ autoSizes as $ columnIndex => $ width ) { if ( $ width == - 1 ) { $ width = $ this -> getDefaultColumnDimension ( ) -> getWidth ( ) ; } $ this -> getColumnDimension ( $ columnIndex ) -> setWidth ( $ width ) ; } } return $ this ; }
5177	public function map ( \ Closure $ callback , $ context = [ ] ) : self { $ collection = new static ( ) ; foreach ( $ this -> props as $ key => $ value ) { $ collection -> add ( $ key , $ callback ( $ value , $ key , $ context ) ) ; } return $ collection ; }
7587	protected function extractFileName ( ) { foreach ( explode ( "\r\n" , $ this -> headers ) as $ header ) { if ( strpos ( $ header , 'filename' ) !== false && strpos ( $ header , 'Content-Disposition' ) !== false ) { $ fileName = substr ( $ header , ( strpos ( $ header , "=" ) + 1 ) ) ; $ this -> setFileName ( $ fileName ) ; break ; } } }
5295	protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ fontFile = realpath ( $ input -> getArgument ( 'font-file' ) ) ; if ( $ fontFile === false || ! file_exists ( $ fontFile ) ) { throw new \ InvalidArgumentException ( '"' . $ input -> getArgument ( 'font-file' ) . '" does not exist' ) ; } $ outputDirectory = realpath ( $ input -> getArgument ( 'output-directory' ) ) ; if ( $ outputDirectory === false || ! file_exists ( $ outputDirectory ) || ! is_dir ( $ outputDirectory ) ) { throw new \ InvalidArgumentException ( '"' . $ input -> getArgument ( 'output-directory' ) . '" is no directory' ) ; } $ generator = new IconFontGenerator ; $ output -> writeln ( 'reading font file from "' . $ fontFile . '" ...' ) ; $ generator -> generateFromFont ( new Font ( array ( ) , file_get_contents ( $ fontFile ) ) ) ; $ output -> writeln ( 'writing SVG files to "' . $ outputDirectory . '" ...' ) ; $ generator -> saveGlyphsToDir ( $ outputDirectory ) ; $ output -> getFormatter ( ) -> setStyle ( 'success' , new OutputFormatterStyle ( null , null , array ( 'bold' , 'reverse' ) ) ) ; $ output -> writeln ( '<success>created SVG files successfully</success>' ) ; }
10110	private function writeSheetLayout ( ) { if ( ! $ this -> phpSheet -> isTabColorSet ( ) ) { return ; } $ recordData = pack ( 'vvVVVvv' , 0x0862 , 0x0000 , 0x00000000 , 0x00000000 , 0x00000014 , $ this -> colors [ $ this -> phpSheet -> getTabColor ( ) -> getRGB ( ) ] , 0x0000 ) ; $ length = strlen ( $ recordData ) ; $ record = 0x0862 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ this -> append ( $ header . $ recordData ) ; }
8431	public function start ( ) { Loop :: run ( function ( ) { $ this -> logger -> info ( sprintf ( "RPQ is now started, and is listening for new jobs every %d ms" , $ this -> config [ 'poll_interval' ] ) , [ 'queue' => $ this -> queue -> getName ( ) ] ) ; $ this -> setIsRunning ( false ) ; Loop :: repeat ( $ this -> config [ 'poll_interval' ] , function ( $ watcherId , $ callback ) { if ( ! $ this -> isRunning ) { return ; } $ this -> queue -> rescheduleJobs ( ) ; if ( count ( $ this -> processes ) === $ this -> config [ 'max_jobs' ] ) { return ; } $ job = $ this -> queue -> pop ( ) ; if ( $ job !== null ) { $ command = sprintf ( 'exec %s %s --jobId=%s --name=%s' , ( $ this -> config [ 'process' ] [ 'script' ] ?? $ _SERVER [ "SCRIPT_FILENAME" ] ) , $ this -> config [ 'process' ] [ 'command' ] , $ job -> getId ( ) , $ this -> queue -> getName ( ) ) ; if ( $ this -> config [ 'process' ] [ 'config' ] === true ) { $ command .= " --config={$this->args['configFile']}" ; } $ process = new Process ( $ command ) ; $ process -> start ( ) ; $ pid = yield $ process -> getPid ( ) ; $ this -> logger -> info ( 'Started worker' , [ 'pid' => $ pid , 'command' => $ command , 'id' => $ job -> getId ( ) , 'queue' => $ this -> queue -> getName ( ) ] ) ; $ this -> processes [ $ pid ] = [ 'process' => $ process , 'id' => $ job -> getId ( ) ] ; $ stream = $ process -> getStdout ( ) ; while ( $ chunk = yield $ stream -> read ( ) ) { $ this -> logger -> info ( $ chunk , [ 'pid' => $ pid , 'jobId' => $ job -> getId ( ) , 'queue' => $ this -> queue -> getName ( ) ] ) ; } $ code = yield $ process -> join ( ) ; $ this -> jobHandler -> exit ( $ job -> getId ( ) , $ pid , $ code , false , $ this -> config [ 'failed_job_backoff_time' ] ) ; unset ( $ this -> processes [ $ pid ] ) ; } } ) ; $ this -> registerSignals ( ) ; } ) ; }
10672	private static function addSegmentsToPath ( $ path , $ segments ) { $ segments = Arr :: toArray ( $ segments ) ; if ( count ( $ segments ) > 0 ) { $ path .= '/' . implode ( '/' , $ segments ) ; } return $ path ; }
1323	private function encodeAppAuthorization ( Consumer $ consumer ) { $ key = rawurlencode ( $ consumer -> key ) ; $ secret = rawurlencode ( $ consumer -> secret ) ; return base64_encode ( $ key . ':' . $ secret ) ; }
1293	private function getTokenFromResponse ( array $ data ) : string { $ url = $ data [ 'nextSyncUrl' ] ?? $ data [ 'nextPageUrl' ] ; $ queryValues = [ ] ; \ parse_str ( \ parse_url ( $ url , \ PHP_URL_QUERY ) , $ queryValues ) ; return $ queryValues [ 'sync_token' ] ; }
11584	public function exec ( $ calcId ) { $ result = [ ] ; $ bonusPercent = Cfg :: TEAM_BONUS_EU_PERCENT ; $ dwnlCompress = $ this -> daoBonDwnl -> getByCalcId ( $ calcId ) ; $ dwnlCurrent = $ this -> daoDwnl -> get ( ) ; $ mapDwnlById = $ this -> hlpDwnlTree -> mapById ( $ dwnlCompress , EBonDwnl :: A_CUST_REF ) ; $ mapCustById = $ this -> hlpDwnlTree -> mapById ( $ dwnlCurrent , ECustomer :: A_CUSTOMER_REF ) ; foreach ( $ mapDwnlById as $ custId => $ custDwnl ) { $ custData = $ mapCustById [ $ custId ] ; $ custMlmId = $ custData -> getMlmId ( ) ; $ pv = $ custDwnl -> getPv ( ) ; $ parentId = $ custDwnl -> getParentRef ( ) ; $ parentDwnl = $ mapDwnlById [ $ parentId ] ; $ parentData = $ mapCustById [ $ parentId ] ; $ parentMlmId = $ parentData -> getMlmId ( ) ; $ scheme = $ this -> hlpScheme -> getSchemeByCustomer ( $ parentData ) ; if ( $ scheme == Cfg :: SCHEMA_EU ) { $ pvParent = $ parentDwnl -> getPv ( ) ; if ( $ pvParent > ( Cfg :: PV_QUALIFICATION_LEVEL_EU - Cfg :: DEF_ZERO ) ) { $ bonus = $ this -> hlpFormat -> roundBonus ( $ pv * $ bonusPercent ) ; if ( $ bonus > Cfg :: DEF_ZERO ) { $ entry = new DBonus ( ) ; $ entry -> setCustomerRef ( $ parentId ) ; $ entry -> setDonatorRef ( $ custId ) ; $ entry -> setValue ( $ bonus ) ; $ result [ ] = $ entry ; } $ this -> logger -> debug ( "parent #$parentId (ref. #$parentMlmId) has '$bonus' as EU Team Bonus from downline customer #$custId (ref. #$custMlmId )." ) ; } else { $ this -> logger -> debug ( "parent #$parentId (ref. #$parentMlmId) does not qualified t oget EU Team Bonus from downline customer #$custId (ref. #$custMlmId )." ) ; } } else { $ this -> logger -> debug ( "Parent #$parentId (ref. #$parentMlmId) has incompatible scheme '$scheme' for EU Team Bonus." ) ; } } unset ( $ mapCustById ) ; unset ( $ mapDwnlById ) ; return $ result ; }
10592	public function display ( $ level = 0 ) { $ value = $ this -> getContent ( ) ; if ( null === $ value ) { $ value = 'null' ; } elseif ( is_object ( $ value ) ) { $ value = get_class ( $ value ) ; } elseif ( is_array ( $ value ) ) { $ value = 'Array' ; } $ ret = str_repeat ( ' ' , $ level * 4 ) . $ value . "\n" ; $ children = $ this -> getChildren ( ) ; foreach ( $ children as $ child ) { $ ret .= $ child -> display ( $ level + 1 ) ; } return $ ret ; }
12215	protected function compileConfiguration ( Traversable $ source , string $ target , CompilerContext $ context ) { $ compiler = new StandardCompiler ( ) ; $ compiler -> setSource ( $ source ) ; $ compiler -> setTarget ( $ target ) ; $ compiler -> compile ( ) ; }
1519	public function addToRelationship ( StoreInterface $ store , UpdateRelationship $ request ) { $ result = $ this -> transaction ( function ( ) use ( $ store , $ request ) { return $ this -> doAddToRelationship ( $ store , $ request ) ; } ) ; if ( $ this -> isResponse ( $ result ) ) { return $ result ; } return $ this -> reply ( ) -> noContent ( ) ; }
7317	public function toJD ( $ scale = null ) { if ( $ scale ) { return bcadd ( ( string ) $ this -> jd , ( string ) $ this -> dayFrac , $ scale ) ; } else { return $ this -> jd + $ this -> dayFrac ; } }
8815	public function get ( $ key = null , $ filter = false ) { if ( is_null ( $ key ) ) { return $ _GET ; } $ value = ( isset ( $ _GET [ $ key ] ) ? $ _GET [ $ key ] : null ) ; return $ this -> filter ( $ value , $ filter ) ; }
9672	private function writeBorderPr ( XMLWriter $ objWriter , $ pName , Border $ pBorder ) { if ( $ pBorder -> getBorderStyle ( ) != Border :: BORDER_NONE ) { $ objWriter -> startElement ( $ pName ) ; $ objWriter -> writeAttribute ( 'style' , $ pBorder -> getBorderStyle ( ) ) ; $ objWriter -> startElement ( 'color' ) ; $ objWriter -> writeAttribute ( 'rgb' , $ pBorder -> getColor ( ) -> getARGB ( ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; } }
1164	protected function throwValidationException ( $ result , $ validator ) { $ response = new JsonResponse ( $ result , 200 ) ; if ( $ result !== true && class_exists ( ValidationException :: class ) ) { throw new ValidationException ( $ validator , $ response ) ; } throw new HttpResponseException ( $ response ) ; }
8864	public function augmentSQL ( SQLQuery & $ query ) { $ stage = Versioned :: current_stage ( ) ; if ( $ stage == 'Live' || ! Permission :: check ( "VIEW_DRAFT_CONTENT" ) ) { $ query -> addWhere ( "PublishDate < '" . Convert :: raw2sql ( SS_Datetime :: now ( ) ) . "'" ) ; } }
12411	public function lists ( $ begin , $ count ) { $ params = [ 'begin' => intval ( $ begin ) , 'count' => intval ( $ count ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_GET_LIST , $ params ] ) ; }
5970	public function accounts ( ) { if ( ! $ this -> accounts instanceof AccountsController ) { $ this -> accounts = new AccountsController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> accounts -> setLogger ( $ this -> logger ) ; } return $ this -> accounts ; }
6973	private function buildFieldValue ( ClassMetadata $ metadata , $ propertyPath , $ value ) { $ type = $ metadata -> getTypeOfField ( $ propertyPath ) ; switch ( $ type ) { case 'smallint' : case 'integer' : case 'bigint' : if ( ! is_int ( $ value ) ) { throw new \ Exception ( 'Expected integer.' ) ; } return intval ( $ value ) ; case 'boolean' : if ( ! is_bool ( $ value ) ) { throw new \ Exception ( 'Expected boolean.' ) ; } return ( bool ) $ value ; case 'float' : case 'double' : case 'decimal' : if ( ! is_numeric ( $ value ) ) { throw new \ Exception ( 'Expected float.' ) ; } return floatval ( $ value ) ; case 'datetime' : return new \ DateTime ( $ value ) ; case 'string' : return ( string ) $ value ; } throw new \ Exception ( "Unsupported field type '$type' for path '$propertyPath'." ) ; }
3982	private function extractUserRights ( TokenInterface $ token ) { $ beUser = $ token -> getUser ( ) ; if ( ! ( $ beUser instanceof BackendUser ) ) { return [ ] ; } $ allowedModules = $ beUser -> modules ; switch ( true ) { case \ is_string ( $ allowedModules ) : $ allowedModules = unserialize ( $ allowedModules , [ 'allowed_classes' => false ] ) ; break ; case null === $ allowedModules : $ allowedModules = [ ] ; break ; default : } return array_flip ( $ allowedModules ) ; }
786	public function scenarios ( ) { $ scenarios = [ self :: SCENARIO_DEFAULT => [ ] ] ; foreach ( $ this -> getValidators ( ) as $ validator ) { foreach ( $ validator -> on as $ scenario ) { $ scenarios [ $ scenario ] = [ ] ; } foreach ( $ validator -> except as $ scenario ) { $ scenarios [ $ scenario ] = [ ] ; } } $ names = array_keys ( $ scenarios ) ; foreach ( $ this -> getValidators ( ) as $ validator ) { if ( empty ( $ validator -> on ) && empty ( $ validator -> except ) ) { foreach ( $ names as $ name ) { foreach ( $ validator -> attributes as $ attribute ) { $ scenarios [ $ name ] [ $ attribute ] = true ; } } } elseif ( empty ( $ validator -> on ) ) { foreach ( $ names as $ name ) { if ( ! in_array ( $ name , $ validator -> except , true ) ) { foreach ( $ validator -> attributes as $ attribute ) { $ scenarios [ $ name ] [ $ attribute ] = true ; } } } } else { foreach ( $ validator -> on as $ name ) { foreach ( $ validator -> attributes as $ attribute ) { $ scenarios [ $ name ] [ $ attribute ] = true ; } } } } foreach ( $ scenarios as $ scenario => $ attributes ) { if ( ! empty ( $ attributes ) ) { $ scenarios [ $ scenario ] = array_keys ( $ attributes ) ; } } return $ scenarios ; }
1566	public function substituteBindings ( StoreInterface $ store ) : void { $ this -> resourceId = $ this -> getResourceId ( ) ? : false ; $ this -> processId = $ this -> getProcessId ( ) ? : false ; if ( $ this -> resourceId ) { $ this -> route -> setParameter ( ResourceRegistrar :: PARAM_RESOURCE_ID , $ store -> findOrFail ( $ this -> getResourceType ( ) , $ this -> resourceId ) ) ; } if ( $ this -> processId ) { $ this -> route -> setParameter ( ResourceRegistrar :: PARAM_PROCESS_ID , $ store -> findOrFail ( $ this -> getProcessType ( ) , $ this -> processId ) ) ; } }
3878	public function addChild ( $ child ) { if ( ! \ is_array ( $ child ) ) { throw new \ RuntimeException ( 'Error Processing sub filter: ' . var_export ( $ child , true ) , 1 ) ; } switch ( strtoupper ( $ child [ 'operation' ] ) ) { case '=' : case '>' : case '<' : return $ this -> getFilterForComparingOperator ( $ child ) ; case 'IN' : return $ this -> getFilterForInList ( $ child ) ; case 'LIKE' : return $ this -> getFilterForLike ( $ child ) ; default : } throw new \ RuntimeException ( 'Error processing filter array ' . var_export ( $ child , true ) , 1 ) ; }
3258	public function scopeFindByUser ( $ query , $ userId , $ statusCode = null ) { if ( ! empty ( $ status ) ) { $ query = $ query -> whereStatus ( $ status ) ; } return $ query -> whereUser ( $ userId ) -> get ( ) ; }
355	public function prepare ( $ forcePrepare = false ) { if ( $ forcePrepare || $ this -> _models === null ) { $ this -> _models = $ this -> prepareModels ( ) ; } if ( $ forcePrepare || $ this -> _keys === null ) { $ this -> _keys = $ this -> prepareKeys ( $ this -> _models ) ; } }
6487	protected function createHeadersFromSuperglobals ( array $ server ) : HttpHeaders { $ headers = new HttpHeaders ( ) ; foreach ( $ server as $ name => $ values ) { $ containsMultipleValues = isset ( self :: $ headersThatPermitMultipleValues [ $ name ] ) && count ( $ explodedValues = preg_split ( '/,(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/' , $ values ) ) > 1 ; if ( $ containsMultipleValues ) { foreach ( $ explodedValues as $ value ) { $ this -> addHeaderValue ( $ headers , $ name , $ value , true ) ; } } else { $ this -> addHeaderValue ( $ headers , $ name , $ values , false ) ; } } return $ headers ; }
1185	public function resolver ( $ field ) { return function ( $ translator , $ data , $ rules , $ messages , $ customAttributes ) use ( $ field ) { return $ this -> resolve ( $ translator , $ data , $ rules , $ messages , $ customAttributes , $ field ) ; } ; }
1854	public static function findCurrentByPid ( $ intPid , $ intStart , $ intEnd , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ intStart = ( int ) $ intStart ; $ intEnd = ( int ) $ intEnd ; $ arrColumns = array ( "$t.pid=? AND (($t.startTime>=$intStart AND $t.startTime<=$intEnd) OR ($t.endTime>=$intStart AND $t.endTime<=$intEnd) OR ($t.startTime<=$intStart AND $t.endTime>=$intEnd) OR ($t.recurring='1' AND ($t.recurrences=0 OR $t.repeatEnd>=$intStart) AND $t.startTime<=$intEnd))" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.startTime" ; } return static :: findBy ( $ arrColumns , $ intPid , $ arrOptions ) ; }
823	private function getPreviousUnsetCall ( Tokens $ tokens , $ index ) { $ previousUnsetSemicolon = $ tokens -> getPrevMeaningfulToken ( $ index ) ; if ( null === $ previousUnsetSemicolon ) { return $ index ; } if ( ! $ tokens [ $ previousUnsetSemicolon ] -> equals ( ';' ) ) { return $ previousUnsetSemicolon ; } $ previousUnsetBraceEnd = $ tokens -> getPrevMeaningfulToken ( $ previousUnsetSemicolon ) ; if ( null === $ previousUnsetBraceEnd ) { return $ index ; } if ( ! $ tokens [ $ previousUnsetBraceEnd ] -> equals ( ')' ) ) { return $ previousUnsetBraceEnd ; } $ previousUnsetBraceStart = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ previousUnsetBraceEnd ) ; $ previousUnset = $ tokens -> getPrevMeaningfulToken ( $ previousUnsetBraceStart ) ; if ( null === $ previousUnset ) { return $ index ; } if ( ! $ tokens [ $ previousUnset ] -> isGivenKind ( T_UNSET ) ) { return $ previousUnset ; } return [ $ previousUnset , $ previousUnsetBraceStart , $ previousUnsetBraceEnd , $ previousUnsetSemicolon , ] ; }
12765	public function addByHttpCode ( int $ code ) : self { $ serverProtocol = filter_input ( \ INPUT_SERVER , 'SERVER_PROTOCOL' , \ FILTER_SANITIZE_STRING ) ; $ protocol = ! empty ( $ serverProtocol ) ? $ serverProtocol : 'HTTP/1.1' ; $ sHeader = "{$protocol} {$code} " . self :: getHTTPExplanationByCode ( $ code ) ; return $ this -> add ( $ sHeader ) ; }
7831	public function getSpacedCore ( ) { $ left = $ this -> getSpacesByCore ( ) ; $ right = $ this -> getSpacesByCore ( true ) ; return $ left . $ this -> core . $ right ; }
5797	public static function getRouteName ( bool $ isAdmin = true , string $ routePrefix = null , string $ routeType = null , string $ requestMethod = null ) : string { $ routeName = '' ; if ( $ isAdmin ) { $ routeName .= ROUTEPREFIX_ADMIN ; } if ( $ routePrefix !== null ) { $ routeName .= '.' . $ routePrefix ; } if ( $ requestMethod !== null ) { $ validActionMethods = [ 'put' , 'post' ] ; if ( ! in_array ( $ requestMethod , $ validActionMethods ) ) { throw new \ Exception ( "Invalid request method $requestMethod. Only post and put accepted in route names." ) ; } $ routeName .= '.' . $ requestMethod ; } if ( $ routeType !== null ) { if ( ! in_array ( $ routeType , self :: VALID_ROUTE_TYPES ) ) { throw new \ Exception ( "Invalid route type $routeType" ) ; } $ routeName .= '.' . $ routeType ; } return $ routeName ; }
12512	public function login ( ) { if ( $ this -> validate ( ) ) { return \ Yii :: $ app -> getUser ( ) -> login ( $ this -> user , $ this -> rememberMe ? $ this -> module -> rememberFor : 0 ) ; } else { return false ; } }
11494	public static function log ( $ message , $ type = DataLogger :: INFO ) { if ( null === self :: $ logger ) { return ; } if ( ! method_exists ( self :: $ logger , $ type ) ) { $ exceptionMessage = sprintf ( 'Logger does not support the %s method.' , $ type ) ; throw new \ InvalidArgumentException ( $ exceptionMessage ) ; } self :: $ logger -> $ type ( $ message ) ; }
8432	public function getDsn ( array $ info ) : string { $ dsn = 'pgsql:host=' ; $ dsn .= ( isset ( $ info [ 'host' ] ) === true ? $ info [ 'host' ] : 'localhost' ) . ';' ; if ( isset ( $ info [ 'port' ] ) === true ) { $ dsn .= 'port=' . $ info [ 'port' ] . ';' ; } $ dsn .= 'dbname=' . $ info [ 'name' ] . ';' ; return $ dsn ; }
9462	private function getEventMap ( ) { return [ WatcherInterface :: CREATE_EVENT => FilesystemEvent :: CREATE , WatcherInterface :: MODIFY_EVENT => FilesystemEvent :: MODIFY , WatcherInterface :: DELETE_EVENT => FilesystemEvent :: DELETE , WatcherInterface :: ALL_EVENT => FilesystemEvent :: ALL ] ; }
12122	public function setLastModified ( Request $ request , \ DateTime $ lastModified ) { $ this -> cache -> save ( $ this -> getCacheKeyRequest ( sha1 ( $ request -> getUri ( ) ) , 'lastmodified' ) , $ lastModified -> format ( 'r' ) ) ; foreach ( $ this -> itemIds as $ itemId => $ bool ) { $ key = $ this -> getCacheKeyItem ( $ itemId , 'uri' ) ; $ urisForItem = Option :: fromValue ( $ this -> cache -> fetch ( $ key ) , false ) -> getOrElse ( array ( ) ) ; $ urisForItem [ $ request -> getUri ( ) ] = $ bool ; $ this -> cache -> save ( $ key , $ urisForItem ) ; Option :: fromValue ( $ this -> logger ) -> map ( function ( LoggerInterface $ logger ) use ( $ request , $ itemId ) { $ logger -> debug ( sprintf ( '[ContentfulBundle:RequestLastModifiedCache] "%s" is used on "%s".' , $ itemId , $ request -> getUri ( ) ) ) ; } ) ; } }
5011	public function getLogger ( ) : LoggerInterface { if ( ! $ this -> logger ) { $ logger = new class implements LoggerInterface { public function emerg ( $ message , $ extra = [ ] ) : void { } public function alert ( $ message , $ extra = [ ] ) : void { } public function crit ( $ message , $ extra = [ ] ) : void { } public function err ( $ message , $ extra = [ ] ) : void { } public function warn ( $ message , $ extra = [ ] ) : void { } public function notice ( $ message , $ extra = [ ] ) : void { } public function info ( $ message , $ extra = [ ] ) : void { } public function debug ( $ message , $ extra = [ ] ) : void { } } ; $ this -> setLogger ( $ logger ) ; } return $ this -> logger ; }
6708	protected function getReaderFactory ( ) { if ( ! $ this -> readerFactory ) { $ this -> readerFactory = new ReaderFactory ( [ new Json ( ) , new Xml ( ) , ] ) ; } return $ this -> readerFactory ; }
9962	public function insertNewRowBefore ( $ pBefore , $ pNumRows = 1 ) { if ( $ pBefore >= 1 ) { $ objReferenceHelper = ReferenceHelper :: getInstance ( ) ; $ objReferenceHelper -> insertNewBefore ( 'A' . $ pBefore , 0 , $ pNumRows , $ this ) ; } else { throw new Exception ( 'Rows can only be inserted before at least row 1.' ) ; } return $ this ; }
11809	protected function fillRelationConfig ( & $ config , $ otherObject ) { if ( isset ( $ config [ 'parent_object_id' ] ) ) { $ config [ 'child_object_id' ] = $ otherObject ; } elseif ( isset ( $ config [ 'child_object_id' ] ) ) { $ config [ 'parent_object_id' ] = $ otherObject ; } }
644	public function addDefaultValue ( $ name , $ table , $ column , $ value ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> addDefaultValue ( $ name , $ table , $ column , $ value ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
237	protected function setTableMetadata ( $ name , $ type , $ data ) { $ this -> _tableMetadata [ $ this -> getRawTableName ( $ name ) ] [ $ type ] = $ data ; }
8966	public static function exists ( $ currencyCode ) { $ currencyCode = trim ( strtoupper ( $ currencyCode ) ) ; return array_key_exists ( $ currencyCode , self :: $ codes ) ; }
5713	public function updateItemEditForm ( $ form ) { if ( $ this -> owner -> record -> stat ( 'better_buttons_enabled' ) !== true ) { return false ; } Requirements :: css ( BETTER_BUTTONS_DIR . '/css/gridfield_betterbuttons.css' ) ; Requirements :: javascript ( BETTER_BUTTONS_DIR . '/javascript/gridfield_betterbuttons.js' ) ; $ actions = $ this -> owner -> record -> getBetterButtonsActions ( ) ; $ form -> setActions ( $ this -> filterFieldList ( $ form , $ actions ) ) ; if ( $ form -> Fields ( ) -> hasTabSet ( ) ) { $ form -> Fields ( ) -> findOrMakeTab ( 'Root' ) -> setTemplate ( TabSet :: class ) ; $ form -> addExtraClass ( 'cms-tabset' ) ; } $ utils = $ this -> owner -> record -> getBetterButtonsUtils ( ) ; $ form -> Utils = $ this -> filterFieldList ( $ form , $ utils ) ; $ form -> setTemplate ( [ 'type' => 'Includes' , 'BetterButtons_EditForm' , ] ) ; $ form -> addExtraClass ( 'better-buttons-form' ) ; }
4675	public function addString ( $ content , $ region = "main" , $ sort = 0 ) { $ view = new View ( ) ; $ view -> set ( $ content , [ ] , $ sort , "string" ) ; $ this -> views [ $ region ] [ ] = $ view ; return $ this ; }
12427	public function getAuthorizerOption ( $ authorizerAppId , $ optionName ) { $ params = [ 'component_appid' => $ this -> getAppId ( ) , 'authorizer_appid' => $ authorizerAppId , 'option_name' => $ optionName , ] ; return $ this -> parseJSON ( 'json' , [ self :: GET_AUTHORIZER_OPTION , $ params ] ) ; }
12382	public static function lastMonth ( ) { $ hits_count = self :: interval ( Carbon :: now ( ) -> subMonth ( ) -> firstOfMonth ( ) , Carbon :: now ( ) -> subMonth ( ) -> lastOfMonth ( ) ) ; return $ hits_count ; }
4423	protected function doInteract ( ) { $ siteAccess = $ this -> askForData ( 'site-access-name' , 'Enter the name of the Netgen Admin UI siteaccess' , 'ngadminui' , function ( $ siteaccess ) { if ( ! preg_match ( '/^[a-z][a-z0-9_]*$/' , $ siteaccess ) ) { throw new InvalidArgumentException ( 'Siteaccess name is not valid. It must start with a letter, followed by any combination of letters, numbers and underscore.' ) ; } $ existingSiteAccesses = $ this -> getContainer ( ) -> getParameter ( 'ezpublish.siteaccess.list' ) ; if ( in_array ( $ siteaccess , $ existingSiteAccesses , true ) ) { throw new InvalidArgumentException ( sprintf ( 'Siteaccess "%s" already exists.' , $ siteaccess ) ) ; } return $ siteaccess ; } ) ; $ this -> output -> writeln ( '' ) ; $ languageCode = $ this -> askForData ( 'language-code' , 'Enter the language code in which the Netgen Admin UI will be translated' , 'eng-GB' , function ( $ languageCode ) { $ languageService = $ this -> getContainer ( ) -> get ( 'ezpublish.api.repository' ) -> getContentLanguageService ( ) ; try { $ languageService -> loadLanguage ( $ languageCode ) ; } catch ( NotFoundException $ e ) { throw new InvalidArgumentException ( sprintf ( 'Language code "%s" does not exist.' , $ languageCode ) ) ; } return $ languageCode ; } ) ; $ this -> output -> writeln ( '' ) ; $ availableGroups = array_keys ( $ this -> getContainer ( ) -> getParameter ( 'ezpublish.siteaccess.groups' ) ) ; $ availableGroups [ ] = 'default' ; $ siteAccessGroup = $ this -> askForChoiceData ( 'site-access-group' , 'Enter the siteaccess group name on which the Netgen Admin UI configuration will be based. This is usually the name of your frontend siteaccess group' , $ availableGroups , current ( $ availableGroups ) ) ; $ this -> writeSection ( 'Summary before installation' ) ; $ this -> output -> writeln ( array ( 'You are going to generate legacy <info>' . $ siteAccess . '</info> siteaccess with <info>' . $ languageCode . '</info> language code based on <info>' . $ siteAccessGroup . '</info> siteaccess group.' , '' , ) ) ; if ( ! $ this -> questionHelper -> ask ( $ this -> input , $ this -> output , $ this -> getConfirmationQuestion ( 'Do you confirm installation (answering <comment>no</comment> will restart the process)' , true ) ) ) { $ this -> output -> writeln ( '' ) ; return false ; } return true ; }
11332	public function setAttributes ( $ value ) { $ this -> _attributes = $ value ; if ( $ this -> model ) { $ this -> _model -> attributes = $ value ; } }
4107	public function showHints ( ) { if ( is_null ( $ this -> showHints ) ) { $ this -> showHints = false ; if ( Mage :: helper ( 'core' ) -> isDevAllowed ( ) ) { if ( Mage :: getSingleton ( 'core/cookie' ) -> get ( 'ath' ) || Mage :: app ( ) -> getRequest ( ) -> get ( 'ath' ) ) { $ this -> showHints = true ; } } } return $ this -> showHints ; }
11274	public function install ( ) : Migrate { Whois :: print ( $ this -> getNotify ( ) ) ; $ this -> exists ( ) || $ this -> migrationRepository -> createRepository ( ) ; return $ this ; }
8869	public function attach ( Runner $ runner ) { if ( $ this -> runners -> contains ( $ runner ) ) { throw new LogicException ( 'Can\'t attach already attached runner.' ) ; } $ this -> runners -> attach ( $ runner ) ; return $ this ; }
11142	public function getAttributes ( $ props ) { $ attr = '' ; if ( isset ( $ props [ 'primaryKey' ] ) ) { $ attr .= 'NOT NULL AUTO_INCREMENT ' ; } if ( isset ( $ props [ 'defaultValue' ] ) ) { $ attr .= "DEFAULT '" . $ props [ 'defaultValue' ] . "'" ; } return $ attr ; }
796	public function getAnnotationEnd ( $ index ) { $ currentIndex = null ; if ( isset ( $ this [ $ index + 2 ] ) ) { if ( $ this [ $ index + 2 ] -> isType ( DocLexer :: T_OPEN_PARENTHESIS ) ) { $ currentIndex = $ index + 2 ; } elseif ( isset ( $ this [ $ index + 3 ] ) && $ this [ $ index + 2 ] -> isType ( DocLexer :: T_NONE ) && $ this [ $ index + 3 ] -> isType ( DocLexer :: T_OPEN_PARENTHESIS ) && Preg :: match ( '/^(\R\s*\*\s*)*\s*$/' , $ this [ $ index + 2 ] -> getContent ( ) ) ) { $ currentIndex = $ index + 3 ; } } if ( null !== $ currentIndex ) { $ level = 0 ; for ( $ max = \ count ( $ this ) ; $ currentIndex < $ max ; ++ $ currentIndex ) { if ( $ this [ $ currentIndex ] -> isType ( DocLexer :: T_OPEN_PARENTHESIS ) ) { ++ $ level ; } elseif ( $ this [ $ currentIndex ] -> isType ( DocLexer :: T_CLOSE_PARENTHESIS ) ) { -- $ level ; } if ( 0 === $ level ) { return $ currentIndex ; } } return null ; } return $ index + 1 ; }
11400	public function fromData ( $ data ) { $ this -> fromdata = $ data ; $ resource = fopen ( 'php://memory' , 'r+' ) ; fwrite ( $ resource , $ data ) ; rewind ( $ resource ) ; $ this -> setResource ( $ resource ) ; return $ this ; }
6071	public function uploadFileChunked ( $ fileData , $ name , $ chunk , $ chunks , $ fileId , $ categoryId , $ title = null ) { $ parameters = [ 'query' => [ 'name' => $ name , 'chunk' => $ chunk , 'chunks' => $ chunks , 'fileId' => $ fileId , 'categoryId' => $ categoryId , 'title' => $ title , ] , 'multipart' => [ [ 'name' => 'file' , 'contents' => \ GuzzleHttp \ Psr7 \ stream_for ( $ fileData ) , 'filename' => $ name , ] , ] , 'headers' => null , ] ; $ result = $ this -> post ( 'v1/media.json' , $ parameters ) ; return $ result ; }
5847	public function sanitizeFileName ( $ fileName , \ TYPO3 \ CMS \ Core \ Resource \ Folder $ folder ) { $ slotArguments = func_get_args ( ) ; array_pop ( $ slotArguments ) ; $ storageConfiguration = $ folder -> getStorage ( ) -> getConfiguration ( ) ; $ storageRecord = $ folder -> getStorage ( ) -> getStorageRecord ( ) ; if ( $ storageRecord [ 'driver' ] !== 'Local' ) { return ; } $ targetDirectory = $ storageConfiguration [ 'pathType' ] === 'relative' ? PATH_site : '' ; $ targetDirectory .= rtrim ( rtrim ( $ storageConfiguration [ 'basePath' ] , '/' ) . $ folder -> getIdentifier ( ) , '/' ) ; $ processedFileName = static :: $ imageResizer -> getProcessedFileName ( $ targetDirectory . '/' . $ fileName , $ GLOBALS [ 'BE_USER' ] ) ; if ( $ processedFileName !== null ) { static :: $ originalFileName = $ fileName ; $ slotArguments [ 0 ] = PathUtility :: basename ( $ processedFileName ) ; return $ slotArguments ; } }
9517	public function recreate ( $ file ) { if ( is_file ( $ file ) ) { return ; } $ virtual = $ tables = $ indexes = array ( ) ; if ( $ result = $ this -> query ( 'SELECT type, name, sql FROM sqlite_master' ) ) { while ( list ( $ type , $ name , $ sql ) = $ this -> fetch ( $ result ) ) { if ( ! empty ( $ sql ) ) { switch ( $ type ) { case 'table' : $ tables [ $ name ] = $ sql ; break ; case 'index' : $ indexes [ ] = $ sql ; break ; } } } $ this -> close ( $ result ) ; } foreach ( $ tables as $ name => $ sql ) { if ( strpos ( $ sql , 'VIRTUAL TABLE' ) ) { $ virtual [ ] = $ name ; } } foreach ( $ virtual as $ table ) { foreach ( $ tables as $ name => $ sql ) { if ( strpos ( $ name , "{$table}_" ) === 0 ) { unset ( $ tables [ $ name ] ) ; } } } $ db = new self ( $ file ) ; $ this -> exec ( 'ATTACH DATABASE ' . $ this -> dbEscape ( $ file ) . ' AS recreate' ) ; foreach ( $ tables as $ table => $ sql ) { $ db -> connection ( ) -> exec ( $ sql ) ; if ( $ fields = $ this -> row ( 'SELECT * FROM ' . $ table . ' LIMIT 1' , '' , 'assoc' ) ) { $ fields = implode ( ', ' , array_keys ( $ fields ) ) ; $ this -> exec ( "INSERT INTO recreate.{$table} ({$fields}) SELECT * FROM {$table}" ) ; } } foreach ( $ indexes as $ sql ) { $ db -> connection ( ) -> exec ( $ sql ) ; } $ db -> connection ( ) -> close ( ) ; }
3467	public function patch ( string $ route , callable $ controller ) : void { $ this -> register ( $ controller , Route :: patch ( $ route ) ) ; }
1067	private function findConflictsBetweenSubSelectionSets ( ValidationContext $ context , $ areMutuallyExclusive , $ parentType1 , SelectionSetNode $ selectionSet1 , $ parentType2 , SelectionSetNode $ selectionSet2 ) { $ conflicts = [ ] ; [ $ fieldMap1 , $ fragmentNames1 ] = $ this -> getFieldsAndFragmentNames ( $ context , $ parentType1 , $ selectionSet1 ) ; [ $ fieldMap2 , $ fragmentNames2 ] = $ this -> getFieldsAndFragmentNames ( $ context , $ parentType2 , $ selectionSet2 ) ; $ this -> collectConflictsBetween ( $ context , $ conflicts , $ areMutuallyExclusive , $ fieldMap1 , $ fieldMap2 ) ; $ fragmentNames2Length = count ( $ fragmentNames2 ) ; if ( $ fragmentNames2Length !== 0 ) { $ comparedFragments = [ ] ; for ( $ j = 0 ; $ j < $ fragmentNames2Length ; $ j ++ ) { $ this -> collectConflictsBetweenFieldsAndFragment ( $ context , $ conflicts , $ comparedFragments , $ areMutuallyExclusive , $ fieldMap1 , $ fragmentNames2 [ $ j ] ) ; } } $ fragmentNames1Length = count ( $ fragmentNames1 ) ; if ( $ fragmentNames1Length !== 0 ) { $ comparedFragments = [ ] ; for ( $ i = 0 ; $ i < $ fragmentNames1Length ; $ i ++ ) { $ this -> collectConflictsBetweenFieldsAndFragment ( $ context , $ conflicts , $ comparedFragments , $ areMutuallyExclusive , $ fieldMap2 , $ fragmentNames1 [ $ i ] ) ; } } for ( $ i = 0 ; $ i < $ fragmentNames1Length ; $ i ++ ) { for ( $ j = 0 ; $ j < $ fragmentNames2Length ; $ j ++ ) { $ this -> collectConflictsBetweenFragments ( $ context , $ conflicts , $ areMutuallyExclusive , $ fragmentNames1 [ $ i ] , $ fragmentNames2 [ $ j ] ) ; } } return $ conflicts ; }
9995	private function writeComment ( Worksheet $ pSheet , $ coordinate ) { $ result = '' ; if ( ! $ this -> isPdf && isset ( $ pSheet -> getComments ( ) [ $ coordinate ] ) ) { $ result .= '<a class="comment-indicator"></a>' ; $ result .= '<div class="comment">' . nl2br ( $ pSheet -> getComment ( $ coordinate ) -> getText ( ) -> getPlainText ( ) ) . '</div>' ; $ result .= PHP_EOL ; } return $ result ; }
11778	public function startAction ( Request $ request , Application $ app ) { $ options = array ( "request" => $ request , "configuration_handler" => $ app [ "red_kite_cms.configuration_handler" ] , ) ; return parent :: start ( $ options ) ; }
9866	private function writeProtectedRanges ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { if ( count ( $ pSheet -> getProtectedCells ( ) ) > 0 ) { $ objWriter -> startElement ( 'protectedRanges' ) ; foreach ( $ pSheet -> getProtectedCells ( ) as $ protectedCell => $ passwordHash ) { $ objWriter -> startElement ( 'protectedRange' ) ; $ objWriter -> writeAttribute ( 'name' , 'p' . md5 ( $ protectedCell ) ) ; $ objWriter -> writeAttribute ( 'sqref' , $ protectedCell ) ; if ( ! empty ( $ passwordHash ) ) { $ objWriter -> writeAttribute ( 'password' , $ passwordHash ) ; } $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; } }
7975	public function createSender ( $ domain , $ sender ) { if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; if ( ! $ sender ) throw new BadMethodCallException ( 'Parameter $sender is missing.' ) ; if ( ! is_array ( $ sender ) ) throw new BadMethodCallException ( 'Parameter $sender must be a array. ' . gettype ( $ sender ) . ' given.' ) ; if ( ! array_key_exists ( 'sender' , $ sender ) ) throw new BadMethodCallException ( 'Parameter $sender have key sender (string).' ) ; $ t = array ( ) ; $ t [ 'sender' ] = $ sender [ 'sender' ] ; ( $ sender [ 'relaunch' ] ) ? $ t [ 'relaunch' ] = $ sender [ 'relaunch' ] : $ t [ 'relaunch' ] = '' ; ( $ sender [ 'reason' ] ) ? $ t [ 'reason' ] = $ sender [ 'reason' ] : $ t [ 'reason' ] = '' ; unset ( $ sender ) ; try { $ r = $ this -> post ( 'sms/' . $ domain . '/senders' , array ( 'Content-Type' => 'application/json;charset=UTF-8' ) , json_encode ( $ t ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new SmsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } }
7396	public function execute ( ) { $ addresses = $ this -> addressRepository -> createQueryBuilder ( 'a' ) -> where ( 'a.latitude IS NULL' ) -> orWhere ( 'a.longitude IS NULL' ) -> setMaxResults ( 500 ) -> getQuery ( ) -> getResult ( ) ; foreach ( $ addresses as $ address ) { try { $ this -> updateLatLong ( $ address ) ; } catch ( \ RuntimeException $ e ) { echo "Stopping work -- over the API query limit.\n" ; break ; } $ this -> entityManager -> persist ( $ address ) ; usleep ( self :: MILLISECONDS_PAUSE_BETWEEN_QUERIES ) ; } $ this -> entityManager -> flush ( ) ; }
7890	protected function getDefaultProjectHook ( ) { $ default = $ this -> config -> get ( self :: CONFIG_DEFAULT ) ; return $ this -> config -> get ( sprintf ( self :: CONFIG_PROJECT , $ default ) ) ; }
10255	public function getApartment ( ) { $ types = [ 'Apt.' , 'Apartment' , 'Ste.' , 'Suite' , 'Box' ] ; if ( $ this -> getBool ( true , false ) ) { $ extra = $ this -> getLetter ( ) ; } else { $ extra = $ this -> getInteger ( 1 , 9999 ) ; } $ type = $ this -> fromArray ( $ types ) ; return $ type . ' ' . $ extra ; }
8492	public static function getTotalMemory ( ) { $ wmi = Windows :: getInstance ( ) ; foreach ( $ wmi -> ExecQuery ( "SELECT TotalPhysicalMemory FROM Win32_ComputerSystem" ) as $ mem ) { return $ mem -> TotalPhysicalMemory ; } return NULL ; }
11334	public function getFormattedValue ( ) { if ( $ this -> format instanceof BaseFormat ) { $ formattedValue = $ this -> format -> get ( ) ; } elseif ( is_callable ( $ this -> format ) || ( is_array ( $ this -> format ) && ! empty ( $ this -> format [ 0 ] ) && is_object ( $ this -> format [ 0 ] ) ) ) { $ formattedValue = $ this -> evaluateExpression ( $ this -> format , [ $ this -> value ] ) ; } else { $ formattedValue = $ this -> value ; } if ( is_object ( $ formattedValue ) ) { $ formattedValue = $ formattedValue -> viewLink ; } return $ formattedValue ; }
4295	public function alert ( $ message , $ class = 'danger' , $ dismissible = false ) { array ( $ class , $ dismissible ) ; $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'message' => null , 'class' => 'danger' , 'dismissible' => false , ) , array ( 'class' , 'dismissible' ) ) ; \ extract ( $ args ) ; $ this -> setLogDest ( 'alerts' ) ; $ this -> appendLog ( 'alert' , array ( $ message ) , $ meta ) ; $ this -> setLogDest ( 'auto' ) ; }
1166	protected function parseParameters ( $ parameters ) { $ newParams = [ 'validate_all' => false ] ; if ( isset ( $ parameters [ 0 ] ) ) { $ newParams [ 'validate_all' ] = ( $ parameters [ 0 ] === 'true' ) ? true : false ; } return $ newParams ; }
2978	public function getLicenseByIdentifier ( $ identifier ) { $ key = strtolower ( $ identifier ) ; if ( ! isset ( $ this -> licenses [ $ key ] ) ) { return ; } list ( $ identifier , $ name , $ isOsiApproved , $ isDeprecatedLicenseId ) = $ this -> licenses [ $ key ] ; return array ( $ name , $ isOsiApproved , 'https://spdx.org/licenses/' . $ identifier . '.html#licenseText' , $ isDeprecatedLicenseId , ) ; }
10826	public static function table ( array $ rows , array $ headers = [ ] ) { $ table = new Table ( ) ; $ table -> setRows ( $ rows ) ; if ( count ( $ headers ) > 0 ) { $ table -> setHeaders ( $ headers ) ; } $ output = $ table -> render ( ) ; self :: writeln ( $ output ) ; }
12393	public function onSiteSaved ( SiteSavedEvent $ event ) { $ fs = new Filesystem ( ) ; $ fs -> mirror ( $ this -> configurationHandler -> uploadAssetsDir ( ) , $ this -> configurationHandler -> uploadAssetsDirProduction ( ) ) ; }
6671	public function restart_rating ( $ post_id , $ post , $ update ) { App :: setCurrentID ( 'EFG' ) ; if ( Module :: CustomRatingGrifus ( ) -> getOption ( 'restart-when-add' ) ) { unset ( $ _POST [ 'imdbRating' ] , $ _POST [ 'imdbVotes' ] ) ; if ( App :: main ( ) -> is_after_insert_post ( $ post , $ update ) ) { if ( ! $ this -> model -> get_movie_votes ( $ post_id ) ) { $ votes = $ this -> get_default_votes ( $ post_id ) ; $ this -> set_rating_and_votes ( $ post_id , $ votes ) ; return true ; } } } return false ; }
11313	public static function buildBasestring ( $ method , Url $ url , array $ data ) { $ base = array ( ) ; $ base [ ] = self :: urlEncode ( self :: getNormalizedMethod ( $ method ) ) ; $ base [ ] = self :: urlEncode ( self :: getNormalizedUrl ( $ url ) ) ; $ base [ ] = self :: urlEncode ( self :: getNormalizedParameters ( $ data ) ) ; return implode ( '&' , $ base ) ; }
2042	public static function validateSymlink ( string $ target , string $ link , string $ rootDir ) : void { if ( '' === $ target ) { throw new \ InvalidArgumentException ( 'The symlink target must not be empty.' ) ; } if ( '' === $ link ) { throw new \ InvalidArgumentException ( 'The symlink path must not be empty.' ) ; } if ( false !== strpos ( $ link , '../' ) ) { throw new \ InvalidArgumentException ( 'The symlink path must not be relative.' ) ; } $ fs = new Filesystem ( ) ; if ( $ fs -> exists ( $ rootDir . '/' . $ link ) && ! is_link ( $ rootDir . '/' . $ link ) ) { throw new \ LogicException ( sprintf ( 'The path "%s" exists and is not a symlink.' , $ link ) ) ; } }
5219	public static function castFrom ( $ predicate ) { if ( $ predicate instanceof self ) { return $ predicate ; } elseif ( is_callable ( $ predicate ) ) { return new CallablePredicate ( $ predicate ) ; } throw new \ InvalidArgumentException ( 'Given predicate is neither a callable nor an instance of ' . __CLASS__ ) ; }
409	public function getHostInfo ( ) { if ( $ this -> _hostInfo === null ) { $ secure = $ this -> getIsSecureConnection ( ) ; $ http = $ secure ? 'https' : 'http' ; if ( $ this -> headers -> has ( 'X-Forwarded-Host' ) ) { $ this -> _hostInfo = $ http . '://' . trim ( explode ( ',' , $ this -> headers -> get ( 'X-Forwarded-Host' ) ) [ 0 ] ) ; } elseif ( $ this -> headers -> has ( 'Host' ) ) { $ this -> _hostInfo = $ http . '://' . $ this -> headers -> get ( 'Host' ) ; } elseif ( isset ( $ _SERVER [ 'SERVER_NAME' ] ) ) { $ this -> _hostInfo = $ http . '://' . $ _SERVER [ 'SERVER_NAME' ] ; $ port = $ secure ? $ this -> getSecurePort ( ) : $ this -> getPort ( ) ; if ( ( $ port !== 80 && ! $ secure ) || ( $ port !== 443 && $ secure ) ) { $ this -> _hostInfo .= ':' . $ port ; } } } return $ this -> _hostInfo ; }
3967	protected function getMetaModelByModelPid ( ModelInterface $ model ) { $ metaModel = $ this -> factory -> getMetaModel ( $ this -> factory -> translateIdToMetaModelName ( $ model -> getProperty ( 'pid' ) ) ) ; if ( $ metaModel === null ) { throw new \ InvalidArgumentException ( 'Could not retrieve MetaModel ' . $ model -> getProperty ( 'pid' ) ) ; } return $ metaModel ; }
7454	protected function getFirstTerm ( WP_Post $ post ) { $ taxonomies = $ this -> getTaxonomies ( $ post -> post_type ) ; foreach ( $ taxonomies as $ taxonomy ) { $ post_terms = \ get_the_terms ( $ post , $ taxonomy ) ; if ( ! $ post_terms || \ is_wp_error ( $ post_terms ) ) { continue ; } return $ post_terms [ 0 ] ; } }
9988	public function generateHTMLHeader ( $ pIncludeStyles = false ) { if ( $ this -> spreadsheet === null ) { throw new WriterException ( 'Internal Spreadsheet object not set to an instance of an object.' ) ; } $ properties = $ this -> spreadsheet -> getProperties ( ) ; $ html = '<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">' . PHP_EOL ; $ html .= '<html>' . PHP_EOL ; $ html .= ' <head>' . PHP_EOL ; $ html .= ' <meta http-equiv="Content-Type" content="text/html; charset=utf-8">' . PHP_EOL ; $ html .= ' <meta name="generator" content="PhpSpreadsheet, https://github.com/PHPOffice/PhpSpreadsheet">' . PHP_EOL ; if ( $ properties -> getTitle ( ) > '' ) { $ html .= ' <title>' . htmlspecialchars ( $ properties -> getTitle ( ) ) . '</title>' . PHP_EOL ; } if ( $ properties -> getCreator ( ) > '' ) { $ html .= ' <meta name="author" content="' . htmlspecialchars ( $ properties -> getCreator ( ) ) . '" />' . PHP_EOL ; } if ( $ properties -> getTitle ( ) > '' ) { $ html .= ' <meta name="title" content="' . htmlspecialchars ( $ properties -> getTitle ( ) ) . '" />' . PHP_EOL ; } if ( $ properties -> getDescription ( ) > '' ) { $ html .= ' <meta name="description" content="' . htmlspecialchars ( $ properties -> getDescription ( ) ) . '" />' . PHP_EOL ; } if ( $ properties -> getSubject ( ) > '' ) { $ html .= ' <meta name="subject" content="' . htmlspecialchars ( $ properties -> getSubject ( ) ) . '" />' . PHP_EOL ; } if ( $ properties -> getKeywords ( ) > '' ) { $ html .= ' <meta name="keywords" content="' . htmlspecialchars ( $ properties -> getKeywords ( ) ) . '" />' . PHP_EOL ; } if ( $ properties -> getCategory ( ) > '' ) { $ html .= ' <meta name="category" content="' . htmlspecialchars ( $ properties -> getCategory ( ) ) . '" />' . PHP_EOL ; } if ( $ properties -> getCompany ( ) > '' ) { $ html .= ' <meta name="company" content="' . htmlspecialchars ( $ properties -> getCompany ( ) ) . '" />' . PHP_EOL ; } if ( $ properties -> getManager ( ) > '' ) { $ html .= ' <meta name="manager" content="' . htmlspecialchars ( $ properties -> getManager ( ) ) . '" />' . PHP_EOL ; } if ( $ pIncludeStyles ) { $ html .= $ this -> generateStyles ( true ) ; } $ html .= ' </head>' . PHP_EOL ; $ html .= '' . PHP_EOL ; $ html .= ' <body>' . PHP_EOL ; return $ html ; }
12080	public function updateChild ( $ idParent , FilterRequest $ filters , $ idChild , $ relation ) { $ idParent = $ this -> getRealId ( $ idParent ) ; $ idChild = $ this -> getRealId ( $ idChild ) ; $ resource = $ this -> repository -> updateChild ( $ idParent , $ relation , $ idChild , $ filters -> all ( ) ) ; if ( ! $ resource ) { } return $ this -> success ( $ resource ) ; }
3546	public function create ( $ request ) { $ data = $ request -> all ( ) ; $ user = $ this -> repository -> create ( $ data ) ; $ event_class = "Acoustep\EntrustGui\Events\\" . ucwords ( $ this -> getModelName ( ) ) . 'CreatedEvent' ; $ event = new $ event_class ; $ this -> dispatcher -> fire ( $ event -> setModel ( $ user ) ) ; return $ user ; }
12815	private static function isNullable ( string $ table , string $ column ) : bool { if ( self :: $ nullablesCache === null || ! array_key_exists ( $ table , self :: $ nullablesCache ) ) self :: getNullables ( $ table ) ; return array_key_exists ( $ column , self :: $ nullablesCache [ $ table ] ) ; }
11409	public function showAction ( Request $ request , Application $ app ) { $ options = array ( 'twig' => $ app [ "twig" ] , 'template_assets' => $ app [ "red_kite_cms.template_assets" ] , "configuration_handler" => $ app [ "red_kite_cms.configuration_handler" ] , "plugin_manager" => $ app [ "red_kite_cms.plugin_manager" ] , ) ; return parent :: show ( $ options ) ; }
6397	private function addEvolution ( $ decoded_taf , $ evolution , $ result , $ entity_name ) { $ new_evolution = clone ( $ evolution ) ; $ new_evolution -> setEntity ( $ result [ $ entity_name ] ) ; if ( $ entity_name == 'visibility' && $ this -> with_cavok == true ) { $ new_evolution -> setCavok ( true ) ; } $ getter_name = 'get' . ucfirst ( $ entity_name ) ; $ setter_name = 'set' . ucfirst ( $ entity_name ) ; $ decoded_entity = $ decoded_taf -> $ getter_name ( ) ; if ( $ decoded_entity == null || $ entity_name == 'clouds' || $ entity_name == 'weatherPhenomenons' ) { $ decoded_entity = $ this -> instantiateEntity ( $ entity_name ) ; } $ decoded_entity -> addEvolution ( $ new_evolution ) ; if ( $ entity_name == 'clouds' ) { $ decoded_taf -> addCloud ( $ decoded_entity ) ; } elseif ( $ entity_name == 'weatherPhenomenons' ) { $ decoded_taf -> addWeatherPhenomenon ( $ decoded_entity ) ; } else { $ decoded_taf -> $ setter_name ( $ decoded_entity ) ; } }
2295	public static function getTinyTemplates ( ) { $ strDir = Config :: get ( 'uploadPath' ) . '/tiny_templates' ; $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( ! is_dir ( $ rootDir . '/' . $ strDir ) ) { return '' ; } $ arrFiles = array ( ) ; $ arrTemplates = scan ( $ rootDir . '/' . $ strDir ) ; foreach ( $ arrTemplates as $ strFile ) { if ( strncmp ( '.' , $ strFile , 1 ) !== 0 && is_file ( $ rootDir . '/' . $ strDir . '/' . $ strFile ) ) { $ arrFiles [ ] = '{ title: "' . $ strFile . '", url: "' . $ strDir . '/' . $ strFile . '" }' ; } } return implode ( ",\n" , $ arrFiles ) . "\n" ; }
4096	public function build ( ) { $ built = array ( ) ; if ( $ this -> fieldname ) { $ built [ $ this -> fieldname ] = array ( ) ; foreach ( array ( "from" , "to" , "includeLower" , "includeUpper" , "boost" ) as $ opt ) { if ( $ this -> $ opt !== null ) $ built [ $ this -> fieldname ] [ $ opt ] = $ this -> $ opt ; } if ( count ( $ built [ $ this -> fieldname ] ) == 0 ) throw new \ ElasticSearch \ Exception ( "Empty RangeQuery cant be created" ) ; } return $ built ; }
2376	public static function sanitizeFileName ( $ strName ) { $ strName = preg_replace ( '/[\pC]/u' , '' , $ strName ) ; if ( $ strName === null ) { throw new \ InvalidArgumentException ( 'The file name could not be sanitzied' ) ; } $ strName = str_replace ( array ( '\\' , '/' , ':' , '*' , '?' , '"' , '<' , '>' , '|' ) , '-' , $ strName ) ; return $ strName ; }
12730	public function renderStraight ( Zend_Navigation_Container $ container = null ) { if ( $ container === null ) { $ container = $ this -> getContainer ( ) ; } if ( ! $ active = $ this -> findActive ( $ container ) ) { return '' ; } $ active = $ active [ 'page' ] ; if ( $ this -> getLinkLast ( ) ) { $ html = '<li>' . $ this -> htmlify ( $ active ) . '</li>' ; } else { $ html = $ active -> getLabel ( ) ; if ( $ this -> getUseTranslator ( ) && $ t = $ this -> getTranslator ( ) ) { $ html = $ t -> translate ( $ html ) ; } $ html = '<li class="active">' . $ this -> view -> escape ( $ html ) . '</li>' ; } while ( ( $ parent = $ active -> getParent ( ) ) != null ) { if ( $ parent instanceof Zend_Navigation_Page ) { $ html = '<li>' . $ this -> htmlify ( $ parent ) . ' <span class="divider">' . $ this -> getSeparator ( ) . '</span></li>' . PHP_EOL . $ html ; } if ( $ parent === $ container ) { break ; } $ active = $ parent ; } return strlen ( $ html ) ? $ this -> getIndent ( ) . '<ul class="breadcrumb">' . $ html . '</ul>' : '' ; }
5814	public function validate ( ) { $ result = parent :: validate ( ) ; $ this -> Title = strtolower ( $ this -> Title ) ; if ( $ result -> valid ( ) && ! $ this -> Title ) { $ result -> error ( '"Title" required!' ) ; } else if ( $ result -> valid ( ) && FusionTag :: get_one ( 'FusionTag' , array ( 'ID != ?' => $ this -> ID , 'Title = ?' => $ this -> Title ) ) ) { $ result -> error ( 'Tag already exists!' ) ; } $ this -> extend ( 'validateFusionTag' , $ result ) ; return $ result ; }
4813	public function get ( $ name , $ default = null ) { return array_key_exists ( $ name , $ this -> storage ) ? $ this -> storage [ $ name ] : $ default ; }
12423	protected function getTranslations ( $ domain ) { if ( ! isset ( $ this -> translations [ $ domain ] ) ) { if ( ! isset ( $ this -> translationSources [ $ domain ] ) ) { $ msg = sprintf ( 'No translation directory for domain "%1$s" available' , $ domain ) ; throw new \ Aimeos \ MW \ Translation \ Exception ( $ msg ) ; } $ locale = $ this -> getLocale ( ) ; $ locations = array_reverse ( $ this -> getTranslationFileLocations ( $ this -> translationSources [ $ domain ] , $ locale ) ) ; foreach ( $ locations as $ location ) { $ translator = \ Zend \ I18n \ Translator \ MwTranslator :: factory ( $ this -> options ) ; $ translator -> addTranslationFile ( $ this -> adapter , $ location , $ domain , $ locale ) ; $ this -> translations [ $ domain ] [ $ location ] = $ translator ; } } return ( isset ( $ this -> translations [ $ domain ] ) ? $ this -> translations [ $ domain ] : [ ] ) ; }
2170	private function setPassword ( ) : Response { $ request = $ this -> container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } if ( 'tl_password' !== $ request -> request -> get ( 'FORM_SUBMIT' ) ) { return $ this -> render ( 'password.html.twig' ) ; } $ password = $ request -> request -> get ( 'password' ) ; $ confirmation = $ request -> request -> get ( 'confirmation' ) ; if ( $ password !== $ confirmation ) { return $ this -> render ( 'password.html.twig' , [ 'error' => $ this -> trans ( 'password_confirmation_mismatch' ) , ] ) ; } $ installTool = $ this -> container -> get ( 'contao.install_tool' ) ; $ minlength = $ installTool -> getConfig ( 'minPasswordLength' ) ; if ( Utf8 :: strlen ( $ password ) < $ minlength ) { return $ this -> render ( 'password.html.twig' , [ 'error' => sprintf ( $ this -> trans ( 'password_too_short' ) , $ minlength ) , ] ) ; } $ installTool -> persistConfig ( 'installPassword' , password_hash ( $ password , PASSWORD_DEFAULT ) ) ; $ this -> container -> get ( 'contao.install_tool_user' ) -> setAuthenticated ( true ) ; return $ this -> getRedirectResponse ( ) ; }
12123	public function onEntryUpdate ( ContentfulEntryEvent $ e ) { $ entry = $ e -> getEntry ( ) ; $ key = $ this -> getCacheKeyItem ( $ entry -> getId ( ) , 'uri' ) ; $ urisForItemOption = Option :: fromValue ( $ this -> cache -> fetch ( $ key ) , false ) ; if ( $ urisForItemOption -> isEmpty ( ) ) { Option :: fromValue ( $ this -> logger ) -> map ( function ( LoggerInterface $ logger ) use ( $ entry ) { $ logger -> debug ( sprintf ( '[ContentfulBundle:RequestLastModifiedCache] Entry "%s" is not used.' , $ entry -> getId ( ) ) ) ; } ) ; return ; } $ urisForItem = $ urisForItemOption -> get ( ) ; foreach ( $ urisForItem as $ uri => $ bool ) { $ key = $ this -> getCacheKeyRequest ( sha1 ( $ uri ) , 'lastmodified' ) ; $ lastModified = $ this -> cache -> fetch ( $ key ) ; if ( $ lastModified >= $ entry -> getUpdatedAt ( ) -> format ( 'r' ) ) { Option :: fromValue ( $ this -> logger ) -> map ( function ( LoggerInterface $ logger ) use ( $ lastModified , $ uri ) { $ logger -> debug ( sprintf ( '[ContentfulBundle:RequestLastModifiedCache] "%s" was last modified at "%s". Entry is older.' , $ uri , $ lastModified ) ) ; } ) ; continue ; } $ this -> cache -> save ( $ key , $ entry -> getUpdatedAt ( ) -> format ( 'r' ) ) ; Option :: fromValue ( $ this -> logger ) -> map ( function ( LoggerInterface $ logger ) use ( $ entry , $ uri ) { $ logger -> debug ( sprintf ( '[ContentfulBundle:RequestLastModifiedCache] Setting last modified time for "%s" to "%s".' , $ uri , $ entry -> getUpdatedAt ( ) -> format ( 'r' ) ) ) ; } ) ; } }
842	public function offsetSet ( $ index , $ newval ) { $ this -> blockEndCache = [ ] ; if ( ! $ this [ $ index ] || ! $ this [ $ index ] -> equals ( $ newval ) ) { $ this -> changed = true ; if ( isset ( $ this [ $ index ] ) ) { $ this -> unregisterFoundToken ( $ this [ $ index ] ) ; } $ this -> registerFoundToken ( $ newval ) ; } parent :: offsetSet ( $ index , $ newval ) ; }
2752	public function processBlockedItems ( $ strippedBlockedItems , $ blockingType = null ) { if ( empty ( $ blockingType ) ) { $ blockingType = $ this -> _scopeConfig -> getValue ( self :: XML_FASTLY_BLOCKING_TYPE ) ; } if ( $ blockingType == '1' ) { $ strippedBlockedItems = '!(' . $ strippedBlockedItems . ')' ; } return $ strippedBlockedItems ; }
12449	static function run_check_gnu_files ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; if ( $ opts [ 'files' ] [ 'gnu_dir' ] ) { $ destdir .= '/' . $ opts [ 'files' ] [ 'gnu_dir' ] ; } $ files = pakeFinder :: type ( 'file' ) -> name ( array ( 'README' , 'LICENSE' ) ) -> maxdepth ( 0 ) -> in ( $ destdir ) ; if ( count ( $ files ) != 2 ) { SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; throw new pakeException ( "README and/or LICENSE files missing. Please fix" ) ; } SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; }
5475	public function getAction ( ) { $ url = $ this -> action ; if ( $ this -> default_target && ! $ url -> getTarget ( ) ) { $ url -> setTarget ( $ this -> default_target ) ; } if ( $ this -> getMethod ( ) === 'get' ) { $ url -> clearRequest ( ) ; } return $ url ; }
5668	public function describeDifference ( $ first , $ second , $ identical = false ) { if ( $ identical ) { if ( ! $ this -> isTypeMatch ( $ first , $ second ) ) { return sprintf ( 'with type mismatch as [%s] does not match [%s]' , $ this -> describeValue ( $ first ) , $ this -> describeValue ( $ second ) ) ; } } $ type = $ this -> getType ( $ first ) ; if ( $ type === 'Unknown' ) { return 'with unknown type' ; } $ method = 'describe' . $ type . 'Difference' ; return $ this -> $ method ( $ first , $ second , $ identical ) ; }
12126	public function validate ( string $ sValue = null ) : bool { if ( $ this -> _sType == 'DateTime' ) { if ( preg_match ( '#^[0-9]{4}/[0-9]{2}/[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}#' , $ sValue ) ) { return true ; } } return false ; }
6317	public function execute ( $ sql ) { $ this -> dispatcher -> dispatch ( 'rentgen.sql_executed' , new SqlEvent ( $ sql ) ) ; return $ this -> getConnection ( ) -> exec ( $ sql ) ; }
6663	public function post ( $ url , $ params ) { if ( is_array ( $ params ) ) { $ params = $ this -> filterParams ( $ params ) ; } $ this -> lastRequestParams = $ params ; $ this -> lastRequestUrl = $ this -> buildUrl ( $ url ) ; return $ this -> curlAgent -> setOption ( CURLOPT_POSTFIELDS , $ params ) -> post ( $ this -> lastRequestUrl , $ this -> rawResponse ) ; }
7994	public function getDedicatedServerList ( ) { $ request = $ this -> get ( 'dedicated/server' ) ; $ response = $ request -> send ( ) ; return $ response -> getBody ( true ) ; }
3138	public function emptyResponse ( RunnerServiceContext $ context , $ responses ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ similar = 0 ; foreach ( $ responses as $ responseVariable ) { $ value = $ responseVariable -> getValue ( ) ; $ default = $ responseVariable -> getDefaultValue ( ) ; if ( TestRunnerUtils :: isQtiValueNull ( $ value ) === true ) { if ( TestRunnerUtils :: isQtiValueNull ( $ default ) === true ) { $ similar ++ ; } } elseif ( $ value -> equals ( $ default ) === true ) { $ similar ++ ; } } $ respCount = count ( $ responses ) ; return $ respCount > 0 && $ similar == $ respCount ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'storeItemResponse' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } }
8630	public function setGetLowestOfferListingsForASINResult ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GetLowestOfferListingsForASINResult' ] [ 'FieldValue' ] = $ value ; return $ this ; }
8140	public function createTemplate ( $ template ) { $ name = sprintf ( '__string_template__%s' , hash ( 'sha256' , $ template , false ) ) ; $ loader = new Twig_Loader_Chain ( array ( new Twig_Loader_Array ( array ( $ name => $ template ) ) , $ current = $ this -> getLoader ( ) , ) ) ; $ this -> setLoader ( $ loader ) ; try { $ template = $ this -> loadTemplate ( $ name ) ; } catch ( Exception $ e ) { $ this -> setLoader ( $ current ) ; throw $ e ; } catch ( Throwable $ e ) { $ this -> setLoader ( $ current ) ; throw $ e ; } $ this -> setLoader ( $ current ) ; return $ template ; }
1502	public function acceptable ( AcceptHeaderInterface $ accept ) : ? Encoding { foreach ( $ accept -> getMediaTypes ( ) as $ mediaType ) { if ( $ encoding = $ this -> matchesTo ( $ mediaType ) ) { return $ encoding ; } } return null ; }
3085	public function getAssessmentItemRefsByPlaceholder ( \ tao_models_classes_service_StorageDirectory $ privateCompilationDirectory , AssessmentItemRef $ placeholder ) { $ urlinfo = parse_url ( $ placeholder -> getHref ( ) ) ; $ adaptiveSectionId = ltrim ( $ urlinfo [ 'path' ] , '/' ) ; $ compilationDataService = $ this -> getServiceLocator ( ) -> get ( CompilationDataService :: SERVICE_ID ) ; $ filename = "adaptive-assessment-section-${adaptiveSectionId}" ; $ component = $ compilationDataService -> readPhpCompilationData ( $ privateCompilationDirectory , "${filename}.php" , $ filename ) ; return $ component -> getComponentsByClassName ( 'assessmentItemRef' ) -> getArrayCopy ( ) ; }
10126	private function writeGuts ( ) { $ record = 0x0080 ; $ length = 0x0008 ; $ dxRwGut = 0x0000 ; $ dxColGut = 0x0000 ; $ maxRowOutlineLevel = 0 ; foreach ( $ this -> phpSheet -> getRowDimensions ( ) as $ rowDimension ) { $ maxRowOutlineLevel = max ( $ maxRowOutlineLevel , $ rowDimension -> getOutlineLevel ( ) ) ; } $ col_level = 0 ; $ colcount = count ( $ this -> columnInfo ) ; for ( $ i = 0 ; $ i < $ colcount ; ++ $ i ) { $ col_level = max ( $ this -> columnInfo [ $ i ] [ 5 ] , $ col_level ) ; } $ col_level = max ( 0 , min ( $ col_level , 7 ) ) ; if ( $ maxRowOutlineLevel ) { ++ $ maxRowOutlineLevel ; } if ( $ col_level ) { ++ $ col_level ; } $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vvvv' , $ dxRwGut , $ dxColGut , $ maxRowOutlineLevel , $ col_level ) ; $ this -> append ( $ header . $ data ) ; }
1471	public function createResponseFactory ( Api $ api ) { return new Responses ( $ this , $ api , $ this -> container -> make ( Route :: class ) , $ this -> container -> make ( 'json-api.exceptions' ) ) ; }
11378	public function postAction ( ) { if ( ! preg_match ( '/\/page\/(\w+[\-\w]*)\/text\/(..)$/' , $ this -> name , $ matches ) ) { throw new InvalidParameterException ( "Invalid parameters" ) ; } list ( $ dummy , $ pageName , $ language ) = $ matches ; $ request = $ this -> environment -> getRequestHelper ( ) ; $ name = $ request -> getIdentifierParam ( 'name' ) ; $ content = $ request -> getParam ( 'content' , '' ) ; try { $ pageTexts = $ this -> getTextModel ( $ pageName ) ; $ text = $ pageTexts -> addTextContainer ( $ name , $ this -> filter ( $ content ) , $ language ) ; $ this -> environment -> sendJSONResult ( $ text ) ; } catch ( \ Exception $ e ) { throw new InvalidParameterException ( $ e -> getMessage ( ) ) ; } }
5951	public function addFolderResponse ( $ item ) { if ( ! ( $ item instanceof FolderResponse ) ) { if ( is_array ( $ item ) ) { try { $ item = new FolderResponse ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate FolderResponse. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } elseif ( ! is_numeric ( $ item ) ) { trigger_error ( 'Array parameter item is not of expected type "FolderResponse"!' , E_USER_WARNING ) ; } } $ this -> results [ ] = $ item ; return $ this ; }
94	protected function hasVendorIgnore ( $ ignoreFile , $ vendor = 'vendor' ) { if ( ! file_exists ( $ ignoreFile ) ) { return false ; } $ pattern = sprintf ( '{^/?%s(/\*?)?$}' , preg_quote ( $ vendor ) ) ; $ lines = file ( $ ignoreFile , FILE_IGNORE_NEW_LINES ) ; foreach ( $ lines as $ line ) { if ( preg_match ( $ pattern , $ line ) ) { return true ; } } return false ; }
12472	public static function isEnabled ( ) { $ class = self :: className ( ) ; foreach ( \ Yii :: $ app -> modules as $ module => $ params ) { switch ( gettype ( $ params ) ) { case 'array' : if ( $ class == @ $ params [ 'class' ] ) return true ; break ; case 'object' : if ( $ class == get_class ( $ params ) ) return true ; break ; default : if ( $ class == $ params ) return true ; } if ( $ module == $ class || ( isset ( $ module [ 'class' ] ) && $ module [ 'class' ] == $ class ) ) { return true ; } } return false ; }
7204	public function getDiscount ( bool $ ati = false ) : float { return $ ati ? $ this -> ati ( $ this -> discount ) : $ this -> discount ; }
10276	public static function getTextWidthPixelsApprox ( $ columnText , \ PhpOffice \ PhpSpreadsheet \ Style \ Font $ font , $ rotation = 0 ) { $ fontName = $ font -> getName ( ) ; $ fontSize = $ font -> getSize ( ) ; switch ( $ fontName ) { case 'Calibri' : $ columnWidth = ( int ) ( 8.26 * StringHelper :: countCharacters ( $ columnText ) ) ; $ columnWidth = $ columnWidth * $ fontSize / 11 ; break ; case 'Arial' : $ columnWidth = ( int ) ( 8 * StringHelper :: countCharacters ( $ columnText ) ) ; $ columnWidth = $ columnWidth * $ fontSize / 10 ; break ; case 'Verdana' : $ columnWidth = ( int ) ( 8 * StringHelper :: countCharacters ( $ columnText ) ) ; $ columnWidth = $ columnWidth * $ fontSize / 10 ; break ; default : $ columnWidth = ( int ) ( 8.26 * StringHelper :: countCharacters ( $ columnText ) ) ; $ columnWidth = $ columnWidth * $ fontSize / 11 ; break ; } if ( $ rotation !== 0 ) { if ( $ rotation == - 165 ) { $ columnWidth = 4 ; } else { $ columnWidth = $ columnWidth * cos ( deg2rad ( $ rotation ) ) + $ fontSize * abs ( sin ( deg2rad ( $ rotation ) ) ) / 5 ; } } return ( int ) $ columnWidth ; }
4878	public function setUser ( UserInterface $ user ) { if ( $ this -> user ) { $ this -> getPermissions ( ) -> revoke ( $ this -> user , Permissions :: PERMISSION_ALL , false ) ; } $ this -> user = $ user ; $ this -> getPermissions ( ) -> grant ( $ user , Permissions :: PERMISSION_ALL ) ; return $ this ; }
11909	public function getRequiredParams ( ) { $ requiredParams = [ ] ; foreach ( $ this -> parameters as $ parameter ) { if ( $ parameter -> getIsOptional ( ) || $ parameter -> hasDefault ( ) ) { continue ; } $ requiredParams [ ] = $ parameter ; } return $ requiredParams ; }
3494	public function withCertificatePassPhrase ( string $ passPhrase ) : Request { $ cloned = clone $ this ; $ cloned -> certificatePassPhrase = $ passPhrase ; return $ cloned ; }
3310	public function getAccessToken ( $ forceRefresh = false ) { $ cacheKey = $ this -> getCacheKey ( ) ; $ cached = $ this -> getCache ( ) -> fetch ( $ cacheKey ) ; if ( empty ( $ cached ) || $ forceRefresh ) { $ token = $ this -> getTokenFormApi ( ) ; $ this -> getCache ( ) -> save ( $ cacheKey , $ token [ $ this -> tokenSucessKey ] , $ token [ 'expires_in' ] ) ; return $ token [ $ this -> tokenSucessKey ] ; } return $ cached ; }
7108	static public function getPrecision ( $ currency ) { if ( isset ( static :: $ precisions [ $ currency ] ) ) { return static :: $ precisions [ $ currency ] ; } return static :: $ precisions [ $ currency ] = static :: getCurrencyBundle ( ) -> getFractionDigits ( $ currency ) ; }
1794	private function getAutoItems ( array $ parameters ) : array { if ( isset ( $ parameters [ 'auto_item' ] ) ) { return [ $ parameters [ 'auto_item' ] ] ; } if ( isset ( $ GLOBALS [ 'TL_AUTO_ITEM' ] ) && \ is_array ( $ GLOBALS [ 'TL_AUTO_ITEM' ] ) ) { return $ GLOBALS [ 'TL_AUTO_ITEM' ] ; } return [ ] ; }
1642	public static function fromString ( string $ string , Ellipsoid $ ellipsoid = null ) : Coordinate { $ string = self :: mergeSecondsToMinutes ( $ string ) ; $ result = self :: parseDecimalMinutesWithoutCardinalLetters ( $ string , $ ellipsoid ) ; if ( $ result instanceof Coordinate ) { return $ result ; } $ result = self :: parseDecimalMinutesWithCardinalLetters ( $ string , $ ellipsoid ) ; if ( $ result instanceof Coordinate ) { return $ result ; } $ result = self :: parseDecimalDegreesWithoutCardinalLetters ( $ string , $ ellipsoid ) ; if ( $ result instanceof Coordinate ) { return $ result ; } $ result = self :: parseDecimalDegreesWithCardinalLetters ( $ string , $ ellipsoid ) ; if ( $ result instanceof Coordinate ) { return $ result ; } throw new InvalidArgumentException ( 'Format of coordinates was not recognized' ) ; }
3671	private function getFolderUrlFragments ( string $ alias , string $ host , string $ locale = null ) : ? array { $ pages = $ this -> getPageCandidates ( $ alias ) ; if ( null === $ pages ) { return null ; } if ( isset ( $ pages [ $ host ] ) ) { $ languages = $ pages [ $ host ] ; } else { $ languages = $ pages [ '*' ] ? : [ ] ; } unset ( $ pages ) ; $ pages = [ ] ; if ( ! $ this -> isLocalePrepended ) { $ pages = current ( $ languages ) ; } elseif ( $ locale && isset ( $ languages [ $ locale ] ) ) { $ pages = $ languages [ $ locale ] ; } if ( empty ( $ pages ) ) { return null ; } $ page = $ pages [ 0 ] ; if ( $ alias == $ page -> alias ) { $ arrFragments = [ $ alias ] ; } else { $ arrFragments = explode ( '/' , substr ( $ alias , ( \ strlen ( $ page -> alias ) + 1 ) ) ) ; array_unshift ( $ arrFragments , $ page -> alias ) ; } return $ arrFragments ; }
12914	protected function getWhereAsArray ( ) { $ filters = [ ] ; if ( ! empty ( $ this -> filters ) ) { $ filters = $ this -> filters ; } if ( ! $ this -> allowDeleted ) { $ filters [ ] = "(`" . $ this -> table . "`.deleted = 0 OR `" . $ this -> table . "`.deleted IS NULL)" ; } if ( ! empty ( $ this -> joins ) ) { foreach ( $ this -> joins as $ join ) { $ manager = $ join [ 'manager' ] ; $ filters = array_merge ( $ filters , $ manager -> getWhereAsArray ( ) ) ; } } return $ filters ; }
12948	public function removeTagValues ( $ tags ) { $ this -> _tagsList = array_diff ( $ this -> getTagValues ( ) , $ this -> parseTags ( $ tags ) ) ; $ this -> updateOwnerTags ( ) ; }
2198	public static function findByIdOrAliasAndPid ( $ varId , $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = ! preg_match ( '/^[1-9]\d*$/' , $ varId ) ? array ( "$t.alias=?" ) : array ( "$t.id=?" ) ; $ arrValues = array ( $ varId ) ; if ( $ intPid ) { $ arrColumns [ ] = "$t.pid=?" ; $ arrValues [ ] = $ intPid ; } return static :: findOneBy ( $ arrColumns , $ arrValues , $ arrOptions ) ; }
5486	public function submitButton ( SelectorInterface $ selector , $ additional = false ) { $ additional = $ additional ? $ additional : array ( ) ; foreach ( $ this -> buttons as $ button ) { if ( $ selector -> isMatch ( $ button ) ) { $ encoding = $ this -> encode ( ) ; $ button -> write ( $ encoding ) ; if ( $ additional ) { $ encoding -> merge ( $ additional ) ; } return $ encoding ; } } return false ; }
6600	public function unlinkFiles ( $ fileName ) { $ folder = $ this -> getWebrootFolder ( ) ; if ( $ fileName ) { if ( @ file_exists ( $ folder . '/' . $ fileName ) ) { unlink ( $ folder . '/' . $ fileName ) ; } if ( @ file_exists ( $ folder . '/' . $ this -> thumbFolder . '/' . $ fileName ) ) { unlink ( $ folder . '/' . $ this -> thumbFolder . '/' . $ fileName ) ; } if ( is_array ( $ this -> sizes ) ) { $ i = 0 ; foreach ( $ this -> sizes as $ size ) { if ( @ file_exists ( $ folder . '/' . $ i . '/' . $ fileName ) ) { unlink ( $ folder . '/' . $ i . '/' . $ fileName ) ; } $ i ++ ; } } } }
9825	public function writeDrawingRelationships ( \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Worksheet $ pWorksheet , & $ chartRef , $ includeCharts = false ) { $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ objWriter -> startElement ( 'Relationships' ) ; $ objWriter -> writeAttribute ( 'xmlns' , 'http://schemas.openxmlformats.org/package/2006/relationships' ) ; $ i = 1 ; $ iterator = $ pWorksheet -> getDrawingCollection ( ) -> getIterator ( ) ; while ( $ iterator -> valid ( ) ) { if ( $ iterator -> current ( ) instanceof \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Drawing || $ iterator -> current ( ) instanceof MemoryDrawing ) { $ this -> writeRelationship ( $ objWriter , $ i , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/image' , '../media/' . str_replace ( ' ' , '' , $ iterator -> current ( ) -> getIndexedFilename ( ) ) ) ; } $ iterator -> next ( ) ; ++ $ i ; } if ( $ includeCharts ) { $ chartCount = $ pWorksheet -> getChartCount ( ) ; if ( $ chartCount > 0 ) { for ( $ c = 0 ; $ c < $ chartCount ; ++ $ c ) { $ this -> writeRelationship ( $ objWriter , $ i ++ , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart' , '../charts/chart' . ++ $ chartRef . '.xml' ) ; } } } $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
7397	public function header ( string $ name , string $ value ) : bool { if ( ! empty ( $ name ) && ! empty ( $ value ) && ! headers_sent ( ) ) { header ( $ name . ': ' . $ value ) ; return true ; } return false ; }
12163	public function getFormSegment ( $ primaryModel = null , $ settings = [ ] ) { if ( empty ( $ primaryModel ) ) { return false ; } return $ primaryModel -> form ( $ settings ) ; }
2175	private function adjustDatabaseTables ( ) : ? RedirectResponse { $ this -> container -> get ( 'contao.install_tool' ) -> handleRunOnce ( ) ; $ installer = $ this -> container -> get ( 'contao.installer' ) ; $ this -> context [ 'sql_form' ] = $ installer -> getCommands ( ) ; $ request = $ this -> container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } if ( 'tl_database_update' !== $ request -> request -> get ( 'FORM_SUBMIT' ) ) { return null ; } $ sql = $ request -> request -> get ( 'sql' ) ; if ( ! empty ( $ sql ) && \ is_array ( $ sql ) ) { foreach ( $ sql as $ hash ) { $ installer -> execCommand ( $ hash ) ; } } return $ this -> getRedirectResponse ( ) ; }
1003	public function parseHttpRequest ( ? callable $ readRawBodyFn = null ) { $ method = $ _SERVER [ 'REQUEST_METHOD' ] ?? null ; $ bodyParams = [ ] ; $ urlParams = $ _GET ; if ( $ method === 'POST' ) { $ contentType = $ _SERVER [ 'CONTENT_TYPE' ] ?? null ; if ( $ contentType === null ) { throw new RequestError ( 'Missing "Content-Type" header' ) ; } if ( stripos ( $ contentType , 'application/graphql' ) !== false ) { $ rawBody = $ readRawBodyFn ? $ readRawBodyFn ( ) : $ this -> readRawBody ( ) ; $ bodyParams = [ 'query' => $ rawBody ? : '' ] ; } elseif ( stripos ( $ contentType , 'application/json' ) !== false ) { $ rawBody = $ readRawBodyFn ? $ readRawBodyFn ( ) : $ this -> readRawBody ( ) ; $ bodyParams = json_decode ( $ rawBody ? : '' , true ) ; if ( json_last_error ( ) ) { throw new RequestError ( 'Could not parse JSON: ' . json_last_error_msg ( ) ) ; } if ( ! is_array ( $ bodyParams ) ) { throw new RequestError ( 'GraphQL Server expects JSON object or array, but got ' . Utils :: printSafeJson ( $ bodyParams ) ) ; } } elseif ( stripos ( $ contentType , 'application/x-www-form-urlencoded' ) !== false ) { $ bodyParams = $ _POST ; } elseif ( stripos ( $ contentType , 'multipart/form-data' ) !== false ) { $ bodyParams = $ _POST ; } else { throw new RequestError ( 'Unexpected content type: ' . Utils :: printSafeJson ( $ contentType ) ) ; } } return $ this -> parseRequestParams ( $ method , $ bodyParams , $ urlParams ) ; }
6026	public function setMimetype ( $ mimetype ) { if ( $ mimetype instanceof MimeType ) { $ this -> mimetype = $ mimetype ; } elseif ( is_array ( $ mimetype ) ) { $ this -> mimetype = new MimeType ( $ mimetype ) ; } else { $ this -> mimetype = null ; trigger_error ( 'Argument must be an object of class MimeType. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
1925	public function convertToPaletteImage ( ) { if ( ! imageistruecolor ( $ this -> gdResource ) ) { return $ this ; } $ width = imagesx ( $ this -> gdResource ) ; $ height = imagesy ( $ this -> gdResource ) ; $ transparentColor = null ; if ( $ this -> countColors ( 256 ) <= 256 ) { $ paletteImage = imagecreate ( $ width , $ height ) ; $ colors = array ( ) ; $ isTransparent = false ; for ( $ x = 0 ; $ x < $ width ; $ x ++ ) { for ( $ y = 0 ; $ y < $ height ; $ y ++ ) { $ color = imagecolorat ( $ this -> gdResource , $ x , $ y ) ; if ( ( ( $ color >> 24 ) & 0x7F ) === 127 ) { $ isTransparent = true ; } else { $ colors [ $ color & 0xFFFFFF ] = true ; } } } $ colors = array_keys ( $ colors ) ; foreach ( $ colors as $ index => $ color ) { imagecolorset ( $ paletteImage , $ index , ( $ color >> 16 ) & 0xFF , ( $ color >> 8 ) & 0xFF , $ color & 0xFF ) ; } if ( $ isTransparent ) { $ transparentColor = imagecolorallocate ( $ paletteImage , 0 , 0 , 0 ) ; imagecolortransparent ( $ paletteImage , $ transparentColor ) ; } imagecopy ( $ paletteImage , $ this -> gdResource , 0 , 0 , 0 , 0 , $ width , $ height ) ; } else { $ paletteImage = imagecreatetruecolor ( $ width , $ height ) ; imagealphablending ( $ paletteImage , false ) ; imagesavealpha ( $ paletteImage , true ) ; imagecopy ( $ paletteImage , $ this -> gdResource , 0 , 0 , 0 , 0 , $ width , $ height ) ; imagetruecolortopalette ( $ paletteImage , false , 255 ) ; $ transparentColor = imagecolorallocate ( $ paletteImage , 0 , 0 , 0 ) ; imagecolortransparent ( $ paletteImage , $ transparentColor ) ; } if ( $ transparentColor !== null ) { for ( $ x = 0 ; $ x < $ width ; $ x ++ ) { for ( $ y = 0 ; $ y < $ height ; $ y ++ ) { if ( ( ( imagecolorat ( $ this -> gdResource , $ x , $ y ) >> 24 ) & 0x7F ) === 127 ) { imagefilledrectangle ( $ paletteImage , $ x , $ y , $ x , $ y , $ transparentColor ) ; } } } } imagedestroy ( $ this -> gdResource ) ; $ this -> gdResource = $ paletteImage ; return $ this ; }
12456	public function installAssets ( $ targetFolder = "web" , $ force = false ) { $ sourceDir = $ this -> pluginDir . '/Resources/public' ; $ targetDir = $ this -> rootDir . '/' . $ targetFolder . '/plugins/' . strtolower ( $ this -> name ) ; if ( is_dir ( $ targetDir ) && ! $ force ) { return ; } $ this -> filesystem -> symlink ( $ sourceDir , $ targetDir , true ) ; }
5390	protected function valueIsPossible ( $ value ) { $ widgets = $ this -> getWidgets ( ) ; for ( $ i = 0 , $ count = count ( $ widgets ) ; $ i < $ count ; $ i ++ ) { if ( $ widgets [ $ i ] -> getAttribute ( 'value' ) == $ value ) { return true ; } } return false ; }
131	protected function updateLocalRepo ( ) { $ fs = new Filesystem ( ) ; $ fs -> ensureDirectoryExists ( $ this -> checkoutDir ) ; if ( ! is_writable ( dirname ( $ this -> checkoutDir ) ) ) { throw new \ RuntimeException ( 'Can not clone ' . $ this -> url . ' to access package information. The "' . $ this -> checkoutDir . '" directory is not writable by the current user.' ) ; } if ( is_file ( $ this -> repoFile ) && is_dir ( $ this -> checkoutDir ) && 0 === $ this -> process -> execute ( 'fossil info' , $ output , $ this -> checkoutDir ) ) { if ( 0 !== $ this -> process -> execute ( 'fossil pull' , $ output , $ this -> checkoutDir ) ) { $ this -> io -> writeError ( '<error>Failed to update ' . $ this -> url . ', package information from this repository may be outdated (' . $ this -> process -> getErrorOutput ( ) . ')</error>' ) ; } } else { $ fs -> removeDirectory ( $ this -> checkoutDir ) ; $ fs -> remove ( $ this -> repoFile ) ; $ fs -> ensureDirectoryExists ( $ this -> checkoutDir ) ; if ( 0 !== $ this -> process -> execute ( sprintf ( 'fossil clone %s %s' , ProcessExecutor :: escape ( $ this -> url ) , ProcessExecutor :: escape ( $ this -> repoFile ) ) , $ output ) ) { $ output = $ this -> process -> getErrorOutput ( ) ; throw new \ RuntimeException ( 'Failed to clone ' . $ this -> url . ' to repository ' . $ this -> repoFile . "\n\n" . $ output ) ; } if ( 0 !== $ this -> process -> execute ( sprintf ( 'fossil open %s --nested' , ProcessExecutor :: escape ( $ this -> repoFile ) ) , $ output , $ this -> checkoutDir ) ) { $ output = $ this -> process -> getErrorOutput ( ) ; throw new \ RuntimeException ( 'Failed to open repository ' . $ this -> repoFile . ' in ' . $ this -> checkoutDir . "\n\n" . $ output ) ; } } }
61	public function isDirEmpty ( $ dir ) { $ finder = Finder :: create ( ) -> ignoreVCS ( false ) -> ignoreDotFiles ( false ) -> depth ( 0 ) -> in ( $ dir ) ; return count ( $ finder ) === 0 ; }
1421	protected function createBelongsToIdentity ( Model $ model , $ relationshipKey ) { $ relation = $ model -> { $ relationshipKey } ( ) ; if ( ! $ relation instanceof BelongsTo ) { throw new RuntimeException ( sprintf ( 'Expecting %s on %s to be a belongs-to relationship.' , $ relationshipKey , get_class ( $ model ) ) ) ; } $ foreignKey = method_exists ( $ relation , 'getForeignKeyName' ) ? $ relation -> getForeignKeyName ( ) : $ relation -> getForeignKey ( ) ; $ id = $ model -> { $ foreignKey } ; if ( is_null ( $ id ) ) { return null ; } $ ownerKey = method_exists ( $ relation , 'getOwnerKeyName' ) ? $ relation -> getOwnerKeyName ( ) : $ relation -> getOwnerKey ( ) ; $ related = $ relation -> getRelated ( ) -> replicate ( ) ; $ related -> { $ ownerKey } = $ id ; return $ related ; }
11740	public function exportAction ( ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ chillSecurityHelper = $ this -> get ( 'chill.main.security.authorization.helper' ) ; $ user = $ this -> get ( 'security.context' ) -> getToken ( ) -> getUser ( ) ; $ reachableCenters = $ chillSecurityHelper -> getReachableCenters ( $ user , new Role ( 'CHILL_PERSON_SEE' ) ) ; $ personRepository = $ em -> getRepository ( 'ChillPersonBundle:Person' ) ; $ qb = $ personRepository -> createQueryBuilder ( 'p' ) ; $ qb -> where ( $ qb -> expr ( ) -> in ( 'p.center' , ':centers' ) ) -> setParameter ( 'centers' , $ reachableCenters ) ; $ persons = $ qb -> getQuery ( ) -> getResult ( ) ; $ response = $ this -> render ( 'ChillPersonBundle:Person:export.csv.twig' , array ( 'persons' => $ persons , 'cf_group' => $ this -> getCFGroup ( ) ) ) ; $ response -> headers -> set ( 'Content-Type' , 'text/csv; charset=utf-8' ) ; $ response -> headers -> set ( 'Content-Disposition' , 'attachment; filename="export_person.csv"' ) ; return $ response ; }
6731	public function get_posts ( ) { $ total_posts = wp_count_posts ( ) ; $ total_posts = isset ( $ total_posts -> publish ) ? $ total_posts -> publish : 0 ; return get_posts ( [ 'post_type' => 'post' , 'numberposts' => $ total_posts , 'post_status' => 'publish' , ] ) ; }
2489	public function hasMultipleEndpoints ( ) { if ( $ this -> hasMultiple !== null ) { return $ this -> hasMultiple ; } $ endpointSet = array_flip ( $ this -> endpointMap ) ; if ( isset ( $ this -> defaultEndpoint ) ) { $ endpointSet [ $ this -> defaultEndpoint ] = true ; } if ( isset ( $ this -> mainLanguagesEndpoint ) ) { $ endpointSet [ $ this -> mainLanguagesEndpoint ] = true ; } return $ this -> hasMultiple = count ( $ endpointSet ) > 1 ; }
12864	public function postDispatch ( Zend_Controller_Request_Abstract $ request ) { $ methods = implode ( ', ' , array_unique ( $ this -> _methods ) ) ; $ headers = implode ( ', ' , array_unique ( $ this -> _headers ) ) ; if ( $ this -> _credentials ) { header ( 'Access-Control-Allow-Credentials: true' , true ) ; } header ( "Access-Control-Allow-Origin: {$this->_origin}" , true ) ; header ( "Access-Control-Allow-Methods: {$methods}" , true ) ; header ( "Access-Control-Allow-Headers: {$headers}" , true ) ; header ( "Access-Control-Max-Age: {$this->_maxAge}" , true ) ; header ( 'X-XSS-Protection: 1; mode=block' , true ) ; header ( 'X-Frame-Options: SAMEORIGIN' , true ) ; }
12414	public function removeDevice ( $ groupId , array $ deviceIdentifiers ) { $ params = [ 'group_id' => intval ( $ groupId ) , 'device_identifiers' => $ deviceIdentifiers , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_DELETE_DEVICE , $ params ] ) ; }
5557	protected function tagUrlsWithFrame ( $ urls , $ frame ) { $ tagged = array ( ) ; foreach ( $ urls as $ url ) { if ( ! $ url -> getTarget ( ) ) { $ url -> setTarget ( $ this -> getPublicNameFromIndex ( $ frame ) ) ; } $ tagged [ ] = $ url ; } return $ tagged ; }
3515	public function getLocale ( ) { if ( ! $ this -> cookiesLoaded ) { $ key = $ this -> cookiePrefix . 'lang_locale' ; $ queuedCookieLocale = \ Cookie :: queued ( $ key , null ) ; $ locale = getSupportedLocale ( $ queuedCookieLocale != null ? $ queuedCookieLocale -> getValue ( ) : \ Cookie :: get ( $ key , '' ) ) ; parent :: setLocale ( $ locale ) ; $ this -> getShowUnpublished ( ) ; $ this -> cookiesLoaded = true ; } return parent :: getLocale ( ) ; }
7854	protected function deleteIfForced ( array $ files ) { if ( ! $ this -> option ( 'force' ) ) return ; foreach ( $ files as $ file ) { if ( $ this -> files -> exists ( $ path = $ this -> getPath ( $ file ) ) ) { $ this -> files -> delete ( $ path ) ; } } }
5104	public function execute ( ) { if ( is_null ( $ this -> conn ) ) throw new SquidException ( "Can't execute query, implicitly created without connection!" ) ; $ cmd = $ this -> assemble ( ) ; $ bind = $ this -> bind ( ) ; return $ this -> conn -> execute ( $ cmd , $ bind ) ; }
6508	public function doStop ( ) { if ( $ this -> controller -> doStop ( ) ) { $ this -> job -> setStatus ( Status :: CANCELLED ( ) ) ; return true ; } return false ; }
2120	public function getFromFile ( ) { $ return = array ( ) ; $ files = System :: getContainer ( ) -> get ( 'contao.resource_finder' ) -> findIn ( 'config' ) -> depth ( 0 ) -> files ( ) -> name ( 'database.sql' ) ; foreach ( $ files as $ file ) { $ return = array_replace_recursive ( $ return , SqlFileParser :: parse ( $ file ) ) ; } ksort ( $ return ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sqlGetFromFile' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sqlGetFromFile' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sqlGetFromFile' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ return = $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ return ) ; } } return $ return ; }
12829	public function setConfig ( $ name , $ value ) { if ( is_null ( $ name ) ) { $ this -> _config = new ArrayStorage ( $ value ) ; } else { $ this -> _config -> setDeepValue ( $ name , $ value ) ; } return $ this ; }
1427	protected function modelRelationForField ( $ field ) { return $ this -> camelCaseRelations ? Str :: camelize ( $ field ) : Str :: underscore ( $ field ) ; }
6960	public static function dt ( AstroDate $ dt ) { $ epoch = new static ( $ dt -> toTT ( ) -> toJD ( ) ) ; $ epoch -> dt = $ dt -> copy ( ) ; return $ epoch ; }
1043	public static function printError ( Error $ error ) { $ printedLocations = [ ] ; if ( $ error -> nodes ) { foreach ( $ error -> nodes as $ node ) { if ( ! $ node -> loc ) { continue ; } if ( $ node -> loc -> source === null ) { continue ; } $ printedLocations [ ] = self :: highlightSourceAtLocation ( $ node -> loc -> source , $ node -> loc -> source -> getLocation ( $ node -> loc -> start ) ) ; } } elseif ( $ error -> getSource ( ) && $ error -> getLocations ( ) ) { $ source = $ error -> getSource ( ) ; foreach ( $ error -> getLocations ( ) as $ location ) { $ printedLocations [ ] = self :: highlightSourceAtLocation ( $ source , $ location ) ; } } return ! $ printedLocations ? $ error -> getMessage ( ) : implode ( "\n\n" , array_merge ( [ $ error -> getMessage ( ) ] , $ printedLocations ) ) . "\n" ; }
4232	private static function getCommentContent ( $ what ) { $ reflector = null ; if ( \ is_object ( $ what ) ) { $ reflector = $ what instanceof \ Reflector ? $ what : new \ ReflectionObject ( $ what ) ; $ docComment = $ reflector -> getDocComment ( ) ; } else { $ docComment = $ what ; } $ docComment = \ preg_replace ( '#^/\*\*(.+)\*/$#s' , '$1' , $ docComment ) ; $ docComment = \ preg_replace ( '#^[ \t]*\*[ ]?#m' , '' , $ docComment ) ; $ docComment = \ trim ( $ docComment ) ; if ( $ reflector ) { if ( \ strtolower ( $ docComment ) == '{@inheritdoc}' ) { return self :: findInheritedDoc ( $ reflector ) ; } else { $ docComment = \ preg_replace_callback ( '/{@inheritdoc}/i' , function ( ) use ( $ reflector ) { $ phpDoc = self :: findInheritedDoc ( $ reflector ) ; return $ phpDoc [ 'description' ] ; } , $ docComment ) ; } } return $ docComment ; }
7582	protected function verifyRequiredData ( ) { $ errors = array ( ) ; foreach ( $ this -> _REQUIRED_DATA as $ property => $ defaultValue ) { if ( ( ! isset ( $ this -> Data [ $ property ] ) ) && empty ( $ defaultValue ) ) { $ errors [ ] = $ property ; } } if ( count ( $ errors ) > 0 ) { throw new RequiredDataException ( get_called_class ( ) , "Missing data for " . implode ( "," , $ errors ) ) ; } return true ; }
9342	public function populate ( $ arrAll ) { $ this -> arr = array_chunk ( $ arrAll , $ this -> size -> cols ) ; return $ this ; }
12364	public function updateSource ( ) { $ source = array ( "value" => $ this -> value , "tags" => $ this -> tags , "type" => $ this -> type , ) ; $ this -> source = Yaml :: dump ( $ source , 100 , 2 ) ; }
5913	public function addUserToGroup ( $ id , array $ groupIds ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'groupIds' => $ groupIds ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/accounts/users/' . $ id . '/groups' , $ parameters ) ; $ result = new User ( $ result ) ; return $ result ; }
824	public function getName ( ) { if ( null === $ this -> name ) { Preg :: matchAll ( '/@[a-zA-Z0-9_-]+(?=\s|$)/' , $ this -> line -> getContent ( ) , $ matches ) ; if ( isset ( $ matches [ 0 ] [ 0 ] ) ) { $ this -> name = ltrim ( $ matches [ 0 ] [ 0 ] , '@' ) ; } else { $ this -> name = 'other' ; } } return $ this -> name ; }
6333	public function validateChecksum ( $ string ) { $ xml = new \ SimpleXMLElement ( $ string ) ; $ checksum = ( string ) $ xml -> Authentication -> Checksum ; $ original = str_replace ( $ checksum , $ this -> getMerchantPassword ( ) , $ string ) ; return md5 ( $ original ) == $ checksum ; }
7050	protected function buildDiscountsLines ( Document \ DocumentInterface $ document ) { $ sale = $ document -> getSale ( ) ; if ( ! $ sale -> hasAdjustments ( Common \ AdjustmentTypes :: TYPE_DISCOUNT ) ) { return ; } $ adjustments = $ sale -> getAdjustments ( ) ; foreach ( $ adjustments as $ adjustment ) { if ( $ adjustment -> getType ( ) === Common \ AdjustmentTypes :: TYPE_DISCOUNT ) { $ this -> buildDiscountLine ( $ adjustment , $ document ) ; } } }
8721	protected function getTranslatableAttributesFromSchema ( ) { if ( ( ! $ con = $ this -> getConnection ( ) ) || ( ! $ builder = $ con -> getSchemaBuilder ( ) ) ) { return [ ] ; } if ( $ columns = TranslatableConfig :: cacheGet ( $ this -> getI18nTable ( ) ) ) { return $ columns ; } $ columns = $ builder -> getColumnListing ( $ this -> getI18nTable ( ) ) ; unset ( $ columns [ array_search ( $ this -> getForeignKey ( ) , $ columns ) ] ) ; TranslatableConfig :: cacheSet ( $ this -> getI18nTable ( ) , $ columns ) ; return $ columns ; }
10839	protected function deleteRaw ( $ Key ) { $ CacheFile = $ this -> getCacheFile ( $ Key ) ; if ( file_exists ( $ CacheFile ) ) { return unlink ( $ CacheFile ) ; } return true ; }
5347	public function revertSnapshotToOtherVps ( $ sourceVpsName , $ snapshotName , $ destinationVpsName ) { return $ this -> call ( self :: SERVICE , 'revertSnapshotToOtherVps' , [ $ sourceVpsName , $ snapshotName , $ destinationVpsName ] ) ; }
12421	public function dn ( $ domain , $ singular , $ plural , $ number ) { $ singular = ( string ) $ singular ; $ plural = ( string ) $ plural ; $ number = ( int ) $ number ; try { $ locale = $ this -> getLocale ( ) ; foreach ( $ this -> getTranslations ( $ domain ) as $ object ) { if ( ( $ string = $ object -> translatePlural ( $ singular , $ plural , $ number , $ domain , $ locale ) ) != $ singular ) { return $ string ; } } } catch ( \ Exception $ e ) { ; } if ( $ this -> getPluralIndex ( $ number , $ this -> getLocale ( ) ) > 0 ) { return ( string ) $ plural ; } return ( string ) $ singular ; }
3373	public function indexAction ( ) { $ request = $ this -> getRequest ( ) ; $ this -> httpClient -> setMethod ( Request :: METHOD_POST ) ; $ this -> httpClient -> setParameterPost ( [ 'dsl_text' => $ request -> getPost ( 'dsl_text' ) ] ) ; $ response = $ this -> httpClient -> send ( ) ; if ( ! $ response -> isSuccess ( ) ) { throw new \ UnexpectedValueException ( 'HTTP Request failed' ) ; } $ redirect = $ this -> plugin ( 'redirect' ) ; return $ redirect -> toUrl ( 'https://yuml.me/' . $ response -> getBody ( ) ) ; }
10219	private static function nbrConversionFormat ( $ xVal , $ places ) { if ( $ places !== null ) { if ( is_numeric ( $ places ) ) { $ places = ( int ) $ places ; } else { return Functions :: VALUE ( ) ; } if ( $ places < 0 ) { return Functions :: NAN ( ) ; } if ( strlen ( $ xVal ) <= $ places ) { return substr ( str_pad ( $ xVal , $ places , '0' , STR_PAD_LEFT ) , - 10 ) ; } return Functions :: NAN ( ) ; } return substr ( $ xVal , - 10 ) ; }
4360	public static function dump ( $ str , $ useHtml = false , $ sanitizeNonBinary = false ) { self :: $ useHtml = $ useHtml ; self :: $ sanitizeNonBinary = $ sanitizeNonBinary ; self :: setStr ( $ str ) ; $ controlCharAs = 'other' ; $ curBlockType = 'utf8' ; $ newBlockType = null ; $ curBlockStart = 0 ; $ strNew = '' ; while ( self :: $ curI < self :: $ stats [ 'strLen' ] ) { $ curI = self :: $ curI ; $ isUtf8 = self :: isOffsetUtf8 ( $ isSpecial , true ) ; if ( $ isUtf8 && $ isSpecial && $ controlCharAs !== 'utf8special' && \ ord ( $ str [ $ curI ] ) < 0x80 ) { if ( $ controlCharAs == 'other' ) { $ isUtf8 = false ; } elseif ( $ controlCharAs == 'utf8' ) { $ isSpecial = false ; } } if ( $ isUtf8 ) { if ( $ isSpecial ) { if ( $ curBlockType !== 'utf8special' ) { $ newBlockType = 'utf8special' ; } } else { if ( $ curBlockType !== 'utf8' ) { $ newBlockType = 'utf8' ; } } } else { if ( $ curBlockType !== 'other' ) { $ newBlockType = 'other' ; } } if ( $ newBlockType ) { $ len = $ curI - $ curBlockStart ; self :: incStat ( $ curBlockType , $ len ) ; $ subStr = \ substr ( self :: $ str , $ curBlockStart , $ len ) ; $ strNew .= self :: dumpBlock ( $ subStr , $ curBlockType ) ; $ curBlockStart = $ curI ; $ curBlockType = $ newBlockType ; $ newBlockType = null ; } } $ len = self :: $ stats [ 'strLen' ] - $ curBlockStart ; self :: incStat ( $ curBlockType , $ len ) ; if ( self :: $ stats [ 'strLen' ] ) { $ percentOther = ( self :: $ stats [ 'bytesOther' ] ) / self :: $ stats [ 'strLen' ] * 100 ; if ( $ percentOther > 33 ) { $ strNew = self :: dumpBlock ( $ str , 'other' , array ( 'prefix' => false ) ) ; } else { $ subStr = \ substr ( self :: $ str , $ curBlockStart , $ len ) ; $ strNew .= self :: dumpBlock ( $ subStr , $ curBlockType ) ; } } return $ strNew ; }
7101	static public function getClasses ( $ type ) { switch ( $ type ) { case static :: TYPE_FORM : return [ CartInterface :: class ] ; case static :: TYPE_QUOTE : return [ QuoteInterface :: class ] ; case static :: TYPE_PROFORMA : return [ QuoteInterface :: class , OrderInterface :: class ] ; case static :: TYPE_CONFIRMATION : return [ OrderInterface :: class ] ; case static :: TYPE_VOUCHER : return [ ] ; default : throw new InvalidArgumentException ( "Unexpected type '$type'." ) ; } }
11988	function readLine ( ) { $ i = $ this -> pos ; $ tot_len = strlen ( $ this -> data ) ; while ( $ i < $ tot_len && ! $ this -> isEndOfLine ( $ i ) ) { $ i ++ ; } $ result = substr ( $ this -> data , $ this -> pos , $ i - $ this -> pos ) ; $ i ++ ; if ( $ this -> getLineEndingModeCrlf ( ) ) $ i ++ ; $ this -> pos = $ i ; return $ result ; }
12858	public function onPageSaved ( PageSavedEvent $ event ) { $ blocks = $ event -> getApprovedBlocks ( ) ; foreach ( $ blocks as $ blockk ) { foreach ( $ blockk as $ block ) { $ this -> pageProductionRenderer -> renderBlock ( json_encode ( $ block ) ) ; } } $ mediaFiles = array_unique ( $ this -> pageProductionRenderer -> getMediaFiles ( ) ) ; $ webDir = $ this -> configurationHandler -> webDir ( ) ; $ fs = new Filesystem ( ) ; foreach ( $ mediaFiles as $ mediaFile ) { $ targetMediaFile = str_replace ( '/backend/' , '/production/' , $ mediaFile ) ; $ fs -> copy ( $ webDir . $ mediaFile , $ webDir . $ targetMediaFile ) ; } }
10801	public function renderPageHistoricContentFiltersActionsAction ( ) { $ melisPageHistoricTable = $ this -> getServiceLocator ( ) -> get ( 'MelisPagehistoricTable' ) ; $ actions = $ melisPageHistoricTable -> getPageHistoricListOfActions ( ) -> toArray ( ) ; $ translator = $ this -> getServiceLocator ( ) -> get ( 'translator' ) ; $ options = '<option value="">' . $ translator -> translate ( 'tr_melispagehistoric_filter_action_select' ) . '</option>' ; foreach ( $ actions as $ action ) { $ options .= '<option value="' . $ action [ 'action' ] . '">' . $ action [ 'action' ] . '</option>' ; } $ view = new ViewModel ( ) ; $ view -> options = $ options ; return $ view ; }
4008	public function collectMetaModelTableNames ( CollectMetaModelTableNamesEvent $ event ) { if ( $ this -> tableNamesCollected ) { $ event -> addMetaModelNames ( $ this -> tableNames ) ; return ; } $ tables = $ this -> database -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel' ) -> orderBy ( 'sorting' ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; foreach ( $ tables as $ table ) { $ this -> tableNames [ $ table [ 'id' ] ] = $ table [ 'tableName' ] ; } $ event -> addMetaModelNames ( $ this -> tableNames ) ; $ this -> tableNamesCollected = true ; }
11595	private function getPageId ( ) { if ( preg_match ( '/\/page\/(\w+)$/' , $ this -> name , $ matches ) ) { $ id = $ matches [ 1 ] ; } else { $ id = $ this -> environment -> getRequestHelper ( ) -> getIdentifierParam ( 'id' , null , true ) ; } return $ id ; }
7637	public function getBlobProperties ( $ containerName = '' , $ blobName = '' , $ snapshotId = null , $ leaseId = null ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; Assertion :: notEmpty ( $ blobName , 'Blob name is not specified.' ) ; self :: assertValidRootContainerBlobName ( $ containerName , $ blobName ) ; return $ this -> getBlobInstance ( $ containerName , $ blobName , $ snapshotId , $ leaseId ) ; }
10665	public function enableBlockMode ( ) : void { if ( ! $ this -> enableProtection ) { throw new MiddlewareException ( $ this , "You can't enable the block mode because the XSS protection is disabled" ) ; } if ( $ this -> reportUri ) { throw new MiddlewareException ( $ this , sprintf ( "You can't enable the block mode because the report mode is already enabled (see %s)" , 'https://developer.mozilla.org/docs/Web/HTTP/Headers/X-XSS-Protection' ) ) ; } $ this -> blockMode = true ; }
1434	public static function decamelize ( $ value ) { if ( isset ( self :: $ decamelized [ $ value ] ) ) { return self :: $ decamelized [ $ value ] ; } return self :: $ decamelized [ $ value ] = strtolower ( preg_replace ( '/(.)(?=[A-Z])/u' , '$1_' , $ value ) ) ; }
5483	public function attachLabelBySelector ( SelectorInterface $ selector , $ label ) { for ( $ i = 0 , $ count = count ( $ this -> widgets ) ; $ i < $ count ; $ i ++ ) { if ( $ selector -> isMatch ( $ this -> widgets [ $ i ] ) ) { if ( method_exists ( $ this -> widgets [ $ i ] , 'setLabel' ) ) { $ this -> widgets [ $ i ] -> setLabel ( $ label ) ; return ; } } } }
11487	protected function callResolvingCallbacks ( $ key , $ object ) { foreach ( $ this -> resolvingAnyCallbacks as $ callback ) { call_user_func ( $ callback , $ object , $ this ) ; } if ( isset ( $ this -> resolvingCallbacks [ $ key ] ) ) { foreach ( $ this -> resolvingCallbacks [ $ key ] as $ callback ) { call_user_func ( $ callback , $ object , $ this ) ; } } }
7186	public function getCombination ( $ quantity , $ reset = false ) { if ( null !== $ this -> combination && ! $ reset ) { return $ this -> combination ; } $ this -> combination = null ; if ( ! empty ( $ combinations = $ this -> buildCombinations ( $ quantity ) ) ) { usort ( $ combinations , function ( AssignmentCombination $ a , AssignmentCombination $ b ) use ( $ quantity ) { if ( $ a -> diff == $ b -> diff ) { if ( $ a -> size == $ b -> size ) { return 0 ; } return $ a -> size < $ b -> size ? - 1 : 1 ; } if ( 0 <= $ a -> diff ) { return intval ( 0 > $ b -> diff ? - 1 : $ a -> diff - $ b -> diff ) ; } return intval ( 0 < $ b -> diff ? 1 : $ b -> diff - $ a -> diff ) ; } ) ; $ this -> combination = reset ( $ combinations ) ; } return $ this -> combination ; }
8976	public static function typeOf ( $ arg ) { if ( null === $ arg ) { return 'NULL' ; } if ( is_object ( $ arg ) ) { return get_class ( $ arg ) ; } return gettype ( $ arg ) ; }
11505	public function getSlots ( $ first , $ last ) { if ( ! static :: isValidRange ( $ first , $ last ) ) { throw new \ OutOfBoundsException ( "Invalid slot range $first-$last" ) ; } return array_intersect_key ( $ this -> slots , array_fill ( $ first , $ last - $ first + 1 , null ) ) ; }
7514	function next_search ( $ characters , $ callback = true ) { $ this -> token_start = $ this -> pos ; if ( ! is_array ( $ characters ) ) { $ characters = array_fill_keys ( str_split ( $ characters ) , true ) ; } while ( ++ $ this -> pos < $ this -> size ) { if ( isset ( $ characters [ $ this -> doc [ $ this -> pos ] ] ) ) { if ( $ callback && isset ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ) { if ( is_string ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ) { return ( $ this -> token = $ this -> { $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] } ( ) ) ; } else { return ( $ this -> token = $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ; } } else { return ( $ this -> token = self :: TOK_UNKNOWN ) ; } } else { $ this -> parse_linebreak ( ) ; } } return ( $ this -> token = self :: TOK_NULL ) ; }
5051	public function triggerUntil ( callable $ callback , $ eventName , $ target = null , $ argv = [ ] ) { $ event = $ eventName instanceof EventInterface ? $ eventName : $ this -> getEvent ( $ eventName , $ target , $ argv ) ; return $ this -> triggerListeners ( $ event , $ callback ) ; }
6803	public function installTaxRules ( $ codes = [ 'US' ] ) { $ codes = ( array ) $ codes ; if ( empty ( $ codes ) ) { return ; } $ countryRepository = $ this -> manager -> getRepository ( Country :: class ) ; $ taxRepository = $ this -> manager -> getRepository ( Tax :: class ) ; $ taxRuleRepository = $ this -> manager -> getRepository ( TaxRule :: class ) ; foreach ( $ codes as $ code ) { $ path = __DIR__ . '/data/' . $ code . '_tax_rules.yml' ; if ( ! ( file_exists ( $ path ) && is_readable ( $ path ) ) ) { call_user_func ( $ this -> log , 'Tax rules data' , 'not found' ) ; continue ; } $ data = Yaml :: parse ( file_get_contents ( $ path ) ) ; if ( ! is_array ( $ data ) || empty ( $ data ) ) { continue ; } foreach ( $ data as $ datum ) { $ name = $ datum [ 'name' ] ; $ result = 'already exists' ; if ( null === $ taxRuleRepository -> findOneBy ( [ 'name' => $ name ] ) ) { $ taxRule = new TaxRule ( ) ; $ taxRule -> setName ( $ name ) -> setPriority ( $ datum [ 'priority' ] ) -> setCustomer ( $ datum [ 'customer' ] ) -> setBusiness ( $ datum [ 'business' ] ) -> setNotices ( $ datum [ 'notices' ] ) ; if ( ! empty ( $ countryCodes = $ datum [ 'countries' ] ) ) { $ taxRule -> setCountries ( $ countryRepository -> findBy ( [ 'code' => $ countryCodes ] ) ) ; } if ( ! empty ( $ taxNames = $ datum [ 'taxes' ] ) ) { $ taxRule -> setTaxes ( $ taxRepository -> findBy ( [ 'name' => $ taxNames ] ) ) ; } $ this -> manager -> persist ( $ taxRule ) ; $ result = 'done' ; } call_user_func ( $ this -> log , $ name , $ result ) ; } } $ this -> manager -> flush ( ) ; }
4709	public function initialize ( Text $ text ) { $ text -> replaceString ( "\r\n" , "\n" ) ; $ text -> replaceString ( "\r" , "\n" ) ; $ text -> append ( "\n\n" ) ; $ this -> markdown -> emit ( 'detab' , array ( $ text ) ) ; $ text -> replace ( '/^[ \t]+$/m' , '' ) ; }
4417	public function showLocationLayouts ( $ locationId ) { $ repository = $ this -> getRepository ( ) ; $ location = $ repository -> getLocationService ( ) -> loadLocation ( $ locationId ) ; $ content = $ repository -> getContentService ( ) -> loadContent ( $ location -> contentInfo -> id ) ; $ request = $ this -> createRequest ( $ content , $ location ) ; return $ this -> render ( '@NetgenAdminUI/layouts/location_layouts.html.twig' , array ( 'rules' => $ this -> layoutResolver -> resolveRules ( $ request , array ( 'ez_content_type' ) ) , 'related_layouts' => $ this -> relatedLayoutsLoader -> loadRelatedLayouts ( $ location ) , 'location' => $ location , ) ) ; }
707	public function bigPrimaryKey ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_BIGPK , $ length ) ; }
5494	public function findFirstAction ( $ parameters ) { $ slot = $ this -> findFirstSlot ( $ parameters ) ; if ( isset ( $ slot ) && isset ( $ slot [ 'content' ] ) ) { return $ slot [ 'content' ] ; } return ; }
8420	public function renderWidget ( $ config = [ ] ) { $ widgetHtml = $ this -> render ( $ this -> template , [ 'name' => $ this -> getModelName ( ) , 'attribute' => $ this -> attribute , 'label' => $ this -> label , 'texture' => $ this -> getTexture ( ) , 'disabled' => $ this -> disabled ] ) ; if ( $ this -> wrap ) { return Html :: tag ( $ this -> wrapper , $ widgetHtml , $ this -> options ) ; } return $ widgetHtml ; }
227	public function getSchemaNames ( $ refresh = false ) { if ( $ this -> _schemaNames === null || $ refresh ) { $ this -> _schemaNames = $ this -> findSchemaNames ( ) ; } return $ this -> _schemaNames ; }
10791	public function register ( SilexApp $ app ) { $ app [ 'twig' ] = $ app -> share ( $ app -> extend ( 'twig' , function ( \ Twig_Environment $ twig , SilexApp $ app ) { $ class = $ this -> getServiceConfig ( ) -> getProviderClass ( ) ; $ twig -> addExtension ( new $ class ) ; return $ twig ; } ) ) ; }
10745	public function getObjectArray ( $ keys ) : array { return array_map ( function ( $ value ) { return $ this -> createObject ( $ value ) ; } , $ this -> getArray ( $ keys ) ) ; }
5266	public static function merge ( Model $ model1 , Model $ model2 , array $ attributes ) { foreach ( $ attributes as $ attribute ) { $ model1 -> $ attribute = $ model2 -> $ attribute ; } return $ model1 ; }
2935	public function backup ( ) { if ( ! is_file ( $ this -> filePath ) ) { throw new FileNotFoundException ( "File does not exist at path {$this->filePath}" ) ; return false ; } copy ( $ this -> filePath , $ this -> backupPath . self :: BACKUP_FILENAME_PREFIX . date ( 'Y_m_d_His' ) . self :: BACKUP_FILENAME_SUFFIX ) ; return $ this ; }
188	private function getColumnDefinition ( $ table , $ column ) { $ row = $ this -> db -> createCommand ( 'SHOW CREATE TABLE ' . $ this -> db -> quoteTableName ( $ table ) ) -> queryOne ( ) ; if ( $ row === false ) { throw new Exception ( "Unable to find column '$column' in table '$table'." ) ; } if ( isset ( $ row [ 'Create Table' ] ) ) { $ sql = $ row [ 'Create Table' ] ; } else { $ row = array_values ( $ row ) ; $ sql = $ row [ 1 ] ; } $ sql = preg_replace ( '/^[^(]+\((.*)\).*$/' , '\1' , $ sql ) ; $ sql = str_replace ( ', [' , ",\n[" , $ sql ) ; if ( preg_match_all ( '/^\s*\[(.*?)\]\s+(.*?),?$/m' , $ sql , $ matches ) ) { foreach ( $ matches [ 1 ] as $ i => $ c ) { if ( $ c === $ column ) { return $ matches [ 2 ] [ $ i ] ; } } } return null ; }
2217	public function getChannels ( ) { if ( ! $ this -> User -> isAdmin && ! \ is_array ( $ this -> User -> newsletters ) ) { return array ( ) ; } $ arrChannels = array ( ) ; $ objChannels = $ this -> Database -> execute ( "SELECT id, title FROM tl_newsletter_channel ORDER BY title" ) ; while ( $ objChannels -> next ( ) ) { if ( $ this -> User -> hasAccess ( $ objChannels -> id , 'newsletters' ) ) { $ arrChannels [ $ objChannels -> id ] = $ objChannels -> title ; } } return $ arrChannels ; }
2444	public static function decrypt ( $ varValue , $ strKey = null ) { if ( \ is_array ( $ varValue ) ) { foreach ( $ varValue as $ k => $ v ) { $ varValue [ $ k ] = static :: decrypt ( $ v ) ; } return $ varValue ; } elseif ( $ varValue == '' ) { return '' ; } if ( static :: $ resTd === null ) { static :: initialize ( ) ; } $ varValue = base64_decode ( $ varValue ) ; $ ivsize = mcrypt_enc_get_iv_size ( static :: $ resTd ) ; $ iv = substr ( $ varValue , 0 , $ ivsize ) ; $ varValue = substr ( $ varValue , $ ivsize ) ; if ( $ varValue == '' ) { return '' ; } if ( ! $ strKey ) { $ strKey = System :: getContainer ( ) -> getParameter ( 'contao.encryption_key' ) ; } mcrypt_generic_init ( static :: $ resTd , md5 ( $ strKey ) , $ iv ) ; $ strDecrypted = mdecrypt_generic ( static :: $ resTd , $ varValue ) ; mcrypt_generic_deinit ( static :: $ resTd ) ; return $ strDecrypted ; }
898	private function isOfLowerPrecedence ( Token $ token ) { static $ tokens ; if ( null === $ tokens ) { $ tokens = [ T_AND_EQUAL , T_BOOLEAN_AND , T_BOOLEAN_OR , T_CASE , T_CONCAT_EQUAL , T_DIV_EQUAL , T_DOUBLE_ARROW , T_GOTO , T_LOGICAL_AND , T_LOGICAL_OR , T_LOGICAL_XOR , T_MINUS_EQUAL , T_MUL_EQUAL , T_OR_EQUAL , T_PLUS_EQUAL , T_RETURN , T_SL_EQUAL , T_SR_EQUAL , T_THROW , T_XOR_EQUAL , T_ECHO , T_PRINT , T_OPEN_TAG , T_OPEN_TAG_WITH_ECHO , ] ; if ( \ defined ( 'T_POW_EQUAL' ) ) { $ tokens [ ] = T_POW_EQUAL ; } if ( \ defined ( 'T_COALESCE' ) ) { $ tokens [ ] = T_COALESCE ; } } static $ otherTokens = [ '&' , '|' , '^' , '?' , ':' , '=' , ',' , ';' , ] ; return $ token -> isGivenKind ( $ tokens ) || $ token -> equalsAny ( $ otherTokens ) ; }
23	public function removePackage ( PackageInterface $ package ) { $ packageId = $ package -> getUniqueName ( ) ; foreach ( $ this -> getPackages ( ) as $ key => $ repoPackage ) { if ( $ packageId === $ repoPackage -> getUniqueName ( ) ) { array_splice ( $ this -> packages , $ key , 1 ) ; return ; } } }
3143	public function timeout ( RunnerServiceContext $ context , $ scope , $ ref , $ late = false ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ session = $ context -> getTestSession ( ) ; if ( $ context -> isAdaptive ( ) ) { \ common_Logger :: t ( "Select next item before timeout" ) ; $ context -> selectAdaptiveNextItem ( ) ; } try { $ session -> closeTimer ( $ ref , $ scope ) ; if ( $ late ) { if ( $ scope == 'assessmentTest' ) { $ code = AssessmentTestSessionException :: ASSESSMENT_TEST_DURATION_OVERFLOW ; } else if ( $ scope == 'testPart' ) { $ code = AssessmentTestSessionException :: TEST_PART_DURATION_OVERFLOW ; } else if ( $ scope == 'assessmentSection' ) { $ code = AssessmentTestSessionException :: ASSESSMENT_SECTION_DURATION_OVERFLOW ; } else { $ code = AssessmentTestSessionException :: ASSESSMENT_ITEM_DURATION_OVERFLOW ; } throw new AssessmentTestSessionException ( "Maximum duration of ${scope} '${ref}' not respected." , $ code ) ; } else { $ session -> checkTimeLimits ( false , true , false ) ; } } catch ( AssessmentTestSessionException $ e ) { $ this -> onTimeout ( $ context , $ e ) ; } } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'timeout' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return true ; }
6242	public function reload ( ) : self { if ( $ this -> loaded === false ) { return $ this ; } clearstatcache ( false , $ this -> raw ) ; $ this -> loaded = false ; return $ this ; }
8581	public function setPrepInstruction ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'PrepInstruction' ] [ 'FieldValue' ] = $ value ; return $ this ; }
8045	public static function select ( array $ readSockets = array ( ) , array $ writeSockets = array ( ) , array $ exceptSockets = array ( ) , $ sec = 0 , $ usec = 0 ) { $ out = array ( ) ; $ out [ 'read' ] = array ( ) ; $ out [ 'write' ] = array ( ) ; $ out [ 'except' ] = array ( ) ; if ( count ( $ readSockets ) === 0 ) { return $ out ; } $ readSocketsResources = array ( ) ; $ writeSocketsResources = array ( ) ; $ exceptSocketsResources = array ( ) ; $ readSockets = self :: createSocketsIndex ( $ readSockets , $ readSocketsResources ) ; $ writeSockets = self :: createSocketsIndex ( $ writeSockets , $ writeSocketsResources ) ; $ exceptSockets = self :: createSocketsIndex ( $ exceptSockets , $ exceptSocketsResources ) ; $ socketsSelected = @ socket_select ( $ readSocketsResources , $ writeSocketsResources , $ exceptSocketsResources , $ sec , $ usec ) ; if ( $ socketsSelected === FALSE ) { $ socketError = socket_last_error ( ) ; if ( $ socketError === SOCKET_EINTR ) { socket_clear_error ( ) ; $ socketsSelected = socket_select ( $ readSocketsResources , $ writeSocketsResources , $ exceptSocketsResources , $ sec , $ usec ) ; if ( $ socketsSelected === FALSE ) { return $ out ; } } else { trigger_error ( sprintf ( 'socket_select(): unable to select [%d]: %s' , $ socketError , socket_strerror ( $ socketError ) ) , E_USER_WARNING ) ; return $ out ; } } foreach ( $ readSocketsResources as $ socketResource ) { $ out [ 'read' ] [ ] = $ readSockets [ intval ( $ socketResource ) ] ; } foreach ( $ writeSocketsResources as $ socketResource ) { $ out [ 'write' ] [ ] = $ writeSockets [ intval ( $ socketResource ) ] ; } foreach ( $ exceptSocketsResources as $ socketResource ) { $ out [ 'except' ] [ ] = $ exceptSockets [ intval ( $ socketResource ) ] ; } return $ out ; }
7197	protected function setIsFirst ( OrderInterface $ order ) { if ( null !== $ customer = $ order -> getCustomer ( ) ) { if ( $ customer -> hasParent ( ) ) { $ customer = $ customer -> getParent ( ) ; } $ first = ! $ this -> orderRepository -> existsForCustomer ( $ customer ) ; } else { $ first = ! $ this -> orderRepository -> existsForEmail ( $ order -> getEmail ( ) ) ; } if ( $ first != $ order -> isFirst ( ) ) { $ order -> setFirst ( $ first ) ; return true ; } return false ; }
9673	private function writeNumFmt ( XMLWriter $ objWriter , NumberFormat $ pNumberFormat , $ pId = 0 ) { $ formatCode = $ pNumberFormat -> getFormatCode ( ) ; if ( $ formatCode !== null ) { $ objWriter -> startElement ( 'numFmt' ) ; $ objWriter -> writeAttribute ( 'numFmtId' , ( $ pId + 164 ) ) ; $ objWriter -> writeAttribute ( 'formatCode' , $ formatCode ) ; $ objWriter -> endElement ( ) ; } }
3055	public function getLastCatItemOutput ( ) { $ sessionId = $ this -> getTestSession ( ) -> getSessionId ( ) ; $ itemOutput = $ this -> getServiceManager ( ) -> get ( ExtendedStateService :: SERVICE_ID ) -> getCatValue ( $ sessionId , $ this -> getCatSection ( ) -> getSectionId ( ) , 'cat-item-output' ) ; $ output = [ ] ; if ( ! is_null ( $ itemOutput ) ) { $ rawData = json_decode ( $ itemOutput , true ) ; foreach ( $ rawData as $ result ) { $ itemResult = ItemResult :: restore ( $ result ) ; $ output [ $ itemResult -> getItemRefId ( ) ] = $ itemResult ; } } return $ output ; }
10651	public function validateCreate ( ) { $ validator = $ this -> getValidator ( 'create' ) ; if ( $ validator -> fails ( ) ) { $ this -> errors = $ validator -> messages ( ) ; return false ; } return true ; }
1406	protected function getDefaultAttributes ( Model $ model ) { $ defaults = [ ] ; if ( $ this -> hasCreatedAtAttribute ( $ model ) ) { $ createdAt = $ model -> getCreatedAtColumn ( ) ; $ field = $ this -> fieldForAttribute ( $ createdAt ) ; $ defaults [ $ field ] = $ this -> extractAttribute ( $ model , $ createdAt , $ field ) ; } if ( $ this -> hasUpdatedAtAttribute ( $ model ) ) { $ updatedAt = $ model -> getUpdatedAtColumn ( ) ; $ field = $ this -> fieldForAttribute ( $ updatedAt ) ; $ defaults [ $ field ] = $ this -> extractAttribute ( $ model , $ updatedAt , $ field ) ; } if ( $ this -> hasDeletedAtAttribute ( $ model ) ) { $ deletedAt = $ model -> getDeletedAtColumn ( ) ; $ field = $ this -> fieldForAttribute ( $ deletedAt ) ; $ defaults [ $ field ] = $ this -> extractAttribute ( $ model , $ deletedAt , $ field ) ; } return $ defaults ; }
3183	private function durationToMs ( $ duration ) { if ( ! is_null ( $ duration ) && $ duration instanceof QtiDuration ) { return TestRunnerUtils :: getDurationWithMicroseconds ( $ duration ) ; } return false ; }
5560	public function recordEntry ( $ url , $ parameters ) { $ this -> dropFuture ( ) ; array_push ( $ this -> sequence , array ( 'url' => $ url , 'parameters' => $ parameters ) ) ; $ this -> position ++ ; }
6898	public function delete ( ... $ args ) { $ this -> open ( ) ; foreach ( $ args as $ key ) { unset ( $ this -> _data [ $ key ] ) ; } return $ this ; }
2736	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ countries = $ this -> countryHelper -> toOptionArray ( ) ; if ( ! $ countries ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Could not fetch list countries.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'countries' => $ countries ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
4041	public function render ( ModelToLabelEvent $ event ) { $ environment = $ event -> getEnvironment ( ) ; $ definition = $ environment -> getDataDefinition ( ) ; $ viewSection = $ definition -> getDefinition ( Contao2BackendViewDefinitionInterface :: NAME ) ; $ listing = $ viewSection -> getListingConfig ( ) ; $ model = $ event -> getModel ( ) ; if ( ! ( $ model instanceof Model ) ) { return ; } $ nativeItem = $ model -> getItem ( ) ; $ metaModel = $ nativeItem -> getMetaModel ( ) ; $ renderSetting = $ this -> renderSettingFactory -> createCollection ( $ metaModel , $ definition -> getMetaModelDefinition ( ) -> getActiveRenderSetting ( ) ) ; if ( ! $ renderSetting ) { return ; } $ data = array ( $ nativeItem -> parseValue ( 'html5' , $ renderSetting ) ) ; if ( $ listing -> getShowColumns ( ) ) { $ event -> setArgs ( $ data [ 0 ] [ 'html5' ] ) ; return ; } $ template = new Template ( $ renderSetting -> get ( 'template' ) ) ; $ renderSetting = self :: removeInvariantAttributes ( $ nativeItem , $ renderSetting ) ; $ template -> setData ( array ( 'settings' => $ renderSetting , 'items' => new Items ( array ( $ nativeItem ) ) , 'view' => $ renderSetting , 'data' => $ data ) ) ; $ event -> setLabel ( '%s' ) -> setArgs ( array ( $ template -> parse ( 'html5' ) ) ) ; }
9980	private function writeComment ( XMLWriter $ objWriter , $ pCellReference , Comment $ pComment , array $ pAuthors ) { $ objWriter -> startElement ( 'comment' ) ; $ objWriter -> writeAttribute ( 'ref' , $ pCellReference ) ; $ objWriter -> writeAttribute ( 'authorId' , $ pAuthors [ $ pComment -> getAuthor ( ) ] ) ; $ objWriter -> startElement ( 'text' ) ; $ this -> getParentWriter ( ) -> getWriterPart ( 'stringtable' ) -> writeRichText ( $ objWriter , $ pComment -> getText ( ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; }
1591	protected function validateData ( ) : bool { if ( ! property_exists ( $ this -> document , 'data' ) ) { $ this -> memberRequired ( '/' , 'data' ) ; return false ; } $ data = $ this -> document -> data ; if ( ! is_object ( $ data ) ) { $ this -> memberNotObject ( '/' , 'data' ) ; return false ; } return true ; }
4309	public function getChannel ( $ channelName , $ config = array ( ) ) { if ( \ strpos ( $ channelName , '.' ) !== false ) { $ this -> error ( 'getChannel(): channelName should not contain period (.)' ) ; return $ this ; } if ( ! isset ( $ this -> channels [ $ channelName ] ) ) { $ cfg = $ this -> getCfg ( ) ; $ cfg = \ array_diff_key ( $ cfg , \ array_flip ( array ( 'errorEmailer' , 'errorHandler' , 'output' , ) ) ) ; unset ( $ cfg [ 'debug' ] [ 'onBootstrap' ] ) ; $ cfg [ 'debug' ] [ 'channel' ] = $ this -> parentInstance ? $ this -> cfg [ 'channel' ] . '.' . $ channelName : $ channelName ; $ cfg [ 'debug' ] [ 'parent' ] = $ this ; $ this -> channels [ $ channelName ] = new static ( $ cfg ) ; if ( $ config ) { $ this -> channels [ $ channelName ] -> setCfg ( $ config ) ; } } return $ this -> channels [ $ channelName ] ; }
8006	public static function forReasonCode ( $ code = 0 , Exception $ previous = null ) { switch ( $ code ) { case self :: CODE_FOR_ENCRYPTION_FAILURE : $ message = self :: MESSAGE_FOR_ENCRYPTION_FAILURE ; break ; case self :: CODE_FOR_RANDOM_DATA_GENERATION_FAILURE : $ message = self :: MESSAGE_FOR_RANDOM_DATA_GENERATION_FAILURE ; break ; default : $ message = self :: DEFAULT_MESSAGE ; } return new static ( $ message , $ code , $ previous ) ; }
1792	private function addHostToContext ( RequestContext $ context , array $ parameters , int & $ referenceType ) : void { [ $ host , $ port ] = $ this -> getHostAndPort ( $ parameters [ '_domain' ] ) ; if ( $ context -> getHost ( ) === $ host ) { return ; } $ context -> setHost ( $ host ) ; $ referenceType = UrlGeneratorInterface :: ABSOLUTE_URL ; if ( ! $ port ) { return ; } if ( isset ( $ parameters [ '_ssl' ] ) && true === $ parameters [ '_ssl' ] ) { $ context -> setHttpsPort ( $ port ) ; } else { $ context -> setHttpPort ( $ port ) ; } }
5158	public static function create ( array $ data ) : \ One \ Model \ Gallery { $ body = self :: validateString ( ( string ) self :: checkData ( $ data , 'body' , '' ) ) ; $ order = self :: validateInteger ( ( int ) self :: checkData ( $ data , 'order' , null ) ) ; $ photo = self :: validateUrl ( ( string ) self :: checkData ( $ data , 'photo' , '' ) ) ; $ source = self :: validateUrl ( ( string ) self :: checkData ( $ data , 'source' , '' ) ) ; $ lead = self :: validateString ( ( string ) self :: checkData ( $ data , 'lead' , '' ) ) ; return self :: createGallery ( $ body , $ order , $ photo , $ source , $ lead ) ; }
1114	protected static function boot ( ) { parent :: boot ( ) ; static :: creating ( function ( $ node ) { $ node -> setDefaultLeftAndRight ( ) ; } ) ; static :: saving ( function ( $ node ) { $ node -> storeNewParent ( ) ; } ) ; static :: saved ( function ( $ node ) { $ node -> moveToNewParent ( ) ; $ node -> setDepth ( ) ; } ) ; static :: deleting ( function ( $ node ) { $ node -> destroyDescendants ( ) ; } ) ; if ( static :: softDeletesEnabled ( ) ) { static :: restoring ( function ( $ node ) { $ node -> shiftSiblingsForRestore ( ) ; } ) ; static :: restored ( function ( $ node ) { $ node -> restoreDescendants ( ) ; } ) ; } }
1807	public function storeDateAdded ( $ dc ) { if ( ! $ dc instanceof Contao \ DataContainer ) { return ; } if ( ! $ dc -> activeRecord || $ dc -> activeRecord -> dateAdded > 0 ) { return ; } if ( $ dc -> activeRecord -> lastLogin > 0 ) { $ time = $ dc -> activeRecord -> lastLogin ; } else { $ time = time ( ) ; } $ this -> Database -> prepare ( "UPDATE tl_member SET dateAdded=? WHERE id=?" ) -> execute ( $ time , $ dc -> id ) ; }
296	public function isAttributeChanged ( $ name , $ identical = true ) { if ( isset ( $ this -> _attributes [ $ name ] , $ this -> _oldAttributes [ $ name ] ) ) { if ( $ identical ) { return $ this -> _attributes [ $ name ] !== $ this -> _oldAttributes [ $ name ] ; } return $ this -> _attributes [ $ name ] != $ this -> _oldAttributes [ $ name ] ; } return isset ( $ this -> _attributes [ $ name ] ) || isset ( $ this -> _oldAttributes [ $ name ] ) ; }
7052	public function logoutCurrentUser ( ) { $ this -> getAuthGuard ( ) -> logout ( ) ; \ Session :: remove ( $ this -> originalUserFromLoginAsActionSessionKey ) ; \ Session :: invalidate ( ) ; $ this -> getCmfConfig ( ) -> resetLocale ( ) ; }
7946	public function getLineProperties ( $ id , $ line ) { if ( ! $ id ) throw new BadMethodCallException ( 'Missing parameter $id.' ) ; if ( ! $ line ) throw new BadMethodCallException ( 'Missing parameter $line.' ) ; try { $ r = $ this -> get ( 'xdsl/' . $ id . '/lines/' . $ line ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new XdslException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
5754	protected function setIndexFilter ( Request $ request , Response $ response , $ args , array $ listViewColumns , AdminListView $ view ) { $ this -> setRequestInput ( $ request , [ $ view -> getSessionFilterFieldKey ( ) ] ) ; if ( ! isset ( $ this -> requestInput [ $ view -> getSessionFilterFieldKey ( ) ] ) ) { throw new \ Exception ( "session filter input must be set" ) ; } $ this -> storeFilterFieldValueInSession ( $ view ) ; if ( null !== $ filterColumnsInfo = $ this -> getFilterColumns ( $ view -> getSessionFilterFieldKey ( ) , $ listViewColumns ) ) { $ this -> storeFilterColumnsInfoInSession ( $ filterColumnsInfo , $ view ) ; } }
5202	public function open ( ) { try { $ additionalConnectionOptions = array ( ) ; foreach ( array ( 'connection_timeout' , 'read_write_timeout' , 'keepalive' , 'heartbeat' ) as $ option ) { if ( isset ( $ this -> $ option ) ) { $ additionalConnectionOptions [ $ option ] = $ this -> $ option ; } } $ this -> AMQPConnection = new AMQPSSLConnection ( $ this -> host , $ this -> port , $ this -> username , $ this -> password , $ this -> vhost , $ this -> ssl_context_options , $ additionalConnectionOptions ) ; $ this -> channel = $ this -> AMQPConnection -> channel ( ) ; $ this -> channel -> queue_declare ( $ this -> queue_name , false , false , false , false ) ; $ this -> channel -> exchange_declare ( $ this -> exchange , $ this -> exchange_type , false , true , false ) ; $ this -> channel -> queue_bind ( $ this -> queue_name , $ this -> exchange ) ; } catch ( Exception $ e ) { throw new Exception ( $ e ) ; } }
6994	public function prePersist ( UploadableInterface $ uploadable ) { if ( ! $ this -> enabled ) { return ; } $ uploadable -> setCreatedAt ( new \ DateTime ( ) ) -> setUpdatedAt ( new \ DateTime ( ) ) ; $ this -> uploader -> prepare ( $ uploadable ) ; }
10631	public static function avgload ( ) { $ avgload = new \ StdClass ( ) ; if ( false !== ( $ data = @ file ( '/proc/loadavg' ) ) ) { $ data = explode ( " " , implode ( "" , $ data ) ) ; $ data = array_chunk ( $ data , 4 ) ; $ avgload -> min1 = $ data [ 0 ] [ 0 ] ; $ avgload -> min5 = $ data [ 0 ] [ 1 ] ; $ avgload -> min15 = $ data [ 0 ] [ 2 ] ; $ fourth = explode ( '/' , $ data [ 0 ] [ 3 ] ) ; $ avgload -> running = $ fourth [ 0 ] ; $ avgload -> exists = $ fourth [ 1 ] ; $ avgload -> recentPID = $ data [ 1 ] [ 0 ] ; } return $ avgload ; }
6412	public static function all ( IteratorAggregate $ iterable , callable $ predicate ) : bool { return Iterators :: all ( Iterators :: from ( $ iterable -> getIterator ( ) ) , $ predicate ) ; }
3779	protected function getParameterFilterOptions ( $ objAttribute , $ arrIds , & $ arrCount = null ) { $ arrOptions = $ objAttribute -> getFilterOptions ( $ this -> get ( 'onlypossible' ) ? $ arrIds : null , ( bool ) $ this -> get ( 'onlyused' ) , $ arrCount ) ; foreach ( $ arrOptions as $ mixOptionKey => $ mixOptions ) { $ mixOptions = strip_tags ( $ mixOptions ) ; $ mixOptions = trim ( $ mixOptions ) ; if ( $ mixOptions === '' || $ mixOptions === null ) { unset ( $ arrOptions [ $ mixOptionKey ] ) ; } } return $ arrOptions ; }
5168	private function convertNonAscii ( string $ string ) : string { $ search = $ replace = [ ] ; $ search [ ] = chr ( 226 ) . chr ( 128 ) . chr ( 152 ) ; $ replace [ ] = "'" ; $ search [ ] = chr ( 226 ) . chr ( 128 ) . chr ( 153 ) ; $ replace [ ] = "'" ; $ search [ ] = chr ( 226 ) . chr ( 128 ) . chr ( 156 ) ; $ replace [ ] = '"' ; $ search [ ] = chr ( 226 ) . chr ( 128 ) . chr ( 157 ) ; $ replace [ ] = '"' ; $ search [ ] = chr ( 226 ) . chr ( 128 ) . chr ( 147 ) ; $ replace [ ] = '--' ; $ search [ ] = chr ( 226 ) . chr ( 128 ) . chr ( 148 ) ; $ replace [ ] = '---' ; $ search [ ] = chr ( 226 ) . chr ( 128 ) . chr ( 162 ) ; $ replace [ ] = '*' ; $ search [ ] = chr ( 194 ) . chr ( 183 ) ; $ replace [ ] = '*' ; $ search [ ] = chr ( 226 ) . chr ( 128 ) . chr ( 166 ) ; $ replace [ ] = '...' ; $ string = str_replace ( $ search , $ replace , $ string ) ; return preg_replace ( "/[^\x01-\x7F]/" , '' , $ string ) ; }
5178	public function filter ( \ Closure $ callback ) : self { $ collection = new static ( ) ; foreach ( $ this -> props as $ key => $ value ) { if ( $ callback ( $ value , $ key ) ) { $ collection -> add ( $ key , $ value ) ; } } return $ collection ; }
8216	private function getNextJob ( $ tube , $ state ) { if ( 'ready' == $ this -> state ) { return $ this -> reserveJob ( $ tube ) ; } return $ this -> peekJob ( $ tube , $ state ) ; }
1482	public function encoder ( $ options = 0 , $ depth = 512 ) { if ( $ options instanceof Encoding ) { $ options = $ options -> getOptions ( ) ; } if ( ! $ options instanceof EncoderOptions ) { $ options = new EncoderOptions ( $ options , $ this -> getUrl ( ) -> toString ( ) , $ depth ) ; } return $ this -> factory -> createEncoder ( $ this -> getContainer ( ) , $ options ) ; }
1980	public static function generateUnwrapped ( $ strScope = TL_MODE , $ blnRaw = false ) { $ session = System :: getContainer ( ) -> get ( 'session' ) ; if ( ! $ session -> isStarted ( ) ) { return '' ; } $ strMessages = '' ; $ flashBag = $ session -> getFlashBag ( ) ; foreach ( static :: getTypes ( ) as $ strType ) { $ strClass = strtolower ( $ strType ) ; $ arrMessages = $ flashBag -> get ( static :: getFlashBagKey ( $ strType , $ strScope ) ) ; foreach ( array_unique ( $ arrMessages ) as $ strMessage ) { if ( $ strType == 'TL_RAW' || $ blnRaw ) { $ strMessages .= $ strMessage ; } else { $ strMessages .= '<p class="' . $ strClass . '">' . $ strMessage . '</p>' ; } } } return trim ( $ strMessages ) ; }
2062	public function generateArticle ( Contao \ DataContainer $ dc ) { if ( ! $ dc -> activeRecord ) { return ; } if ( $ dc -> activeRecord -> title == '' || ! \ in_array ( $ dc -> activeRecord -> type , array ( 'regular' , 'error_401' , 'error_403' , 'error_404' ) ) ) { return ; } $ objSessionBag = Contao \ System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; $ new_records = $ objSessionBag -> get ( 'new_records' ) ; if ( ! $ new_records || ! \ is_array ( $ new_records [ $ dc -> table ] ) || ! \ in_array ( $ dc -> id , $ new_records [ $ dc -> table ] ) ) { return ; } $ objTotal = $ this -> Database -> prepare ( "SELECT COUNT(*) AS count FROM tl_article WHERE pid=?" ) -> execute ( $ dc -> id ) ; if ( $ objTotal -> count > 0 ) { return ; } $ arrSet [ 'pid' ] = $ dc -> id ; $ arrSet [ 'sorting' ] = 128 ; $ arrSet [ 'tstamp' ] = time ( ) ; $ arrSet [ 'author' ] = $ this -> User -> id ; $ arrSet [ 'inColumn' ] = 'main' ; $ arrSet [ 'title' ] = $ dc -> activeRecord -> title ; $ arrSet [ 'alias' ] = str_replace ( '/' , '-' , $ dc -> activeRecord -> alias ) ; $ arrSet [ 'published' ] = $ dc -> activeRecord -> published ; $ this -> Database -> prepare ( "INSERT INTO tl_article %s" ) -> set ( $ arrSet ) -> execute ( ) ; }
1131	public function inSameScope ( $ other ) { foreach ( $ this -> getScopedColumns ( ) as $ fld ) { if ( $ this -> $ fld != $ other -> $ fld ) return false ; } return true ; }
8687	public static function replaceRecursive ( $ iterable1 , $ iterable2 ) { Assert :: allIsIterable ( [ $ iterable1 , $ iterable2 ] ) ; if ( $ iterable1 instanceof Traversable ) { $ iterable1 = iterator_to_array ( $ iterable1 ) ; } if ( $ iterable2 instanceof Traversable ) { $ iterable2 = iterator_to_array ( $ iterable2 ) ; } $ merged = $ iterable1 ; foreach ( $ iterable2 as $ key => $ value ) { if ( $ value instanceof Traversable ) { $ value = iterator_to_array ( $ value ) ; } if ( is_array ( $ value ) && static :: isAssociative ( $ value ) && isset ( $ merged [ $ key ] ) && \ is_iterable ( $ merged [ $ key ] ) ) { $ merged [ $ key ] = static :: replaceRecursive ( $ merged [ $ key ] , $ value ) ; } elseif ( $ value === null && isset ( $ merged [ $ key ] ) && \ is_iterable ( $ merged [ $ key ] ) ) { if ( $ merged [ $ key ] instanceof Traversable ) { $ merged [ $ key ] = iterator_to_array ( $ merged [ $ key ] ) ; } continue ; } else { $ merged [ $ key ] = $ value ; } } return $ merged ; }
202	private function queryValueExists ( $ query , $ value ) { if ( is_array ( $ value ) ) { return $ query -> count ( "DISTINCT [[$this->targetAttribute]]" ) == count ( $ value ) ; } return $ query -> exists ( ) ; }
3602	public function isDebug ( ) { if ( null !== $ this -> container && $ this -> container -> has ( 'kernel' ) ) { return $ this -> container -> get ( 'kernel' ) -> isDebug ( ) ; } return true ; }
10876	public function processApprove ( string $ hash ) : bool { $ decode = $ this -> getDecodeHash ( $ hash ) ; $ id = ( int ) $ decode [ 'id' ] ; $ verifyHash = $ decode [ 'verifyHash' ] ; $ item = $ this -> getById ( $ id ) ; if ( $ item && $ id == $ item [ 'id' ] ) { if ( ! $ item [ 'active' ] ) { if ( $ this -> verifyHash ( $ item [ 'id' ] . $ item [ 'login' ] , $ verifyHash ) ) { return $ this -> update ( $ item [ 'id' ] , [ 'active' => true ] ) ; } else { throw new IdentityException ( 'Invalid hash!' ) ; } } else { throw new IdentityException ( 'User is already approve!' ) ; } } else { throw new IdentityException ( 'User does not exist!' ) ; } }
8122	public function getReviewContentForm ( $ id ) { $ page = $ this -> findRecord ( [ 'ID' => $ id ] ) ; $ user = Security :: getCurrentUser ( ) ; if ( ! $ page -> canEdit ( ) || ( $ page -> hasMethod ( 'canBeReviewedBy' ) && ! $ page -> canBeReviewedBy ( $ user ) ) ) { $ this -> owner -> httpError ( 403 , _t ( __CLASS__ . '.ErrorItemPermissionDenied' , 'It seems you don\'t have the necessary permissions to review this content' ) ) ; return null ; } $ form = $ this -> getReviewContentHandler ( ) -> Form ( $ page ) ; $ form -> setValidationResponseCallback ( function ( ValidationResult $ errors ) use ( $ form , $ id ) { $ schemaId = $ this -> owner -> join_links ( $ this -> owner -> Link ( 'schema/ReviewContentForm' ) , $ id ) ; return $ this -> getSchemaResponse ( $ schemaId , $ form , $ errors ) ; } ) ; return $ form ; }
744	private function getFragmentCacheConfiguration ( ) { $ cache = $ this -> getCacheInstance ( ) ; $ fragmentCacheConfiguration = [ 'cache' => $ cache , 'duration' => $ this -> cacheDuration , 'dependency' => $ this -> cacheDependency , 'enabled' => $ this -> cacheEnabled , ] ; return $ fragmentCacheConfiguration ; }
6822	protected function getGoodAccountNumber ( TaxRuleInterface $ rule , float $ rate , string $ origin ) { foreach ( $ this -> accounts as $ account ) { if ( $ account -> getType ( ) !== AccountingTypes :: TYPE_GOOD ) { continue ; } if ( $ account -> getTaxRule ( ) !== $ rule ) { continue ; } if ( is_null ( $ account -> getTax ( ) ) ) { if ( $ rate == 0 ) { return $ account -> getNumber ( ) ; } continue ; } if ( 0 === bccomp ( $ account -> getTax ( ) -> getRate ( ) , $ rate , 5 ) ) { return $ account -> getNumber ( ) ; } } throw new LogicException ( sprintf ( "No goods account number configured for tax rule '%s' and tax rate %s (%s)" , $ rule -> getName ( ) , $ rate , $ origin ) ) ; }
869	private function createProcessForSource ( $ source ) { if ( null === $ this -> temporaryFile ) { $ this -> temporaryFile = tempnam ( '.' , 'cs_fixer_tmp_' ) ; $ this -> fileRemoval -> observe ( $ this -> temporaryFile ) ; } if ( false === @ file_put_contents ( $ this -> temporaryFile , $ source ) ) { throw new IOException ( sprintf ( 'Failed to write file "%s".' , $ this -> temporaryFile ) , 0 , null , $ this -> temporaryFile ) ; } return $ this -> createProcessForFile ( $ this -> temporaryFile ) ; }
4621	public function buildJsonObject ( $ data ) { $ this -> object = new RObject ( ) ; $ this -> object -> setData ( $ data ) ; $ this -> object -> setContentType ( Http :: CONTENT_TYPE_JSON ) ; return $ this ; }
4811	public function create ( ) { $ language = new ExpressionLanguage ( ) ; foreach ( $ this -> providers as $ provider ) { $ language -> registerProvider ( $ provider ) ; } return $ language ; }
1411	public function resourceIdNotSupported ( string $ id , string $ path = '/data' ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_CONFLICT , $ this -> trans ( 'resource_id_not_supported' , 'code' ) , $ this -> trans ( 'resource_id_not_supported' , 'title' ) , $ this -> trans ( 'resource_id_not_supported' , 'detail' , compact ( 'id' ) ) , $ this -> pointer ( $ path , 'id' ) ) ; }
3035	protected function exists ( $ key ) { return isset ( $ this -> cache [ $ key ] ) && in_array ( $ this -> cache [ $ key ] [ 'state' ] , [ self :: STATE_ALIGNED , self :: STATE_PENDING_WRITE ] ) ; }
7403	public static function reload ( $ file , $ rangePath = null ) { if ( ! empty ( $ rangePath ) ) { self :: $ rangePath = $ rangePath ; } if ( PHP_SAPI === 'cli' ) { $ cilpath = realpath ( dirname ( dirname ( dirname ( dirname ( __FILE__ ) ) ) ) ) . '/config/' ; $ file = $ cilpath . $ file . '.' . self :: $ format ; } else { $ file = self :: $ rangePath . $ file . '.' . self :: $ format ; } $ name = strtolower ( $ file ) ; $ type = pathinfo ( $ file , PATHINFO_EXTENSION ) ; if ( self :: $ format == $ type ) return self :: set ( include $ file ) ; }
9685	public function setStorage ( $ storage , $ options = null ) { if ( ! $ storage instanceof Storage \ StorageInterface ) { $ storage = $ this -> getStoragePluginManager ( ) -> get ( $ storage , $ options ) ; } $ this -> storage = $ storage ; return $ this ; }
5302	public static function unicodeToHex ( $ char ) { if ( ! is_string ( $ char ) || mb_strlen ( $ char , 'utf-8' ) !== 1 ) { throw new \ InvalidArgumentException ( '$char must be one single character' ) ; } $ unicode = unpack ( 'N' , mb_convert_encoding ( $ char , 'UCS-4BE' , 'UTF-8' ) ) ; return dechex ( $ unicode [ 1 ] ) ; }
1357	public function field ( string $ field , string $ inverse = null ) : self { $ this -> defaults = array_merge ( $ this -> defaults , [ ResourceRegistrar :: PARAM_RELATIONSHIP_NAME => $ field , ResourceRegistrar :: PARAM_RELATIONSHIP_INVERSE_TYPE => $ inverse ? : Str :: plural ( $ field ) , ] ) ; return $ this ; }
12169	private function createPropertyValuesTable ( ) { $ this -> database -> query ( "DROP TABLE IF EXISTS `?property_values`;" ) ; $ this -> database -> query ( "CREATE TABLE IF NOT EXISTS `?property_values` ( `value_id` mediumint(11) NOT NULL AUTO_INCREMENT, `value_data` text NOT NULL, `value_updated_on` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP, `property_id` int(11) NOT NULL, `object_id` int(11) NOT NULL, PRIMARY KEY (`value_id`), UNIQUE KEY `object_property_uid` (`object_id`,`property_id`), KEY `property_id_idxfk` (`property_id`), KEY `object_id_idxfk` (`object_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8;" ) ; $ this -> database -> query ( "DROP PROCEDURE IF EXISTS `property_value_validate`;" ) ; $ this -> database -> query ( "CREATE PROCEDURE `?property_value_validate`(IN _property_id INT, IN _value_data LONGTEXT) BEGIN DECLARE _validationFails CONDITION FOR SQLSTATE '99001'; DECLARE _dataTypeRegExp VARCHAR(255); DECLARE _signalText TEXT; SELECT r.datatype_validation FROM `?properties` AS d INNER JOIN `?property_datatypes` AS r WHERE `property_id`= _property_id AND d.property_datatype=r.datatype_name INTO _dataTypeRegExp; IF (_dataTypeRegExp IS NOT NULL) THEN IF (_value_data NOT REGEXP(_dataTypeRegExp)) THEN SET _signalText = CONCAT('The inserted/updated value fails the property data type validation'); SIGNAL _validationFails SET MESSAGE_TEXT=_signalText; END IF; END IF; END;" ) ; $ this -> database -> query ( "DROP TRIGGER IF EXISTS `?property_value_validate_insert`;" ) ; $ this -> database -> query ( "CREATE TRIGGER `?property_value_validate_insert` BEFORE INSERT ON `?property_values` FOR EACH ROW BEGIN CALL ?property_value_validate(NEW.property_id, NEW.value_data); END;" ) ; $ this -> database -> query ( "DROP TRIGGER IF EXISTS `?property_value_validate_update`;" ) ; $ this -> database -> query ( "CREATE TRIGGER `?property_value_validate_update` BEFORE UPDATE ON `?property_values` FOR EACH ROW BEGIN CALL ?property_value_validate(NEW.property_id, NEW.value_data); END;" ) ; }
7836	protected function deleteAllFilesOfWorkflowIfForced ( $ workflow ) { $ files = $ this -> pipelines -> getPipesByPipeline ( $ workflow ) ; $ files [ ] = $ this -> inflector -> getRequest ( ) ; $ files [ ] = $ this -> inflector -> getJob ( ) ; $ this -> deleteIfForced ( $ files ) ; }
11690	protected function processAuth ( string $ actionName , array $ actionArgs ) : void { $ callAction = function ( string $ actionName , array $ actionArgs ) { if ( empty ( $ actionArgs ) ) { $ this -> ctrl -> { $ actionName } ( ) ; } else { ( new \ ReflectionMethod ( $ this -> ctrl , $ actionName ) ) -> invokeArgs ( $ this -> ctrl , $ actionArgs ) ; } } ; if ( class_exists ( '\extensions\core\Auth' ) ) { $ auth = new \ extensions \ core \ Auth ( $ this -> ctrl -> getRequest ( ) ) ; $ auth -> run ( ) ; if ( $ auth -> isValid ( ) ) { $ callAction ( $ actionName , $ actionArgs ) ; } else { $ auth -> onFail ( ) ; } } else { $ callAction ( $ actionName , $ actionArgs ) ; } }
2243	public static function getForm ( $ varId , $ strColumn = 'main' , $ blnModule = false ) { if ( \ is_object ( $ varId ) ) { $ objRow = $ varId ; } else { if ( $ varId == '' ) { return '' ; } $ objRow = FormModel :: findByIdOrAlias ( $ varId ) ; if ( $ objRow === null ) { return '' ; } } $ strClass = $ blnModule ? Module :: findClass ( 'form' ) : ContentElement :: findClass ( 'form' ) ; if ( ! class_exists ( $ strClass ) ) { static :: log ( 'Form class "' . $ strClass . '" does not exist' , __METHOD__ , TL_ERROR ) ; return '' ; } $ objRow -> typePrefix = $ blnModule ? 'mod_' : 'ce_' ; $ objRow -> form = $ objRow -> id ; $ objElement = new $ strClass ( $ objRow , $ strColumn ) ; $ strBuffer = $ objElement -> generate ( ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getForm' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getForm' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getForm' ] as $ callback ) { $ strBuffer = static :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ objRow , $ strBuffer , $ objElement ) ; } } return $ strBuffer ; }
4029	protected function getLabelText ( TranslatorInterface $ translator , ModelInterface $ model ) { $ type = $ model -> getProperty ( 'type' ) ; $ label = $ translator -> translate ( 'typenames.' . $ type , 'tl_metamodel_filtersetting' ) ; if ( $ label == 'typenames.' . $ type ) { return $ type ; } return $ label ; }
609	public function convert ( $ asset , $ basePath ) { $ pos = strrpos ( $ asset , '.' ) ; if ( $ pos !== false ) { $ ext = substr ( $ asset , $ pos + 1 ) ; if ( isset ( $ this -> commands [ $ ext ] ) ) { list ( $ ext , $ command ) = $ this -> commands [ $ ext ] ; $ result = substr ( $ asset , 0 , $ pos + 1 ) . $ ext ; if ( $ this -> forceConvert || @ filemtime ( "$basePath/$result" ) < @ filemtime ( "$basePath/$asset" ) ) { $ this -> runCommand ( $ command , $ basePath , $ asset , $ result ) ; } return $ result ; } } return $ asset ; }
6235	public function mkdir ( ) : self { if ( ! $ this -> storage -> isDir ( ) ) { if ( ! $ this -> storage -> mkdir ( ) ) { throw new AccessDeniedException ( sprintf ( 'unable to create directory at: "%s"' , $ this -> storage -> path ( ) -> raw ) , 500 ) ; } } return $ this ; }
1790	private function prepareAlias ( string $ alias , array & $ parameters ) : void { if ( 'index' === $ alias ) { return ; } $ hasAutoItem = false ; $ autoItems = $ this -> getAutoItems ( $ parameters ) ; $ config = $ this -> framework -> getAdapter ( Config :: class ) ; $ parameters [ 'alias' ] = preg_replace_callback ( '/\{([^\}]+)\}/' , static function ( array $ matches ) use ( $ alias , & $ parameters , $ autoItems , & $ hasAutoItem , $ config ) : string { $ param = $ matches [ 1 ] ; if ( ! isset ( $ parameters [ $ param ] ) ) { throw new MissingMandatoryParametersException ( sprintf ( 'Parameters "%s" is missing to generate a URL for "%s"' , $ param , $ alias ) ) ; } $ value = $ parameters [ $ param ] ; unset ( $ parameters [ $ param ] ) ; if ( $ hasAutoItem || ! $ config -> get ( 'useAutoItem' ) || ! \ in_array ( $ param , $ autoItems , true ) ) { return $ param . '/' . $ value ; } $ hasAutoItem = true ; return $ value ; } , $ alias ) ; }
4784	public function handle ( $ message , callable $ next ) { try { $ next ( $ message ) ; } catch ( UndefinedCallable $ exception ) { $ this -> logger -> log ( $ this -> logLevel , 'No message handler found, trying to handle it asynchronously' , [ 'type' => get_class ( $ message ) ] ) ; $ this -> publisher -> publish ( $ message ) ; } }
6395	public function init ( ) { parent :: init ( ) ; $ this -> path = Yii :: getAlias ( $ this -> path ) ; FileHelper :: createDirectory ( $ this -> path , $ this -> dirMode , true ) ; }
5063	public function outputJson ( int $ depth = 512 , int $ options = 0 ) { $ json = json_decode ( $ this -> output ( ) , false , $ depth , $ options ) ; if ( is_null ( $ json ) ) { $ errorMessage = json_last_error_msg ( ) ; throw new JsonDecodeException ( $ errorMessage ) ; } return $ json ; }
12462	private function createCreateForm ( CustomFieldsGroup $ entity ) { $ form = $ this -> createForm ( 'custom_fields_group' , $ entity , array ( 'action' => $ this -> generateUrl ( 'customfieldsgroup_create' ) , 'method' => 'POST' , ) ) ; $ form -> add ( 'submit' , 'submit' , array ( 'label' => 'Create' ) ) ; return $ form ; }
6756	public static function createApp ( string $ appPath , string $ environment , bool $ debug ) : BaseKernel { $ envPath = $ appPath . '/.env' ; if ( file_exists ( $ envPath ) ) { $ dotenv = new Dotenv ( ) ; $ dotenv -> load ( $ envPath ) ; } $ oneBundleAppConfig = new \ OneBundleApp \ App \ OneBundleAppConfig ( $ appPath , $ environment ) ; \ Symfony \ Component \ Debug \ ErrorHandler :: register ( ) ; \ Symfony \ Component \ Debug \ ExceptionHandler :: register ( ) ; return new \ Mmoreram \ BaseBundle \ Kernel \ BaseKernel ( $ oneBundleAppConfig -> getBundles ( ) , $ oneBundleAppConfig -> getConfig ( ) , $ oneBundleAppConfig -> getRoutes ( ) , $ environment , $ debug , $ appPath . '/var' ) ; }
1462	protected function getColumnValue ( $ id ) { $ value = $ this -> getQuery ( ) -> where ( $ this -> key , $ id ) -> value ( $ this -> column ) ; if ( is_null ( $ value ) ) { throw new \ OutOfRangeException ( "Cursor key {$id} does not exist or has a null value." ) ; } return $ value ; }
447	private function attachBehaviorInternal ( $ name , $ behavior ) { if ( ! ( $ behavior instanceof Behavior ) ) { $ behavior = Yii :: createObject ( $ behavior ) ; } if ( is_int ( $ name ) ) { $ behavior -> attach ( $ this ) ; $ this -> _behaviors [ ] = $ behavior ; } else { if ( isset ( $ this -> _behaviors [ $ name ] ) ) { $ this -> _behaviors [ $ name ] -> detach ( ) ; } $ behavior -> attach ( $ this ) ; $ this -> _behaviors [ $ name ] = $ behavior ; } return $ behavior ; }
10764	public function generateText ( ) { $ result = 'SPD' . self :: DELIMITER . $ this -> version . self :: DELIMITER . $ this -> implodeContent ( ) ; if ( $ this -> appendCRC32 ) { $ result .= self :: DELIMITER . 'CRC32:' . sprintf ( '%x' , crc32 ( $ result ) ) ; } return $ result ; }
5301	public function getCss ( ) { $ css = '' ; foreach ( $ this -> getGlyphNames ( ) as $ unicode => $ name ) { $ css .= ".icon-" . $ name . ":before {" . "\n" ; $ css .= "\tcontent: \"\\" . $ unicode . "\";\n" ; $ css .= "}\n" ; } return $ css ; }
11559	public function SetWeekWords ( $ weekWords , $ lang = '' ) { if ( ! $ lang ) $ lang = $ this -> lang ; if ( is_array ( $ weekWords ) ) { $ this -> weekWords [ $ lang ] = $ weekWords ; } else { $ this -> weekWords [ $ lang ] = explode ( ',' , ( string ) $ weekWords ) ; } return $ this ; }
2048	private function createStatement ( ) : void { if ( null !== $ this -> statement ) { return ; } if ( null === $ this -> container || ! $ this -> container -> has ( $ this -> dbalServiceName ) ) { throw new \ RuntimeException ( 'The container has not been injected or the database service is missing' ) ; } $ connection = $ this -> container -> get ( $ this -> dbalServiceName ) ; $ this -> statement = $ connection -> prepare ( ' INSERT INTO tl_log (tstamp, source, action, username, text, func, browser) VALUES (:tstamp, :source, :action, :username, :text, :func, :browser) ' ) ; }
7577	protected function setFileFieldValue ( $ value ) { if ( version_compare ( PHP_VERSION , '5.5.0' ) >= 0 ) { if ( ! ( $ value instanceof \ CURLFile ) ) { $ value = ltrim ( $ value , "@" ) ; $ value = new \ CURLFile ( $ value ) ; } } else { if ( strpos ( $ value , '@' ) !== 0 ) { $ value = '@' . $ value ; } } return $ value ; }
10511	public function notify ( ) { $ observersToNotify = array ( ) ; foreach ( $ this -> _observers as $ observer ) { if ( $ this -> checkIfObserverMustBeUpdate ( $ observer ) ) { $ observersToNotify [ ] = $ observer ; } } usort ( $ observersToNotify , array ( $ this , 'orderObserversForPriority' ) ) ; foreach ( $ observersToNotify as $ observer ) { try { $ this -> updateObserverState ( $ observer ) ; } catch ( \ Exception $ e ) { if ( ( int ) $ e -> getCode ( ) === 600 ) { break 1 ; } } } }
12836	public function makeDirectory ( $ path , $ mode = 0755 , $ recursive = false ) { if ( ! file_exists ( $ path ) ) { return mkdir ( $ path , $ mode , $ recursive ) ; } return true ; }
11035	function check_level ( $ error_level , $ errno , $ message ) { if ( error_reporting ( ) & $ error_level ) { switch ( $ error_level ) { case E_NOTICE : $ type = 'notice' ; break ; case E_WARNING : $ type = 'warning' ; break ; case E_ERROR : $ type = 'error' ; break ; } echo "<b>ETS $type:</b> $message" ; } if ( $ error_level == E_ERROR ) { exit ; } }
4219	private function clearSummary ( $ flags ) { $ return = null ; $ clearErrors = $ flags & Debug :: CLEAR_SUMMARY_ERRORS ; if ( $ flags & Debug :: CLEAR_SUMMARY ) { $ return = 'summary (' . ( $ clearErrors ? 'incl errors' : 'sans errors' ) . ')' ; $ curPriority = \ end ( $ this -> data [ 'groupPriorityStack' ] ) ; foreach ( \ array_keys ( $ this -> data [ 'logSummary' ] ) as $ priority ) { $ entriesKeep = array ( ) ; if ( $ priority === $ curPriority ) { $ curDepth = 0 ; foreach ( $ this -> data [ 'groupStacks' ] [ $ priority ] as $ group ) { $ curDepth += ( int ) $ group [ 'collect' ] ; } $ entriesKeep = $ this -> debug -> internal -> getCurrentGroups ( $ this -> data [ 'logSummary' ] [ $ priority ] , $ curDepth ) ; } else { $ this -> data [ 'groupStacks' ] [ $ priority ] = array ( ) ; } $ this -> clearLogHelper ( $ this -> data [ 'logSummary' ] [ $ priority ] , $ clearErrors , $ entriesKeep ) ; } } elseif ( $ clearErrors ) { $ return = 'summary errors' ; } return $ return ; }
7044	private function getMetaModelTableNames ( $ keyTranslated , $ keyUntranslated ) { $ result = [ ] ; foreach ( $ this -> factory -> collectNames ( ) as $ table ) { $ metaModel = $ this -> factory -> getMetaModel ( $ table ) ; if ( null === $ metaModel ) { continue ; } if ( $ metaModel -> isTranslated ( ) ) { $ result [ $ keyTranslated ] [ $ table ] = \ sprintf ( '%s (%s)' , $ metaModel -> get ( 'name' ) , $ table ) ; } else { $ result [ $ keyUntranslated ] [ $ table ] = \ sprintf ( '%s (%s)' , $ metaModel -> get ( 'name' ) , $ table ) ; } } return $ result ; }
10993	public function getByteSize ( ) : int { if ( $ this -> test ( \ sndsgd \ Fs :: READABLE ) !== true ) { $ this -> error = "failed to stat filesize; {$this->error}" ; return - 1 ; } $ bytes = @ filesize ( $ this -> path ) ; if ( $ bytes === false ) { $ this -> setError ( "failed to stat filesize for '{$this->path}'" ) ; return - 1 ; } return $ bytes ; }
4351	private function setDebugCfg ( $ cfg ) { if ( isset ( $ cfg [ 'key' ] ) ) { $ cfg = \ array_merge ( $ cfg , $ this -> debugKeyValues ( $ cfg [ 'key' ] ) ) ; } if ( isset ( $ cfg [ 'logEnvInfo' ] ) && \ is_bool ( $ cfg [ 'logEnvInfo' ] ) ) { $ keys = \ array_keys ( $ this -> cfg [ 'logEnvInfo' ] ) ; $ cfg [ 'logEnvInfo' ] = \ array_fill_keys ( $ keys , $ cfg [ 'logEnvInfo' ] ) ; } if ( isset ( $ cfg [ 'logServerKeys' ] ) ) { $ this -> cfg [ 'logServerKeys' ] = array ( ) ; } $ this -> cfg = $ this -> debug -> utilities -> arrayMergeDeep ( $ this -> cfg , $ cfg ) ; }
6556	public function log ( $ msg , $ logLevel = null ) { $ helper = new FormatterHelper ( ) ; $ style = $ this -> mapLogLevelToStyle ( $ logLevel ) ; $ this -> getOutput ( ) -> writeln ( $ logLevel ? $ helper -> formatBlock ( $ msg , $ style ) : $ msg ) ; if ( $ logLevel && $ systemLogger = $ this -> getSystemLogger ( ) ) { $ systemLogger -> log ( $ logLevel , $ msg ) ; } }
1014	private function moveStringCursor ( $ positionOffset , $ byteStreamOffset ) { $ this -> position += $ positionOffset ; $ this -> byteStreamPosition += $ byteStreamOffset ; return $ this ; }
9220	protected function requestAllPages ( $ forceRefresh = false ) { $ _page = $ this -> page ; $ _key = $ this -> key ; $ nextPageNumber = false ; if ( isset ( $ this -> pagination [ CanvasPageLink :: NEXT ] ) ) { $ nextPageNumber = $ this -> pagination [ CanvasPageLink :: NEXT ] -> getPageNumber ( ) ; } while ( $ nextPageNumber !== false ) { $ this -> requestPageNumber ( $ nextPageNumber , $ forceRefresh ) ; if ( isset ( $ this -> paginationPerPage [ $ nextPageNumber ] [ CanvasPageLink :: NEXT ] ) ) { $ nextPageNumber = $ this -> paginationPerPage [ $ nextPageNumber ] [ CanvasPageLink :: NEXT ] -> getPageNumber ( ) ; } else { $ nextPageNumber = false ; } } $ this -> page = $ _page ; $ this -> key = $ _key ; }
233	public function quoteSimpleTableName ( $ name ) { if ( is_string ( $ this -> tableQuoteCharacter ) ) { $ startingCharacter = $ endingCharacter = $ this -> tableQuoteCharacter ; } else { list ( $ startingCharacter , $ endingCharacter ) = $ this -> tableQuoteCharacter ; } return strpos ( $ name , $ startingCharacter ) !== false ? $ name : $ startingCharacter . $ name . $ endingCharacter ; }
3382	public function hasPermission ( $ permission ) { $ permission = Permission :: whereName ( $ permission ) -> first ( ) ; if ( is_null ( $ permission ) ) { return false ; } return $ this -> hasRole ( $ permission -> roles ) ; }
4826	public function getAsDom ( ) { if ( is_null ( $ this -> node ) ) { $ this -> node = XmlUtil :: createXmlDocumentFromStr ( "<row></row>" ) ; $ root = $ this -> node -> getElementsByTagName ( "row" ) -> item ( 0 ) ; foreach ( $ this -> row as $ key => $ value ) { if ( ! is_array ( $ value ) ) { $ field = XmlUtil :: createChild ( $ root , "field" , $ value ) ; XmlUtil :: addAttribute ( $ field , "name" , $ key ) ; } else { foreach ( $ value as $ valueItem ) { $ field = XmlUtil :: createChild ( $ root , "field" , $ valueItem ) ; XmlUtil :: addAttribute ( $ field , "name" , $ key ) ; } } } } return $ this -> node ; }
4715	public function split ( $ pattern , $ flags = PREG_SPLIT_DELIM_CAPTURE ) { return new Collection ( array_map ( function ( $ item ) { return new static ( $ item ) ; } , preg_split ( $ pattern , $ this -> text , - 1 , $ flags ) ) ) ; }
11440	public function getInfos ( $ echoable = false ) { if ( true === $ echoable ) { return join ( "\n<br />" , $ this -> infos ) ; } else { return $ this -> infos ; } }
8163	static public function register ( ) { if ( static :: $ registered === true ) { return true ; } $ kirby = kirby ( ) ; if ( ! class_exists ( 'Kirby\Component\Template' ) ) { throw new Exception ( 'The Kirby Twig plugin requires Kirby 2.3 or higher. Current version: ' . $ kirby -> version ( ) ) ; } if ( ! class_exists ( 'Twig_Environment' ) ) { require_once __DIR__ . '/../lib/Twig/lib/Twig/Autoloader.php' ; \ Twig_Autoloader :: register ( ) ; } $ kirby -> set ( 'component' , 'template' , 'Kirby\Twig\TwigComponent' ) ; if ( is_executable ( 'twig' ) === false ) { require_once __DIR__ . '/helpers.php' ; } return static :: $ registered = true ; }
12980	protected function configureBehavior ( $ behavior , EventSubscriber $ es ) { switch ( $ behavior ) { case 'translatable' : $ es -> setTranslatableLocale ( \ Config :: get ( 'language' , 'en' ) ) ; $ es -> setDefaultLocale ( \ Config :: get ( 'language_fallback' , 'en' ) ) ; break ; } }
3214	function disableAccessToken ( ) { $ response = $ this -> doPost ( $ this -> apiHost , "1/disable_access_token" ) ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; }
1899	private function createConfig ( $ size , ImageInterface $ image ) : array { if ( ! \ is_array ( $ size ) ) { $ size = [ 0 , 0 , $ size ] ; } $ config = new ResizeConfiguration ( ) ; if ( isset ( $ size [ 2 ] ) && is_numeric ( $ size [ 2 ] ) ) { $ imageModel = $ this -> framework -> getAdapter ( ImageSizeModel :: class ) ; $ imageSize = $ imageModel -> findByPk ( $ size [ 2 ] ) ; if ( null !== $ imageSize ) { $ config -> setWidth ( $ imageSize -> width ) -> setHeight ( $ imageSize -> height ) -> setMode ( $ imageSize -> resizeMode ) -> setZoomLevel ( $ imageSize -> zoom ) ; } return [ $ config , null ] ; } if ( ! empty ( $ size [ 0 ] ) ) { $ config -> setWidth ( $ size [ 0 ] ) ; } if ( ! empty ( $ size [ 1 ] ) ) { $ config -> setHeight ( $ size [ 1 ] ) ; } if ( ! isset ( $ size [ 2 ] ) || 1 !== substr_count ( $ size [ 2 ] , '_' ) ) { if ( ! empty ( $ size [ 2 ] ) ) { $ config -> setMode ( $ size [ 2 ] ) ; } return [ $ config , null ] ; } $ config -> setMode ( ResizeConfigurationInterface :: MODE_CROP ) ; return [ $ config , $ this -> getImportantPartFromLegacyMode ( $ image , $ size [ 2 ] ) ] ; }
4435	public static function fromErrorMessage ( string $ error ) : QlessException { $ area = null ; $ message = $ error ; if ( preg_match ( self :: ERROR_MESSAGE_RE , $ error , $ matches ) > 0 ) { $ area = $ matches [ 'area' ] ; $ message = $ matches [ 'message' ] ; } switch ( true ) { case ( $ area === 'Requeue' && stripos ( $ message , 'does not exist' ) !== false ) : case ( stripos ( $ message , 'Job does not exist' ) !== false ) : return new InvalidJobException ( $ message , $ area ) ; case ( stripos ( $ message , 'Job given out to another worker' ) !== false ) : return new JobLostException ( $ message , $ area ) ; case ( stripos ( $ message , 'Job not currently running' ) !== false ) : default : return new QlessException ( $ message , $ area ) ; } }
3387	public function sendResetLinkEmail ( Request $ request ) { $ this -> validateEmail ( $ request ) ; $ user = $ this -> broker ( ) -> getUser ( $ request -> only ( 'email' ) ) ; if ( $ user && is_null ( $ user -> confirmed_at ) ) { session ( [ 'confirmation_user_id' => $ user -> getKey ( ) ] ) ; throw ValidationException :: withMessages ( [ 'confirmation' => [ __ ( 'confirmation::confirmation.not_confirmed_reset_password' , [ 'resend_link' => route ( 'auth.resend_confirmation' ) ] ) ] ] ) ; } $ response = $ this -> broker ( ) -> sendResetLink ( $ request -> only ( 'email' ) ) ; return $ response == Password :: RESET_LINK_SENT ? $ this -> sendResetLinkResponse ( $ response ) : $ this -> sendResetLinkFailedResponse ( $ request , $ response ) ; }
5848	public function populateMetadata ( \ TYPO3 \ CMS \ Core \ Resource \ FileInterface $ file , \ TYPO3 \ CMS \ Core \ Resource \ Folder $ folder ) { if ( is_array ( static :: $ metadata ) && count ( static :: $ metadata ) ) { \ Causal \ ImageAutoresize \ Utility \ FAL :: indexFile ( $ file , '' , '' , static :: $ metadata [ 'COMPUTED' ] [ 'Width' ] , static :: $ metadata [ 'COMPUTED' ] [ 'Height' ] , static :: $ metadata ) ; } }
3377	public function postRemind ( ) { \ App :: make ( 'route' ) ; \ Config :: set ( 'auth.defaults.passwords' , 'panel' ) ; $ response = \ Password :: sendResetLink ( Input :: only ( 'email' ) , function ( $ message ) { $ message -> subject ( 'Password Reminder' ) ; } ) ; switch ( $ response ) { case PasswordBrokerContract :: INVALID_USER : return \ Redirect :: back ( ) -> with ( 'message' , \ Lang :: get ( $ response ) ) -> with ( 'mesType' , 'error' ) ; case PasswordBrokerContract :: RESET_LINK_SENT : return \ Redirect :: back ( ) -> with ( 'message' , \ Lang :: get ( $ response ) ) -> with ( 'mesType' , 'info' ) ; } }
10376	protected static function look_if_process_files ( $ type ) { if ( is_string ( self :: $ unify ) || isset ( self :: $ unify [ "{$type}s" ] ) ) { return self :: unify_files ( self :: prepare_files ( $ type ) ) ; } }
1763	public function onKernelTerminate ( PostResponseEvent $ event ) : void { if ( ! $ this -> framework -> isInitialized ( ) || ! $ this -> canRunController ( $ event -> getRequest ( ) ) ) { return ; } $ controller = $ this -> framework -> createInstance ( FrontendCron :: class ) ; $ controller -> run ( ) ; }
8848	public function tag ( ) { $ tag = $ this -> getCurrentTag ( ) ; if ( $ tag ) { $ this -> blogPosts = $ tag -> BlogPosts ( ) ; return $ this -> render ( ) ; } return $ this -> httpError ( 404 , "Not Found" ) ; }
12447	static function run_build_dependencies ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; $ current = $ opts [ 'extension' ] [ 'name' ] ; foreach ( $ opts [ 'dependencies' ] [ 'extensions' ] as $ ext => $ source ) { if ( $ ext != $ current ) { foreach ( $ source as $ type => $ def ) { break ; } $ tempconf = array ( 'extension' => array ( 'name' => $ ext ) , 'version' => array ( 'major' => 0 , 'minor' => 0 , 'release' => 0 ) , $ type => $ def ) ; $ tempconffile = self :: getOptionsDir ( ) . "/options-tmp_$ext.yaml" ; pakeYaml :: emitfile ( $ tempconf , $ tempconffile ) ; $ task = pakeTask :: get ( 'init' ) ; $ task -> execute ( array ( "tmp_$ext" ) , array_merge ( $ cliopts , array ( 'skip-init' => false , 'skip-init-fetch' => false , 'skip-init-clean' => true ) ) ) ; if ( is_file ( self :: getBuildDir ( $ opts ) . "/$ext/pake/options-$ext.yaml" ) ) { pake_copy ( self :: getBuildDir ( $ opts ) . "/$ext/pake/options-$ext.yaml" , self :: getOptionsDir ( ) . "/options-$ext.yaml" ) ; } else { throw new pakeException ( "Missing pake/options.yaml extension in dependent extension $ext" ) ; } $ task -> execute ( array ( "tmp_$ext" ) , array_merge ( $ cliopts , array ( 'skip-init' => false , 'skip-init-fetch' => true , 'skip-init-clean' => false ) ) ) ; pake_remove ( $ tempconffile , '' ) ; $ task = pakeTask :: get ( 'build' ) ; foreach ( $ task -> get_prerequisites ( ) as $ pretask ) { $ pretask = pakeTask :: get ( $ pretask ) ; $ pretask -> execute ( array ( $ ext ) , array_merge ( $ opts , array ( 'skip-init' => true ) ) ) ; } $ task -> execute ( array ( $ ext ) , array_merge ( $ opts , array ( 'skip-init' => true ) ) ) ; } } }
3514	public function postMissingKeys ( ) { $ missingKeys = Request :: json ( 'missingKeys' ) ; $ this -> manager -> setConnectionName ( '' ) ; $ translator = App :: make ( 'translator' ) ; $ affectedGroups = [ ] ; foreach ( $ missingKeys as $ key ) { $ key = decodeKey ( $ key ) ; list ( $ namespace , $ group , $ item ) = $ translator -> parseKey ( $ key ) ; if ( $ item && $ group ) { if ( ! in_array ( $ group , $ this -> manager -> config ( Manager :: EXCLUDE_GROUPS_KEY ) ) ) { $ t = $ this -> manager -> missingKey ( $ namespace , $ group , $ item , null , false , true ) ; if ( ! $ t -> exists ) { $ affectedGroups [ ] = $ t -> group ; $ t -> save ( ) ; } } } else { } } $ data = [ 'connectionName' => '' , 'affectedGroups' => $ affectedGroups , 'missingKeys' => [ ] , ] ; $ pretty = Request :: has ( 'pretty-json' ) ? JSON_PRETTY_PRINT : 0 ; return Response :: json ( $ data , 200 , [ ] , JSON_UNESCAPED_SLASHES | $ pretty ) ; }
5046	public function form ( $ form , $ options = null , $ as = 'searchform' ) { if ( is_string ( $ options ) ) { $ as = $ options ; $ options = null ; } $ this -> stack [ 'form' ] = [ 'as' => $ as , $ form , $ options ] ; return $ this ; }
652	public function execute ( ) { $ sql = $ this -> getSql ( ) ; list ( $ profile , $ rawSql ) = $ this -> logQuery ( __METHOD__ ) ; if ( $ sql == '' ) { return 0 ; } $ this -> prepare ( false ) ; try { $ profile and Yii :: beginProfile ( $ rawSql , __METHOD__ ) ; $ this -> internalExecute ( $ rawSql ) ; $ n = $ this -> pdoStatement -> rowCount ( ) ; $ profile and Yii :: endProfile ( $ rawSql , __METHOD__ ) ; $ this -> refreshTableSchema ( ) ; return $ n ; } catch ( Exception $ e ) { $ profile and Yii :: endProfile ( $ rawSql , __METHOD__ ) ; throw $ e ; } }
6193	protected function loadModels ( $ path ) { $ this -> app -> config [ 'model' ] = array_unique ( array_merge ( $ this -> app -> config [ 'model' ] ?? [ ] , $ path ) ) ; }
4781	public function addWidgetConfig ( string $ widgetId , array $ config = [ ] ) { $ this -> config [ $ widgetId ] = array_merge ( $ this -> config [ $ widgetId ] ?? [ ] , $ config ) ; return $ this ; }
2577	protected function hasPricingOption ( $ optionKey , $ priceOptions ) { $ found = false ; foreach ( $ priceOptions as $ pog ) { if ( $ pog -> pricingOptionKey -> pricingOptionKey === $ optionKey ) { $ found = true ; } } return $ found ; }
1239	private static function getActualType ( $ value ) { $ actualType = gettype ( $ value ) ; if ( 'object' === $ actualType ) { $ actualType = get_class ( $ value ) ; } return $ actualType ; }
7711	function Delete ( $ Contents = true ) { $ this -> FindEndTag ( ) ; if ( $ Contents || $ this -> SelfClosing ) { $ this -> ReplaceSrc ( '' ) ; } else { $ inner = $ this -> GetInnerSrc ( ) ; $ this -> ReplaceSrc ( $ inner ) ; } }
6522	public function isCompatibleForMerge ( Field $ other ) { if ( $ this -> name !== $ other -> name ) { return false ; } if ( $ this -> type !== $ other -> type ) { return false ; } if ( $ this -> rule !== $ other -> rule ) { return false ; } if ( $ this -> className !== $ other -> className ) { return false ; } if ( ! array_intersect ( $ this -> anyOfClassNames , $ other -> anyOfClassNames ) ) { return false ; } return true ; }
5449	public function acceptEndToken ( $ token , $ event ) { if ( ! preg_match ( '/<\/(.*)>/' , $ token , $ matches ) ) { return false ; } return $ this -> listener -> endElement ( strtolower ( $ matches [ 1 ] ) ) ; }
4919	public function attachInputFilterDefaults ( InputFilterInterface $ inputFilter , FieldsetInterface $ fieldset ) { parent :: attachInputFilterDefaults ( $ inputFilter , $ fieldset ) ; foreach ( $ inputFilter -> getInputs ( ) as $ name => $ input ) { if ( ! $ input instanceof InputFilterInterface ) { $ required = $ input -> isRequired ( ) ; $ inputExists = $ fieldset -> has ( $ name ) ; if ( ! $ inputExists && $ required ) { $ fieldsetName = '' ; if ( $ fieldset -> hasAttribute ( 'name' ) ) { $ fieldsetName = 'in Fieldset "' . $ fieldset -> getAttribute ( 'name' ) . '" ' ; } throw new \ RuntimeException ( 'input for "' . $ name . '" ' . $ fieldsetName . 'is required but a input-field with this name is not defined' ) ; } } } }
3482	public function withContentAvailable ( bool $ contentAvailable ) : Aps { $ cloned = clone $ this ; $ cloned -> contentAvailable = $ contentAvailable ; return $ cloned ; }
4083	public function getStandaloneInputScreens ( ) { $ result = array ( ) ; foreach ( array_keys ( $ this -> information ) as $ modelName ) { if ( $ this -> isInputScreenStandalone ( $ modelName ) ) { $ result [ ] = $ this -> getInputScreenDetails ( $ modelName ) ; } } return $ result ; }
12377	public function superadmin ( User $ account , Container $ application , Database $ database ) { $ config = $ this -> config ; $ username = $ application -> input -> getString ( "user_first_name" , "" , "post" , FALSE , array ( ) ) ; $ usernameid = $ application -> input -> getString ( "user_name_id" , "" , "post" , FALSE , array ( ) ) ; $ userpass = $ application -> input -> getString ( "user_password" , "" , "post" , FALSE , array ( ) ) ; $ userpass2 = $ application -> input -> getString ( "user_password_2" , "" , "post" , FALSE , array ( ) ) ; $ useremail = $ application -> input -> getString ( "user_email" , "" , "post" , FALSE , array ( ) ) ; if ( empty ( $ userpass ) || empty ( $ username ) || empty ( $ usernameid ) || empty ( $ useremail ) ) { throw new Exception ( t ( 'Please provide at least a Name, Username, E-mail and Password' ) ) ; return false ; } if ( $ userpass <> $ userpass2 ) { throw new Exception ( t ( 'The user passwords do not match' ) ) ; return false ; } if ( ! $ account -> store ( $ application -> input -> data ( "post" ) , true ) ) { throw new Exception ( t ( 'Could not store the admin user account' ) ) ; return false ; } $ adminAuthority = $ this -> config -> get ( "setup.site.superadmin-authority" , NULL ) ; if ( ! empty ( $ adminAuthority ) ) { $ query = "INSERT INTO ?objects_authority( authority_id, object_id ) SELECT {$database->quote((int)$adminAuthority)}, object_id FROM ?objects WHERE object_uri={$database->quote($usernameid)}" ; $ database -> exec ( $ query ) ; } $ config -> set ( "setup.session.store" , "database" ) ; $ config -> set ( "setup.database.installed" , TRUE ) ; if ( ! $ config -> saveParams ( ) ) { throw new Exception ( "could not save config" ) ; return false ; } return true ; }
10628	public static function cpuPercentages ( $ cpuCoreInfo1 , $ cpuCoreInfo2 ) { $ cpus = array ( ) ; foreach ( $ cpuCoreInfo1 as $ idx => $ core ) { $ dif = array ( ) ; $ cpu = array ( ) ; $ dif [ 'user' ] = $ cpuCoreInfo2 [ $ idx ] [ 'user' ] - $ cpuCoreInfo1 [ $ idx ] [ 'user' ] ; $ dif [ 'nice' ] = $ cpuCoreInfo2 [ $ idx ] [ 'nice' ] - $ cpuCoreInfo1 [ $ idx ] [ 'nice' ] ; $ dif [ 'sys' ] = $ cpuCoreInfo2 [ $ idx ] [ 'sys' ] - $ cpuCoreInfo1 [ $ idx ] [ 'sys' ] ; $ dif [ 'idle' ] = $ cpuCoreInfo2 [ $ idx ] [ 'idle' ] - $ cpuCoreInfo1 [ $ idx ] [ 'idle' ] ; $ dif [ 'iowait' ] = $ cpuCoreInfo2 [ $ idx ] [ 'iowait' ] - $ cpuCoreInfo1 [ $ idx ] [ 'iowait' ] ; $ dif [ 'irq' ] = $ cpuCoreInfo2 [ $ idx ] [ 'irq' ] - $ cpuCoreInfo1 [ $ idx ] [ 'irq' ] ; $ dif [ 'softirq' ] = $ cpuCoreInfo2 [ $ idx ] [ 'softirq' ] - $ cpuCoreInfo1 [ $ idx ] [ 'softirq' ] ; $ total = array_sum ( $ dif ) ; foreach ( $ dif as $ x => $ y ) { $ cpu [ $ x ] = round ( $ y / $ total * 100 , 2 ) ; } $ cpus [ 'cpu' . $ idx ] = $ cpu ; } return $ cpus ; }
5901	public function listGroups ( $ includeDeleted = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'includeDeleted' => $ includeDeleted ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/groups' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new Group ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
3139	public function storeItemResponse ( RunnerServiceContext $ context , $ itemRef , $ responses ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ session = $ this -> getCurrentAssessmentSession ( $ context ) ; try { \ common_Logger :: t ( 'Responses sent from the client-side. The Response Processing will take place.' ) ; if ( $ context -> isAdaptive ( ) ) { $ session -> beginItemSession ( ) ; $ session -> beginAttempt ( ) ; $ session -> endAttempt ( $ responses ) ; $ assessmentItem = $ session -> getAssessmentItem ( ) ; $ assessmentItemIdentifier = $ assessmentItem -> getIdentifier ( ) ; $ score = $ session -> getVariable ( 'SCORE' ) ; $ output = $ context -> getLastCatItemOutput ( ) ; if ( $ score !== null ) { $ output [ $ assessmentItemIdentifier ] = new ItemResult ( $ assessmentItemIdentifier , new ResultVariable ( $ score -> getIdentifier ( ) , BaseType :: getNameByConstant ( $ score -> getBaseType ( ) ) , $ score -> getValue ( ) -> getValue ( ) , null , $ score -> getCardinality ( ) ) , microtime ( true ) ) ; } else { \ common_Logger :: i ( "No 'SCORE' outcome variable for item '${assessmentItemIdentifier}' involved in an adaptive section." ) ; } $ context -> persistLastCatItemOutput ( $ output ) ; $ resultTransmitter = new \ taoQtiCommon_helpers_ResultTransmitter ( $ context -> getSessionManager ( ) -> getResultServer ( ) ) ; $ outcomeVariables = [ ] ; $ hrefParts = explode ( '|' , $ assessmentItem -> getHref ( ) ) ; $ sessionId = $ context -> getTestSession ( ) -> getSessionId ( ) ; $ itemIdentifier = $ assessmentItem -> getIdentifier ( ) ; $ attempt = $ context -> getCatAttempts ( $ itemIdentifier ) ; $ transmissionId = "${sessionId}.${itemIdentifier}.${attempt}" ; $ attempt ++ ; foreach ( $ session -> getAllVariables ( ) as $ var ) { if ( $ var -> getIdentifier ( ) === 'numAttempts' ) { $ var -> setValue ( new \ qtism \ common \ datatypes \ QtiInteger ( $ attempt ) ) ; } $ variables [ ] = $ var ; } $ resultTransmitter -> transmitItemVariable ( $ variables , $ transmissionId , $ hrefParts [ 0 ] , $ hrefParts [ 2 ] ) ; $ context -> persistCatAttempts ( $ itemIdentifier , $ attempt ) ; $ context -> getTestSession ( ) -> endAttempt ( new State ( ) , true ) ; } else { $ session -> endAttempt ( $ responses , true ) ; } return true ; } catch ( AssessmentTestSessionException $ e ) { \ common_Logger :: w ( $ e -> getMessage ( ) ) ; return false ; } } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'storeItemResponse' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } }
9441	public function get ( ) { if ( $ this -> range -> as_integer ) { return mt_rand ( $ this -> range -> min , $ this -> range -> max ) ; } else { return mt_rand ( 0 , mt_getrandmax ( ) ) / mt_getrandmax ( ) ; } }
12228	public function removeSelf ( ) { $ tmp = dom_import_simplexml ( $ this ) ; if ( $ tmp -> isSameNode ( $ tmp -> ownerDocument -> documentElement ) ) { throw new BadMethodCallException ( 'removeSelf() cannot be used to remove the root node' ) ; } $ node = $ tmp -> parentNode -> removeChild ( $ tmp ) ; return simplexml_import_dom ( $ node , get_class ( $ this ) ) ; }
1576	public function register ( $ apiName , $ options = [ ] , Closure $ routes = null ) : ApiRegistration { $ registrar = $ this -> container -> make ( 'json-api.registrar' ) ; return $ registrar -> api ( $ apiName , $ options , $ routes ) ; }
11227	final public function setProperties ( array $ properties = [ ] ) { foreach ( $ properties as $ name => $ value ) { if ( property_exists ( $ this , $ name ) ) { $ this -> $ name = $ value ; } else { trigger_error ( Message :: get ( Message :: MSG_PROPERTY_UNKNOWN , $ name , get_class ( $ this ) ) , E_USER_WARNING ) ; } } }
12854	public function process ( Pipeline \ Pipeline $ pipeline , $ payload ) { $ runner = clone ( $ this ) ; $ runner -> stages = $ pipeline -> getIterator ( ) ; return $ runner -> handle ( $ payload ) ; }
11349	public function setData ( $ data ) { $ data = $ this -> transformer -> encode ( $ data ) ; foreach ( $ this -> fields as $ field ) { if ( isset ( $ data [ $ field -> getName ( ) ] ) ) { $ field -> setData ( $ data [ $ field -> getName ( ) ] ) ; } } }
6812	private function getDateTimeFormatter ( ) { if ( $ this -> dateTimeFormatter ) { return $ this -> dateTimeFormatter ; } return $ this -> dateTimeFormatter = IntlDateFormatter :: create ( $ this -> locale , IntlDateFormatter :: SHORT , IntlDateFormatter :: SHORT , ini_get ( 'date.timezone' ) , IntlDateFormatter :: GREGORIAN ) ; }
4233	private static function getHash ( $ what ) { $ str = null ; if ( ! ( $ what instanceof \ Reflector ) ) { $ str = \ get_class ( $ what ) ; } elseif ( $ what instanceof \ ReflectionClass ) { $ str = $ what -> getName ( ) ; } elseif ( $ what instanceof \ ReflectionMethod ) { $ str = $ what -> getDeclaringClass ( ) -> getName ( ) . '::' . $ what -> getName ( ) . '()' ; } elseif ( $ what instanceof \ ReflectionFunction ) { $ str = $ what -> getName ( ) . '()' ; } elseif ( $ what instanceof \ ReflectionProperty ) { $ str = $ what -> getDeclaringClass ( ) -> getName ( ) . '::' . $ what -> getName ( ) ; } return $ str ? \ md5 ( $ str ) : null ; }
4641	private function buildCallback ( BuildInfo $ output ) { $ message = "" ; if ( $ output -> getError ( ) ) { $ this -> logger -> error ( sprintf ( "Error when creating job: %s\n" , $ output -> getError ( ) ) , array ( 'static' => false , 'static-id' => null ) ) ; return ; } if ( $ output -> getStream ( ) ) { $ message = $ output -> getStream ( ) ; } if ( $ output -> getStatus ( ) ) { $ message = $ output -> getStatus ( ) ; if ( $ output -> getProgress ( ) ) { $ message .= " " . $ output -> getProgress ( ) ; } } if ( ! $ output -> getId ( ) && ! preg_match ( '#\n#' , $ message ) ) { $ message .= "\n" ; } $ this -> logger -> debug ( $ message , array ( 'static' => $ output -> getId ( ) !== null , 'static-id' => $ output -> getId ( ) , ) ) ; }
12245	public function sortChildren ( ) { $ nodes = $ this -> removeNodes ( '*' ) ; $ args = func_get_args ( ) ; array_unshift ( $ args , null ) ; $ args [ 0 ] = & $ nodes ; call_user_func_array ( array ( get_class ( $ this ) , 'sort' ) , $ args ) ; foreach ( $ nodes as $ node ) { $ this -> appendChild ( $ node ) ; } return $ this ; }
10109	private function writeMergedCells ( ) { $ mergeCells = $ this -> phpSheet -> getMergeCells ( ) ; $ countMergeCells = count ( $ mergeCells ) ; if ( $ countMergeCells == 0 ) { return ; } $ maxCountMergeCellsPerRecord = 1027 ; $ record = 0x00E5 ; $ i = 0 ; $ j = 0 ; $ recordData = '' ; foreach ( $ mergeCells as $ mergeCell ) { ++ $ i ; ++ $ j ; $ range = Coordinate :: splitRange ( $ mergeCell ) ; list ( $ first , $ last ) = $ range [ 0 ] ; list ( $ firstColumn , $ firstRow ) = Coordinate :: coordinateFromString ( $ first ) ; list ( $ lastColumn , $ lastRow ) = Coordinate :: coordinateFromString ( $ last ) ; $ recordData .= pack ( 'vvvv' , $ firstRow - 1 , $ lastRow - 1 , Coordinate :: columnIndexFromString ( $ firstColumn ) - 1 , Coordinate :: columnIndexFromString ( $ lastColumn ) - 1 ) ; if ( $ j == $ maxCountMergeCellsPerRecord or $ i == $ countMergeCells ) { $ recordData = pack ( 'v' , $ j ) . $ recordData ; $ length = strlen ( $ recordData ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ this -> append ( $ header . $ recordData ) ; $ recordData = '' ; $ j = 0 ; } } }
2096	public function getWeekBegin ( $ intStartDay = 0 ) { $ intOffset = date ( 'w' , $ this -> strDate ) - $ intStartDay ; if ( $ intOffset < 0 ) { $ intOffset += 7 ; } return strtotime ( '-' . $ intOffset . ' days' , $ this -> strDate ) ; }
9963	public function removeRow ( $ pRow , $ pNumRows = 1 ) { if ( $ pRow >= 1 ) { $ highestRow = $ this -> getHighestDataRow ( ) ; $ objReferenceHelper = ReferenceHelper :: getInstance ( ) ; $ objReferenceHelper -> insertNewBefore ( 'A' . ( $ pRow + $ pNumRows ) , 0 , - $ pNumRows , $ this ) ; for ( $ r = 0 ; $ r < $ pNumRows ; ++ $ r ) { $ this -> getCellCollection ( ) -> removeRow ( $ highestRow ) ; -- $ highestRow ; } } else { throw new Exception ( 'Rows to be deleted should at least start from row 1.' ) ; } return $ this ; }
3391	public function confirm ( $ confirmation_code ) { $ model = $ this -> guard ( ) -> getProvider ( ) -> createModel ( ) ; $ user = $ model -> where ( 'confirmation_code' , $ confirmation_code ) -> firstOrFail ( ) ; $ user -> confirmation_code = null ; $ user -> confirmed_at = now ( ) ; $ user -> save ( ) ; event ( new Confirmed ( $ user ) ) ; return $ this -> confirmed ( $ user ) ? : redirect ( $ this -> redirectAfterConfirmationPath ( ) ) -> with ( 'confirmation' , __ ( 'confirmation::confirmation.confirmation_successful' ) ) ; }
8062	public function destroy ( $ maxWaitSecs = null ) { if ( $ maxWaitSecs === null ) { $ maxWaitSecs = $ this -> child_timeout_sec ; } if ( ! $ this -> created ) { throw new WorkerPoolException ( 'The pool hasn\'t yet been created.' ) ; } $ this -> created = FALSE ; if ( $ this -> parentPid === getmypid ( ) ) { $ maxWaitSecs = ( ( int ) $ maxWaitSecs ) * 2 ; if ( $ maxWaitSecs <= 1 ) { $ maxWaitSecs = 2 ; } foreach ( $ this -> workerProcesses as $ processDetails ) { try { $ processDetails -> getSocket ( ) -> send ( array ( 'cmd' => 'exit' ) ) ; } catch ( \ Exception $ e ) { } } for ( $ i = 0 ; $ i < $ maxWaitSecs ; $ i ++ ) { usleep ( 500000 ) ; pcntl_signal_dispatch ( ) ; if ( $ this -> workerPoolSize == 0 ) { break ; } } foreach ( $ this -> signals as $ signo ) { pcntl_signal ( $ signo , SIG_DFL ) ; } $ this -> workerProcesses -> killAllProcesses ( ) ; usleep ( 500000 ) ; $ this -> reaper ( ) ; $ this -> semaphore -> destroy ( ) ; unset ( $ this -> workerProcesses ) ; } return $ this ; }
4577	public function getXml ( $ id , Parameters $ parameters = null ) { if ( null !== $ id ) { $ resource = str_replace ( '{id}' , $ id , static :: RESOURCE_OBJECT_XML ) ; } else { $ key = $ parameters -> getKey ( ) ; $ tenantId = $ parameters -> getTenantId ( ) ; switch ( true ) { case null !== $ key && null !== $ tenantId : $ resource = str_replace ( [ '{key}' , '{tenant-id}' ] , [ $ key , $ tenantId ] , static :: RESOURCE_OBJECT_XML_BY_KEY_AND_TENANT_ID ) ; break ; case null !== $ key : $ resource = str_replace ( '{key}' , $ key , static :: RESOURCE_OBJECT_XML_BY_KEY ) ; break ; default : throw new LogicException ( '"Key" and/or "TenantId" parameters are not defined.' ) ; } } $ options = [ 'headers' => [ 'Accept' => 'application/json' ] ] ; $ object = $ this -> execute ( 'GET' , $ resource , $ options ) ; $ model = new Xml ; $ model -> setId ( $ object -> id ) -> setXml ( new SimpleXMLElement ( $ object -> bpmn20Xml ) ) ; return $ model ; }
4086	public function handle ( BuildWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) || ( $ event -> getProperty ( ) -> getName ( ) !== 'filterparams' ) ) { return ; } $ model = $ event -> getModel ( ) ; $ objFilterSettings = $ this -> settingFactory -> createCollection ( $ model -> getProperty ( 'filter' ) ) ; $ extra = $ event -> getProperty ( ) -> getExtra ( ) ; $ extra [ 'subfields' ] = $ objFilterSettings -> getParameterDCA ( ) ; $ event -> getProperty ( ) -> setExtra ( $ extra ) ; }
4132	public function clear ( $ objectName = null ) { if ( $ objectName === null ) { $ this -> unitOfWork = new UnitOfWork ( $ this ) ; } else { throw new CouchDBException ( "DocumentManager#clear(\$objectName) not yet implemented." ) ; } }
3027	private function makeRequest ( $ method , $ path , $ options , $ addApiKey ) { if ( $ addApiKey ) { $ options = array_merge ( array ( 'api_key' => $ this -> apiKey ) , $ options ? : array ( ) ) ; } return $ this -> requestHandler -> request ( $ method , $ path , $ options ) ; }
6476	public function readAsJson ( ? IHttpBody $ body ) : array { if ( $ body === null ) { return [ ] ; } $ json = json_decode ( $ body -> readAsString ( ) , true ) ; if ( $ json === null ) { throw new RuntimeException ( 'Body could not be decoded as JSON' ) ; } return $ json ; }
10681	public function onBeforeWrite ( ) { if ( $ this -> owner -> Title ) { $ this -> owner -> URLSegment = $ this -> generateURLSegment ( $ this -> owner -> Title ) ; } parent :: onBeforeWrite ( ) ; }
7825	protected function getTotalWidth ( ) { $ borders = ( static :: BORDER_WIDTH + static :: MIN_SPACE_FROM_BORDER_X ) * 2 ; if ( empty ( $ this -> pipes ) ) { return $ borders + $ this -> getCoreLength ( ) ; } $ borders *= count ( $ this -> pipes ) ; $ name = ( $ this -> getLongestPipeLength ( ) + static :: SPACE_FROM_ARROW ) * 2 ; return $ borders + $ name + static :: ARROW_WIDTH ; }
3426	public function sort ( $ by , $ order = 'ASC' ) { $ this -> sort = is_array ( $ by ) ? $ by : [ $ by => $ order ] ; return $ this ; }
11371	public function destroy ( $ menuId = null ) { if ( $ menuId !== null ) { return $ this -> parseJSON ( 'json' , [ self :: API_CONDITIONAL_DELETE , [ 'menuid' => $ menuId ] ] ) ; } return $ this -> parseJSON ( 'get' , [ self :: API_DELETE ] ) ; }
5171	private function getAvailableRatios ( ) : array { return [ self :: RATIO_SQUARE , self :: RATIO_RECTANGLE , self :: RATIO_HEADLINE , self :: RATIO_VERTICAL , self :: RATIO_COVER , ] ; }
10700	public static function isMobilePhoneNumber ( $ phone ) { $ phoneNumber = substr ( Tools :: removeSpace ( $ phone ) , - 9 , 1 ) ; return ( ! self :: isCzechPhoneNumber ( $ phoneNumber ) || ( $ phoneNumber === '6' || $ phoneNumber === '7' ) ) ; }
6477	public function readAsMultipart ( ? IHttpBody $ body , string $ boundary ) : ? MultipartBody { if ( $ body === null ) { return null ; } $ rawBodyParts = explode ( "--$boundary" , $ body -> readAsString ( ) ) ; array_shift ( $ rawBodyParts ) ; array_pop ( $ rawBodyParts ) ; $ parsedBodyParts = [ ] ; foreach ( $ rawBodyParts as $ rawBodyPart ) { $ headerStartIndex = strlen ( "\r\n" ) ; $ headerEndIndex = strpos ( $ rawBodyPart , "\r\n\r\n" ) ; $ bodyStartIndex = $ headerEndIndex + strlen ( "\r\n\r\n" ) ; $ bodyEndIndex = strlen ( $ rawBodyPart ) - strlen ( "\r\n" ) ; $ rawHeaders = explode ( "\r\n" , substr ( $ rawBodyPart , $ headerStartIndex , $ headerEndIndex - $ headerStartIndex ) ) ; $ parsedHeaders = new HttpHeaders ( ) ; foreach ( $ rawHeaders as $ headerLine ) { [ $ headerName , $ headerValue ] = explode ( ':' , $ headerLine , 2 ) ; $ parsedHeaders -> add ( trim ( $ headerName ) , trim ( $ headerValue ) ) ; } $ body = new StringBody ( substr ( $ rawBodyPart , $ bodyStartIndex , $ bodyEndIndex - $ bodyStartIndex ) ) ; $ parsedBodyParts [ ] = new MultipartBodyPart ( $ parsedHeaders , $ body ) ; } return new MultipartBody ( $ parsedBodyParts , $ boundary ) ; }
12193	public function onKernelException ( GetResponseForExceptionEvent $ event ) { $ exception = $ event -> getException ( ) ; if ( $ exception instanceof AuthenticationCredentialsNotFoundException ) { return new RedirectResponse ( "/login" ) ; } $ message = $ exception -> getMessage ( ) ; if ( $ exception instanceof NotFoundHttpException || $ exception instanceof PageNotPublishedException ) { $ this -> render404page ( $ event , $ message ) ; return ; } if ( ! $ exception instanceof RedKiteCmsExceptionInterface ) { DataLogger :: log ( $ message , DataLogger :: CRITICAL ) ; if ( $ this -> debug ) { return $ event ; } $ this -> setUpResponse ( $ event , $ message ) ; return ; } $ message = Utils :: translateException ( $ message , $ exception ) ; $ this -> setUpResponse ( $ event , $ message ) ; DataLogger :: log ( $ message , DataLogger :: ERROR ) ; }
4708	public function initialize ( Text $ text , array $ options = array ( ) ) { $ text -> replace ( '{ ^[ ]{0,' . $ options [ 'tabWidth' ] . '}\[(.+)\]: # id = $1 [ \t]* \n? # maybe *one* newline [ \t]* <?(\S+?)>? # url = $2 [ \t]* \n? # maybe one newline [ \t]* (?: (?<=\s) # lookbehind for whitespace ["\'(] (.+?) # title = $3 ["\')] [ \t]* )? # title is optional (?:\n+|\Z) }xm' , function ( Text $ whole , Text $ id , Text $ url , Text $ title = null ) { $ id -> lower ( ) ; $ this -> markdown -> emit ( 'escape.special_chars' , [ $ url -> replace ( '/(?<!\\\\)_/' , '\\\\_' ) ] ) ; $ this -> markdown -> getUrlRegistry ( ) -> set ( $ id , htmlspecialchars ( $ url , ENT_QUOTES , 'UTF-8' , false ) ) ; if ( $ title ) { $ this -> markdown -> getTitleRegistry ( ) -> set ( $ id , preg_replace ( '/"/' , '&quot;' , $ title ) ) ; } return '' ; } ) ; }
10370	public static function add ( $ type , $ data = [ ] ) { $ is_admin = is_admin ( ) ; if ( self :: validate ( $ type , $ data , $ is_admin ) ) { $ hook = $ is_admin ? 'admin_enqueue_scripts' : 'wp_enqueue_scripts' ; $ method = __CLASS__ . "::add_{$type}s" ; if ( has_action ( $ hook , $ method ) === false ) { add_action ( $ hook , $ method ) ; } return true ; } return false ; }
6792	public function build ( Notify $ notify ) { $ event = new NotifyEvent ( $ notify ) ; $ this -> eventDispatcher -> dispatch ( NotifyEvents :: BUILD , $ event ) ; return ! $ event -> isAbort ( ) ; }
1440	protected function getResourceName ( ) { $ name = ucwords ( $ this -> getResourceInput ( ) ) ; if ( $ this -> isByResource ( ) ) { return str_plural ( $ name ) ; } return $ name ; }
1204	protected function renderChildren ( ItemInterface $ item , array $ options ) { if ( null !== $ options [ 'depth' ] ) { $ options [ 'depth' ] = $ options [ 'depth' ] - 1 ; } if ( null !== $ options [ 'matchingDepth' ] && $ options [ 'matchingDepth' ] > 0 ) { $ options [ 'matchingDepth' ] = $ options [ 'matchingDepth' ] - 1 ; } $ html = '' ; foreach ( $ item -> getChildren ( ) as $ child ) { $ html .= $ this -> renderItem ( $ child , $ options ) ; } return $ html ; }
2863	public function getLogging ( ) { $ logging = array ( ) ; foreach ( $ this -> files as $ logFile ) { $ logging [ $ logFile ] = $ this -> getLoggedContent ( $ logFile ) ; } return $ logging ; }
11478	public function addTemplateSlots ( $ templateName , $ username ) { if ( ! array_key_exists ( $ templateName , $ this -> templateBlocks ) ) { return null ; } $ blocks = $ this -> templateBlocks [ $ templateName ] ; $ this -> addSlots ( $ blocks , $ username ) ; }
4589	public function setWithVariablesInReturn ( ? bool $ withVariablesInReturn ) { $ this -> withVariablesInReturn = $ withVariablesInReturn ; $ this -> _withVariablesInReturn = null !== $ withVariablesInReturn ; return $ this ; }
8901	public function update_batch ( $ data , $ where_key ) { $ _data = array ( ) ; foreach ( $ data as $ key => $ row ) { if ( false !== $ row = $ this -> _do_pre_update ( $ row ) ) { $ _data [ $ key ] = $ row ; } } return $ this -> _database -> update_batch ( $ this -> _table , $ _data , $ where_key ) ; }
7621	public function permissionMatchesRequest ( $ permissionUrl = '' , $ requestUrl = '' , $ resourceType = Storage :: RESOURCE_UNKNOWN , $ requiredPermission = CredentialsAbstract :: PERMISSION_READ ) { $ requiredResourceType = $ resourceType ; if ( $ requiredResourceType == Storage :: RESOURCE_BLOB ) { $ requiredResourceType .= Storage :: RESOURCE_CONTAINER ; } $ parsedPermissionUrl = parse_url ( $ permissionUrl ) ; $ permissionParts = explode ( '&' , $ parsedPermissionUrl [ 'query' ] ) ; $ parsedRequestUrl = parse_url ( $ requestUrl ) ; $ matches = true ; foreach ( $ permissionParts as $ part ) { list ( $ property , $ value ) = explode ( '=' , $ part , 2 ) ; if ( $ property == 'sr' ) { $ matches = $ matches && ( strpbrk ( $ value , $ requiredResourceType ) !== false ) ; } if ( $ property == 'sp' ) { $ matches = $ matches && ( strpbrk ( $ value , $ requiredPermission ) !== false ) ; } } $ matches = $ matches && ( strpos ( $ parsedRequestUrl [ 'path' ] , $ parsedPermissionUrl [ 'path' ] ) !== false ) ; return $ matches ; }
9923	public function requireParam ( $ key ) { $ param = $ this -> fetch ( $ key , function ( $ key ) { throw new ParameterMissingException ( "Missing param '$key'" ) ; } ) ; if ( $ this -> valueIsEmpty ( $ param ) ) { throw new ParameterMissingException ( "Missing param '$key'" ) ; } return $ param ; }
3660	private function getFilterRule ( ) { $ this -> compile ( ) ; return new SimpleQuery ( $ this -> queryString , $ this -> queryParameter , 'id' , $ this -> container -> get ( Connection :: class ) ) ; }
8582	public function setAny ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'Any' ] [ 'FieldValue' ] = $ value ; return $ this ; }
8594	public function listOrdersByNextToken ( $ request ) { if ( ! ( $ request instanceof MarketplaceWebServiceOrders_Model_ListOrdersByNextTokenRequest ) ) { $ request = new MarketplaceWebServiceOrders_Model_ListOrdersByNextTokenRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListOrdersByNextToken' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = MarketplaceWebServiceOrders_Model_ListOrdersByNextTokenResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
4515	public static function parseFile ( string $ file , array $ data = [ ] ) : array { $ string = file_get_contents ( $ file ) ; return static :: parse ( $ string , $ data ) ; }
6878	private function getRevenueQuery ( ) { if ( null !== $ this -> revenueQuery ) { return $ this -> revenueQuery ; } $ qb = $ this -> createQueryBuilder ( 'o' ) ; $ expr = $ qb -> expr ( ) ; return $ this -> revenueQuery = $ qb -> select ( [ 'o.date' , 'o.revenue' , 'o.details' ] ) -> andWhere ( $ expr -> eq ( 'o.type' , ':type' ) ) -> andWhere ( $ expr -> gte ( 'o.date' , ':from' ) ) -> andWhere ( $ expr -> lte ( 'o.date' , ':to' ) ) -> addOrderBy ( 'o.date' ) -> getQuery ( ) ; }
4928	public function setListener ( $ event , $ service , $ method = null , $ priority = 0 ) { if ( is_int ( $ method ) ) { $ priority = $ method ; $ method = null ; } $ name = uniqid ( ) ; $ this -> listenerSpecs [ $ name ] = [ 'event' => $ event , 'service' => $ service , 'method' => $ method , 'priority' => $ priority , 'instance' => null , ] ; return $ this ; }
3326	public function render ( OptionCollection $ options ) { $ lines = array ( ) ; foreach ( $ options as $ option ) { $ c1 = $ this -> renderOption ( $ option ) ; $ lines [ ] = "\t" . $ c1 ; $ lines [ ] = wordwrap ( "\t\t" . $ option -> desc , $ this -> screenWidth , "\n\t\t" ) ; $ lines [ ] = '' ; } return implode ( "\n" , $ lines ) ; }
2730	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ dictionary = $ this -> api -> getSingleDictionary ( $ activeVersion , Config :: AUTH_DICTIONARY_NAME ) ; $ vclPath = Config :: VCL_AUTH_SNIPPET_PATH ; $ snippets = $ this -> config -> getVclSnippets ( $ vclPath ) ; $ status = true ; foreach ( $ snippets as $ key => $ value ) { $ name = Config :: FASTLY_MAGENTO_MODULE . '_basic_auth_' . $ key ; $ status = $ this -> api -> getSnippet ( $ activeVersion , $ name ) ; if ( ! $ status ) { break ; } } if ( ( is_array ( $ dictionary ) && empty ( $ dictionary ) ) || ! isset ( $ dictionary -> id ) ) { return $ result -> setData ( [ 'status' => 'empty' , 'msg' => 'Authentication dictionary does not exist.' ] ) ; } $ authItems = $ this -> api -> dictionaryItemsList ( $ dictionary -> id ) ; if ( ( $ status == true && is_array ( $ authItems ) && count ( $ authItems ) < 2 ) || $ authItems == false ) { return $ result -> setData ( [ 'status' => 'empty' , 'msg' => 'While Basic Authentication is enabled, at least one user must exist.' , ] ) ; } $ itemKey = $ this -> getRequest ( ) -> getParam ( 'item_key_id' ) ; $ deleteItem = $ this -> api -> deleteDictionaryItem ( $ dictionary -> id , $ itemKey ) ; if ( ! $ deleteItem ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to create Dictionary item.' ] ) ; } return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
4189	protected function dumpConstants ( $ constants ) { $ str = '' ; if ( $ constants && $ this -> debug -> output -> getCfg ( 'outputConstants' ) ) { $ str = '<dt class="constants">constants</dt>' . "\n" ; foreach ( $ constants as $ k => $ value ) { $ str .= '<dd class="constant">' . '<span class="constant-name">' . $ k . '</span>' . ' <span class="t_operator">=</span> ' . $ this -> debug -> output -> html -> dump ( $ value ) . '</dd>' . "\n" ; } } return $ str ; }
470	public function up ( ) { $ transaction = $ this -> db -> beginTransaction ( ) ; try { if ( $ this -> safeUp ( ) === false ) { $ transaction -> rollBack ( ) ; return false ; } $ transaction -> commit ( ) ; } catch ( \ Exception $ e ) { $ this -> printException ( $ e ) ; $ transaction -> rollBack ( ) ; return false ; } catch ( \ Throwable $ e ) { $ this -> printException ( $ e ) ; $ transaction -> rollBack ( ) ; return false ; } return null ; }
9475	public function stripQuotes ( $ string ) { if ( strlen ( $ string ) < 2 || substr ( $ string , 0 , 1 ) !== '"' || substr ( $ string , - 1 , 1 ) !== '"' ) { return $ string ; } return substr ( $ string , 1 , - 1 ) ; }
8059	public function setSemaphore ( Semaphore $ semaphore ) { if ( $ this -> created ) { throw new WorkerPoolException ( 'Cannot set the Worker Pool Size for a created pool.' ) ; } if ( ! $ semaphore -> isCreated ( ) ) { throw new \ InvalidArgumentException ( 'The Semaphore hasn\'t yet been created.' ) ; } $ this -> semaphore = $ semaphore ; return $ this ; }
2236	public function generate ( $ blnNoMarkup = false ) { if ( TL_MODE == 'FE' && ! BE_USER_LOGGED_IN && ( ! $ this -> published || ( $ this -> start != '' && $ this -> start > time ( ) ) || ( $ this -> stop != '' && $ this -> stop < time ( ) ) ) ) { return '' ; } $ this -> type = 'article' ; $ this -> blnNoMarkup = $ blnNoMarkup ; if ( System :: getContainer ( ) -> has ( 'fos_http_cache.http.symfony_response_tagger' ) ) { $ responseTagger = System :: getContainer ( ) -> get ( 'fos_http_cache.http.symfony_response_tagger' ) ; $ responseTagger -> addTags ( array ( 'contao.db.tl_article.' . $ this -> id ) ) ; } return parent :: generate ( ) ; }
12022	function addCheckScopeMethod ( ) { $ scopes = $ this -> operationDefinition -> getScopes ( ) ; if ( count ( $ scopes ) == 0 ) { return ; } $ methodGenerator = new MethodGenerator ( 'checkScopeRequirement' ) ; $ parameterGenerator = new ParameterGenerator ( 'allowedScopes' , 'array' ) ; $ methodGenerator -> setParameter ( $ parameterGenerator ) ; $ body = '//For each of the elements, all of the scopes in that element' . PHP_EOL ; $ body .= '//must be satisfied' . PHP_EOL ; $ body .= '$requiredScopesArray = [' . PHP_EOL ; foreach ( $ scopes as $ scopeList ) { $ body .= ' [' ; $ separator = '' ; foreach ( $ scopeList as $ scope ) { $ body .= sprintf ( "%s'%s'" , $ separator , $ scope ) ; $ separator = ', ' ; } $ body .= ']' . PHP_EOL ; } $ body .= '];' . PHP_EOL . PHP_EOL ; $ body .= <<< 'END'foreach($requiredScopesArray as $requiredScopes) { $requirementMet = true; foreach ($requiredScopes as $requiredScope) { if (in_array($requiredScope, $allowedScopes) == false) { $requirementMet = false; break; } } if ($requirementMet == true) { return true; }}return false;END ; $ methodGenerator -> setBody ( $ body ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
6793	protected function getTagSortSourceColumn ( $ prefix = null ) { $ column = $ this -> get ( 'tag_srcsorting' ) ; if ( ! $ column ) { return null ; } if ( null !== $ prefix ) { return $ prefix . '.' . $ column ; } return $ column ; }
7381	public function route ( bool $ dropIndex = false ) : string { if ( $ dropIndex ) { if ( 'index' == $ this -> route ) { return '' ; } } return $ this -> route ; }
9120	public function registerRouter ( AbstractRouter $ router ) { $ this -> router = $ router ; $ this -> router -> setApplication ( $ this ) ; return $ this ; }
12130	public function clear ( ) { $ this -> _repeat = 1 ; $ this -> _startTime = 0 ; $ this -> _duration = 0 ; $ this -> _average = 0 ; $ this -> _rate = 0 ; $ this -> _startMem = 0 ; $ this -> _memory = 0 ; }
4798	function offsetGet ( $ key ) { if ( $ this -> single && ! isset ( $ this -> data ) ) { $ clone = clone $ this ; if ( is_array ( $ key ) ) { $ clone -> where ( $ key ) -> limit ( 1 ) ; } else { $ clone -> where ( $ this -> primary , $ key ) ; } $ return = $ clone -> fetch ( ) ; if ( $ return ) { return $ return ; } } else { $ this -> execute ( ) ; if ( is_array ( $ key ) ) { foreach ( $ this -> data as $ row ) { foreach ( $ key as $ k => $ v ) { if ( ( isset ( $ v ) && $ row [ $ k ] !== null ? $ row [ $ k ] != $ v : $ row [ $ k ] !== $ v ) ) { continue 2 ; } } return $ row ; } } elseif ( isset ( $ this -> data [ $ key ] ) ) { return $ this -> data [ $ key ] ; } } return NULL ; }
7658	function SmtpClose ( ) { if ( $ this -> smtp != NULL ) { if ( $ this -> smtp -> Connected ( ) ) { $ this -> smtp -> Quit ( ) ; $ this -> smtp -> Close ( ) ; } } }
1040	public function processPsrRequest ( ServerRequestInterface $ request , ResponseInterface $ response , StreamInterface $ writableBodyStream ) { $ result = $ this -> executePsrRequest ( $ request ) ; return $ this -> helper -> toPsrResponse ( $ result , $ response , $ writableBodyStream ) ; }
7766	public function getContextAction ( $ type ) { $ context = $ this -> get ( 'hydra.api' ) -> getContext ( $ type ) ; if ( null === $ context ) { $ this -> createNotFoundException ( ) ; } return new JsonLdResponse ( $ context ) ; }
7530	protected function toString_attributes ( ) { $ s = '' ; foreach ( $ this -> attributes as $ a => $ v ) { $ s .= ' ' . $ a ; if ( ( ! $ this -> attribute_shorttag ) || ( $ v !== $ a ) ) { $ quote = ( strpos ( $ v , '"' ) === false ) ? '"' : "'" ; $ s .= '=' . $ quote . $ v . $ quote ; } } return $ s ; }
10852	public function echo ( $ type , $ content ) { if ( $ this -> option ( 'debug' ) == false ) { return ; } if ( trim ( $ content ) ) { $ this -> { $ type } ( $ content ) ; } }
7797	protected function statementNumber ( $ text ) { if ( $ line = $ this -> getLine ( '60F' , $ text ) ) { if ( preg_match ( '/(C|D)(\d{6})([A-Z]{3})([0-9,]{1,15})/' , $ line , $ match ) ) { return $ match [ 2 ] ; } } return null ; }
7039	public function getShippedAt ( $ latest = false ) { if ( 0 == $ this -> shipments -> count ( ) ) { return null ; } $ criteria = Criteria :: create ( ) ; $ criteria -> andWhere ( Criteria :: expr ( ) -> eq ( 'return' , false ) ) -> andWhere ( Criteria :: expr ( ) -> in ( 'state' , [ ShipmentStates :: STATE_READY , ShipmentStates :: STATE_SHIPPED ] ) ) -> orderBy ( [ 'createdAt' => $ latest ? Criteria :: DESC : Criteria :: ASC ] ) ; $ shipments = $ this -> shipments ; $ shipments = $ shipments -> matching ( $ criteria ) ; if ( false !== $ shipment = $ shipments -> first ( ) ) { return $ shipment -> getCreatedAt ( ) ; } return null ; }
8602	public function deregisterDestination ( $ request ) { if ( ! ( $ request instanceof MWSSubscriptionsService_Model_DeregisterDestinationInput ) ) { require_once ( dirname ( __FILE__ ) . '/Model/DeregisterDestinationInput.php' ) ; $ request = new MWSSubscriptionsService_Model_DeregisterDestinationInput ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'DeregisterDestination' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/DeregisterDestinationResponse.php' ) ; $ response = MWSSubscriptionsService_Model_DeregisterDestinationResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
10752	protected function getStateFormatted ( UserEntity $ user ) { switch ( $ user -> getState ( ) ) { case UserEntity :: USER_STATE_ACTIVE : $ this -> stateClass = 'success' ; return 'Attivo' ; break ; case UserEntity :: USER_STATE_BANNED : $ this -> stateClass = 'danger' ; return 'Bannato' ; break ; case UserEntity :: USER_STATE_DEACTIVE : $ this -> stateClass = 'warning' ; return 'Disattivo' ; break ; case UserEntity :: USER_STATE_DELETED : $ this -> stateClass = 'danger' ; return 'Eliminato' ; break ; } $ this -> stateClass = 'danger' ; return 'Error with user state' ; }
8460	public function exec ( $ command ) { fwrite ( $ this -> _fp , str_replace ( "\n" , '\n' , $ command ) . PHP_EOL ) ; $ answer = fgets ( $ this -> _fp ) ; if ( is_string ( $ answer ) ) { if ( substr ( $ answer , 0 , 7 ) === 'ANSWER ' ) { $ bytes = ( int ) substr ( $ answer , 7 ) ; if ( $ bytes > 0 ) { $ jsonObj = json_decode ( trim ( fread ( $ this -> _fp , $ bytes + 1 ) ) ) ; if ( is_null ( $ jsonObj ) ) { return 'You must enable the json flag on the telegram daemon to get proper response messages here.' ; } return $ jsonObj ; } } else { return $ answer ; } } return false ; }
6063	public function listFolders ( $ id , $ depth = 0 , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'depth' => $ depth ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/media/' . $ id . '/folders' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new FolderResponse ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
6363	public function start ( $ name ) : Profiler { if ( ! $ this -> globalStopwatch -> isRunning ( ) ) { $ this -> globalStopwatch -> start ( ) ; } if ( $ this -> entryStopwatch -> isRunning ( ) ) { $ this -> recordEntry ( ) ; } $ this -> currentName = $ name ; $ this -> entryStopwatch -> start ( ) ; return $ this ; }
11228	protected function getUrl ( $ section , array $ uriParams = [ ] ) { $ endpoint = rtrim ( $ this -> getEndpoint ( ) , '/' ) ; $ section = ltrim ( $ section , '/' ) ; $ params = http_build_query ( $ uriParams ) ; if ( $ params ) { return sprintf ( "%s/%s?%s" , $ endpoint , $ section , $ params ) ; } else { return sprintf ( "%s/%s" , $ endpoint , $ section ) ; } }
11027	protected function city ( ) { $ pluginOptions = [ 'url' => Url :: to ( [ "/{$this->module->id}/city/list" ] ) , 'depends' => [ $ this -> fieldIds [ 'country' ] ] ] ; if ( isset ( $ this -> fieldIds [ 'state' ] ) ) { $ pluginOptions [ 'depends' ] [ ] = $ this -> fieldIds [ 'state' ] ; $ pluginOptions [ 'initDepends' ] = [ $ this -> fieldIds [ 'country' ] ] ; } else { $ pluginOptions [ 'depends' ] [ ] = null ; } if ( isset ( $ this -> fieldIds [ 'region' ] ) ) { $ pluginOptions [ 'depends' ] [ ] = $ this -> fieldIds [ 'region' ] ; if ( isset ( $ this -> fieldIds [ 'state' ] ) ) { $ pluginOptions [ 'initDepends' ] [ ] = $ this -> fieldIds [ 'state' ] ; } } else { $ pluginOptions [ 'depends' ] [ ] = null ; } $ this -> parts [ '{city}' ] = $ this -> form -> field ( $ this -> model , $ this -> model -> getCityPropertyName ( ) ) -> widget ( DepDrop :: className ( ) , [ 'options' => [ 'id' => $ this -> fieldIds [ 'city' ] , 'cityholder' => Yii :: t ( 'jlorente/location' , 'Select city' ) , 'name' => $ this -> getSubmitModelName ( $ this -> model -> getCityPropertyName ( ) ) ] , 'data' => ArrayHelper :: map ( City :: find ( ) -> where ( [ 'region_id' => $ this -> model -> region_id ] ) -> orderBy ( [ 'name' => SORT_ASC ] ) -> all ( ) , 'id' , 'name' ) , 'pluginOptions' => $ pluginOptions ] ) ; }
1241	private static function encodeValueXml ( $ value ) { if ( $ value instanceof \ DateTime ) { return $ value -> format ( 'Y-m-d\TH:i:s.000\Z' ) ; } elseif ( is_bool ( $ value ) ) { return $ value ? 'true' : 'false' ; } else { return htmlspecialchars ( $ value , ENT_QUOTES , 'UTF-8' , true ) ; } }
6970	protected function calculateShipmentLine ( Model \ DocumentLineInterface $ line , Amount $ final ) : Amount { if ( $ line -> getType ( ) !== Model \ DocumentLineTypes :: TYPE_SHIPMENT ) { throw new LogicException ( sprintf ( "Expected document line with type '%s'." , Model \ DocumentLineTypes :: TYPE_SHIPMENT ) ) ; } $ sale = $ line -> getDocument ( ) -> getSale ( ) ; $ result = $ this -> calculator -> calculateSaleShipment ( $ sale , $ final ) ; if ( null === $ result ) { throw new LogicException ( "Unexpected document shipment line." ) ; } $ this -> syncLineWithResult ( $ line , $ result ) ; return $ result ; }
4817	public function insertRowBefore ( $ rowNumber , $ row = null ) { if ( $ rowNumber > count ( $ this -> collection ) ) { $ this -> appendRow ( $ row ) ; } else { $ singleRow = $ row ; if ( ! ( $ row instanceof Row ) ) { $ singleRow = new Row ( $ row ) ; } array_splice ( $ this -> collection , $ rowNumber , 0 , '' ) ; $ this -> collection [ $ rowNumber ] = $ singleRow ; } }
1298	public function getReferences ( Query $ query = null ) : ResourceArray { $ query = $ query ? : new Query ( ) ; $ query -> linksToEntry ( $ this -> getId ( ) ) ; return $ this -> client -> getEntries ( $ query ) ; }
11216	public static function setSingletonName ( $ method ) { if ( ! is_string ( $ method ) || empty ( $ method ) ) { return false ; } self :: $ singleton = $ method ; return true ; }
570	public function validateData ( $ data , $ key , $ rawHash = false ) { $ test = @ hash_hmac ( $ this -> macHash , '' , '' , $ rawHash ) ; if ( ! $ test ) { throw new InvalidConfigException ( 'Failed to generate HMAC with hash algorithm: ' . $ this -> macHash ) ; } $ hashLength = StringHelper :: byteLength ( $ test ) ; if ( StringHelper :: byteLength ( $ data ) >= $ hashLength ) { $ hash = StringHelper :: byteSubstr ( $ data , 0 , $ hashLength ) ; $ pureData = StringHelper :: byteSubstr ( $ data , $ hashLength , null ) ; $ calculatedHash = hash_hmac ( $ this -> macHash , $ pureData , $ key , $ rawHash ) ; if ( $ this -> compareString ( $ hash , $ calculatedHash ) ) { return $ pureData ; } } return false ; }
2828	public function getOptionArray ( array $ data ) { $ options = array ( ) ; foreach ( $ data as $ value ) { $ options [ ] = array ( 'value' => $ value , 'label' => $ value ) ; } return $ options ; }
4723	public function setAttribute ( $ attribute , $ value = null ) { $ this -> attributes -> set ( $ attribute , $ value ) ; return $ this ; }
1251	private function startElement ( $ parser , $ name , array $ attributes ) { $ this -> metaStack -> push ( $ this -> getPhpMeta ( $ this -> normalizeElementName ( $ name ) , $ attributes ) ) ; }
10080	public static function getCurrencyCode ( ) { if ( ! empty ( self :: $ currencyCode ) ) { return self :: $ currencyCode ; } self :: $ currencyCode = '$' ; $ localeconv = localeconv ( ) ; if ( ! empty ( $ localeconv [ 'currency_symbol' ] ) ) { self :: $ currencyCode = $ localeconv [ 'currency_symbol' ] ; return self :: $ currencyCode ; } if ( ! empty ( $ localeconv [ 'int_curr_symbol' ] ) ) { self :: $ currencyCode = $ localeconv [ 'int_curr_symbol' ] ; return self :: $ currencyCode ; } return self :: $ currencyCode ; }
1369	protected function bindInboundRequest ( ) { $ this -> app -> singleton ( JsonApiRequest :: class ) ; $ this -> app -> alias ( JsonApiRequest :: class , 'json-api.request' ) ; $ this -> app -> singleton ( Route :: class , function ( Application $ app ) { return new Route ( $ app -> make ( ResolverInterface :: class ) , $ app -> make ( 'router' ) -> current ( ) ) ; } ) ; $ this -> app -> bind ( StoreInterface :: class , function ( ) { return json_api ( ) -> getStore ( ) ; } ) ; $ this -> app -> bind ( ResolverInterface :: class , function ( ) { return json_api ( ) -> getResolver ( ) ; } ) ; $ this -> app -> bind ( ErrorRepositoryInterface :: class , function ( ) { return json_api ( ) -> getErrors ( ) ; } ) ; $ this -> app -> bind ( ContainerInterface :: class , function ( ) { return json_api ( ) -> getContainer ( ) ; } ) ; $ this -> app -> singleton ( HeaderParametersInterface :: class , function ( Application $ app ) { $ parser = $ app -> make ( HttpFactoryInterface :: class ) -> createHeaderParametersParser ( ) ; $ serverRequest = $ app -> make ( ServerRequestInterface :: class ) ; return $ parser -> parse ( $ serverRequest , http_contains_body ( $ serverRequest ) ) ; } ) ; $ this -> app -> singleton ( EncodingParametersInterface :: class , function ( Application $ app ) { $ parser = $ app -> make ( HttpFactoryInterface :: class ) -> createQueryParametersParser ( ) ; return $ parser -> parseQueryParameters ( request ( ) -> query ( ) ) ; } ) ; }
2875	public function getCategory ( $ timerName ) { $ category = self :: CORE_CATEGORY ; if ( strpos ( $ timerName , 'mage::dispatch' ) === 0 || strpos ( $ timerName , 'column.phtml' ) > 0 ) { $ category = self :: SECTION ; } else if ( strpos ( $ timerName , 'Model_Resource' ) > 0 ) { $ category = self :: DB_CATEGORY ; } else if ( strpos ( $ timerName , 'EAV' ) === 0 || strpos ( $ timerName , '_LOAD_ATTRIBUTE_' ) === 0 || strpos ( $ timerName , '__EAV_' ) === 0 ) { $ category = self :: EAV_CATEGORY ; } else if ( strpos ( $ timerName , 'CORE::create_object_of' ) === 0 ) { $ category = self :: CORE_CATEGORY ; } else if ( strpos ( $ timerName , 'OBSERVER' ) === 0 || strpos ( $ timerName , 'DISPATCH EVENT' ) === 0 ) { $ category = self :: EVENT_CATEGORY ; } else if ( strpos ( $ timerName , 'BLOCK' ) === 0 ) { $ category = self :: LAYOUT_CATEGORY ; } else if ( strpos ( $ timerName , 'init_config' ) === 0 ) { $ category = self :: CONFIG_CATEGORY ; } else if ( strpos ( $ timerName , 'layout/' ) === 0 || strpos ( $ timerName , 'layout_' ) > 0 ) { $ category = self :: LAYOUT_CATEGORY ; } else if ( strpos ( $ timerName , 'Mage_Core_Model_Design' ) === 0 ) { $ category = self :: LAYOUT_CATEGORY ; } else if ( strpos ( $ timerName , '.phtml' ) > 0 ) { $ category = self :: LAYOUT_CATEGORY ; } return $ category ; }
11861	public function getCompanionId ( ) { if ( $ this -> isForeign && isset ( $ this -> foreignPrimaryKey ) ) { return $ this -> foreignPrimaryKey ; } elseif ( ! $ this -> isForeign && isset ( $ this -> localPrimaryKey ) ) { return $ this -> localPrimaryKey ; } if ( isset ( $ this -> companionObject ) ) { return $ this -> companionObject -> primaryKey ; } return ; }
10994	public function getSize ( int $ precision = 0 , string $ point = "." , string $ sep = "," ) : string { $ bytes = $ this -> getByteSize ( ) ; if ( $ bytes === - 1 ) { return "" ; } return \ sndsgd \ Fs :: formatSize ( $ bytes , $ precision , $ point , $ sep ) ; }
9758	function closeTo ( $ value , float $ delta ) : self { return $ this -> expect ( $ this -> target , equalTo ( $ value , $ delta ) ) ; }
1196	protected function renderHtmlAttribute ( $ name , $ value ) { if ( true === $ value ) { return sprintf ( '%s="%s"' , $ name , $ this -> escape ( $ name ) ) ; } return sprintf ( '%s="%s"' , $ name , $ this -> escape ( $ value ) ) ; }
7657	function Send ( ) { $ header = "" ; $ body = "" ; $ result = true ; if ( ( count ( $ this -> to ) + count ( $ this -> cc ) + count ( $ this -> bcc ) ) < 1 ) { $ this -> SetError ( $ this -> Lang ( "provide_address" ) ) ; return false ; } if ( ! empty ( $ this -> AltBody ) ) $ this -> ContentType = "multipart/alternative" ; $ this -> error_count = 0 ; $ this -> SetMessageType ( ) ; $ header .= $ this -> CreateHeader ( ) ; $ body = $ this -> CreateBody ( ) ; if ( $ body == "" ) { return false ; } switch ( $ this -> Mailer ) { case "sendmail" : $ result = $ this -> SendmailSend ( $ header , $ body ) ; break ; case "mail" : $ result = $ this -> MailSend ( $ header , $ body ) ; break ; case "smtp" : $ result = $ this -> SmtpSend ( $ header , $ body ) ; break ; default : $ this -> SetError ( $ this -> Mailer . $ this -> Lang ( "mailer_not_supported" ) ) ; $ result = false ; break ; } return $ result ; }
8411	public function disconnect ( ) { if ( isset ( $ this -> servers [ 'all' ] ) === true ) { unset ( $ this -> servers [ 'all' ] [ 'link' ] ) ; } else { unset ( $ this -> servers [ 'read' ] [ 'link' ] ) ; unset ( $ this -> servers [ 'write' ] [ 'link' ] ) ; } }
2817	public function addModel ( Mage_Core_Model_Abstract $ model ) { $ modelInfo = Mage :: getModel ( 'sheep_debug/model' ) ; $ modelInfo -> init ( $ model ) ; $ key = $ modelInfo -> getClass ( ) ; if ( ! array_key_exists ( $ key , $ this -> models ) ) { $ this -> models [ $ key ] = $ modelInfo ; } $ this -> models [ $ key ] -> incrementCount ( ) ; }
1675	public function unsynchronize ( ) { if ( ! file_exists ( $ this -> strRootDir . '/' . $ this -> strFolder . '/.nosync' ) ) { System :: getContainer ( ) -> get ( 'filesystem' ) -> touch ( $ this -> strRootDir . '/' . $ this -> strFolder . '/.nosync' ) ; } }
9682	function fromXML ( $ xmlElement ) { $ this -> contact = new ReportContact ( ) ; $ this -> contact -> fromXML ( $ xmlElement -> contact ) ; if ( isset ( $ xmlElement -> mailing_id ) ) $ this -> mailingId = $ xmlElement -> mailing_id ; if ( isset ( $ xmlElement -> timestamp ) ) $ this -> timestamp = $ xmlElement -> timestamp ; if ( isset ( $ xmlElement -> link_id ) ) $ this -> linkId = $ xmlElement -> link_id ; if ( isset ( $ xmlElement -> link_url ) ) $ this -> linkUrl = $ xmlElement -> link_url ; if ( isset ( $ xmlElement -> link_tags ) ) { $ this -> linkTags = array ( ) ; foreach ( $ xmlElement -> link_tags -> children ( ) as $ field ) { array_push ( $ this -> linkTags , $ field [ 0 ] ) ; } } }
12857	function giveBuiltInQueue ( iQueueDriver $ queueDriver ) { if ( $ this -> builtinQueue ) throw new exImmutable ( sprintf ( 'Built-in Queue (%s) is given.' , \ Poirot \ Std \ flatten ( $ this -> builtinQueue ) ) ) ; $ this -> builtinQueue = $ queueDriver ; return $ this ; }
5283	public function insert ( $ data , $ format = null ) { global $ wpdb ; $ wpdb -> insert ( $ this -> table , $ data , $ format ) ; return $ wpdb -> insert_id ; }
3398	private function parseStr ( $ string ) { $ params = array ( ) ; $ pairs = explode ( '&' , $ string ) ; foreach ( $ pairs as $ pair ) { if ( ! $ pair ) { continue ; } $ var = explode ( '=' , $ pair , 2 ) ; $ val = ( isset ( $ var [ 1 ] ) ? $ var [ 1 ] : '' ) ; if ( isset ( $ params [ $ var [ 0 ] ] ) ) { if ( is_array ( $ params [ $ var [ 0 ] ] ) ) { $ params [ $ var [ 0 ] ] [ ] = $ val ; } else { $ params [ $ var [ 0 ] ] = array ( $ params [ $ var [ 0 ] ] , $ val ) ; } } else { $ params [ $ var [ 0 ] ] = $ val ; } } return $ params ; }
9418	public function f ( $ x ) { if ( ! is_numeric ( $ x ) ) { throw new \ InvalidArgumentException ( 'x variable must be numeric value.' ) ; } $ float_fx = exp ( - 0.5 * pow ( ( $ x - $ this -> float_mu ) / $ this -> float_sigma , 2 ) ) / ( $ this -> float_sigma * sqrt ( 2 * pi ( ) ) ) ; if ( $ this -> int_precision ) { return round ( $ float_fx , $ this -> int_precision ) ; } return $ float_fx ; }
279	private function notifyNotFound ( $ fixtures ) { $ this -> stdout ( "Some fixtures were not found under path:\n" , Console :: BG_RED ) ; $ this -> stdout ( "\t" . $ this -> getFixturePath ( ) . "\n\n" , Console :: FG_GREEN ) ; $ this -> stdout ( "Check that they have correct namespace \"{$this->namespace}\" \n" , Console :: BG_RED ) ; $ this -> outputList ( $ fixtures ) ; $ this -> stdout ( "\n" ) ; }
2622	public function sendConfigurationRequest ( $ configuredFlag ) { if ( $ configuredFlag ) { $ configuredState = self :: FASTLY_CONFIGURED_FLAG ; } else { $ configuredState = self :: FASTLY_NOT_CONFIGURED_FLAG ; } $ pageViewParams = [ 'dl' => self :: GA_PAGEVIEW_URL . $ configuredState , 'dh' => preg_replace ( '#^https?://#' , '' , rtrim ( self :: GA_PAGEVIEW_URL , '/' ) ) , 'dp' => '/' . $ configuredState , 'dt' => ucfirst ( $ configuredState ) , 't' => self :: GA_HITTYPE_PAGEVIEW , ] ; $ this -> sendReqToGA ( $ pageViewParams ) ; $ eventParams = [ 'ec' => self :: GA_FASTLY_SETUP , 'ea' => 'Fastly ' . $ configuredState , 'el' => $ this -> getWebsiteName ( ) , 'ev' => $ this -> daysFromInstallation ( ) , 't' => self :: GA_HITTYPE_EVENT ] ; $ result = $ this -> sendReqToGA ( array_merge ( $ pageViewParams , $ eventParams ) ) ; return $ result ; }
6034	public function setMimeType ( $ mimeType ) { if ( $ mimeType instanceof MimeType ) { $ this -> mimeType = $ mimeType ; } elseif ( is_array ( $ mimeType ) ) { $ this -> mimeType = new MimeType ( $ mimeType ) ; } else { $ this -> mimeType = null ; trigger_error ( 'Argument must be an object of class MimeType. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
2582	protected function loadTransactionFlowLink ( $ params ) { if ( isset ( $ params [ 'enableTransactionFlowLink' ] ) && $ params [ 'enableTransactionFlowLink' ] === true ) { $ this -> enableTransactionFlowLink = true ; $ this -> consumerId = ( isset ( $ params [ 'consumerId' ] ) ) ? $ params [ 'consumerId' ] : null ; } }
9003	protected function extra_tablenav ( $ which ) { if ( $ which !== 'top' ) { return ; } $ this -> months_dropdown ( '' ) ; $ selected = isset ( $ _GET [ 'level' ] ) ? $ _GET [ 'level' ] : '' ; ?> <label for="filter-by-level" class="screen-reader-text"> <?php echo $ this -> translations [ 'levelFilterLabel' ] ; ?> </label> <select name="level" id="filter-by-level"> <option value=""> <?php echo $ this -> translations [ 'allLevels' ] ; ?> </option> <?php foreach ( $ this -> get_levels ( ) as $ level => $ label ) : ?> <option value=" <?php echo esc_attr ( $ level ) ; ?> " <?php selected ( $ selected , $ level ) ; ?> > <?php echo $ label ; ?> </option> <?php endforeach ; ?> </select> <?php submit_button ( $ this -> translations [ 'filter' ] , 'button' , 'filter_action' , false ) ; }
5350	public function setMailBoxPassword ( $ domainName , $ mailBox , $ password ) { return $ this -> call ( self :: SERVICE , 'setMailBoxPassword' , [ $ domainName , $ mailBox , $ password ] ) ; }
3867	public function handle ( ManipulateWidgetEvent $ event ) { if ( ! ( $ this -> wantToHandle ( $ event ) && ( 'tl_class' === $ event -> getProperty ( ) -> getName ( ) ) ) ) { return ; } $ link = ' <a href="%1$s" onclick="Backend.getScrollOffset();Backend.openModalIframe({' . '\'width\':765,' . '\'title\':\'%2$s\',' . '\'url\':this.href,' . '\'id\':\'%3$s\'' . '});return false">%4$s</a>' ; $ image = $ this -> iconBuilder -> getBackendIconImageTag ( 'bundles/metamodelscore/images/icons/dca_wizard.png' , $ event -> getEnvironment ( ) -> getTranslator ( ) -> translate ( 'stylepicker' , 'tl_metamodel_dca' ) , 'style="vertical-align:top;"' ) ; $ event -> getWidget ( ) -> wizard = sprintf ( $ link , $ this -> urlGenerator -> generate ( 'metamodels.picker' , [ 'tbl' => $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getName ( ) , 'fld' => $ event -> getProperty ( ) -> getName ( ) , 'inputName' => 'ctrl_' . $ event -> getProperty ( ) -> getName ( ) , 'id' => $ event -> getModel ( ) -> getId ( ) , 'item' => 'PALETTE_STYLE_PICKER' , ] ) , addslashes ( $ event -> getEnvironment ( ) -> getTranslator ( ) -> translate ( 'stylepicker' , 'tl_metamodel_dca' ) ) , $ event -> getModel ( ) -> getId ( ) , $ image ) ; }
6331	private function registerPostProcessor ( string $ type , string $ class ) : void { if ( \ class_exists ( $ class ) ) { $ interfaces = \ class_implements ( $ class ) ; if ( \ in_array ( PostProcessor :: class , $ interfaces , true ) ) { $ this -> postProcessorsMap [ $ type ] = $ class ; } else { throw new ConfigException ( "Class {$class} don't implement interface " . PostProcessor :: class ) ; } } else { throw new ConfigException ( "Class {$class} not found" ) ; } }
8616	public function setId ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'Id' ] [ 'FieldValue' ] = $ value ; return $ this ; }
9757	function below ( $ value ) : self { $ target = $ this -> hasFlag ( 'length' ) ? $ this -> getLength ( $ this -> target ) : $ this -> target ; return $ this -> expect ( $ target , lessThan ( $ value ) ) ; }
9419	public function samples ( $ amount ) { if ( ! is_numeric ( $ amount ) || $ amount < 1 ) { throw new \ InvalidArgumentException ( 'Amount of samples must be greater or equal to one' ) ; } $ arr = array ( ) ; for ( $ i = 1 ; $ i <= $ amount ; $ i ++ ) { $ r = new Random ( ) ; $ float_u = $ r -> get ( ) ; $ float_v = $ r -> get ( ) ; $ double_x = $ this -> float_sigma * sqrt ( - 2 * log ( $ float_u ) ) * cos ( 2 * pi ( ) * $ float_v ) + $ this -> float_mu ; if ( $ this -> int_precision ) { $ arr [ ] = round ( $ double_x , $ this -> int_precision ) ; } else { $ arr [ ] = $ double_x ; } } return $ arr ; }
10183	private function getAllCacheKeys ( ) { $ keys = [ ] ; foreach ( $ this -> getCoordinates ( ) as $ coordinate ) { $ keys [ ] = $ this -> cachePrefix . $ coordinate ; } return $ keys ; }
4865	public function listing ( array $ options = [ ] ) { $ filter = [ 'queue' => $ this -> getName ( ) ] ; if ( isset ( $ options [ 'status' ] ) ) { $ filter [ 'status' ] = $ options [ 'status' ] ; } $ opt = [ 'sort' => [ 'scheduled' => 1 , 'priority' => 1 ] ] ; if ( isset ( $ options [ 'limit' ] ) ) { $ opt [ 'limit' ] = $ options [ 'limit' ] ; } $ cursor = $ this -> mongoCollection -> find ( $ filter , $ opt ) ; $ jobs = $ cursor -> toArray ( ) ; foreach ( $ jobs as & $ envelope ) { $ envelope [ 'job' ] = $ this -> unserializeJob ( $ envelope [ 'data' ] , [ '__id__' => $ envelope [ '_id' ] ] ) ; } return $ jobs ; }
2861	public function getRange ( $ logFile ) { if ( ! array_key_exists ( $ logFile , $ this -> ranges ) ) { throw new Exception ( 'Invalid log file' ) ; } return $ this -> ranges [ $ logFile ] ; }
10899	public function save ( bool $ validate = true ) : self { if ( $ validate && $ this -> validate ( ) ) { throw new Exception ( 'Entity ' . $ this -> __getEntityName ( ) . ' data is not valid' ) ; } $ scheme = \ array_keys ( $ this -> getScheme ( ) ) ; foreach ( $ this -> data as $ key => $ value ) { if ( ! \ in_array ( $ key , $ scheme , true ) ) { unset ( $ this -> data [ $ key ] ) ; } } if ( $ this -> getId ( ) ) { $ this -> medoo -> update ( $ this -> getTable ( ) , $ this -> data , [ 'id' => $ this -> getId ( ) ] ) ; } else { $ this -> medoo -> insert ( $ this -> getTable ( ) , $ this -> data ) ; $ this -> setId ( $ this -> medoo -> id ( ) ) ; } $ this -> sentry -> breadcrumbs -> record ( [ 'message' => 'Entity ' . $ this -> __getEntityName ( ) . '::save()' , 'data' => [ 'query' => $ this -> medoo -> last ( ) ] , 'category' => 'Database' , 'level' => 'info' , ] ) ; return $ this ; }
10237	public static function getInstance ( Spreadsheet $ spreadsheet = null ) { if ( $ spreadsheet !== null ) { $ instance = $ spreadsheet -> getCalculationEngine ( ) ; if ( isset ( $ instance ) ) { return $ instance ; } } if ( ! isset ( self :: $ instance ) || ( self :: $ instance === null ) ) { self :: $ instance = new self ( ) ; } return self :: $ instance ; }
3543	public function actionCreateExampleRole ( ) { $ auth = Yii :: $ app -> authManager ; $ displayDetailedAbout = $ auth -> createPermission ( 'permissionDisplayDetailedAbout' ) ; $ displayDetailedAbout -> description = 'Permission to display detailed about informations' ; $ auth -> add ( $ displayDetailedAbout ) ; $ useContactPage = $ auth -> createPermission ( 'permissionToUseContanctPage' ) ; $ useContactPage -> description = 'Permission to use the contanct page' ; $ auth -> add ( $ useContactPage ) ; $ yii2ExampleGroup = $ auth -> createRole ( 'yii2_example_group' ) ; $ auth -> add ( $ yii2ExampleGroup ) ; $ auth -> addChild ( $ yii2ExampleGroup , $ displayDetailedAbout ) ; $ auth -> addChild ( $ yii2ExampleGroup , $ useContactPage ) ; $ useHomePage = $ auth -> createPermission ( 'permissionToSeeHome' ) ; $ useHomePage -> description = 'Permission to use the home page' ; $ auth -> add ( $ useHomePage ) ; $ yii2HomeGroup = $ auth -> createRole ( 'yii2_see_home_group' ) ; $ auth -> add ( $ yii2HomeGroup ) ; $ auth -> addChild ( $ yii2HomeGroup , $ useHomePage ) ; echo "\n\n!!!! TODO !!!!\nTow roles with the name yii2_example_group and yii2_see_home_group were created in yii2.\nPlease create the groups with the same name in Active Directory.\nAssign the user you are using for the login to this groups in Active Directory.\n" ; }
7914	protected function renderLabel ( ) { $ label = $ this -> encodeLabel ? Html :: encode ( $ this -> label ) : $ this -> label ; return $ this -> hasModel ( ) ? Html :: activeLabel ( $ this -> model , $ this -> attribute , $ this -> labelOptions ) : Html :: label ( $ label , $ this -> getId ( ) , $ this -> labelOptions ) ; }
8749	public function loadFromRegistry ( Registry $ registry ) { foreach ( $ registry as $ key => $ serviceProvider ) { $ this -> loadServiceProviderFactories ( $ serviceProvider , $ key ) ; } foreach ( $ registry as $ key => $ serviceProvider ) { $ this -> loadServiceProviderExtensions ( $ serviceProvider , $ key ) ; } }
10576	public static function applyStyle ( $ text , $ style ) { $ foreground = self :: getForeground ( $ style ) ; $ background = self :: getBackground ( $ style ) ; return self :: apply ( $ text , $ foreground , $ background ) ; }
3462	public function process ( ServerRequestInterface $ request , RequestHandlerInterface $ next ) : ResponseInterface { $ route = $ this -> router -> find ( $ request -> getMethod ( ) , $ request -> getUri ( ) -> getPath ( ) ) ; $ controller = $ route -> getController ( ) ; if ( $ request instanceof ServerRequest ) { $ request = $ request -> withAttributes ( $ route -> getAttributes ( ) ) ; } if ( is_string ( $ controller ) && class_exists ( $ controller ) && is_subclass_of ( $ controller , Controller :: class ) ) { $ instance = $ this -> resolver -> resolve ( $ controller ) ; return $ instance ( $ request ) ; } if ( is_callable ( $ controller ) ) { $ response = $ controller ( $ request ) ; if ( ! $ response instanceof ResponseInterface ) { throw ControllerException :: forInvalidReturnValue ( ) ; } return $ response ; } throw ControllerException :: forMissingController ( $ route -> getPath ( ) ) ; }
5522	public function generate ( $ methods ) { if ( ! $ this -> reflection -> classOrInterfaceExists ( ) ) { return false ; } $ mock_reflection = new SimpleReflection ( $ this -> mock_class ) ; if ( $ mock_reflection -> classExistsWithoutAutoload ( ) ) { return false ; } $ code = $ this -> createCodeForClass ( $ methods ? $ methods : array ( ) ) ; return eval ( "$code return \$code;" ) ; }
5417	protected function createResponse ( $ socket ) { $ response = new SimpleHttpResponse ( $ socket , $ this -> route -> getUrl ( ) , $ this -> encoding ) ; $ socket -> close ( ) ; return $ response ; }
10134	public function positionImage ( $ col_start , $ row_start , $ x1 , $ y1 , $ width , $ height ) { $ col_end = $ col_start ; $ row_end = $ row_start ; if ( $ x1 >= Xls :: sizeCol ( $ this -> phpSheet , Coordinate :: stringFromColumnIndex ( $ col_start + 1 ) ) ) { $ x1 = 0 ; } if ( $ y1 >= Xls :: sizeRow ( $ this -> phpSheet , $ row_start + 1 ) ) { $ y1 = 0 ; } $ width = $ width + $ x1 - 1 ; $ height = $ height + $ y1 - 1 ; while ( $ width >= Xls :: sizeCol ( $ this -> phpSheet , Coordinate :: stringFromColumnIndex ( $ col_end + 1 ) ) ) { $ width -= Xls :: sizeCol ( $ this -> phpSheet , Coordinate :: stringFromColumnIndex ( $ col_end + 1 ) ) ; ++ $ col_end ; } while ( $ height >= Xls :: sizeRow ( $ this -> phpSheet , $ row_end + 1 ) ) { $ height -= Xls :: sizeRow ( $ this -> phpSheet , $ row_end + 1 ) ; ++ $ row_end ; } if ( Xls :: sizeCol ( $ this -> phpSheet , Coordinate :: stringFromColumnIndex ( $ col_start + 1 ) ) == 0 ) { return ; } if ( Xls :: sizeCol ( $ this -> phpSheet , Coordinate :: stringFromColumnIndex ( $ col_end + 1 ) ) == 0 ) { return ; } if ( Xls :: sizeRow ( $ this -> phpSheet , $ row_start + 1 ) == 0 ) { return ; } if ( Xls :: sizeRow ( $ this -> phpSheet , $ row_end + 1 ) == 0 ) { return ; } $ x1 = $ x1 / Xls :: sizeCol ( $ this -> phpSheet , Coordinate :: stringFromColumnIndex ( $ col_start + 1 ) ) * 1024 ; $ y1 = $ y1 / Xls :: sizeRow ( $ this -> phpSheet , $ row_start + 1 ) * 256 ; $ x2 = $ width / Xls :: sizeCol ( $ this -> phpSheet , Coordinate :: stringFromColumnIndex ( $ col_end + 1 ) ) * 1024 ; $ y2 = $ height / Xls :: sizeRow ( $ this -> phpSheet , $ row_end + 1 ) * 256 ; $ this -> writeObjPicture ( $ col_start , $ x1 , $ row_start , $ y1 , $ col_end , $ x2 , $ row_end , $ y2 ) ; }
6330	private function registerEffect ( string $ type , string $ class ) : void { if ( \ class_exists ( $ class ) ) { $ interfaces = \ class_implements ( $ class ) ; if ( \ in_array ( Effect :: class , $ interfaces , true ) ) { $ this -> effectsMap [ $ type ] = $ class ; } else { throw new ConfigException ( "Class {$class} don't implement interface " . Effect :: class ) ; } } else { throw new ConfigException ( "Class {$class} not found" ) ; } }
1193	private function addCustomElements ( array $ elements , HTMLPurifier_HTMLDefinition $ definition ) { foreach ( $ elements as $ element ) { $ name = $ element [ 0 ] ; $ contentSet = $ element [ 1 ] ; $ allowedChildren = $ element [ 2 ] ; $ attributeCollection = $ element [ 3 ] ; $ attributes = isset ( $ element [ 4 ] ) ? $ element [ 4 ] : null ; if ( ! empty ( $ attributes ) ) { $ definition -> addElement ( $ name , $ contentSet , $ allowedChildren , $ attributeCollection , $ attributes ) ; } else { $ definition -> addElement ( $ name , $ contentSet , $ allowedChildren , $ attributeCollection ) ; } } }
12160	public function getDetailsWidget ( $ objectModel = null ) { if ( is_null ( $ objectModel ) && isset ( Yii :: $ app -> request -> object ) ) { $ objectModel = Yii :: $ app -> request -> object ; } elseif ( is_null ( $ objectModel ) ) { $ objectModel = $ this -> dummyModel ; } $ detailsSection = $ this -> getDetailsSection ( ) ; if ( $ detailsSection === false ) { return false ; } if ( $ detailsSection === true ) { $ detailsSection = '_self' ; } $ detailsWidgetClass = self :: classNamespace ( ) . '\widgets\\' . 'Details' ; $ widgetClass = $ this -> fallbackDetailsWidgetClass ; @ class_exists ( $ detailsWidgetClass ) ; if ( class_exists ( $ detailsWidgetClass , false ) ) { $ widgetClass = $ detailsWidgetClass ; } $ widget = [ 'class' => $ widgetClass ] ; $ widget [ 'owner' ] = $ this ; $ widgetItem = [ 'widget' => $ widget , 'locations' => [ 'self' ] , 'priority' => 1 ] ; $ widgetItem [ 'section' ] = Yii :: $ app -> collectors [ 'sections' ] -> getOne ( $ detailsSection ) ; return $ widgetItem ; }
8607	private function _convertListSubscriptions ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'ListSubscriptions' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetMarketplaceId ( ) ) { $ parameters [ 'MarketplaceId' ] = $ request -> getMarketplaceId ( ) ; } return $ parameters ; }
963	public function postProcess ( ) { if ( ! $ this -> shop -> trashed ( ) ) { return ; } $ this -> shop -> restore ( ) ; $ this -> shop -> charges ( ) -> restore ( ) ; $ this -> shop -> save ( ) ; }
33	protected function addReason ( $ id , $ reason ) { if ( ! isset ( $ this -> reasonSeen [ $ id ] ) ) { $ this -> reasonSeen [ $ id ] = true ; $ this -> reasons [ $ this -> section ] [ ] = $ reason ; } }
5956	public function channelClientPermList ( $ cid , $ cldbid , $ permsid = false ) { return $ this -> execute ( "channelclientpermlist" , array ( "cid" => $ cid , "cldbid" => $ cldbid , $ permsid ? "-permsid" : null ) ) -> toAssocArray ( $ permsid ? "permsid" : "permid" ) ; }
6260	public function getControllerNameAndAction ( Request $ request ) { $ controller = $ this -> _registry -> getController ( ) ; $ name = $ controller -> name ; $ action = $ request -> action ; if ( ! empty ( $ request -> params [ 'plugin' ] ) ) { $ name = Inflector :: camelize ( $ request -> params [ 'plugin' ] ) . '.' . $ name ; } return compact ( 'name' , 'action' ) ; }
5293	protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ directory = $ input -> getArgument ( 'directory' ) ; $ outputFile = $ input -> getArgument ( 'output-file' ) ; $ generator = new IconFontGenerator ; $ output -> writeln ( 'reading files from "' . $ directory . '" ...' ) ; $ generator -> generateFromDir ( $ directory , array ( 'id' => $ input -> getOption ( 'name' ) ? : 'SVGFont' , ) , $ input -> getOption ( 'rename-files' ) ) ; $ output -> writeln ( 'writing font to "' . $ outputFile . '" ...' ) ; file_put_contents ( $ outputFile , $ generator -> getFont ( ) -> getXML ( ) ) ; $ output -> getFormatter ( ) -> setStyle ( 'success' , new OutputFormatterStyle ( null , null , array ( 'bold' , 'reverse' ) ) ) ; $ output -> writeln ( '<success>created ' . $ outputFile . ' successfully</success>' ) ; }
1604	public function onException ( ExceptionEvent $ event ) { $ exception = $ event -> exception ; $ craft = \ Craft :: $ app ; if ( ! ( $ exception instanceof HttpException ) || $ exception -> statusCode !== 404 ) return ; $ path = $ craft -> request -> getFullPath ( ) ; $ query = $ craft -> request -> getQueryStringWithoutPath ( ) ; if ( $ query ) $ path .= '?' . $ query ; if ( $ redirect = $ this -> findRedirectByPath ( $ path ) ) { $ event -> handled = true ; $ craft -> response -> redirect ( $ redirect [ 'to' ] , $ redirect [ 'type' ] ) -> send ( ) ; $ craft -> end ( ) ; } }
7199	protected function assignSaleItemRecursively ( SaleItemInterface $ item ) { $ this -> stockAssigner -> assignSaleItem ( $ item ) ; foreach ( $ item -> getChildren ( ) as $ child ) { $ this -> assignSaleItemRecursively ( $ child ) ; } }
5516	public function errorOn ( $ method , $ error = 'A mock error' , $ args = false , $ severity = E_USER_ERROR ) { $ this -> dieOnNoMethod ( $ method , 'error on' ) ; $ this -> actions -> register ( $ method , $ args , new SimpleErrorThrower ( $ error , $ severity ) ) ; }
12579	public function previewImageByName ( $ message , $ to ) { return $ this -> preview ( self :: MSG_TYPE_IMAGE , $ message , $ to , self :: PREVIEW_BY_NAME ) ; }
6119	public function serverDelete ( $ sid ) { $ this -> serverListReset ( ) ; $ this -> execute ( "serverdelete" , array ( "sid" => $ sid ) ) ; Signal :: getInstance ( ) -> emit ( "notifyServerdeleted" , $ this , $ sid ) ; }
11747	public function group ( ) { if ( is_null ( $ this -> group ) ) { $ this -> group = new Group ( $ this -> accessToken ) ; } return $ this -> group ; }
10890	public static function input ( $ prompt , $ default = null ) { $ ret = false ; while ( ! $ ret ) { if ( $ prompt ) { echo $ prompt ; if ( $ default ) echo " (" . $ default . ")" ; echo ": " ; } $ ret = trim ( fgets ( STDIN ) ) ; if ( ! $ ret && $ default !== null ) return $ default ; } return trim ( $ ret ) ; }
8012	public static function forChallengeMessage ( $ challenge_message , $ code = 0 , Exception $ previous = null ) { $ message = self :: DEFAULT_MESSAGE ; $ reason_messages = [ ] ; if ( ( self :: CODE_FOR_INVALID_SIGNATURE & $ code ) === self :: CODE_FOR_INVALID_SIGNATURE ) { $ reason_messages [ ] = self :: MESSAGE_FOR_INVALID_SIGNATURE ; } if ( ( self :: CODE_FOR_INVALID_MESSAGE_TYPE & $ code ) === self :: CODE_FOR_INVALID_MESSAGE_TYPE ) { $ reason_messages [ ] = self :: MESSAGE_FOR_INVALID_MESSAGE_TYPE ; } $ message .= sprintf ( self :: MESSAGE_EXTENSION_FOR_REASONS_FORMAT , implode ( self :: MESSAGE_REASON_GLUE , $ reason_messages ) ) ; $ instance = new static ( $ message , $ code , $ previous ) ; $ instance -> challenge_message = $ challenge_message ; return $ instance ; }
11738	protected function normalize ( $ scheme = true , $ www = true ) { $ address = $ this -> address ; if ( $ scheme && null === $ this -> get ( self :: PARSE_SCHEME ) ) { $ address = sprintf ( 'http://%s' , $ this -> address ) ; } elseif ( ! $ scheme && $ this -> get ( self :: PARSE_SCHEME ) ) { $ address = str_replace ( $ this -> get ( self :: PARSE_SCHEME ) . '://' , '' , $ this -> address ) ; } if ( false === $ www && 0 === strpos ( $ this -> get ( self :: PARSE_HOST ) , 'www.' ) ) { $ address = substr ( $ address , 4 ) ; } return $ address ; }
9242	private function __next ( ServerRequestInterface $ request , ResponseInterface $ response , $ next ) { $ this -> __loadConfigFiles ( ) ; return $ next ( $ request , $ response ) ; }
2939	public static function linearUnitFactory ( $ name , $ toNativeUnitFactor ) { return new static ( $ name , function ( $ valueInNativeUnit ) use ( $ toNativeUnitFactor ) { return $ valueInNativeUnit / $ toNativeUnitFactor ; } , function ( $ valueInThisUnit ) use ( $ toNativeUnitFactor ) { return $ valueInThisUnit * $ toNativeUnitFactor ; } ) ; }
6156	public function redirect ( string $ url ) : object { return parent :: redirect ( $ this -> di -> get ( "url" ) -> create ( $ url ) ) ; }
12021	private function generateParameterSetBlock ( $ indent , \ ArtaxServiceBuilder \ Parameter $ operationParameter ) { switch ( $ operationParameter -> getLocation ( ) ) { case 'absoluteURL' : { return $ indent . '$url = $value;' . PHP_EOL ; break ; } case 'postField' : { return sprintf ( $ indent . '$formBody->addField(\'%s\', $value);' . PHP_EOL , $ operationParameter -> getSentAs ( ) ) ; } case 'postFile' : { return sprintf ( $ indent . '$formBody->addFileField(\'%s\', $value);' . PHP_EOL , $ operationParameter -> getSentAs ( ) ) ; break ; } case 'json' : { return sprintf ( $ indent . '$jsonParams[\'%s\'] = $value;' . PHP_EOL , $ operationParameter -> getSentAs ( ) ) ; } case ( 'header' ) : { return sprintf ( $ indent . '$request->setHeader(\'%s\', $value);' . PHP_EOL , $ operationParameter -> getSentAs ( ) , $ operationParameter -> getName ( ) ) ; } default : case 'query' : { return sprintf ( $ indent . '$queryParameters[\'%s\'] = $value;' . PHP_EOL , $ operationParameter -> getSentAs ( ) , $ operationParameter -> getName ( ) ) ; } } }
4391	public function getConfigBE ( ) { $ list = [ ] ; foreach ( $ this -> beConfig as $ key => $ config ) { $ list [ $ key ] = new \ Aimeos \ MW \ Criteria \ Attribute \ Standard ( $ config ) ; } return $ list ; }
8480	public function run ( $ eventGroupId = null ) { $ eventGroups = EventGroup :: find ( ) -> asArray ( true ) -> all ( ) ; if ( count ( $ eventGroups ) === 0 ) { throw new Exception ( 'Event groups not found' ) ; } if ( $ eventGroupId === null ) { $ first = reset ( $ eventGroups ) ; $ eventGroupId = $ first [ 'id' ] ; } $ tabs = [ ] ; foreach ( $ eventGroups as $ eventGroup ) { $ tabs [ ] = [ 'label' => $ eventGroup [ 'name' ] , 'url' => [ 'index' , 'eventGroupId' => $ eventGroup [ 'id' ] ] , 'active' => $ eventGroupId == $ eventGroup [ 'id' ] , ] ; } $ model = new EventEventHandler ( [ 'scenario' => 'search' ] ) ; $ eventsList = Event :: find ( ) -> select ( [ 'name' , 'id' ] ) -> where ( [ 'event_group_id' => $ eventGroupId ] ) -> indexBy ( 'id' ) -> column ( ) ; return $ this -> controller -> render ( 'index' , [ 'dataProvider' => $ model -> search ( \ Yii :: $ app -> request -> get ( ) , array_keys ( $ eventsList ) ) , 'eventGroupId' => $ eventGroupId , 'eventsList' => $ eventsList , 'model' => $ model , 'tabs' => $ tabs , ] ) ; }
2990	public function uploadFromPath ( $ path ) { $ file = new FormUpload ( $ path ) ; $ this -> request -> setParam ( 'content' , $ file ) ; return $ this ; }
4774	public function build ( $ widgets , string $ widgetGroup = '' , array $ widgetId = [ ] ) { if ( ! $ widgets ) { return $ widgets ; } $ this -> loadUserConfig ( ) ; $ outputWidget = [ ] ; if ( $ widgetId ) { foreach ( $ widgetId as $ id ) { if ( isset ( $ widgets [ $ id ] ) ) { $ widgets [ $ id ] -> setActive ( $ this -> widgetConfig [ $ widget -> getId ( ) ] [ 'status' ] ?? false ) ; $ widgets [ $ id ] -> setConfig ( $ this -> widgetConfig [ $ widget -> getId ( ) ] ?? [ ] ) ; $ outputWidget [ ] = $ widgets [ $ id ] ; } } return $ outputWidget ; } foreach ( $ widgets as $ widget ) { if ( '' !== $ widgetGroup && $ widget -> getGroup ( ) !== $ widgetGroup ) { continue ; } if ( isset ( $ this -> widgetConfig [ $ widget -> getId ( ) ] [ 'order' ] ) ) { $ widget -> setOrder ( $ this -> widgetConfig [ $ widget -> getId ( ) ] [ 'order' ] ) ; } if ( null !== $ widget -> getOrder ( ) ) { while ( isset ( $ outputWidget [ $ widget -> getOrder ( ) ] ) ) { $ widget -> setOrder ( $ widget -> getOrder ( ) + 1 ) ; } $ outputWidget [ $ widget -> getOrder ( ) ] = $ widget ; } else { $ outputWidget [ ] = $ widget ; } $ widget -> setActive ( $ this -> widgetConfig [ $ widget -> getId ( ) ] [ 'status' ] ?? false ) ; $ widget -> setConfig ( $ this -> widgetConfig [ $ widget -> getId ( ) ] ?? [ ] ) ; } ksort ( $ outputWidget ) ; return $ outputWidget ; }
1356	protected function getSortColumn ( $ field , Model $ model ) { if ( isset ( $ this -> sortColumns [ $ field ] ) ) { return $ this -> sortColumns [ $ field ] ; } return $ model :: $ snakeAttributes ? Str :: underscore ( $ field ) : Str :: camelize ( $ field ) ; }
2248	public static function addToUrl ( $ strRequest , $ blnAddRef = true , $ arrUnset = array ( ) ) { $ query = new Query ( Environment :: get ( 'queryString' ) ) ; $ query = $ query -> withoutPairs ( array_merge ( array ( 'rt' , 'ref' ) , $ arrUnset ) ) ; $ query = $ query -> merge ( str_replace ( '&amp;' , '&' , $ strRequest ) ) ; if ( isset ( $ _GET [ 'ref' ] ) || ( $ strRequest != '' && $ blnAddRef ) ) { $ query = $ query -> merge ( 'ref=' . System :: getContainer ( ) -> get ( 'request_stack' ) -> getCurrentRequest ( ) -> attributes -> get ( '_contao_referer_id' ) ) ; } $ uri = $ query -> getUriComponent ( ) ; if ( strpos ( $ strRequest , '%2B' ) !== false ) { $ uri = str_replace ( '+' , '%2B' , $ uri ) ; } return TL_SCRIPT . ampersand ( $ uri ) ; }
12792	public static function createSnippet ( string $ snptName ) : ? Snippet { $ snptRoot = AppHelper :: getInstance ( ) -> getComponentRoot ( 'snippets' ) ; $ snptFile = $ snptRoot . \ DIRECTORY_SEPARATOR . strtolower ( $ snptName ) . '.php' ; if ( is_readable ( $ snptFile ) ) { return new Snippet ( $ snptFile ) ; } return null ; }
6642	public static function encodeId ( $ id , $ salt , $ hashLength = self :: MIN_HASH_LENGTH ) { $ hashIds = new Hashids ( $ salt , $ hashLength ) ; return $ hashIds -> encode ( $ id ) ; }
12172	public static function getDefaultForCallable ( $ callable , array $ params = array ( ) ) { if ( $ callable instanceof Closure ) { $ factory = new static ( $ callable , 'closure' ) ; $ factory -> addOptionalClassArgument ( '$container' , 'Autarky\Container\ContainerInterface' ) ; return $ factory -> getFactory ( $ params ) ; } return static :: getFromReflection ( $ callable , null ) -> getFactory ( $ params ) ; }
3676	public function checkColumnDoesNotExist ( $ strTableName , $ strColName , $ blnAllowSystemCol = false ) { $ this -> checkTableExists ( $ strTableName ) ; $ this -> checkColumnName ( $ strColName , $ blnAllowSystemCol ) ; if ( $ this -> fieldExists ( $ strColName , $ strTableName ) ) { throw ColumnExistsException :: withName ( $ strColName , $ strTableName ) ; } }
9008	private function prepareColumn ( Row $ row ) : string { $ nullable = $ row -> Null === 'YES' ; if ( $ row -> Default === null && ! $ nullable ) { $ default = ' NOT null' ; } elseif ( $ row -> Default === null && $ nullable ) { $ default = ' DEFAULT null' ; } else { $ default = ( $ nullable ? '' : ' NOT null' ) . " DEFAULT '{$row->Default}'" ; } if ( ! empty ( $ row -> Collation ) ) { $ collate = ' COLLATE ' . $ row -> Collation ; } else { $ collate = '' ; } if ( $ row -> Extra === 'auto_increment' ) { $ autoIncrement = ' AUTO_INCREMENT' ; } else { $ autoIncrement = '' ; } return "`{$row->Field}` " . $ row -> Type . $ collate . $ default . $ autoIncrement ; }
4297	public function clear ( $ flags = self :: CLEAR_LOG ) { array ( $ flags ) ; $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'flags' => self :: CLEAR_LOG ) , array ( 'flags' => 'bitmask' ) ) ; $ event = $ this -> methodClear -> onLog ( new Event ( $ this , array ( 'method' => __FUNCTION__ , 'args' => array ( ) , 'meta' => $ meta , ) ) ) ; $ this -> setLogDest ( 'log' ) ; $ collect = $ this -> cfg [ 'collect' ] ; $ this -> cfg [ 'collect' ] = true ; if ( $ event [ 'log' ] ) { $ this -> appendLog ( $ event [ 'method' ] , $ event [ 'args' ] , $ event [ 'meta' ] ) ; } elseif ( $ event [ 'publish' ] ) { $ this -> internal -> publishBubbleEvent ( 'debug.log' , $ event ) ; } $ this -> cfg [ 'collect' ] = $ collect ; $ this -> setLogDest ( 'auto' ) ; }
8769	public function bootstrap ( ) { $ this -> hasBeenBootstrapped = true ; $ this [ 'events' ] -> dispatch ( 'bootstrapping' , [ $ this ] ) ; $ this -> boot ( ) ; $ this [ 'events' ] -> dispatch ( 'bootstrapped' , [ $ this ] ) ; }
12808	private static function getPrimaryKey ( string $ table ) : array { if ( self :: $ primaryKeyCache !== null && array_key_exists ( $ table , self :: $ primaryKeyCache ) ) return self :: $ primaryKeyCache [ $ table ] ; $ pdo = Database :: connect ( ) ; $ query = " SELECT tc.constraint_name, tc.table_name, kcu.column_name, ccu.table_name AS foreign_table_name, ccu.column_name AS foreign_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'PRIMARY KEY' AND tc.table_name = '$table' " ; $ results = $ pdo -> query ( $ query ) ; self :: $ primaryKeyCache [ $ table ] = $ results -> fetch ( ) ; return self :: $ primaryKeyCache [ $ table ] ; }
3056	public function persistLastCatItemOutput ( array $ lastCatItemOutput ) { $ sessionId = $ this -> getTestSession ( ) -> getSessionId ( ) ; $ this -> getServiceManager ( ) -> get ( ExtendedStateService :: SERVICE_ID ) -> setCatValue ( $ sessionId , $ this -> getCatSection ( ) -> getSectionId ( ) , 'cat-item-output' , json_encode ( $ lastCatItemOutput ) ) ; }
9172	public function getViewHelpers ( ) { return [ 'aliases' => [ 'formmulticheckbox' => Form \ View \ Helper \ FormMultiCheckbox :: class , 'formradio' => Form \ View \ Helper \ FormRadio :: class , 'zettaFlashMessenger' => View \ Helper \ FlashMessenger :: class , 'zettaFormMultiCheckbox' => Form \ View \ Helper \ FormMultiCheckbox :: class , 'zettaFormRadio' => Form \ View \ Helper \ FormRadio :: class , 'zettaFormRow' => Form \ View \ Helper \ FormRow :: class , 'zettaPaginator' => View \ Helper \ Paginator :: class , 'zettaReferer' => View \ Helper \ Referer :: class , 'settings' => View \ Helper \ Settings :: class , 'thumbnail' => View \ Helper \ Thumbnail :: class , 'zettaUrl' => View \ Helper \ Url :: class , ] , 'factories' => [ Form \ View \ Helper \ FormMultiCheckbox :: class => InvokableFactory :: class , Form \ View \ Helper \ FormRadio :: class => InvokableFactory :: class , Form \ View \ Helper \ FormRow :: class => InvokableFactory :: class , View \ Helper \ FlashMessenger :: class => InvokableFactory :: class , View \ Helper \ Paginator :: class => View \ Helper \ Factory \ PaginatorFactory :: class , View \ Helper \ Referer :: class => View \ Helper \ Factory \ RefererFactory :: class , View \ Helper \ Settings :: class => Factory \ WithSettingsFactory :: class , View \ Helper \ Thumbnail :: class => Factory \ WithThumbnailFactory :: class , View \ Helper \ Url :: class => View \ Helper \ Factory \ UrlFactory :: class ] , ] ; }
12389	protected function updateCredentialHash ( PasswordableInterface $ identityObject , $ password ) { $ cryptoService = $ this -> getMapper ( ) -> getPasswordService ( ) ; if ( ! $ cryptoService instanceof Bcrypt ) { return $ this ; } $ hash = explode ( '$' , $ identityObject -> getPassword ( ) ) ; if ( $ hash [ 2 ] === $ cryptoService -> getCost ( ) ) { return $ this ; } $ identityObject -> setPassword ( $ cryptoService -> create ( $ password ) ) ; return $ this ; }
3435	public function substituteGroup ( $ old , $ new ) { $ groups = $ this -> getGroups ( ) ; if ( ( $ key = array_search ( $ old , $ groups ) ) !== false ) { unset ( $ groups [ $ key ] ) ; } if ( ! in_array ( $ new , $ groups ) ) { $ groups [ ] = $ new ; } $ this -> fields [ 'GROUP_ID' ] = $ groups ; }
6657	protected function createFailSafeResponse ( ) { $ status = new Status ( 500 ) ; $ response = new Response ( ) ; $ response -> setRequest ( new Request ( ) ) ; $ response -> setWriter ( new Json ( ) ) ; $ response -> setStatus ( $ status ) ; $ response -> setBodyData ( $ status -> getMessage ( ) ) ; return $ response ; }
11720	public function countPost ( $ actor ) { $ em = $ this -> container -> get ( 'doctrine' ) -> getManager ( ) ; $ entities = $ em -> getRepository ( 'BlogBundle:Post' ) -> findBy ( array ( 'actor' => $ actor ) ) ; return count ( $ entities ) ; }
5632	protected function removeTrailingSlash ( $ path ) { if ( substr ( $ path , - 1 ) == DIRECTORY_SEPARATOR ) { return substr ( $ path , 0 , - 1 ) ; } elseif ( substr ( $ path , - 1 ) == '/' ) { return substr ( $ path , 0 , - 1 ) ; } else { return $ path ; } }
11114	public function rollback ( array $ options = [ ] ) : void { $ migrations = $ this -> getMigrationsForRollback ( $ options ) ; if ( count ( $ migrations ) === 0 ) { $ this -> notify -> note ( '<info>Nothing to rollback.</info>' ) ; return ; } $ this -> rollbackMigrations ( $ migrations ) ; }
9376	protected function check ( array $ files , $ path , $ source , $ template ) { $ file = null ; foreach ( ( array ) $ files as $ key => $ value ) { $ filepath = ( string ) str_replace ( $ path , $ source , $ value ) ; $ filepath = str_replace ( '\\' , '/' , ( string ) $ filepath ) ; $ filepath = ( string ) preg_replace ( '/^\d\//i' , '' , $ filepath ) ; $ exists = ( string ) $ filepath === $ template ; $ lowercase = strtolower ( $ filepath ) === $ template ; ( $ exists || $ lowercase ) && $ file = $ value ; } return $ file ; }
6805	private function generate ( $ class , array $ names , $ defaultCode ) { $ repository = $ this -> manager -> getRepository ( $ class ) ; foreach ( $ names as $ code => $ name ) { $ result = 'already exists' ; if ( null === $ repository -> findOneBy ( [ 'code' => $ code ] ) ) { $ entity = $ repository -> createNew ( ) ; $ entity -> setName ( $ name ) -> setCode ( $ code ) -> setEnabled ( $ defaultCode === $ code ) ; $ this -> manager -> persist ( $ entity ) ; $ result = 'done' ; } call_user_func ( $ this -> log , $ name , $ result ) ; } $ this -> manager -> flush ( ) ; }
304	private function resetDependentRelations ( $ attribute ) { foreach ( $ this -> _relationsDependencies [ $ attribute ] as $ relation ) { unset ( $ this -> _related [ $ relation ] ) ; } unset ( $ this -> _relationsDependencies [ $ attribute ] ) ; }
10758	protected function prepareHeader ( array $ data ) { return array_merge_recursive ( [ 'date' => trans ( 'dashboard::logs.date' ) , 'all' => trans ( 'dashboard::logs.all' ) , ] , $ this -> levels -> names ( $ this -> locale ) ) ; }
7478	public function getFormFor ( $ entity , $ className = null , array $ options = array ( ) ) { if ( empty ( $ this -> _formHelper ) && ( $ this -> _formHelper = $ this -> get ( 'orkestra.application.helper.form' ) ) == null ) { throw new \ RuntimeException ( 'Orkestra FormHelper is not registered as a service' ) ; } $ type = $ this -> container -> get ( 'orkestra.application.helper.form' ) -> getType ( $ entity , $ className ) ; return $ this -> createForm ( $ type , $ entity , $ options ) ; }
4790	function insert_update ( array $ unique , array $ insert , array $ update = array ( ) ) { if ( ! $ update ) { $ update = $ insert ; } $ insert = $ unique + $ insert ; $ values = "(" . implode ( ", " , array_keys ( $ insert ) ) . ") VALUES " . $ this -> quote ( $ insert ) ; if ( $ this -> notORM -> driver == "mysql" ) { $ set = array ( ) ; if ( ! $ update ) { $ update = $ unique ; } $ quoteChar = $ this -> getQuoteChar ( ) ; foreach ( $ update as $ key => $ val ) { $ set [ ] = "{$quoteChar}{$key}{$quoteChar} = " . $ this -> quote ( $ val ) ; } return $ this -> insert ( "$values ON DUPLICATE KEY UPDATE " . implode ( ", " , $ set ) ) ; } else { $ connection = $ this -> notORM -> connection ; $ errorMode = $ connection -> getAttribute ( PDO :: ATTR_ERRMODE ) ; $ connection -> setAttribute ( PDO :: ATTR_ERRMODE , PDO :: ERRMODE_EXCEPTION ) ; try { $ return = $ this -> insert ( $ values ) ; $ connection -> setAttribute ( PDO :: ATTR_ERRMODE , $ errorMode ) ; return $ return ; } catch ( PDOException $ e ) { $ connection -> setAttribute ( PDO :: ATTR_ERRMODE , $ errorMode ) ; if ( $ e -> getCode ( ) == "23000" || $ e -> getCode ( ) == "23505" ) { if ( ! $ update ) { return 0 ; } $ clone = clone $ this ; $ return = $ clone -> where ( $ unique ) -> update ( $ update ) ; return ( $ return ? $ return + 1 : $ return ) ; } if ( $ errorMode == PDO :: ERRMODE_EXCEPTION ) { throw $ e ; } elseif ( $ errorMode == PDO :: ERRMODE_WARNING ) { trigger_error ( "PDOStatement::execute(): " . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } } return 0 ; }
8609	private function _convertRegisterDestination ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'RegisterDestination' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetMarketplaceId ( ) ) { $ parameters [ 'MarketplaceId' ] = $ request -> getMarketplaceId ( ) ; } if ( $ request -> isSetDestination ( ) ) { $ DestinationRegisterDestinationInput = $ request -> getDestination ( ) ; foreach ( $ DestinationRegisterDestinationInput -> getDeliveryChannel ( ) as $ DeliveryChannelDestinationIndex => $ DeliveryChannelDestination ) { $ parameters [ 'Destination' . '.' . 'DeliveryChannel' . '.' . ( $ DeliveryChannelDestinationIndex + 1 ) ] = $ DeliveryChannelDestination ; } } return $ parameters ; }
8523	public function setAdvertisingRecommendations ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'AdvertisingRecommendations' ] [ 'FieldValue' ] = $ value ; return $ this ; }
9442	public function getManyWithoutReplacement ( $ n ) { if ( ! is_integer ( $ n ) || $ n < 2 ) { throw new \ InvalidArgumentException ( 'You must take 2 or more items in this case.' ) ; } if ( $ this -> range -> as_integer ) { $ arr_range = range ( $ this -> range -> min , $ this -> range -> max ) ; $ max_takable = count ( $ arr_range ) ; shuffle ( $ arr_range ) ; if ( $ n > $ max_takable ) { throw new \ OutOfRangeException ( sprintf ( 'Cannot take without replacement more than available items into range [%d;%d]' , $ this -> range -> min , $ this -> range -> max ) ) ; } elseif ( $ n == $ max_takable ) { return array_values ( $ arr_range ) ; } else { return array_slice ( $ arr_range , 0 , $ n ) ; } } else { $ arr_out = array ( ) ; while ( count ( $ arr_out ) < $ n ) { $ r = $ this -> get ( ) ; if ( ! in_array ( $ r , $ arr_out ) ) { $ arr_out [ ] = $ r ; } } return $ arr_out ; } }
6948	private function setDueParameters ( $ query ) { $ query -> setParameter ( 'trigger_invoiced' , Trigger :: TRIGGER_INVOICED ) -> setParameter ( 'state_invoiced' , [ InvoiceStates :: STATE_PARTIAL , InvoiceStates :: STATE_COMPLETED ] ) -> setParameter ( 'trigger_fully_invoiced' , Trigger :: TRIGGER_FULLY_INVOICED ) -> setParameter ( 'state_fully_invoiced' , InvoiceStates :: STATE_COMPLETED ) -> setParameter ( 'trigger_shipped' , Trigger :: TRIGGER_SHIPPED ) -> setParameter ( 'state_shipped' , [ ShipmentStates :: STATE_PARTIAL , ShipmentStates :: STATE_COMPLETED ] ) -> setParameter ( 'trigger_fully_shipped' , Trigger :: TRIGGER_FULLY_SHIPPED ) -> setParameter ( 'state_fully_shipped' , ShipmentStates :: STATE_COMPLETED ) ; }
515	public function actionTo ( $ version ) { if ( ( $ namespaceVersion = $ this -> extractNamespaceMigrationVersion ( $ version ) ) !== false ) { $ this -> migrateToVersion ( $ namespaceVersion ) ; } elseif ( ( $ migrationName = $ this -> extractMigrationVersion ( $ version ) ) !== false ) { $ this -> migrateToVersion ( $ migrationName ) ; } elseif ( ( string ) ( int ) $ version == $ version ) { $ this -> migrateToTime ( $ version ) ; } elseif ( ( $ time = strtotime ( $ version ) ) !== false ) { $ this -> migrateToTime ( $ time ) ; } else { throw new Exception ( "The version argument must be either a timestamp (e.g. 101129_185401),\n the full name of a migration (e.g. m101129_185401_create_user_table),\n the full namespaced name of a migration (e.g. app\\migrations\\M101129185401CreateUserTable),\n a UNIX timestamp (e.g. 1392853000), or a datetime string parseable\nby the strtotime() function (e.g. 2014-02-15 13:00:50)." ) ; } }
8490	public static function getUpTime ( ) { $ wmi = Windows :: getInstance ( ) ; $ booted_str = '' ; foreach ( $ wmi -> ExecQuery ( "SELECT LastBootUpTime FROM Win32_OperatingSystem" ) as $ os ) { $ booted_str = $ os -> LastBootUpTime ; } $ booted = [ 'year' => substr ( $ booted_str , 0 , 4 ) , 'month' => substr ( $ booted_str , 4 , 2 ) , 'day' => substr ( $ booted_str , 6 , 2 ) , 'hour' => substr ( $ booted_str , 8 , 2 ) , 'minute' => substr ( $ booted_str , 10 , 2 ) , 'second' => substr ( $ booted_str , 12 , 2 ) ] ; $ booted_ts = mktime ( $ booted [ 'hour' ] , $ booted [ 'minute' ] , $ booted [ 'second' ] , $ booted [ 'month' ] , $ booted [ 'day' ] , $ booted [ 'year' ] ) ; return date ( 'm/d/y h:i A (T)' , $ booted_ts ) ; }
12484	protected function getDefaultOptionIds ( ) { $ optionIds = [ ] ; $ defaultDefinition = $ this -> getDefaultInputDefinition ( ) ; foreach ( $ defaultDefinition -> getOptions ( ) as $ option ) { $ optionIds [ ] = $ option -> getName ( ) ; } ; return $ optionIds ; }
8751	private function addCurrentMessage ( ) { if ( $ this -> currentMessage -> hasTranslation ( ) ) { $ this -> messages [ ] = $ this -> currentMessage ; $ this -> currentMessage = new Message ( ) ; } }
12173	protected static function addReflectionArguments ( Definition $ factory , ReflectionFunctionAbstract $ reflectionFunction = null ) { if ( ! $ reflectionFunction ) { $ callable = $ factory -> getCallable ( ) ; if ( is_array ( $ callable ) ) { $ reflectionFunction = new ReflectionMethod ( $ callable [ 0 ] , $ callable [ 1 ] ) ; } else { $ reflectionFunction = new ReflectionFunction ( $ callable ) ; } } foreach ( $ reflectionFunction -> getParameters ( ) as $ arg ) { try { $ name = $ arg -> getName ( ) ; $ required = ! $ arg -> isOptional ( ) ; if ( $ argClass = $ arg -> getClass ( ) ) { $ factory -> addClassArgument ( $ name , $ argClass -> getName ( ) , $ required ) ; } else { $ default = ( $ required ? null : $ arg -> getDefaultValue ( ) ) ; $ factory -> addScalarArgument ( $ name , null , $ required , $ default ) ; } } catch ( ReflectionException $ re ) { throw UnresolvableArgumentException :: fromReflectionParam ( $ arg , $ reflectionFunction , $ re ) ; } } }
2741	public function getAllRepoManifests ( ) { $ fastlyEdgeModules = $ this -> config -> getFastlyEdgeModules ( ) ; $ manifests = [ ] ; foreach ( $ fastlyEdgeModules as $ key => $ value ) { $ decodedManifestData = json_decode ( $ value , true ) ; $ manifests [ ] = $ decodedManifestData ; } return $ manifests ; }
5862	protected function expandValuesInRuleset ( array $ ruleset ) { $ values = [ ] ; foreach ( $ ruleset as $ key => $ value ) { switch ( $ key ) { case 'usergroup' : $ value = GeneralUtility :: trimExplode ( ',' , $ value , true ) ; break ; case 'directories' : $ values [ 'directories_config' ] = '' ; $ value = GeneralUtility :: trimExplode ( ',' , $ value , true ) ; foreach ( $ value as & $ directory ) { $ directory = rtrim ( $ directory , '/' ) . '/' ; if ( ! empty ( $ values [ 'directories_config' ] ) ) { $ values [ 'directories_config' ] .= ',' ; } $ values [ 'directories_config' ] .= $ directory ; $ directory = $ this -> getDirectoryPattern ( $ directory ) ; } if ( count ( $ value ) == 0 ) { $ value = '' ; } break ; case 'file_types' : $ value = GeneralUtility :: trimExplode ( ',' , $ value , true ) ; if ( count ( $ value ) == 0 ) { $ value = '' ; } break ; case 'threshold' : if ( ! is_numeric ( $ value ) ) { $ unit = strtoupper ( substr ( $ value , - 1 ) ) ; $ factor = 1 * ( $ unit === 'K' ? 1024 : ( $ unit === 'M' ? 1024 * 1024 : 0 ) ) ; $ value = intval ( trim ( substr ( $ value , 0 , strlen ( $ value ) - 1 ) ) ) * $ factor ; } case 'max_width' : case 'max_height' : if ( $ value <= 0 ) { $ value = '' ; } break ; case 'max_size' : if ( ! is_numeric ( $ value ) ) { $ unit = strtoupper ( substr ( $ value , - 1 ) ) ; $ factor = 1 * ( $ unit === 'M' ? 1000000 : 1 ) ; $ value = intval ( trim ( substr ( $ value , 0 , strlen ( $ value ) - 1 ) ) ) * $ factor ; } break ; case 'conversion_mapping' : if ( strpos ( $ value , CRLF ) !== false ) { $ mapping = GeneralUtility :: trimExplode ( CRLF , $ value , true ) ; } else { $ mapping = GeneralUtility :: trimExplode ( ',' , $ value , true ) ; } if ( count ( $ mapping ) > 0 ) { $ value = $ this -> expandConversionMapping ( $ mapping ) ; } else { $ value = '' ; } break ; } $ values [ $ key ] = $ value ; } return $ values ; }
1764	private function canRunDbQuery ( ) : bool { try { return $ this -> connection -> isConnected ( ) && $ this -> connection -> getSchemaManager ( ) -> tablesExist ( [ 'tl_cron' ] ) ; } catch ( DriverException $ e ) { return false ; } }
7560	protected function parse_gt ( ) { if ( ( ( $ this -> pos + 1 ) < $ this -> size ) && ( $ this -> doc [ $ this -> pos + 1 ] === '=' ) ) { ++ $ this -> pos ; return ( $ this -> token = self :: TOK_COMPARE_BIGGER_THAN ) ; } else { return ( $ this -> token = self :: TOK_CHILD ) ; } }
1317	public function delete ( $ path , array $ parameters = [ ] ) { return $ this -> http ( 'DELETE' , self :: API_HOST , $ path , $ parameters , false ) ; }
5979	public function propertysets ( ) { if ( ! $ this -> propertysets instanceof PropertysetsController ) { $ this -> propertysets = new PropertysetsController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> propertysets -> setLogger ( $ this -> logger ) ; } return $ this -> propertysets ; }
11328	public function setFormField ( $ value ) { if ( is_array ( $ value ) ) { if ( is_null ( $ this -> formFieldClass ) ) { throw new Exception ( "DB Field incorrectly set up. What is the form class?" ) ; } if ( is_null ( $ this -> _formField ) ) { $ config = $ value ; $ config [ 'class' ] = $ this -> formFieldClass ; $ config [ 'modelField' ] = $ this ; $ value = Yii :: createObject ( $ config ) ; } else { $ settings = $ value ; $ value = $ this -> _formField ; unset ( $ settings [ 'class' ] ) ; Yii :: configure ( $ value , $ settings ) ; } } $ this -> _formField = $ value ; return true ; }
7446	public function updateAction ( $ id ) { $ em = $ this -> getDoctrine ( ) -> getEntityManager ( ) ; $ group = $ em -> getRepository ( 'Orkestra\Bundle\ApplicationBundle\Entity\Group' ) -> find ( $ id ) ; if ( ! $ group ) { throw $ this -> createNotFoundException ( 'Unable to locate Group' ) ; } $ form = $ this -> createForm ( GroupType :: class , $ group ) ; $ form -> bindRequest ( $ this -> getRequest ( ) ) ; if ( $ form -> isValid ( ) ) { $ em -> persist ( $ group ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'success' , 'Your changes have been saved.' ) ; return $ this -> redirect ( $ this -> generateUrl ( 'orkestra_group_show' , array ( 'id' => $ id ) ) ) ; } return array ( 'group' => $ group , 'form' => $ form -> createView ( ) , ) ; }
1881	protected function isValid ( $ strFile ) { $ strFolder = Input :: get ( 'pid' , true ) ; if ( Validator :: isInsecurePath ( $ strFile ) ) { throw new AccessDeniedException ( 'Invalid file name "' . $ strFile . '" (hacking attempt).' ) ; } elseif ( Validator :: isInsecurePath ( $ strFolder ) ) { throw new AccessDeniedException ( 'Invalid folder name "' . $ strFolder . '" (hacking attempt).' ) ; } if ( ! empty ( $ this -> arrValidFileTypes ) && is_file ( $ this -> strRootDir . '/' . $ strFile ) ) { $ fileinfo = preg_replace ( '/.*\.(.*)$/u' , '$1' , $ strFile ) ; if ( ! \ in_array ( strtolower ( $ fileinfo ) , $ this -> arrValidFileTypes ) ) { throw new AccessDeniedException ( 'File "' . $ strFile . '" is not an allowed file type.' ) ; } } if ( ! preg_match ( '/^' . preg_quote ( Config :: get ( 'uploadPath' ) , '/' ) . '/i' , $ strFile ) ) { throw new AccessDeniedException ( 'File or folder "' . $ strFile . '" is not within the files directory.' ) ; } if ( $ strFolder && ! preg_match ( '/^' . preg_quote ( Config :: get ( 'uploadPath' ) , '/' ) . '/i' , $ strFolder ) ) { throw new AccessDeniedException ( 'Parent folder "' . $ strFolder . '" is not within the files directory.' ) ; } if ( Input :: get ( 'act' ) == 'edit' || Input :: get ( 'act' ) == 'paste' || Input :: get ( 'act' ) == 'delete' ) { $ this -> import ( BackendUser :: class , 'User' ) ; if ( ! $ this -> User -> isAdmin && \ in_array ( $ strFile , $ this -> User -> filemounts ) ) { throw new AccessDeniedException ( 'Attempt to edit, copy, move or delete the root folder "' . $ strFile . '".' ) ; } } return true ; }
8288	protected function loadModules ( ) { foreach ( $ this -> config [ "authModules" ] as $ name ) { try { $ instance = $ this -> container -> get ( $ name ) ; } catch ( \ League \ Container \ Exception \ NotFoundException $ e ) { if ( ! class_exists ( $ name ) ) { throw new \ RuntimeException ( "PicoAuth module not found: " . $ name ) ; } $ instance = new $ name ; } if ( ! is_subclass_of ( $ instance , Module \ AbstractAuthModule :: class , false ) ) { throw new \ RuntimeException ( "PicoAuth module class must inherit from AbstractAuthModule." ) ; } $ name = $ instance -> getName ( ) ; $ this -> modules [ $ name ] = $ instance ; } }
11467	public function init ( array $ viewDirs , array $ params ) { $ this -> viewDirs = $ viewDirs ; $ this -> params = $ params ; $ this -> parts = new ClearViewPartsCollection ( ) ; }
12518	public static function files ( $ path , $ filter = '.' , $ recurse = false , $ full = false , $ exclude = array ( '.svn' , 'CVS' , '.DS_Store' , '__MACOSX' , 'Thumbs.db' ) , $ excludefilter = array ( '^\..*' , '.*~' ) , $ naturalSort = true ) { $ path = Path :: clean ( $ path ) ; if ( ! is_dir ( $ path ) ) { throw new Exception ( Helper :: getTranslation ( 'NOT_A_FOLDER' ) ) ; } if ( count ( $ excludefilter ) ) { $ excludefilter_string = '/(' . implode ( '|' , $ excludefilter ) . ')/' ; } else { $ excludefilter_string = '' ; } $ arr = Folder :: _items ( $ path , $ filter , $ recurse , $ full , $ exclude , $ excludefilter_string , true ) ; if ( $ naturalSort ) { natsort ( $ arr ) ; } else { asort ( $ arr ) ; } return array_values ( $ arr ) ; }
12558	public function actionFlush ( $ category = null ) { if ( is_null ( $ category ) ) { $ category = $ this -> prompt ( "Category (blank for all): " ) ; } if ( empty ( $ category ) ) { $ category = 'all' ; } else { $ category = [ 'category' , $ category ] ; } Cacher :: invalidateGroup ( $ category ) ; $ this -> out ( "Done!" ) ; }
8837	private function hasExceededTimeout ( ) : bool { return - 1 !== $ this -> timeout && ( microtime ( true ) - $ this -> startTime ) * 1000000 > $ this -> timeout ; }
749	public function load ( $ filePath , $ context ) { $ pattern = '/(msgctxt\s+"(.*?(?<!\\\\))")?\s+' . 'msgid\s+((?:".*(?<!\\\\)"\s*)+)\s+' . 'msgstr\s+((?:".*(?<!\\\\)"\s*)+)/' ; $ content = file_get_contents ( $ filePath ) ; $ matches = [ ] ; $ matchCount = preg_match_all ( $ pattern , $ content , $ matches ) ; $ messages = [ ] ; for ( $ i = 0 ; $ i < $ matchCount ; ++ $ i ) { if ( $ matches [ 2 ] [ $ i ] === $ context ) { $ id = $ this -> decode ( $ matches [ 3 ] [ $ i ] ) ; $ message = $ this -> decode ( $ matches [ 4 ] [ $ i ] ) ; $ messages [ $ id ] = $ message ; } } return $ messages ; }
7054	public function message_id_header ( $ headers , $ iac_options , $ item_ID ) { $ type = ( 'iac_comment_headers' == current_filter ( ) ) ? 'comment' : 'post' ; $ item = ( 'post' == $ type ) ? get_post ( $ item_ID ) : get_comment ( $ item_ID ) ; $ headers [ 'Message-ID' ] = '<' . Iac_Mail_ID :: generate_ID ( $ type , $ item ) . '>' ; return $ headers ; }
8333	private function getSelectSql ( ) { if ( self :: LOCK_TRANSACTIONAL === $ this -> lockMode ) { $ this -> beginTransaction ( ) ; switch ( $ this -> driver ) { case 'mysql' : case 'oci' : case 'pgsql' : return "SELECT $this->dataCol, $this->lifetimeCol, $this->timeCol FROM $this->table WHERE $this->idCol = :id FOR UPDATE" ; case 'sqlsrv' : return "SELECT $this->dataCol, $this->lifetimeCol, $this->timeCol FROM $this->table WITH (UPDLOCK, ROWLOCK) WHERE $this->idCol = :id" ; case 'sqlite' : break ; default : throw new \ DomainException ( sprintf ( 'Transactional locks are currently not implemented for PDO driver "%s".' , $ this -> driver ) ) ; } } return "SELECT $this->dataCol, $this->lifetimeCol, $this->timeCol FROM $this->table WHERE $this->idCol = :id" ; }
8926	public static function fetch ( $ dir = false ) { if ( false === $ dir ) { $ dir = getcwd ( ) ; } $ config = [ ] ; $ files = glob ( $ dir . '/config/*.config.php' , GLOB_BRACE ) ; foreach ( $ files as $ file ) { $ config = array_merge ( $ config , ( require $ file ) ) ; } return $ config ; }
1177	public function make ( array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] , $ selector = null ) { $ validator = $ this -> getValidatorInstance ( $ rules , $ messages , $ customAttributes ) ; return $ this -> validator ( $ validator , $ selector ) ; }
6049	public function setProperties ( array $ properties ) { $ this -> properties = [ ] ; foreach ( $ properties as $ item ) { $ this -> addPropertyResponse ( $ item ) ; } return $ this ; }
10810	public function actionIndex ( $ option = null ) { $ allNames = [ 'web/assets' , 'runtime' , 'runtime/cache' , 'tests/_output' , ] ; $ answer = Select :: display ( 'Select objects' , $ allNames , 1 ) ; $ result = ClearHelper :: run ( $ answer ) ; if ( $ result ) { Output :: items ( $ result , "Clear completed: " . count ( $ result ) . " objects" ) ; } else { Output :: block ( "Not fount object for clear!" ) ; } }
4933	public function loadEntities ( $ entity , $ id = null ) { $ params = $ this -> options ; $ params [ 'id' ] = $ id ; $ params [ 'repositories' ] = $ this -> repositories ; $ event = $ this -> loadEntitiesEvents -> getEvent ( $ entity , $ this , $ params ) ; $ responses = $ this -> loadEntitiesEvents -> triggerEventUntil ( function ( $ response ) { return ( is_array ( $ response ) || $ response instanceof \ Traversable ) && count ( $ response ) ; } , $ event ) ; $ entities = $ responses -> last ( ) ; return $ entities ; }
6868	protected function buildInvoicePayments ( SaleInterface $ sale ) { $ currency = $ sale -> getCurrency ( ) -> getCode ( ) ; $ payments = $ this -> buildPaymentList ( $ sale ) ; $ invoices = $ this -> buildInvoiceList ( $ sale ) ; foreach ( $ invoices as $ x => & $ i ) { $ oid = spl_object_id ( $ i [ 'invoice' ] ) ; $ this -> cache [ $ oid ] = [ ] ; foreach ( $ payments as $ y => & $ p ) { $ r = new IM \ InvoicePayment ( ) ; $ r -> setPayment ( $ p [ 'payment' ] ) ; $ c = Money :: compare ( $ i [ 'total' ] , $ p [ 'amount' ] , $ currency ) ; if ( 0 === $ c ) { $ r -> setAmount ( $ p [ 'amount' ] ) ; $ i [ 'total' ] = 0 ; $ p [ 'amount' ] = 0 ; unset ( $ payments [ $ y ] ) ; } elseif ( 1 === $ c ) { $ r -> setAmount ( $ p [ 'amount' ] ) ; $ i [ 'total' ] -= $ p [ 'amount' ] ; $ p [ 'amount' ] = 0 ; unset ( $ payments [ $ y ] ) ; } else { $ r -> setAmount ( $ i [ 'total' ] ) ; $ p [ 'amount' ] -= $ i [ 'total' ] ; $ i [ 'total' ] = 0 ; } $ this -> cache [ $ oid ] [ ] = $ r ; unset ( $ p ) ; } unset ( $ i ) ; } }
11531	public static function slotDir ( $ sourceDir , array $ options ) { $ paths = array ( sprintf ( '%s/pages/pages/%s/%s_%s/%s' , $ sourceDir , $ options [ 'page' ] , $ options [ 'language' ] , $ options [ 'country' ] , $ options [ 'slot' ] ) , sprintf ( '%s/slots/%s/%s_%s' , $ sourceDir , $ options [ 'slot' ] , $ options [ 'language' ] , $ options [ 'country' ] ) , sprintf ( '%s/slots/%s' , $ sourceDir , $ options [ 'slot' ] ) , ) ; return self :: cascade ( $ paths ) ; }
1523	protected function doSearch ( StoreInterface $ store , FetchResources $ request ) { if ( $ result = $ this -> invoke ( 'searching' , $ request ) ) { return $ result ; } $ found = $ store -> queryRecords ( $ request -> getResourceType ( ) , $ request -> getParameters ( ) ) ; $ records = ( $ found instanceof PageInterface ) ? $ found -> getData ( ) : $ found ; if ( $ result = $ this -> invoke ( 'searched' , $ records , $ request ) ) { return $ result ; } return $ found ; }
3612	public function setTargetTemperatureMode ( $ mode , $ temperature = NULL , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; if ( $ temperature !== NULL ) { if ( $ mode == TARGET_TEMP_MODE_RANGE ) { if ( ! is_array ( $ temperature ) || count ( $ temperature ) != 2 || ! is_numeric ( $ temperature [ 0 ] ) || ! is_numeric ( $ temperature [ 1 ] ) ) { echo "Error: when using TARGET_TEMP_MODE_RANGE, you need to set the target temperatures (second argument of setTargetTemperatureMode) using an array of two numeric values.\n" ; return FALSE ; } $ temp_low = $ this -> temperatureInCelsius ( $ temperature [ 0 ] , $ serial_number ) ; $ temp_high = $ this -> temperatureInCelsius ( $ temperature [ 1 ] , $ serial_number ) ; $ data = json_encode ( array ( 'target_change_pending' => TRUE , 'target_temperature_low' => $ temp_low , 'target_temperature_high' => $ temp_high ) ) ; $ set_temp_result = $ this -> doPOST ( "/v2/put/shared." . $ serial_number , $ data ) ; } elseif ( $ mode != TARGET_TEMP_MODE_OFF ) { if ( ! is_numeric ( $ temperature ) ) { echo "Error: when using TARGET_TEMP_MODE_HEAT or TARGET_TEMP_MODE_COLD, you need to set the target temperature (second argument of setTargetTemperatureMode) using an numeric value.\n" ; return FALSE ; } $ temperature = $ this -> temperatureInCelsius ( $ temperature , $ serial_number ) ; $ data = json_encode ( array ( 'target_change_pending' => TRUE , 'target_temperature' => $ temperature ) ) ; $ set_temp_result = $ this -> doPOST ( "/v2/put/shared." . $ serial_number , $ data ) ; } } $ data = json_encode ( array ( 'target_change_pending' => TRUE , 'target_temperature_type' => $ mode ) ) ; return $ this -> doPOST ( "/v2/put/shared." . $ serial_number , $ data ) ; }
6379	protected function readStoreRecords ( $ type , array $ query ) { $ model = $ this -> store -> get_records ( $ type , $ query ) ; return $ model ; }
4021	protected function validator ( $ varInput ) { $ blnHasError = false ; foreach ( $ this -> arrSubFields as $ strFieldName => & $ arrSubField ) { if ( ! $ this -> validateWidget ( $ arrSubField , $ strFieldName , 'value' , $ varInput ) ) { $ blnHasError = true ; } foreach ( $ this -> arrFlagFields as $ strFlag => $ arrFlagField ) { if ( ! $ this -> validateWidget ( $ arrFlagField , $ strFieldName , $ strFlag , $ varInput ) ) { $ blnHasError = true ; } } } unset ( $ arrSubField ) ; if ( $ blnHasError ) { $ this -> blnSubmitInput = false ; $ this -> addError ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'general' ] ) ; } return $ varInput ; }
1342	public function getParameters ( ) : EncodingParametersInterface { if ( $ this -> parameters ) { return $ this -> parameters ; } return $ this -> parameters = $ this -> container -> make ( EncodingParametersInterface :: class ) ; }
12820	public function execute ( callable $ callback , array $ vars ) : Response { $ arguments = $ this -> resolveDependencies ( $ callback , $ vars ) ; return call_user_func_array ( $ callback , $ arguments ) ; }
3741	protected function getLabelParameters ( EnvironmentInterface $ environment , ModelInterface $ model ) { if ( $ model -> getProperty ( 'type' ) == 'simplelookup' ) { return $ this -> getLabelParametersWithAttributeAndUrlParam ( $ environment , $ model ) ; } return $ this -> getLabelParametersNormal ( $ environment , $ model ) ; }
3163	public function startTimer ( RunnerServiceContext $ context , $ timestamp = null ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ session = $ context -> getTestSession ( ) ; if ( $ session -> getState ( ) === AssessmentTestSessionState :: INTERACTING ) { $ session -> startItemTimer ( $ timestamp ) ; } } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'startTimer' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return true ; }
1080	public static function parse ( $ source , array $ options = [ ] ) { $ sourceObj = $ source instanceof Source ? $ source : new Source ( $ source ) ; $ parser = new self ( $ sourceObj , $ options ) ; return $ parser -> parseDocument ( ) ; }
6644	public static function getStatusHtml ( $ status , $ extraClasses = '' , $ baseClass = 'label' , $ tag = 'span' ) { $ status = strtolower ( $ status ) ; $ statusHyphenated = implode ( '-' , explode ( ' ' , $ status ) ) ; $ class = trim ( "{$baseClass} {$baseClass}-$statusHyphenated $extraClasses" ) ; return Html :: tag ( $ tag , $ status , [ 'class' => $ class ] ) ; }
12195	protected function extractArguments ( array $ arguments , array $ data ) { $ instanceArgs = [ ] ; foreach ( $ arguments as $ arg ) { if ( array_key_exists ( $ arg -> getName ( ) , $ data ) ) { $ instanceArgs [ ] = $ data [ $ arg -> getName ( ) ] ; } else { $ instanceArgs [ ] = null ; } } return $ instanceArgs ; }
780	public function getValue ( $ name , $ defaultValue = null ) { return isset ( $ this -> _cookies [ $ name ] ) ? $ this -> _cookies [ $ name ] -> value : $ defaultValue ; }
8873	private function buildHeaders ( $ required_headers = [ ] ) { $ build_headers = array_merge ( $ this -> headers , $ required_headers ) ; $ headers = [ ] ; foreach ( $ build_headers as $ name => $ value ) { $ headers [ ] = "{$name}: {$value}" ; } return implode ( "\r\n" , $ headers ) . "\nThis is a multi-part message in MIME format.\n" ; }
1405	protected function findRelated ( $ record , array $ relationship ) { $ inverse = $ this -> getRelation ( $ record , $ this -> key ) -> getRelated ( ) ; $ related = $ this -> findToMany ( $ relationship ) ; $ related = collect ( $ related ) -> filter ( function ( $ model ) use ( $ inverse ) { return $ model instanceof $ inverse ; } ) ; return new Collection ( $ related ) ; }
877	private function skipClass ( Tokens $ tokens , $ classIndex , $ classOpenIndex , $ classCloseIndex ) { $ prevToken = $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ classIndex ) ] ; if ( ! $ prevToken -> isGivenKind ( T_FINAL ) ) { return true ; } for ( $ index = $ classIndex ; $ index < $ classOpenIndex ; ++ $ index ) { if ( $ tokens [ $ index ] -> isGivenKind ( T_EXTENDS ) ) { return true ; } } $ useIndex = $ tokens -> getNextTokenOfKind ( $ classIndex , [ [ CT :: T_USE_TRAIT ] ] ) ; return $ useIndex && $ useIndex < $ classCloseIndex ; }
8282	public function onPageRendering ( & $ templateName , array & $ twigVariables ) { $ twigVariables [ 'auth' ] [ 'plugin' ] = $ this ; $ twigVariables [ 'auth' ] [ 'vars' ] = $ this -> output ; if ( ! $ this -> errorOccurred ) { $ twigVariables [ 'auth' ] [ 'user' ] = $ this -> user ; $ old = $ this -> session -> getFlash ( 'old' ) ; if ( count ( $ old ) && isset ( $ old [ 0 ] ) ) { $ twigVariables [ 'auth' ] [ 'old' ] = $ old [ 0 ] ; } } }
12430	public function sort ( $ key , $ order = Sortable :: ASC ) { $ this -> criteria -> sort ( $ key , $ order ) ; return $ this ; }
8153	public function removeExtension ( $ name ) { @ trigger_error ( sprintf ( 'The %s method is deprecated since version 1.12 and will be removed in Twig 2.0.' , __METHOD__ ) , E_USER_DEPRECATED ) ; if ( $ this -> extensionInitialized ) { throw new LogicException ( sprintf ( 'Unable to remove extension "%s" as extensions have already been initialized.' , $ name ) ) ; } $ class = ltrim ( $ name , '\\' ) ; if ( ! isset ( $ this -> extensionsByClass [ $ class ] ) && class_exists ( $ class , false ) ) { $ class = new ReflectionClass ( $ class ) ; $ class = $ class -> name ; } if ( isset ( $ this -> extensions [ $ class ] ) ) { if ( $ class !== get_class ( $ this -> extensions [ $ class ] ) ) { @ trigger_error ( sprintf ( 'Referencing the "%s" extension by its name (defined by getName()) is deprecated since 1.26 and will be removed in Twig 2.0. Use the Fully Qualified Extension Class Name instead.' , $ class ) , E_USER_DEPRECATED ) ; } unset ( $ this -> extensions [ $ class ] ) ; } unset ( $ this -> extensions [ $ class ] ) ; $ this -> updateOptionsHash ( ) ; }
2906	public function getContent ( Zend_Mail $ mail ) { $ hasQueue = $ this -> hasQueue ( ) ; if ( $ hasQueue && $ queue = $ this -> getQueue ( ) ) { return $ queue -> getMessageBody ( ) ; } $ mimePart = $ this -> isPlain ( ) ? $ mail -> getBodyText ( ) : $ mail -> getBodyHtml ( ) ; return $ mimePart ? $ this -> getPartDecodedContent ( $ mimePart ) : '' ; }
6490	public function getDrupalSelector ( $ name ) { $ selectors = $ this -> getDrupalParameter ( 'selectors' ) ; if ( ! isset ( $ selectors [ $ name ] ) ) { throw new \ Exception ( sprintf ( 'No such selector configured: %s' , $ name ) ) ; } return $ selectors [ $ name ] ; }
3252	public function placeOrder ( $ statusCode = null ) { if ( empty ( $ statusCode ) ) $ statusCode = Config :: get ( 'shop.order_status_placement' ) ; $ order = call_user_func ( Config :: get ( 'shop.order' ) . '::create' , [ 'user_id' => $ this -> user_id , 'statusCode' => $ statusCode ] ) ; for ( $ i = count ( $ this -> items ) - 1 ; $ i >= 0 ; -- $ i ) { $ this -> items [ $ i ] -> order_id = $ order -> id ; $ this -> items [ $ i ] -> cart_id = null ; $ this -> items [ $ i ] -> save ( ) ; } $ this -> resetCalculations ( ) ; return $ order ; }
9451	protected function logDLStatDetails ( ) { $ pageId = $ GLOBALS [ 'objPage' ] -> id ; $ pageHost = \ Environment :: get ( 'host' ) ; if ( isset ( $ GLOBALS [ 'TL_CONFIG' ] [ 'dlstatdets' ] ) && ( bool ) $ GLOBALS [ 'TL_CONFIG' ] [ 'dlstatdets' ] === true ) { $ username = '' ; $ strCookie = 'FE_USER_AUTH' ; $ hash = sha1 ( session_id ( ) . ( ! $ GLOBALS [ 'TL_CONFIG' ] [ 'disableIpCheck' ] ? $ this -> IP : '' ) . $ strCookie ) ; if ( \ Input :: cookie ( $ strCookie ) == $ hash ) { $ qs = \ Database :: getInstance ( ) -> prepare ( "SELECT pid, tstamp, sessionID, ip FROM `tl_session` WHERE `hash`=? AND `name`=?" ) -> execute ( $ hash , $ strCookie ) ; if ( $ qs -> next ( ) && $ qs -> sessionID == session_id ( ) && ( $ GLOBALS [ 'TL_CONFIG' ] [ 'disableIpCheck' ] || $ qs -> ip == $ this -> IP ) && ( $ qs -> tstamp + $ GLOBALS [ 'TL_CONFIG' ] [ 'sessionTimeout' ] ) > time ( ) ) { $ qm = \ Database :: getInstance ( ) -> prepare ( "SELECT `username` FROM `tl_member` WHERE id=?" ) -> execute ( $ qs -> pid ) ; if ( $ qm -> next ( ) ) { $ username = $ qm -> username ; } } } \ Database :: getInstance ( ) -> prepare ( "INSERT INTO `tl_dlstatdets` %s" ) -> set ( array ( 'tstamp' => time ( ) , 'pid' => $ this -> _statId , 'ip' => $ this -> dlstatsAnonymizeIP ( ) , 'domain' => $ this -> dlstatsAnonymizeDomain ( ) , 'username' => $ username , 'page_host' => $ pageHost , 'page_id' => $ pageId , 'browser_lang' => $ this -> dlstatsGetLang ( ) ) ) -> execute ( ) ; } else { \ Database :: getInstance ( ) -> prepare ( "INSERT INTO `tl_dlstatdets` %s" ) -> set ( array ( 'tstamp' => time ( ) , 'pid' => $ this -> _statId ) ) -> execute ( ) ; } }
4602	public function encrypt ( $ data , string $ key = null ) : string { $ key = $ this -> createKey ( $ key ) ; $ data = Crypto :: encrypt ( serialize ( $ data ) , $ key ) ; return $ data ; }
11742	public function add ( Theme $ theme , array $ pageValues ) { $ pageName = $ pageValues [ "name" ] ; $ pageDir = $ this -> pagesDir . '/' . $ pageName ; $ this -> pageExists ( $ pageDir ) ; if ( ! @ mkdir ( $ pageDir ) ) { $ this -> folderNotCreated ( $ pageDir ) ; } $ seoValues = $ pageValues [ "seo" ] ; unset ( $ pageValues [ "seo" ] ) ; $ encodedPage = json_encode ( $ pageValues ) ; $ pageFile = $ pageDir . '/' . $ this -> pageFile ; $ event = Dispatcher :: dispatch ( PageCollectionEvents :: PAGE_COLLECTION_ADDING , new PageCollectionAddingEvent ( $ pageFile , $ encodedPage ) ) ; $ encodedPage = $ event -> getFileContent ( ) ; FilesystemTools :: writeFile ( $ pageFile , $ encodedPage ) ; if ( $ this -> pageFile != 'page.json' ) { FilesystemTools :: writeFile ( $ pageDir . '/page.json' , $ encodedPage ) ; } foreach ( $ seoValues as $ seoValue ) { $ languageName = $ seoValue [ "language" ] ; unset ( $ seoValue [ "language" ] ) ; $ languageDir = $ pageDir . '/' . $ languageName ; @ mkdir ( $ languageDir ) ; FilesystemTools :: writeFile ( $ languageDir . '/' . $ this -> seoFile , json_encode ( $ seoValue ) ) ; $ theme -> addTemplateSlots ( $ pageValues [ "template" ] , $ this -> username ) ; } Dispatcher :: dispatch ( PageCollectionEvents :: PAGE_COLLECTION_ADDED , new PageCollectionAddedEvent ( $ pageFile , $ encodedPage ) ) ; DataLogger :: log ( sprintf ( 'Page "%s" was successfully added to the website' , $ pageName ) ) ; return $ pageValues ; }
5318	public function wait ( ) { $ this -> internalWait ( ) ; $ event = $ this -> isSuccessExit ( ) ? 'success' : 'error' ; $ this -> internalEmit ( 'exit' , $ this -> pid ) ; $ this -> internalEmit ( $ event ) ; return $ this ; }
1312	public function setTimeouts ( $ connectionTimeout , $ timeout ) { $ this -> connectionTimeout = ( int ) $ connectionTimeout ; $ this -> timeout = ( int ) $ timeout ; }
12149	public function getReservedCodes ( ) { $ reserved = [ ] ; foreach ( $ this -> factories as $ factoryClass => $ factory ) { $ reserved [ $ factoryClass ] = $ factory -> getReservedDiapason ( ) ; } return $ reserved ; }
2869	public function renderArray ( array $ data , $ noDataLabel = 'No Data' , $ header = null ) { $ block = $ this -> getLayout ( ) -> createBlock ( 'sheep_debug/view' ) ; $ html = $ block -> renderArray ( $ data , $ noDataLabel , $ header ) ; $ this -> getResponse ( ) -> setHttpResponseCode ( 200 ) -> setBody ( $ html ) ; }
3427	public function addFilter ( $ filters ) { foreach ( $ filters as $ field => $ value ) { $ this -> filter [ $ field ] = $ value ; } return $ this ; }
12363	public function initialize ( ) { parent :: initialize ( ) ; $ this -> addClauses ( [ self :: DEFERRABLE => 'DEFERRABLE %s' , self :: EITHER => 'OR %s' , self :: MATCH => 'MATCH %s' , self :: NOT_DEFERRABLE => 'NOT DEFERRABLE %s' , self :: UNIQUE_KEY => 'UNIQUE (%2$s)' ] ) ; $ this -> addKeywords ( [ self :: ABORT => 'ABORT' , self :: BINARY => 'BINARY' , self :: AUTO_INCREMENT => 'AUTOINCREMENT' , self :: FAIL => 'FAIL' , self :: IGNORE => 'IGNORE' , self :: INIT_DEFERRED => 'INITIALLY DEFERRED' , self :: INIT_IMMEDIATE => 'INITIALLY IMMEDIATE' , self :: NOCASE => 'NOCASE' , self :: PRIMARY_KEY => 'PRIMARY KEY' , self :: REPLACE => 'REPLACE' , self :: ROLLBACK => 'ROLLBACK' , self :: RTRIM => 'RTRIM' , self :: UNIQUE => 'UNIQUE' ] ) ; $ this -> addStatements ( [ Query :: INSERT => new Statement ( 'INSERT {or} INTO {table} {fields} VALUES {values}' ) , Query :: SELECT => new Statement ( 'SELECT {distinct} {fields} FROM {table} {joins} {where} {groupBy} {having} {compounds} {orderBy} {limit}' ) , Query :: UPDATE => new Statement ( 'UPDATE {or} {table} SET {fields} {where}' ) , Query :: DELETE => new Statement ( 'DELETE FROM {table} {where}' ) , Query :: CREATE_TABLE => new Statement ( "CREATE {temporary} TABLE IF NOT EXISTS {table} (\n{columns}{keys}\n)" ) , Query :: CREATE_INDEX => new Statement ( 'CREATE {type} INDEX IF NOT EXISTS {index} ON {table} ({fields})' ) , Query :: DROP_TABLE => new Statement ( 'DROP TABLE IF EXISTS {table}' ) , Query :: DROP_INDEX => new Statement ( 'DROP INDEX IF EXISTS {index}' ) ] ) ; unset ( $ this -> _statements [ Query :: TRUNCATE ] ) ; }
6633	public function requestProfile ( AccessTokenInterface $ access_token ) { $ request = [ 'url' => $ this -> settings [ 'api_url' ] . $ this -> settings [ 'profile_uri' ] , 'params' => [ 'access_token' => $ access_token -> token ( ) ] , ] ; return $ this -> parseProfileResponse ( $ this -> http -> get ( $ request ) , $ access_token ) ; }
11126	public function update ( Request $ request ) { foreach ( $ request -> all ( ) as $ key => $ value ) { if ( substr ( $ key , 0 , 8 ) == 'setting_' ) { $ skipSave = false ; $ key = substr ( $ key , 8 ) ; if ( ! $ skipSave ) { $ this -> settingRepository -> save ( $ key , $ value ) ; } } } Flash :: success ( trans ( 'l5starter::messages.update.success' ) ) ; return redirect ( route ( 'admin.settings.index' ) ) ; }
8908	public function created_at ( $ row ) { if ( is_object ( $ row ) ) { $ row -> { $ this -> created_at_key } = date ( 'Y-m-d H:i:s' ) ; } else { $ row [ $ this -> created_at_key ] = date ( 'Y-m-d H:i:s' ) ; } return $ row ; }
216	public function asNtext ( $ value ) { if ( $ value === null ) { return $ this -> nullDisplay ; } return nl2br ( Html :: encode ( $ value ) ) ; }
7049	protected function buildGoodsLines ( Document \ DocumentInterface $ document ) { foreach ( $ document -> getSale ( ) -> getItems ( ) as $ item ) { $ this -> buildGoodLine ( $ item , $ document ) ; } }
581	public function getAssetManager ( ) { if ( ! is_object ( $ this -> _assetManager ) ) { $ options = $ this -> _assetManager ; if ( ! isset ( $ options [ 'class' ] ) ) { $ options [ 'class' ] = 'yii\\web\\AssetManager' ; } if ( ! isset ( $ options [ 'basePath' ] ) ) { throw new Exception ( "Please specify 'basePath' for the 'assetManager' option." ) ; } if ( ! isset ( $ options [ 'baseUrl' ] ) ) { throw new Exception ( "Please specify 'baseUrl' for the 'assetManager' option." ) ; } if ( ! isset ( $ options [ 'forceCopy' ] ) ) { $ options [ 'forceCopy' ] = true ; } $ this -> _assetManager = Yii :: createObject ( $ options ) ; } return $ this -> _assetManager ; }
353	public static function escapeJsRegularExpression ( $ regexp ) { $ pattern = preg_replace ( '/\\\\x\{?([0-9a-fA-F]+)\}?/' , '\u$1' , $ regexp ) ; $ deliminator = substr ( $ pattern , 0 , 1 ) ; $ pos = strrpos ( $ pattern , $ deliminator , 1 ) ; $ flag = substr ( $ pattern , $ pos + 1 ) ; if ( $ deliminator !== '/' ) { $ pattern = '/' . str_replace ( '/' , '\\/' , substr ( $ pattern , 1 , $ pos - 1 ) ) . '/' ; } else { $ pattern = substr ( $ pattern , 0 , $ pos + 1 ) ; } if ( ! empty ( $ flag ) ) { $ pattern .= preg_replace ( '/[^igmu]/' , '' , $ flag ) ; } return $ pattern ; }
7453	protected function renderLTR ( ) : string { $ trail = '' ; if ( $ this -> before ) { $ trail .= '<span class="before">' . $ this -> before . '</span> ' ; } $ trail .= \ join ( ' <span class="sep delimiter">' . $ this -> delimiter . '</span> ' , $ this -> links ) ; if ( $ this -> after ) { $ trail .= ' <span class="after">' . $ this -> after . '</span>' ; } return $ trail ; }
5156	private function getFilename ( string $ name ) : string { return sprintf ( "%s/%s.%s" , $ this -> directory , strtolower ( str_replace ( [ '/' , '\\' ] , '-' , $ name ) ) , self :: EXTENSION ) ; }
11756	public function unmarkElect ( $ msgId , $ index , $ commentId ) { $ params = [ 'msg_data_id' => $ msgId , 'index' => $ index , 'user_comment_id' => $ commentId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_UNMARK_ELECT , $ params ] ) ; }
5904	public function listRoles ( $ includeDeleted = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'includeDeleted' => $ includeDeleted ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/roles' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new Role ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
6511	public function onPreDeserialize ( PreDeserializeEvent $ event ) { $ type = $ event -> getType ( ) ; if ( isset ( $ type [ 'name' ] ) && ( $ type [ 'name' ] == Job :: class || is_subclass_of ( $ type [ 'name' ] , Job :: class ) ) ) { $ data = $ event -> getData ( ) ; if ( isset ( $ data [ 'type' ] ) && isset ( $ data [ 'parameters' ] ) && is_array ( $ data [ 'parameters' ] ) && count ( $ data [ 'parameters' ] ) > 0 ) { array_push ( $ data [ 'parameters' ] , [ 'abc.job.type' => $ data [ 'type' ] ] ) ; $ event -> setData ( $ data ) ; } } }
2768	public function checkoutNewBranch ( string $ branch , array $ options = [ ] ) : string { $ options [ 'b' ] = true ; return $ this -> checkout ( $ branch , $ options ) ; }
8762	public function upload ( $ input ) { $ validator = \ Validator :: make ( $ input , config ( 'dropzoner.validator' ) , config ( 'dropzoner.validator-messages' ) ) ; if ( $ validator -> fails ( ) ) { return response ( ) -> json ( [ 'error' => true , 'message' => $ validator -> messages ( ) -> first ( ) , 'code' => 400 ] , 400 ) ; } $ photo = $ input [ 'file' ] ; $ original_name = $ photo -> getClientOriginalName ( ) ; $ extension = $ photo -> getClientOriginalExtension ( ) ; $ original_name_without_extension = substr ( $ original_name , 0 , strlen ( $ original_name ) - strlen ( $ extension ) - 1 ) ; $ filename = $ this -> sanitize ( $ original_name_without_extension ) ; $ allowed_filename = $ this -> createUniqueFilename ( $ filename ) ; $ filename_with_extension = $ allowed_filename . '.' . $ extension ; $ manager = new ImageManager ( ) ; $ image = $ manager -> make ( $ photo ) -> save ( config ( 'dropzoner.upload-path' ) . $ filename_with_extension ) ; if ( ! $ image ) { return response ( ) -> json ( [ 'error' => true , 'message' => 'Server error while uploading' , 'code' => 500 ] , 500 ) ; } event ( new ImageWasUploaded ( $ original_name , $ filename_with_extension ) ) ; return response ( ) -> json ( [ 'error' => false , 'code' => 200 , 'filename' => $ filename_with_extension ] , 200 ) ; }
5997	public function setMin ( $ min ) { if ( $ min instanceof DateTime ) { $ this -> min = $ min ; } else { try { $ this -> min = new DateTime ( $ min ) ; } catch ( \ Exception $ e ) { $ this -> min = null ; } } return $ this ; }
12740	public function setRequired ( $ flag ) { $ this -> tags [ 'required' ] = $ flag ; if ( $ this -> validator ) { $ this -> validator -> setOption ( 'empty' , ! $ flag ) ; } }
275	protected function renderDataCellContent ( $ model , $ key , $ index ) { if ( $ this -> content !== null ) { return call_user_func ( $ this -> content , $ model , $ key , $ index , $ this ) ; } return $ this -> grid -> emptyCell ; }
11817	protected function step4 ( ) { $ this -> view -> addToBlock ( "form" , "import://admin/setup/user" ) ; $ this -> view -> setData ( "step" , "4" ) ; $ this -> view -> setData ( "title" , t ( "Installation | Install SuperUser" ) ) ; if ( $ this -> application -> input -> methodIs ( "post" ) ) { $ install = new Helpers \ Install ( $ this -> application -> config , $ this -> application -> encrypt ) ; if ( ! $ install -> database ( $ this -> application ) ) { $ this -> application -> dispatcher -> redirect ( "/admin/setup/install/3" ) ; } $ this -> response -> addAlert ( "Wohooo! The database was successfully configure. Now please create a super user." , "info" ) ; } return ; }
145	public function propagateLiteral ( $ decidedLiteral , $ level , $ decisions ) { $ literal = - $ decidedLiteral ; if ( ! isset ( $ this -> watchChains [ $ literal ] ) ) { return null ; } $ chain = $ this -> watchChains [ $ literal ] ; $ chain -> rewind ( ) ; while ( $ chain -> valid ( ) ) { $ node = $ chain -> current ( ) ; $ otherWatch = $ node -> getOtherWatch ( $ literal ) ; if ( ! $ node -> getRule ( ) -> isDisabled ( ) && ! $ decisions -> satisfy ( $ otherWatch ) ) { $ ruleLiterals = $ node -> getRule ( ) -> getLiterals ( ) ; $ alternativeLiterals = array_filter ( $ ruleLiterals , function ( $ ruleLiteral ) use ( $ literal , $ otherWatch , $ decisions ) { return $ literal !== $ ruleLiteral && $ otherWatch !== $ ruleLiteral && ! $ decisions -> conflict ( $ ruleLiteral ) ; } ) ; if ( $ alternativeLiterals ) { reset ( $ alternativeLiterals ) ; $ this -> moveWatch ( $ literal , current ( $ alternativeLiterals ) , $ node ) ; continue ; } if ( $ decisions -> conflict ( $ otherWatch ) ) { return $ node -> getRule ( ) ; } $ decisions -> decide ( $ otherWatch , $ level , $ node -> getRule ( ) ) ; } $ chain -> next ( ) ; } return null ; }
2492	protected function defineEndpoint ( ContainerBuilder $ container , $ alias , $ params ) { $ definition = new Definition ( self :: ENDPOINT_CLASS , array ( $ params ) ) ; $ definition -> addTag ( self :: ENDPOINT_TAG , array ( 'alias' => $ alias ) ) ; $ container -> setDefinition ( sprintf ( $ this -> getAlias ( ) . '.endpoints.%s' , $ alias ) , $ definition ) ; }
9449	protected function allowed ( $ method ) { if ( in_array ( $ method , $ this -> allowed ) === false ) { $ message = 'Used method is not allowed' ; throw new \ UnexpectedValueException ( $ message ) ; } return true ; }
5349	public function installOperatingSystemUnattended ( $ vpsName , $ operatingSystemName , $ base64InstallText ) { return $ this -> call ( self :: SERVICE , 'installOperatingSystemUnattended' , [ $ vpsName , $ operatingSystemName , $ base64InstallText ] ) ; }
2478	protected function getRequestHeaders ( Message $ message , Endpoint $ endpoint ) { $ headers = $ message -> headers ; if ( $ endpoint -> user !== null ) { $ headers [ 'Authorization' ] = 'Basic ' . base64_encode ( "{$endpoint->user}:{$endpoint->pass}" ) ; } $ requestHeaders = '' ; foreach ( $ headers as $ name => $ value ) { if ( is_numeric ( $ name ) ) { throw new \ RuntimeException ( "Invalid HTTP header name $name" ) ; } $ requestHeaders .= "$name: $value\r\n" ; } return $ requestHeaders ; }
11733	public function publish ( $ pageName , $ languageName ) { $ this -> contributorDefined ( ) ; $ baseDir = $ this -> pagesDir . '/' . $ pageName ; $ pageCollectionSourceFile = $ baseDir . '/' . $ this -> username . '.json' ; $ pageCollectionTargetFile = $ baseDir . '/page.json' ; $ pageDir = $ baseDir . '/' . $ languageName ; $ pageSourceFile = $ pageDir . '/' . $ this -> username . '.json' ; $ pageTargetFile = $ pageDir . '/seo.json' ; Dispatcher :: dispatch ( PageEvents :: PAGE_PUBLISHING , new PagePublishingEvent ( ) ) ; copy ( $ pageCollectionSourceFile , $ pageCollectionTargetFile ) ; copy ( $ pageSourceFile , $ pageTargetFile ) ; Dispatcher :: dispatch ( PageEvents :: PAGE_PUBLISHED , new PagePublishedEvent ( ) ) ; DataLogger :: log ( sprintf ( 'Page "%s" for language "%s" was published in production' , $ pageName , $ languageName ) ) ; }
5472	private function getPrivatePropertyNoMatterWhat ( $ name , $ object ) { foreach ( ( array ) $ object as $ mangled_name => $ value ) { if ( $ this -> unmangle ( $ mangled_name ) == $ name ) { return $ value ; } } }
2907	public function getPartDecodedContent ( Zend_Mime_Part $ mimePart ) { if ( method_exists ( $ mimePart , 'getRawContent' ) ) { return $ mimePart -> getRawContent ( ) ; } $ content = '' ; if ( method_exists ( $ mimePart , 'getContent' ) ) { $ encoding = $ mimePart -> encoding ; $ mimePart -> encoding = 'none' ; $ content = $ mimePart -> getContent ( ) ; $ mimePart -> encoding = $ encoding ; } return $ content ; }
7803	protected function statementBody ( $ text ) { $ accountNumber = $ this -> accountNumber ( $ text ) ; $ account = $ this -> reader -> createAccount ( $ accountNumber ) ; if ( ! ( $ account instanceof AccountInterface ) ) { return null ; } $ account -> setNumber ( $ accountNumber ) ; $ number = $ this -> statementNumber ( $ text ) ; $ statement = $ this -> reader -> createStatement ( $ account , $ number ) ; if ( ! ( $ statement instanceof StatementInterface ) ) { return null ; } $ statement -> setAccount ( $ account ) -> setNumber ( $ this -> statementNumber ( $ text ) ) -> setOpeningBalance ( $ this -> openingBalance ( $ text ) ) -> setClosingBalance ( $ this -> closingBalance ( $ text ) ) ; foreach ( $ this -> splitTransactions ( $ text ) as $ chunk ) { $ statement -> addTransaction ( $ this -> transaction ( $ chunk ) ) ; } return $ statement ; }
5827	public function buildUrl ( $ url , array $ query ) { if ( ! empty ( $ query ) ) { $ queryString = http_build_query ( $ query ) ; $ url .= '?' . $ queryString ; } return $ url ; }
11734	public function hide ( $ pageName , $ languageName ) { $ this -> contributorDefined ( ) ; $ baseDir = $ this -> pagesDir . '/' . $ pageName . '/' . $ languageName ; $ sourceFile = $ baseDir . '/seo.json' ; Dispatcher :: dispatch ( PageEvents :: PAGE_HIDING , new PageHidingEvent ( ) ) ; unlink ( $ sourceFile ) ; Dispatcher :: dispatch ( PageEvents :: PAGE_HID , new PageHidEvent ( ) ) ; DataLogger :: log ( sprintf ( 'Page "%s" for language "%s" was hidden from production' , $ pageName , $ languageName ) ) ; }
3355	public function getUrl ( $ postfix = null ) { $ url = sprintf ( '%s%s' , $ this -> api -> getCdnUri ( ) , $ this -> getPath ( $ postfix ) ) ; return $ url ; }
12547	public function getBlockPlugin ( $ name ) { if ( ! array_key_exists ( $ name , $ this -> blocks ) ) { return null ; } return $ this -> blocks [ $ name ] ; }
7626	public function containerExists ( $ containerName = '' ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; $ containers = $ this -> listContainers ( $ containerName , 1 ) ; foreach ( $ containers as $ container ) { if ( $ container -> Name == $ containerName ) { return true ; } } return false ; }
11056	public function urlFunction ( $ route , array $ params = [ ] ) { return $ this -> container [ 'url_generator' ] -> generate ( $ route , $ params , UrlGeneratorInterface :: ABSOLUTE_URL ) ; }
12663	static public function getMessage ( $ code = self :: CODE_INTERNAL_SERVER_ERROR ) { if ( isset ( self :: $ messages [ $ code ] ) ) { return self :: $ messages [ $ code ] ; } return self :: $ messages [ self :: CODE_INTERNAL_SERVER_ERROR ] ; }
11394	public static function setKindOfReportLog ( string $ sKindOfReportLog ) { if ( $ sKindOfReportLog === 'screen' || $ sKindOfReportLog === 'all' ) { self :: $ _sKindOfReportLog = $ sKindOfReportLog ; } else { self :: $ _sKindOfReportLog = 'error_log' ; } }
12198	public static function toJson ( Serializer $ serializer , \ RedKiteCms \ Content \ Block \ BaseBlock $ block ) { return $ serializer -> serialize ( $ block , 'json' ) ; }
9304	public function setFailureLogLifetime ( $ time ) { if ( ! is_numeric ( $ time ) ) { throw new \ InvalidArgumentException ( '`failureLogLifetime` expects integer value!' ) ; } $ this -> options [ 'failureLogLifetime' ] = ( int ) $ time ; return $ this ; }
12666	public function edit ( $ sourceDir , array $ options , $ username , $ values ) { $ this -> resolveOptions ( $ options ) ; $ this -> init ( $ sourceDir , $ options , $ username ) ; $ this -> createContributorDir ( $ sourceDir , $ options , $ username ) ; $ filename = sprintf ( '%s/blocks/%s.json' , $ this -> getDirInUse ( ) , $ options [ "blockname" ] ) ; $ currentBlock = $ options [ "baseBlock" ] = JsonTools :: jsonDecode ( FilesystemTools :: readFile ( $ filename ) ) ; $ values = $ this -> parseChildren ( $ values ) ; $ block = JsonTools :: join ( $ currentBlock , $ values ) ; $ encodedBlock = json_encode ( $ block ) ; $ blockClass = BlockFactory :: getBlockClass ( $ block [ "type" ] ) ; $ event = Dispatcher :: dispatch ( BlockEvents :: BLOCK_EDITING , new BlockEditingEvent ( $ this -> serializer , $ filename , $ encodedBlock , $ blockClass ) ) ; $ blockContent = $ event -> getFileContent ( ) ; FilesystemTools :: writeFile ( $ filename , $ blockContent ) ; Dispatcher :: dispatch ( BlockEvents :: BLOCK_EDITED , new BlockEditedEvent ( $ this -> serializer , $ filename , $ encodedBlock , $ blockClass ) ) ; DataLogger :: log ( sprintf ( 'Block "%s" has been edited on the "%s" slot on page "%s" for the "%s_%s" language' , $ options [ "blockname" ] , $ options [ "slot" ] , $ options [ "page" ] , $ options [ "language" ] , $ options [ "country" ] ) ) ; }
5093	public function rotate ( $ tableA , $ tableB ) { $ tableT = $ tableA . '_' . time ( ) . '_' . rand ( 0 , 1000000 ) ; return $ this -> rename ( [ $ tableB => $ tableT , $ tableA => $ tableB , $ tableT => $ tableA ] ) ; }
5467	protected function findRealmFromUrl ( $ url ) { if ( ! isset ( $ this -> realms [ $ url -> getHost ( ) ] ) ) { return false ; } foreach ( $ this -> realms [ $ url -> getHost ( ) ] as $ name => $ realm ) { if ( $ realm -> isWithin ( $ url ) ) { return $ realm ; } } return false ; }
4931	public function updateValues ( ) { $ values = [ ] ; foreach ( $ this -> getItems ( ) as $ item ) { if ( ! is_null ( $ item ) ) { $ values [ ] = $ item -> getValueWithParents ( ) ; } } $ this -> values = $ values ; }
6647	public function callback ( $ input ) { if ( isset ( $ input [ 'denied' ] ) ) { throw new AuthenticationCanceledException ( ) ; } if ( ! isset ( $ input [ 'oauth_token' ] ) || ! isset ( $ input [ 'oauth_verifier' ] ) ) { throw new InvalidOAuthTokenException ( 'missing oauth_token or oauth_verifier' ) ; } $ verifier_token = $ this -> token -> verifier ( $ input [ 'oauth_token' ] , $ input [ 'oauth_verifier' ] ) ; $ access_token = $ this -> oauth -> getAccessToken ( $ this -> settings , $ this -> consumer , $ verifier_token ) ; return $ this -> getProfile ( $ access_token ) ; }
439	public function hasProperty ( $ name , $ checkVars = true , $ checkBehaviors = true ) { return $ this -> canGetProperty ( $ name , $ checkVars , $ checkBehaviors ) || $ this -> canSetProperty ( $ name , false , $ checkBehaviors ) ; }
5194	public function addRoutes ( RouteCollector $ routeCollector ) : void { foreach ( $ this -> routes as $ index => $ route ) { $ routeCollector -> addRoute ( $ route -> getMethods ( ) , $ route -> getPath ( ) , $ index ) ; } }
10390	public static function loadString ( $ xmlString ) { $ xmlFile = tempnam ( self :: getSysTempDir ( ) , 'xml_' ) ; file_put_contents ( $ xmlFile , $ xmlString ) ; $ xml = self :: parseXml ( $ xmlFile ) ; unlink ( $ xmlFile ) ; return $ xml ; }
10029	function getContactsByFilterId ( $ filterId , $ page_index = 1 , $ page_size = 100 , $ standard_fields = array ( ) , $ custom_fields = array ( ) ) { $ queryParameters = array ( 'page_index' => $ page_index , 'page_size' => $ page_size , 'standard_field' => $ standard_fields ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'custom_field' , $ custom_fields ) ; return $ this -> get ( 'contacts/filter/' . utf8_encode ( $ filterId ) , $ queryParameters ) ; }
1338	public static function defaultApi ( string $ name ) : self { if ( empty ( $ name ) ) { throw new \ InvalidArgumentException ( 'Default API name must not be empty.' ) ; } self :: $ defaultApi = $ name ; return new self ( ) ; }
10731	public function getMinute ( ) { if ( $ this -> value !== null ) { preg_match ( '/^(?P<year>[0-9]{4,4})-(?P<month>[0-9]{2,2})-(?P<day>[0-9]{2,2}) (?P<hour>[0-9]{2,2}):(?P<minute>[0-9]{2,2}):(?P<second>[0-9]{2,2})$/ui' , $ this -> value , $ m ) ; return ( int ) $ m [ 'minute' ] ; } }
3803	private function createProperty ( PropertyInterface $ property , $ propertyName , $ variantHandling , ConditionInterface $ condition = null , ConditionInterface $ legendCondition = null ) { $ paletteProperty = new Property ( $ propertyName ) ; $ extra = $ property -> getExtra ( ) ; $ chain = new PropertyConditionChain ( ) ; $ paletteProperty -> setEditableCondition ( $ chain ) ; if ( isset ( $ extra [ 'readonly' ] ) ) { $ chain -> addCondition ( new BooleanCondition ( $ extra [ 'readonly' ] ) ) ; } $ chain = new PropertyConditionChain ( ) ; $ paletteProperty -> setVisibleCondition ( $ chain ) ; if ( $ variantHandling ) { $ chain -> addCondition ( new IsVariantAttribute ( ) ) ; } $ chain -> addCondition ( new BooleanCondition ( ! ( ( isset ( $ extra [ 'doNotShow' ] ) && $ extra [ 'doNotShow' ] ) || ( isset ( $ extra [ 'hideInput' ] ) && $ extra [ 'hideInput' ] ) ) ) ) ; if ( null !== $ condition ) { $ chain -> addCondition ( $ condition ) ; } if ( null !== $ legendCondition ) { $ chain -> addCondition ( $ legendCondition ) ; } return $ paletteProperty ; }
5064	public function exec ( ) : string { ob_start ( ) ; $ response = curl_exec ( $ this -> ch ) ; $ this -> buffer = ob_get_contents ( ) ; ob_end_clean ( ) ; if ( false === $ response ) { throw new CurlException ( $ this -> error ( ) ) ; } if ( true === $ response ) { $ response = $ this -> buffer ; } return $ response ; }
11536	public static function cast ( $ time ) { return $ time instanceof self ? $ time : new self ( $ time -> format ( self :: ISO8601 ) , $ time -> getTimezone ( ) ) ; }
7951	public function orderCacheRule ( $ nbCacheRule , $ duration ) { return json_decode ( self :: getClient ( ) -> orderCacheRule ( $ this -> sn , $ nbCacheRule , $ duration ) ) ; }
3407	public function setLockStore ( StoreInterface $ store ) : Factory { $ this -> lockFactory = new Factory ( $ store ) ; return $ this -> lockFactory ; }
11134	protected function calculateSELECT ( ) { $ this -> query .= 'SELECT ' ; if ( $ this -> distinct ) { $ this -> query .= ' DISTINCT ' ; } $ this -> queryStringFromArray ( 'selects' , '' , ', ' ) ; $ this -> queryStringFromArray ( 'tables' , ' FROM ' , ', ' ) ; $ this -> joinStringFromArray ( 'joins' ) ; $ this -> conditionStringFromArray ( 'wheres' , ' WHERE ' , ' AND ' ) ; $ this -> queryStringFromArray ( 'groupBys' , ' GROUP BY ' , ', ' ) ; $ this -> conditionStringFromArray ( 'havings' , ' HAVING ' , ' AND ' ) ; $ this -> queryStringFromArray ( 'orderBys' , ' ORDER BY ' , ', ' , false ) ; if ( $ this -> limit ) { $ this -> query .= ' LIMIT ' . $ this -> limit ; } if ( $ this -> offset ) { $ this -> query .= ' OFFSET ' . $ this -> offset ; } }
2005	protected function validateForm ( Widget $ objWidget = null ) { $ varInput = Idna :: encodeEmail ( Input :: post ( 'email' , true ) ) ; if ( ! Validator :: isEmail ( $ varInput ) ) { $ this -> Template -> mclass = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'email' ] ; return false ; } $ this -> Template -> email = $ varInput ; $ arrChannels = Input :: post ( 'channels' ) ; if ( ! \ is_array ( $ arrChannels ) ) { $ this -> Template -> mclass = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'noChannels' ] ; return false ; } $ arrChannels = array_intersect ( $ arrChannels , $ this -> nl_channels ) ; if ( empty ( $ arrChannels ) || ! \ is_array ( $ arrChannels ) ) { $ this -> Template -> mclass = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'noChannels' ] ; return false ; } $ this -> Template -> selectedChannels = $ arrChannels ; $ arrSubscriptions = array ( ) ; if ( ( $ objSubscription = NewsletterRecipientsModel :: findBy ( array ( "email=? AND active='1'" ) , $ varInput ) ) !== null ) { $ arrSubscriptions = $ objSubscription -> fetchEach ( 'pid' ) ; } $ arrChannels = array_intersect ( $ arrChannels , $ arrSubscriptions ) ; if ( empty ( $ arrChannels ) ) { $ this -> Template -> mclass = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'unsubscribed' ] ; return false ; } if ( $ objWidget !== null ) { $ objWidget -> validate ( ) ; if ( $ objWidget -> hasErrors ( ) ) { return false ; } } return array ( $ varInput , $ arrChannels ) ; }
12965	public function getIcon ( ) { if ( is_null ( $ this -> _icon ) && isset ( $ this -> object ) ) { $ this -> _icon = [ 'class' => $ this -> object -> objectType -> icon , 'title' => $ this -> objectTypeDescriptor ] ; } return $ this -> _icon ; }
1233	private function ensurePropertyType ( $ value ) { $ actualType = gettype ( $ value ) ; if ( 'object' === $ actualType ) { $ actualType = get_class ( $ value ) ; } $ valid = explode ( '|' , $ this -> expectedType ) ; $ isValid = false ; foreach ( $ valid as $ check ) { if ( $ check !== 'any' && \ DTS \ eBaySDK \ checkPropertyType ( $ check ) ) { if ( $ check === $ actualType ) { return ; } $ isValid = false ; } else { $ isValid = true ; } } if ( ! $ isValid ) { throw new Exceptions \ InvalidPropertyTypeException ( $ this -> property , $ this -> expectedType , $ actualType ) ; } }
412	public function getPort ( ) { if ( $ this -> _port === null ) { $ serverPort = $ this -> getServerPort ( ) ; $ this -> _port = ! $ this -> getIsSecureConnection ( ) && $ serverPort !== null ? $ serverPort : 80 ; } return $ this -> _port ; }
12882	public function getUnmappedKeys ( ) { $ u = [ ] ; $ f = $ this -> unmappedForeignKeys ; $ l = $ this -> unmappedLocalKeys ; if ( ! empty ( $ f ) ) { $ u [ 'foreign' ] = $ f ; } if ( ! empty ( $ l ) ) { $ u [ 'local' ] = $ l ; } return $ u ; }
6498	public function useScreenResolution ( $ width_height ) { list ( $ width , $ height ) = explode ( 'x' , $ width_height ) ; $ this -> getSessionDriver ( ) -> resizeWindow ( ( int ) $ width , ( int ) $ height ) ; }
7648	public function stream_close ( ) { @ fclose ( $ this -> temporaryFileHandle ) ; if ( $ this -> writeMode ) { $ containerExists = $ this -> getStorageClient ( $ this -> fileName ) -> containerExists ( $ this -> getContainerName ( $ this -> fileName ) ) ; if ( ! $ containerExists ) { $ this -> getStorageClient ( $ this -> fileName ) -> createContainer ( $ this -> getContainerName ( $ this -> fileName ) ) ; } try { $ this -> getStorageClient ( $ this -> fileName ) -> putBlob ( $ this -> getContainerName ( $ this -> fileName ) , $ this -> getFileName ( $ this -> fileName ) , $ this -> temporaryFileName ) ; } catch ( BlobException $ ex ) { @ unlink ( $ this -> temporaryFileName ) ; unset ( $ this -> storageClient ) ; throw $ ex ; } } @ unlink ( $ this -> temporaryFileName ) ; unset ( $ this -> storageClient ) ; }
6562	public static function joinPath ( $ base , $ path ) { if ( substr ( $ path , 0 , 1 ) === '/' ) { return $ path ; } if ( substr ( $ base , 0 , 1 ) !== '/' ) { return false ; } $ pathParts = self :: splitPath ( $ path ) ; $ resultParts = self :: splitPath ( $ base ) ; while ( ( $ part = array_shift ( $ pathParts ) ) !== null ) { switch ( $ part ) { case '.' : break ; case '..' : if ( count ( $ resultParts ) > 1 ) { array_pop ( $ resultParts ) ; } break ; default : $ resultParts [ ] = $ part ; break ; } } return implode ( '/' , $ resultParts ) ; }
6591	protected function asset ( $ type ) { $ busters = $ this -> checkAndGetBusters ( ) ; $ bustersOfThisType = array ( ) ; foreach ( $ busters as $ key => $ value ) { if ( strpos ( $ key , $ type ) !== false ) { $ bustersOfThisType [ $ key ] = $ value ; } } $ busterStrings = $ this -> parseTags ( $ bustersOfThisType , $ type ) ; return implode ( "\n" , $ busterStrings ) ; }
7665	function EncodeFile ( $ path , $ encoding = "base64" ) { if ( ! @ $ fd = fopen ( $ path , "rb" ) ) { $ this -> SetError ( $ this -> Lang ( "file_open" ) . $ path ) ; return "" ; } $ magic_quotes = get_magic_quotes_runtime ( ) ; set_magic_quotes_runtime ( 0 ) ; $ file_buffer = fread ( $ fd , filesize ( $ path ) ) ; $ file_buffer = $ this -> EncodeString ( $ file_buffer , $ encoding ) ; fclose ( $ fd ) ; set_magic_quotes_runtime ( $ magic_quotes ) ; return $ file_buffer ; }
5500	protected function replaceWildcards ( $ args ) { if ( $ args === false ) { return false ; } for ( $ i = 0 ; $ i < count ( $ args ) ; $ i ++ ) { if ( $ args [ $ i ] === $ this -> wildcard ) { $ args [ $ i ] = new AnythingExpectation ( ) ; } } return $ args ; }
5545	public function getText ( ) { if ( is_integer ( $ this -> focus ) ) { return $ this -> frames [ $ this -> focus ] -> getText ( ) ; } $ raw = '' ; for ( $ i = 0 ; $ i < count ( $ this -> frames ) ; $ i ++ ) { $ raw .= ' ' . $ this -> frames [ $ i ] -> getText ( ) ; } return trim ( $ raw ) ; }
8072	public function validateCredentials ( Authenticatable $ user , array $ credentials ) { return $ this -> ldap -> auth ( $ user -> dn , $ credentials [ 'password' ] ) ; }
11619	public function site ( ) : \ TheCMSThread \ Core \ Main \ Site { static $ site ; if ( $ site === null ) { $ site = $ this -> container -> get ( "TheCMSThread\\Core\\Main\\Site" ) ; } return $ site ; }
9914	public function create ( $ modelName , ModelConfig $ config = null ) { $ menu = new Menu ( ) ; $ addMenuItem = new LinkMenuItem ( ) ; $ addMenuItem -> setText ( Lang :: trans ( 'Add' ) ) ; $ addMenuItem -> setIcon ( Icons :: ion_plus ) ; $ addMenuItem -> setTarget ( URL :: route ( $ this -> aujaRouter -> getCreateName ( $ modelName ) ) ) ; $ menu -> addMenuItem ( $ addMenuItem ) ; $ spacerMenuItem = new SpacerMenuItem ( ) ; $ spacerMenuItem -> setText ( Lang :: trans ( $ modelName ) ) ; $ menu -> addMenuItem ( $ spacerMenuItem ) ; $ resourceMenuItem = new ResourceMenuItem ( ) ; $ resourceMenuItem -> setTarget ( URL :: route ( $ this -> aujaRouter -> getIndexName ( $ modelName ) ) ) ; $ model = $ this -> aujaConfigurator -> getModel ( $ modelName ) ; if ( $ this -> aujaConfigurator -> isSearchable ( $ model , $ config ) ) { $ target = urldecode ( URL :: route ( $ this -> aujaRouter -> getIndexName ( $ modelName ) , [ 'q' => '%s' ] ) ) ; $ property = new Searchable ( $ target ) ; $ resourceMenuItem -> addProperty ( $ property ) ; } $ menu -> addMenuItem ( $ resourceMenuItem ) ; return $ menu ; }
9699	public function text ( $ paragraphs = null ) { $ this -> paragraphs = $ paragraphs ; $ this -> params [ 'plaintext' ] = true ; return $ this -> generate ( ) ; }
6058	public function removeFolder ( $ id ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> delete ( 'v1/folders/' . $ id . '' , $ parameters ) ; $ result = new FolderResponse ( $ result ) ; return $ result ; }
1778	public static function optionChecked ( $ strOption , $ varValues ) { if ( $ strOption === '' ) { return '' ; } return ( \ is_array ( $ varValues ) ? \ in_array ( $ strOption , $ varValues ) : $ strOption == $ varValues ) ? ' checked' : '' ; }
2760	public function fetchBranches ( bool $ onlyRemote = false ) : array { $ options = $ onlyRemote ? [ 'r' => true ] : [ 'a' => true ] ; $ output = $ this -> gitWorkingCopy -> branch ( $ options ) ; $ branches = ( array ) preg_split ( "/\r\n|\n|\r/" , rtrim ( $ output ) ) ; return array_map ( [ $ this , 'trimBranch' ] , $ branches ) ; }
10004	static function getStringFromHTTPStatusCode ( $ httpStatusCode ) { if ( array_key_exists ( $ httpStatusCode , HTTPResponseCodes :: $ codes ) === true ) { return HTTPResponseCodes :: $ codes [ $ httpStatusCode ] ; } else { return "unknown error code: " . $ httpStatusCode ; } }
10308	private function setGlowSize ( $ size ) { if ( $ size !== null ) { $ this -> glowProperties [ 'size' ] = $ this -> getExcelPointsWidth ( $ size ) ; } return $ this ; }
9291	public function addGrid16CSS ( \ PageModel $ objPage , \ LayoutModel $ objLayout , \ PageRegular $ objPageRegular ) { $ arrFrameworkGrid16 = \ StringUtil :: deserialize ( $ objLayout -> frameworkGrid16 ) ; if ( is_array ( $ arrFrameworkGrid16 ) ) { foreach ( $ arrFrameworkGrid16 as $ strFile ) { if ( $ objLayout -> loadingOrderGrid16 == 'before_framework' ) { $ GLOBALS [ 'TL_CSS' ] [ ] = 'bundles/bugbustergrid16/' . basename ( $ strFile , '.css' ) . '.min.css' ; } else { $ GLOBALS [ 'TL_HEAD' ] [ ] = '<link rel="stylesheet" href="bundles/bugbustergrid16/' . basename ( $ strFile , '.css' ) . '.min.css">' ; } } } return ; }
6629	public function authenticate ( ) { $ state = $ this -> makeState ( ) ; $ this -> store -> put ( $ state , $ this -> settings ) ; return $ this -> redirect -> to ( $ this -> authURL ( $ state ) ) ; }
726	public function getAttribute ( $ attribute ) { try { return parent :: getAttribute ( $ attribute ) ; } catch ( \ PDOException $ e ) { switch ( $ attribute ) { case self :: ATTR_SERVER_VERSION : return $ this -> query ( "SELECT CAST(SERVERPROPERTY('productversion') AS VARCHAR)" ) -> fetchColumn ( ) ; default : throw $ e ; } } }
2264	public function tableExists ( $ strTable , $ strDatabase = null , $ blnNoCache = false ) { if ( $ strTable == '' ) { return false ; } return \ in_array ( $ strTable , $ this -> listTables ( $ strDatabase , $ blnNoCache ) ) ; }
813	private function fixSpaceAboveClassElement ( Tokens $ tokens , $ classStartIndex , $ elementIndex ) { static $ methodAttr = [ T_PRIVATE , T_PROTECTED , T_PUBLIC , T_ABSTRACT , T_FINAL , T_STATIC ] ; $ firstElementAttributeIndex = $ elementIndex ; for ( $ i = $ elementIndex ; $ i > $ classStartIndex ; -- $ i ) { $ nonWhiteAbove = $ tokens -> getNonWhitespaceSibling ( $ i , - 1 ) ; if ( null !== $ nonWhiteAbove && $ tokens [ $ nonWhiteAbove ] -> isGivenKind ( $ methodAttr ) ) { $ firstElementAttributeIndex = $ nonWhiteAbove ; } else { break ; } } if ( $ tokens [ $ nonWhiteAbove ] -> isGivenKind ( T_COMMENT ) ) { if ( 1 === $ firstElementAttributeIndex - $ nonWhiteAbove ) { $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAbove , $ firstElementAttributeIndex , 1 ) ; return ; } if ( substr_count ( $ tokens [ $ nonWhiteAbove + 1 ] -> getContent ( ) , "\n" ) > 1 ) { $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAbove , $ firstElementAttributeIndex , 2 ) ; return ; } if ( $ tokens [ $ nonWhiteAbove - 1 ] -> isWhitespace ( ) && substr_count ( $ tokens [ $ nonWhiteAbove - 1 ] -> getContent ( ) , "\n" ) > 0 ) { $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAbove , $ firstElementAttributeIndex , 1 ) ; $ nonWhiteAbove = $ this -> findCommentBlockStart ( $ tokens , $ nonWhiteAbove ) ; $ nonWhiteAboveComment = $ tokens -> getNonWhitespaceSibling ( $ nonWhiteAbove , - 1 ) ; $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAboveComment , $ nonWhiteAbove , $ nonWhiteAboveComment === $ classStartIndex ? 1 : 2 ) ; } else { $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAbove , $ firstElementAttributeIndex , 2 ) ; } return ; } if ( false === $ tokens [ $ nonWhiteAbove ] -> isGivenKind ( T_DOC_COMMENT ) ) { $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAbove , $ firstElementAttributeIndex , $ nonWhiteAbove === $ classStartIndex ? 1 : 2 ) ; return ; } $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAbove , $ firstElementAttributeIndex , 1 ) ; $ nonWhiteAbovePHPDoc = $ tokens -> getNonWhitespaceSibling ( $ nonWhiteAbove , - 1 ) ; $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAbovePHPDoc , $ nonWhiteAbove , $ nonWhiteAbovePHPDoc === $ classStartIndex ? 1 : 2 ) ; }
5058	public function generate ( $ subject , $ status , $ color , $ format ) { $ badge = new Badge ( $ subject , $ status , $ color , $ format ) ; return $ this -> getRenderFor ( $ badge -> getFormat ( ) ) -> render ( $ badge ) ; }
11801	public function hookTemplateRender ( $ templates , $ data , $ rendered , $ controller ) { $ template = reset ( $ templates ) ; if ( strpos ( $ template , '/modules/ga_report/templates/panels/' ) !== false && isset ( $ data [ 'content' ] [ 'data' ] [ 'report' ] [ 'data' ] ) && isset ( $ data [ 'content' ] [ 'data' ] [ 'handler' ] [ 'id' ] ) ) { $ handler_id = $ data [ 'content' ] [ 'data' ] [ 'handler' ] [ 'id' ] ; $ controller -> setJsSettings ( "ga_chart_$handler_id" , $ data [ 'content' ] [ 'data' ] [ 'report' ] [ 'data' ] ) ; $ controller -> setJs ( __DIR__ . "/js/handlers/$handler_id.js" ) ; $ controller -> setJs ( __DIR__ . "/js/common.js" ) ; } }
9812	protected function putRaw ( string $ path , $ body = null , array $ headers = [ ] ) { $ response = $ this -> client -> put ( $ path , $ headers , $ body ) ; return ResponseMediator :: getContent ( $ response ) ; }
9714	private function writeStyle ( ) { $ record = 0x0293 ; $ length = 0x0004 ; $ ixfe = 0x8000 ; $ BuiltIn = 0x00 ; $ iLevel = 0xff ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vCC' , $ ixfe , $ BuiltIn , $ iLevel ) ; $ this -> append ( $ header . $ data ) ; }
9438	public function reset ( ) { $ this -> rho = null ; $ this -> theta = null ; $ this -> r = null ; $ this -> i = null ; return $ this ; }
7285	protected function initializeInvoiceSubject ( ) { $ this -> invoiceTotal = 0 ; $ this -> creditTotal = 0 ; $ this -> invoiceState = InvoiceStates :: STATE_NEW ; $ this -> invoices = new ArrayCollection ( ) ; }
689	public function addRules ( $ rules , $ append = true ) { if ( ! $ this -> enablePrettyUrl ) { return ; } $ rules = $ this -> buildRules ( $ rules ) ; if ( $ append ) { $ this -> rules = array_merge ( $ this -> rules , $ rules ) ; } else { $ this -> rules = array_merge ( $ rules , $ this -> rules ) ; } }
12738	public function addClass ( $ name ) { $ classParts = explode ( ' ' , $ this -> tags [ 'class' ] ) ; foreach ( $ classParts as $ part ) { if ( $ name == $ part ) return ; } $ this -> tags [ 'class' ] .= ' ' . $ name ; $ this -> tags [ 'class' ] = trim ( $ this -> tags [ 'class' ] ) ; }
9067	public static function bootUuidForKey ( ) { static :: creating ( function ( $ model ) { $ model -> incrementing = false ; $ model -> attributes [ $ model -> getKeyName ( ) ] = ( string ) Str :: orderedUuid ( ) ; } ) ; }
9104	protected function parse_user ( ) { if ( ! empty ( $ this -> args [ 'user' ] ) ) { $ this -> args [ 'user__in' ] = array ( $ this -> args [ 'user' ] ) ; } return $ this -> parse_in_or_not_in_query ( 'user' , $ this -> args [ 'user__in' ] , $ this -> args [ 'user__not_in' ] ) ; }
3752	public function resetFallback ( $ strField ) { @ trigger_error ( __CLASS__ . '::' . __METHOD__ . ' is deprecated - handle resetting manually' , E_USER_DEPRECATED ) ; $ metaModel = $ this -> getMetaModel ( ) ; $ attribute = $ metaModel -> getAttribute ( $ strField ) ; $ ids = $ metaModel -> getIdsFromFilter ( null ) ; if ( $ attribute instanceof IComplex ) { $ attribute -> unsetDataFor ( $ ids ) ; } if ( $ attribute instanceof ITranslated ) { $ attribute -> unsetValueFor ( $ ids , $ this -> getCurrentLanguage ( ) ) ; } if ( $ attribute instanceof IAttribute ) { $ data = array ( ) ; foreach ( $ ids as $ id ) { $ data [ $ id ] = null ; } $ attribute -> setDataFor ( $ data ) ; } throw new \ RuntimeException ( 'Unknown attribute or type ' . $ strField ) ; }
1277	private function createRequest ( ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ trackRequest = $ xml -> appendChild ( $ xml -> createElement ( 'TrackRequest' ) ) ; $ trackRequest -> setAttribute ( 'xml:lang' , 'en-US' ) ; $ request = $ trackRequest -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , 'Track' ) ) ; if ( null !== $ this -> requestOption ) { $ request -> appendChild ( $ xml -> createElement ( 'RequestOption' , $ this -> requestOption ) ) ; } if ( null !== $ this -> trackingNumber ) { $ trackRequest -> appendChild ( $ xml -> createElement ( 'TrackingNumber' , $ this -> trackingNumber ) ) ; } if ( $ this -> isMailInnovations ( ) ) { $ trackRequest -> appendChild ( $ xml -> createElement ( 'IncludeMailInnovationIndicator' ) ) ; } if ( null !== $ this -> referenceNumber ) { $ trackRequest -> appendChild ( $ xml -> createElement ( 'ReferenceNumber' ) ) -> appendChild ( $ xml -> createElement ( 'Value' , $ this -> referenceNumber ) ) ; } if ( null !== $ this -> shipperNumber ) { $ trackRequest -> appendChild ( $ xml -> createElement ( 'ShipperNumber' , $ this -> shipperNumber ) ) ; } if ( null !== $ this -> beginDate || null !== $ this -> endDate ) { $ DateRange = $ xml -> createElement ( 'PickupDateRange' ) ; if ( null !== $ this -> beginDate ) { $ beginDate = $ this -> beginDate -> format ( 'Ymd' ) ; $ DateRange -> appendChild ( $ xml -> createElement ( 'BeginDate' , $ beginDate ) ) ; } if ( null !== $ this -> endDate ) { $ endDate = $ this -> endDate -> format ( 'Ymd' ) ; $ DateRange -> appendChild ( $ xml -> createElement ( 'EndDate' , $ endDate ) ) ; } $ trackRequest -> appendChild ( $ DateRange ) ; } return $ xml -> saveXML ( ) ; }
12603	public static function read ( $ path ) { $ path = Path :: clean ( $ path ) ; if ( ! File :: exists ( $ path ) ) { return '' ; } return file_get_contents ( $ path ) ; }
8060	private function createWorker ( $ i ) { $ sockets = array ( ) ; if ( socket_create_pair ( AF_UNIX , SOCK_STREAM , 0 , $ sockets ) === FALSE ) { throw new \ RuntimeException ( 'socket_create_pair failed.' ) ; return ; } $ processId = pcntl_fork ( ) ; if ( $ processId < 0 ) { throw new \ RuntimeException ( 'pcntl_fork failed.' ) ; return ; } elseif ( $ processId === 0 ) { $ this -> workerProcesses = new ProcessDetailsCollection ( ) ; $ this -> workerPoolSize = 0 ; socket_close ( $ sockets [ 1 ] ) ; $ this -> runWorkerProcess ( $ this -> worker , new SimpleSocket ( $ sockets [ 0 ] ) , $ i ) ; } else { socket_close ( $ sockets [ 0 ] ) ; $ this -> workerProcesses -> addFree ( new ProcessDetails ( $ processId , new SimpleSocket ( $ sockets [ 1 ] ) ) ) ; } }
1993	protected function prepareMetaDescription ( $ strText ) { $ strText = $ this -> replaceInsertTags ( $ strText , false ) ; $ strText = strip_tags ( $ strText ) ; $ strText = str_replace ( "\n" , ' ' , $ strText ) ; $ strText = StringUtil :: substr ( $ strText , 320 ) ; return trim ( $ strText ) ; }
5812	public function onBeforeWrite ( ) { parent :: onBeforeWrite ( ) ; $ types = array ( ) ; foreach ( singleton ( 'FusionService' ) -> getFusionTagTypes ( ) as $ type => $ field ) { $ types [ $ type ] = $ type ; } $ types = array_intersect ( $ this -> owner -> many_many ( ) , $ types ) ; if ( empty ( $ types ) ) { $ tagging = array ( ) ; foreach ( $ this -> owner -> FusionTags ( ) as $ tag ) { $ tagging [ ] = $ tag -> Title ; } } else { $ this -> owner -> FusionTags ( ) -> removeAll ( ) ; $ tagging = array ( ) ; foreach ( $ types as $ relationship => $ type ) { foreach ( $ this -> owner -> $ relationship ( ) as $ tag ) { $ fusion = FusionTag :: get ( ) -> byID ( $ tag -> FusionTagID ) ; $ this -> owner -> FusionTags ( ) -> add ( $ fusion ) ; $ tagging [ ] = $ fusion -> Title ; } } } $ this -> owner -> Tagging = implode ( ' ' , $ tagging ) ; }
1855	public static function findUpcomingByPids ( $ arrIds , $ intLimit = 0 , array $ arrOptions = array ( ) ) { if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } $ t = static :: $ strTable ; $ time = Date :: floorToMinute ( ) ; $ arrColumns = array ( "($t.endTime>=$time OR ($t.recurring='1' AND ($t.recurrences=0 OR $t.repeatEnd>=$time))) AND $t.pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrIds ) ) . ") AND ($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ) ; if ( $ intLimit > 0 ) { $ arrOptions [ 'limit' ] = $ intLimit ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.startTime" ; } return static :: findBy ( $ arrColumns , null , $ arrOptions ) ; }
12005	public function archive ( $ sourceDir , array $ options , $ username , $ block ) { $ this -> resolveOptions ( $ options ) ; $ block = json_decode ( $ block , true ) ; $ block [ "history" ] = array ( ) ; $ this -> init ( $ sourceDir , $ options , $ username ) ; $ historyDirName = sprintf ( '%s/archive/%s' , $ this -> getDirInUse ( ) , $ options [ "blockname" ] ) ; $ historyFileName = $ historyDirName . '/history.json' ; if ( ! is_dir ( $ historyDirName ) ) { mkdir ( $ historyDirName ) ; } $ history = array ( ) ; if ( file_exists ( $ historyFileName ) ) { $ history = json_decode ( file_get_contents ( $ historyFileName ) , true ) ; } $ history = array_merge ( $ history , array ( $ block [ "history_name" ] => $ block ) ) ; FilesystemTools :: writeFile ( $ historyFileName , json_encode ( $ history ) ) ; }
2872	public function init ( Mage_Core_Model_Abstract $ model ) { $ this -> class = get_class ( $ model ) ; $ this -> resource = $ model -> getResourceName ( ) ; $ this -> count = 0 ; }
9993	private function createCSSStyle ( Style $ pStyle ) { $ css = array_merge ( $ this -> createCSSStyleAlignment ( $ pStyle -> getAlignment ( ) ) , $ this -> createCSSStyleBorders ( $ pStyle -> getBorders ( ) ) , $ this -> createCSSStyleFont ( $ pStyle -> getFont ( ) ) , $ this -> createCSSStyleFill ( $ pStyle -> getFill ( ) ) ) ; return $ css ; }
6979	private function getClient ( ) { if ( null !== $ this -> client ) { return $ this -> client ; } try { return $ this -> client = new \ SoapClient ( static :: ENDPOINT ) ; } catch ( \ SoapFault $ oExcept ) { if ( $ this -> debug ) { @ trigger_error ( 'Failed to connect to the europa web service: ' . $ oExcept -> getMessage ( ) ) ; } } return $ this -> client = null ; }
4422	protected function interact ( InputInterface $ input , OutputInterface $ output ) { $ this -> input = $ input ; $ this -> output = $ output ; $ this -> questionHelper = $ this -> getHelper ( 'question' ) ; if ( Kernel :: VERSION_ID < 20700 ) { throw new RuntimeException ( 'Installation is not possible. Netgen Admin UI requires Symfony 2.7 or later to work.' ) ; } if ( ! $ this -> getContainer ( ) -> hasParameter ( 'ezpublish_legacy.root_dir' ) ) { throw new RuntimeException ( sprintf ( "%s\n%s" , 'Installation is not possible because eZ Publish Legacy is not present.' , 'Netgen Admin UI requires eZ Publish Community 2014.12 (Netgen Variant), eZ Publish 5.4.x or eZ Platform with Legacy Bridge to work.' ) ) ; } $ this -> writeSection ( 'Welcome to the Netgen Admin UI installation' ) ; while ( ! $ this -> doInteract ( ) ) { } return 0 ; }
7908	protected function renderDropdown ( ) { $ lines = [ ] ; $ lines [ ] = $ this -> encodeText ? Html :: encode ( $ this -> text ) : $ this -> text ; if ( $ this -> icon && is_string ( $ this -> icon ) ) { $ lines [ ] = $ this -> icon ; } $ lines [ ] = $ this -> renderItems ( $ this -> items , $ this -> options , $ this -> displaySearchInput ) ; return Html :: tag ( 'div' , implode ( "\n" , $ lines ) , $ this -> options ) ; }
7004	public function format ( $ format ) { $ this -> format = $ format ; $ format = preg_replace ( '/([a-zA-Z])/' , '%$1' , $ format ) ; $ format = preg_replace ( '/\\\\%(.)/' , '\\\\$1' , $ format ) ; $ this -> format_d ( $ format ) ; $ this -> formatD ( $ format ) ; $ this -> format_j ( $ format ) ; $ this -> format_l ( $ format ) ; $ this -> formatL ( $ format ) ; $ this -> formatN ( $ format ) ; $ this -> formatS ( $ format ) ; $ this -> format_w ( $ format ) ; $ this -> format_z ( $ format ) ; $ this -> formatW ( $ format ) ; $ this -> formatF ( $ format ) ; $ this -> format_m ( $ format ) ; $ this -> formatM ( $ format ) ; $ this -> format_n ( $ format ) ; $ this -> format_t ( $ format ) ; $ this -> formatY ( $ format ) ; $ this -> format_y ( $ format ) ; $ this -> format_a ( $ format ) ; $ this -> formatA ( $ format ) ; $ this -> format_g ( $ format ) ; $ this -> formatG ( $ format ) ; $ this -> format_h ( $ format ) ; $ this -> formatH ( $ format ) ; $ this -> format_i ( $ format ) ; $ this -> format_s ( $ format ) ; $ this -> format_u ( $ format ) ; $ this -> format_e ( $ format ) ; $ this -> formatO ( $ format ) ; $ this -> formatP ( $ format ) ; $ this -> formatZ ( $ format ) ; $ this -> format_r ( $ format ) ; $ this -> format_c ( $ format ) ; $ this -> formatC ( $ format ) ; return str_replace ( '\\' , '' , $ format ) ; }
6463	public function tryGetFirst ( $ name , & $ value ) : bool { try { $ value = $ this -> get ( $ name ) [ 0 ] ; return true ; } catch ( OutOfBoundsException $ ex ) { return false ; } }
8167	public function addIndentation ( ) { @ trigger_error ( 'The ' . __METHOD__ . ' method is deprecated since version 1.27 and will be removed in 2.0. Use write(\'\') instead.' , E_USER_DEPRECATED ) ; $ this -> source .= str_repeat ( ' ' , $ this -> indentation * 4 ) ; return $ this ; }
8587	public function setLowestOfferListing ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'LowestOfferListing' ] [ 'FieldValue' ] = $ value ; return $ this ; }
11806	public function chunk ( $ count , callable $ callback ) { return $ this -> buildQuery ( $ this -> getQueryColumns ( ) ) -> chunk ( $ count , $ callback ) ; }
6928	private function persistInvoice ( Invoice \ InvoiceInterface $ invoice ) { $ this -> persistenceHelper -> persistAndRecompute ( $ invoice , true ) ; foreach ( $ invoice -> getLines ( ) as $ line ) { $ this -> persistenceHelper -> persistAndRecompute ( $ line , true ) ; } $ this -> persistenceHelper -> persistAndRecompute ( $ invoice -> getShipment ( ) , false ) ; }
3548	public function create ( $ request ) { $ model = $ this -> repository -> create ( $ request -> all ( ) ) ; $ model -> { $ this -> getShortRelationName ( ) } ( ) -> sync ( $ request -> get ( $ this -> getRelationName ( ) , [ ] ) ) ; $ event_class = "Acoustep\EntrustGui\Events\\" . ucwords ( $ this -> getModelName ( ) ) . 'CreatedEvent' ; $ event = new $ event_class ; $ this -> dispatcher -> fire ( $ event -> setModel ( $ model ) ) ; return $ model ; }
2832	public function stacktraceSqlAction ( ) { if ( $ query = $ this -> _initQuery ( ) ) { $ helper = Mage :: helper ( 'sheep_debug' ) ; $ stripZendPath = $ helper -> canStripZendDbTrace ( ) ? 'lib/Zend/Db/Adapter' : '' ; $ trimPath = $ helper -> canTrimMagentoBaseDir ( ) ? Mage :: getBaseDir ( ) . DS : '' ; $ html = '<pre>' . Mage :: helper ( 'sheep_debug' ) -> formatStacktrace ( $ query -> getStackTrace ( ) , $ stripZendPath , $ trimPath ) . '</pre>' ; $ this -> getResponse ( ) -> setBody ( $ html ) ; } }
8649	private function calculateStringToSignV2 ( array $ parameters , $ queuepath = null ) { $ parsedUrl = parse_url ( $ this -> config [ 'ServiceURL' ] ) ; $ endpoint = $ parsedUrl [ 'host' ] ; if ( isset ( $ parsedUrl [ 'port' ] ) && ! is_null ( $ parsedUrl [ 'port' ] ) ) { $ endpoint .= ':' . $ parsedUrl [ 'port' ] ; } $ data = 'POST' ; $ data .= "\n" ; $ data .= $ endpoint ; $ data .= "\n" ; if ( $ queuepath ) { $ uri = $ queuepath ; } else { $ uri = "/" ; } $ uriencoded = implode ( "/" , array_map ( array ( $ this , "urlencode" ) , explode ( "/" , $ uri ) ) ) ; $ data .= $ uriencoded ; $ data .= "\n" ; uksort ( $ parameters , 'strcmp' ) ; $ data .= $ this -> getParametersAsString ( $ parameters ) ; return $ data ; }
8196	public function collectDir ( $ dir , $ ext = '.twig' ) { $ iterator = new RegexIterator ( new RecursiveIteratorIterator ( new RecursiveDirectoryIterator ( $ dir ) , RecursiveIteratorIterator :: LEAVES_ONLY ) , '{' . preg_quote ( $ ext ) . '$}' ) ; return $ this -> collect ( new Twig_Util_TemplateDirIterator ( $ iterator ) ) ; }
10268	function createMailing ( $ name , $ subject , $ deprecatedParameter = false , $ type = "regular" ) { $ queryParameters = array ( 'name' => urlencode ( $ name ) , 'subject' => urlencode ( $ subject ) , 'type' => urlencode ( $ type ) , ) ; return $ this -> post ( 'mailings' , "" , $ queryParameters ) ; }
2952	protected function prepareTemplate ( $ templateTxt ) { $ patterns = [ '/\\\{%(.*)%\\\}/U' , '/\s+/' , ] ; $ replacements = [ '(?<$1>.*)' , ' ' , ] ; $ templateTxt = preg_replace ( $ patterns , $ replacements , preg_quote ( $ templateTxt , '/' ) ) ; return trim ( $ templateTxt ) ; }
4549	public function get ( string $ alias ) { $ stat = $ this -> statCollection -> filter ( function ( $ element ) use ( $ alias ) { return $ element -> getAlias ( ) === $ alias ; } ) -> first ( ) ; if ( ! $ stat ) { throw new InvalidAliasException ( 'Stat alias "' . $ alias . '" does not exist.' ) ; } $ datum = $ stat -> get ( ) ; return $ datum ; }
29	private function filterRequiredPackages ( RepositoryInterface $ repo , PackageInterface $ package , $ bucket = array ( ) ) { $ requires = array_keys ( $ package -> getRequires ( ) ) ; $ packageListNames = array_keys ( $ bucket ) ; $ packages = array_filter ( $ repo -> getPackages ( ) , function ( $ package ) use ( $ requires , $ packageListNames ) { return in_array ( $ package -> getName ( ) , $ requires ) && ! in_array ( $ package -> getName ( ) , $ packageListNames ) ; } ) ; $ bucket = $ this -> appendPackages ( $ packages , $ bucket ) ; foreach ( $ packages as $ package ) { $ bucket = $ this -> filterRequiredPackages ( $ repo , $ package , $ bucket ) ; } return $ bucket ; }
12378	public function database ( Container $ application ) { $ config = $ this -> config ; $ dbName = $ application -> input -> getString ( "dbname" , "" , "post" ) ; $ dbPass = $ application -> input -> getString ( "dbpassword" , "" , "post" ) ; $ dbHost = $ application -> input -> getString ( "dbhost" , "" , "post" ) ; $ dbPref = $ application -> input -> getString ( "dbtableprefix" , "" , "post" ) ; $ dbUser = $ application -> input -> getString ( "dbusername" , "" , "post" ) ; $ dbDriver = $ application -> input -> getString ( "dbdriver" , "MySQLi" , "post" ) ; $ dbPort = $ application -> input -> getInt ( "dbport" , "" , "post" ) ; if ( empty ( $ dbName ) ) { throw new \ Exception ( t ( "Database Name is required to proceed." ) ) ; return false ; } if ( empty ( $ dbDriver ) ) { throw new \ Exception ( t ( "Database Driver Type is required to proceed." ) ) ; return false ; } if ( empty ( $ dbUser ) ) { throw new \ Exception ( t ( "Database username is required to proceed" ) ) ; return false ; } if ( empty ( $ dbHost ) ) { throw new \ Exception ( t ( "Please provide a link to your database host. If using SQLite, provide a path to the SQLite database as host" ) ) ; return false ; } $ config -> set ( "setup.database.host" , $ dbHost ) ; $ config -> set ( "setup.database.prefix" , $ dbPref ) ; $ config -> set ( "setup.database.user" , $ dbUser ) ; $ config -> set ( "setup.database.password" , $ dbPass ) ; $ config -> set ( "setup.database.name" , $ dbName ) ; $ config -> set ( "setup.database.driver" , strtolower ( $ dbDriver ) ) ; $ config -> set ( "setup.database.port" , intval ( $ dbPort ) ) ; try { $ application -> createInstance ( "database" , [ $ application -> config -> get ( "setup.database.driver" ) , $ application -> config -> get ( "setup.database" ) ] ) ; } catch ( Exception $ exception ) { return false ; } $ schema = new Schema ( ) ; if ( ! $ schema -> createTables ( $ application -> database ) ) { echo "wtf" ; return false ; } $ encryptor = $ this -> encryptor ; $ encryptKey = $ encryptor -> generateKey ( time ( ) . getRandomString ( 5 ) ) ; $ config -> set ( "setup.encrypt.key" , $ encryptKey ) ; if ( ! $ config -> saveParams ( ) ) { throw new Exception ( "could not save config" ) ; return false ; } return true ; }
1243	private static function actualValue ( array $ info , $ value ) { if ( is_object ( $ value ) ) { return $ value ; } $ types = explode ( '|' , $ info [ 'type' ] ) ; foreach ( $ types as $ type ) { switch ( $ type ) { case 'integer' : case 'string' : case 'double' : case 'boolean' : case 'any' : return $ value ; case 'DateTime' : return new \ DateTime ( $ value , new \ DateTimeZone ( 'UTC' ) ) ; } } return new $ info [ 'type' ] ( $ value ) ; }
3914	protected function sortByName ( $ blnAscending = true ) { $ arrFiles = $ this -> foundFiles ; if ( ! $ arrFiles ) { return array ( 'files' => array ( ) , 'source' => array ( ) ) ; } \ uasort ( $ arrFiles , ( $ blnAscending ) ? '\basename_natcasecmp' : '\basename_natcasercmp' ) ; return $ this -> remapSorting ( $ arrFiles , $ this -> outputBuffer ) ; }
8371	protected function shutdown ( ) { $ this -> shutdown = true ; $ this -> args [ 'messages' ] = array_filter ( $ this -> messages , function ( $ message ) { if ( ! isset ( $ message [ 'sent' ] ) || $ message [ 'sent' ] === false ) { return $ message ; } } ) ; $ redis = new Redis ; $ client = new Client ( $ redis ) ; $ client -> push ( static :: class , $ this -> args , 1 , 100 ) ; return true ; }
12557	private static function init ( ) : void { static $ inited = false ; if ( ! $ inited ) { if ( ! isset ( $ _SESSION [ 'Booby' ] ) || ! $ _SESSION [ 'Booby' ] ) { $ _SESSION [ 'Booby' ] = [ ] ; } self :: $ store = & $ _SESSION [ 'Booby' ] ; $ inited = true ; } }
4634	public function getComputedAttachments ( ) : array { if ( ! $ this -> hasAttachments ( ) ) { return [ ] ; } $ attachments = $ this -> getAttachments ( ) ; $ dir = $ this -> getAttachmentsDir ( ) ; $ path = $ dir [ 'path' ] ?? null ; $ recursive = $ dir [ 'recursive' ] ?? false ; if ( is_string ( $ path ) && is_dir ( $ path ) ) { $ files = $ recursive ? new RecursiveIteratorIterator ( new RecursiveDirectoryIterator ( $ path , RecursiveDirectoryIterator :: SKIP_DOTS ) , RecursiveIteratorIterator :: CHILD_FIRST ) : new DirectoryIterator ( $ path ) ; foreach ( $ files as $ fileInfo ) { if ( $ fileInfo -> isDir ( ) ) { continue ; } $ attachments [ ] = $ fileInfo -> getPathname ( ) ; } } return $ attachments ; }
4058	private function drawAttribute ( ModelToLabelEvent $ event ) { $ model = $ event -> getModel ( ) ; $ metaModel = $ this -> getMetaModelFromModel ( $ model ) ; $ attribute = $ metaModel -> getAttributeById ( $ model -> getProperty ( 'attr_id' ) ) ; if ( $ attribute ) { $ type = $ attribute -> get ( 'type' ) ; $ image = $ this -> iconBuilder -> getBackendIconImageTag ( $ this -> attributeFactory -> getIconForType ( $ type ) , $ type , '' , 'bundles/metamodelscore/images/icons/fields.png' ) ; $ name = $ attribute -> getName ( ) ; $ colName = $ attribute -> getColName ( ) ; $ isUnique = $ attribute -> get ( 'isunique' ) ; } else { $ type = 'unknown ID: ' . $ model -> getProperty ( 'attr_id' ) ; $ image = $ this -> iconBuilder -> getBackendIconImageTag ( 'bundles/metamodelscore/images/icons/fields.png' ) ; $ name = 'unknown attribute' ; $ colName = 'unknown column' ; $ isUnique = false ; } $ event -> setLabel ( '<div class="field_heading cte_type %s"><strong>%s</strong> <em>[%s]</em></div> <div class="field_type block"> %s<strong>%s</strong><span class="mandatory">%s</span> <span class="tl_class">%s</span> </div>' ) -> setArgs ( [ $ model -> getProperty ( 'published' ) ? 'published' : 'unpublished' , $ colName , $ type , $ image , $ name , $ model -> getProperty ( 'mandatory' ) || $ isUnique ? ' [' . $ this -> trans ( 'mandatory.0' ) . ']' : '' , $ model -> getProperty ( 'tl_class' ) ? sprintf ( '[%s]' , $ model -> getProperty ( 'tl_class' ) ) : '' ] ) ; }
1702	public function getSearchablePages ( $ arrPages , $ intRoot = 0 , $ blnIsSitemap = false ) { $ arrRoot = array ( ) ; if ( $ intRoot > 0 ) { $ arrRoot = $ this -> Database -> getChildRecords ( $ intRoot , 'tl_page' ) ; } $ arrProcessed = array ( ) ; $ time = Date :: floorToMinute ( ) ; $ objArchive = NewsArchiveModel :: findByProtected ( '' ) ; if ( $ objArchive !== null ) { while ( $ objArchive -> next ( ) ) { if ( ! $ objArchive -> jumpTo ) { continue ; } if ( ! empty ( $ arrRoot ) && ! \ in_array ( $ objArchive -> jumpTo , $ arrRoot ) ) { continue ; } if ( ! isset ( $ arrProcessed [ $ objArchive -> jumpTo ] ) ) { $ objParent = PageModel :: findWithDetails ( $ objArchive -> jumpTo ) ; if ( $ objParent === null ) { continue ; } if ( ! $ objParent -> published || ( $ objParent -> start != '' && $ objParent -> start > $ time ) || ( $ objParent -> stop != '' && $ objParent -> stop <= ( $ time + 60 ) ) ) { continue ; } if ( $ blnIsSitemap ) { if ( $ objParent -> protected ) { continue ; } if ( $ objParent -> sitemap == 'map_never' ) { continue ; } } $ arrProcessed [ $ objArchive -> jumpTo ] = $ objParent -> getAbsoluteUrl ( Config :: get ( 'useAutoItem' ) ? '/%s' : '/items/%s' ) ; } $ strUrl = $ arrProcessed [ $ objArchive -> jumpTo ] ; $ objArticle = NewsModel :: findPublishedDefaultByPid ( $ objArchive -> id ) ; if ( $ objArticle !== null ) { while ( $ objArticle -> next ( ) ) { $ arrPages [ ] = $ this -> getLink ( $ objArticle , $ strUrl ) ; } } } } return $ arrPages ; }
9829	public function getAssociationName ( $ modelName , $ otherModelName ) { return sprintf ( 'auja.%s.%s' , $ this -> toUrlName ( $ modelName ) , $ this -> toUrlName ( $ otherModelName ) ) ; }
5506	public function returnsAt ( $ timing , $ method , $ value , $ args = false ) { $ this -> dieOnNoMethod ( $ method , 'set return value sequence' ) ; $ this -> actions -> registerAt ( $ timing , $ method , $ args , new SimpleReturn ( $ value ) ) ; }
1635	protected function setupEvents ( Dispatcher $ events , array $ config ) { if ( isset ( $ config [ 'auto_capture_sessions' ] ) && $ config [ 'auto_capture_sessions' ] ) { $ events -> listen ( RouteMatched :: class , function ( $ event ) { $ this -> app -> bugsnag -> getSessionTracker ( ) -> startSession ( ) ; } ) ; } if ( isset ( $ config [ 'query' ] ) && ! $ config [ 'query' ] ) { return ; } $ show = isset ( $ config [ 'bindings' ] ) && $ config [ 'bindings' ] ; if ( class_exists ( QueryExecuted :: class ) ) { $ events -> listen ( QueryExecuted :: class , function ( QueryExecuted $ query ) use ( $ show ) { $ this -> app -> bugsnag -> leaveBreadcrumb ( 'Query executed' , Breadcrumb :: PROCESS_TYPE , $ this -> formatQuery ( $ query -> sql , $ show ? $ query -> bindings : [ ] , $ query -> time , $ query -> connectionName ) ) ; } ) ; } else { $ events -> listen ( 'illuminate.query' , function ( $ sql , array $ bindings , $ time , $ connection ) use ( $ show ) { $ this -> app -> bugsnag -> leaveBreadcrumb ( 'Query executed' , Breadcrumb :: PROCESS_TYPE , $ this -> formatQuery ( $ sql , $ show ? $ bindings : [ ] , $ time , $ connection ) ) ; } ) ; } }
6134	public function setMetadata ( $ metadata ) { if ( is_array ( $ metadata ) ) { $ this -> metadata = $ metadata ; return $ this ; } $ this -> metadata = json_decode ( $ metadata , true ) ; if ( null === $ this -> metadata ) { $ this -> metadata = $ metadata ; } return $ this ; }
462	public function buildCondition ( $ condition , & $ params ) { if ( is_array ( $ condition ) ) { if ( empty ( $ condition ) ) { return '' ; } $ condition = $ this -> createConditionFromArray ( $ condition ) ; } if ( $ condition instanceof ExpressionInterface ) { return $ this -> buildExpression ( $ condition , $ params ) ; } return ( string ) $ condition ; }
5767	private function create ( ) { $ m = new \ PHPMailer ( ) ; switch ( $ this -> protocol ) { case 'sendmail' : $ m -> isSendmail ( ) ; break ; case 'smtp' : $ m -> isSMTP ( ) ; $ m -> Host = $ this -> smtpHost ; $ m -> SMTPAuth = false ; $ m -> SMTPAutoTLS = false ; $ m -> Port = $ this -> smtpPort ; break ; case 'mail' : $ m -> isMail ( ) ; break ; case 'qmail' : $ m -> isQmail ( ) ; break ; default : throw new \ Exception ( 'bad phpmailerType: ' . $ this -> protocol ) ; } return $ m ; }
6265	public function resolve ( ResponseInterface $ response ) { if ( HttpPromise :: PENDING !== $ this -> state ) { throw new \ RuntimeException ( 'Promise is already resolved' ) ; } $ this -> state = HttpPromise :: FULFILLED ; $ this -> response = $ response ; $ this -> doResolve ( $ response ) ; }
2072	public function getAllowedArchives ( ) { if ( $ this -> User -> isAdmin ) { $ objArchive = Contao \ NewsArchiveModel :: findAll ( ) ; } else { $ objArchive = Contao \ NewsArchiveModel :: findMultipleByIds ( $ this -> User -> news ) ; } $ return = array ( ) ; if ( $ objArchive !== null ) { while ( $ objArchive -> next ( ) ) { $ return [ $ objArchive -> id ] = $ objArchive -> title ; } } return $ return ; }
9011	public function tinytext ( string $ charset = null ) : self { $ this -> type = 'tinytext' . $ this -> stringOptions ( $ charset ) ; return $ this ; }
11969	public static function SetAuthClass ( $ authClass ) { $ toolClass = \ MvcCore \ Application :: GetInstance ( ) -> GetToolClass ( ) ; if ( $ toolClass :: CheckClassInterface ( $ authClass , 'MvcCore\Ext\Auths\Basics\IAuth' , TRUE , TRUE ) ) self :: $ authClass = $ authClass ; }
6107	public function clientPermList ( $ cldbid , $ permsid = false ) { return $ this -> getParent ( ) -> channelClientPermList ( $ this -> getId ( ) , $ cldbid , $ permsid ) ; }
2352	public function sendToBrowser ( $ filename = '' , $ inline = false ) { $ response = new BinaryFileResponse ( $ this -> strRootDir . '/' . $ this -> strFile ) ; $ response -> setContentDisposition ( $ inline ? ResponseHeaderBag :: DISPOSITION_INLINE : ResponseHeaderBag :: DISPOSITION_ATTACHMENT , $ filename , Utf8 :: toAscii ( $ this -> basename ) ) ; $ response -> headers -> addCacheControlDirective ( 'must-revalidate' ) ; $ response -> headers -> addCacheControlDirective ( 'post-check' , 0 ) ; $ response -> headers -> addCacheControlDirective ( 'pre-check' , 0 ) ; $ response -> headers -> set ( 'Connection' , 'close' ) ; throw new ResponseException ( $ response ) ; }
11914	public function addDynamic ( $ name , $ factory , $ createDefault = 0 , $ forceDefault = false ) { $ control = new RContainer ( $ factory , $ createDefault , $ forceDefault ) ; $ control -> currentGroup = $ this -> currentGroup ; return $ this [ $ name ] = $ control ; }
7552	function getChildrenByCallback ( $ callback , $ recursive = true , $ check_self = false ) { $ count = $ this -> childCount ( ) ; if ( $ check_self && $ callback ( $ this ) ) { $ res = array ( $ this ) ; } else { $ res = array ( ) ; } if ( $ count > 0 ) { if ( is_int ( $ recursive ) ) { $ recursive = ( ( $ recursive > 1 ) ? $ recursive - 1 : false ) ; } for ( $ i = 0 ; $ i < $ count ; $ i ++ ) { if ( $ callback ( $ this -> children [ $ i ] ) ) { $ res [ ] = $ this -> children [ $ i ] ; } if ( $ recursive ) { $ res = array_merge ( $ res , $ this -> children [ $ i ] -> getChildrenByCallback ( $ callback , $ recursive ) ) ; } } } return $ res ; }
441	public function hasMethod ( $ name , $ checkBehaviors = true ) { if ( method_exists ( $ this , $ name ) ) { return true ; } elseif ( $ checkBehaviors ) { $ this -> ensureBehaviors ( ) ; foreach ( $ this -> _behaviors as $ behavior ) { if ( $ behavior -> hasMethod ( $ name ) ) { return true ; } } } return false ; }
12551	public function isSerialized ( ) { if ( ! is_string ( $ this -> serialized ) ) { return false ; } $ this -> serialized = trim ( $ this -> serialized ) ; if ( 'N;' == $ this -> serialized ) { return true ; } $ length = strlen ( $ this -> serialized ) ; if ( $ length < 4 ) { return false ; } if ( ':' !== $ this -> serialized [ 1 ] ) { return false ; } $ lastc = $ this -> serialized [ $ length - 1 ] ; if ( ';' !== $ lastc && '}' !== $ lastc ) { return false ; } $ token = $ this -> serialized [ 0 ] ; switch ( $ token ) { case 's' : if ( '"' !== $ this -> serialized [ $ length - 2 ] ) { return false ; } case 'a' : case 'O' : return ( bool ) preg_match ( "/^{$token}:[0-9]+:/s" , $ this -> serialized ) ; case 'b' : case 'i' : case 'd' : return ( bool ) preg_match ( "/^{$token}:[0-9.E-]+;\$/" , $ this -> serialized ) ; } return false ; }
734	public function init ( ) { parent :: init ( ) ; $ this -> itemFile = Yii :: getAlias ( $ this -> itemFile ) ; $ this -> assignmentFile = Yii :: getAlias ( $ this -> assignmentFile ) ; $ this -> ruleFile = Yii :: getAlias ( $ this -> ruleFile ) ; $ this -> load ( ) ; }
7372	public function updateAction ( Request $ request ) { $ user = $ this -> getUser ( ) ; $ form = $ this -> createForm ( ProfileType :: class , $ user ) ; $ form -> bind ( $ request ) ; if ( $ form -> isValid ( ) ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; try { $ em -> persist ( $ user ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'success' , 'Your changes have been saved.' ) ; return new JsonReloadResponse ( ) ; } catch ( \ Exception $ e ) { $ form -> addError ( new FormError ( 'Could not save changes. If the problem persists, please contact support.' ) ) ; } } return new JsonErrorResponse ( $ form ) ; }
11291	protected function _getAttributeDataWhenSet ( $ attributeName , $ query = false , $ loadMap = false , $ record = false ) { if ( is_numeric ( $ this -> model_data [ $ attributeName ] ) ) { if ( $ this -> _isRelation ( $ attributeName ) && ! isset ( $ this -> model_dynamicOff ) ) { $ this -> $ attributeName = $ this -> _getRelation ( $ attributeName , $ query , $ loadMap , $ record ) ; } } $ this -> beforeGet ( $ attributeName ) ; $ returnValue = $ this -> model_data [ $ attributeName ] ; $ this -> afterGet ( $ attributeName , $ returnValue ) ; return $ returnValue ; }
7540	function index ( $ count_all = true ) { if ( ! $ this -> parent ) { return - 1 ; } elseif ( $ count_all ) { return $ this -> parent -> findChild ( $ this ) ; } else { $ index = - 1 ; foreach ( array_keys ( $ this -> parent -> children ) as $ k ) { if ( ! $ this -> parent -> children [ $ k ] -> isTextOrComment ( ) ) { ++ $ index ; } if ( $ this -> parent -> children [ $ k ] === $ this ) { return $ index ; } } return - 1 ; } }
8276	public function triggerEvent ( $ eventName , array $ params = array ( ) ) { foreach ( $ this -> modules as $ module ) { $ module -> handleEvent ( $ eventName , $ params ) ; } }
10083	protected function registerRouter ( ) { $ this -> app -> singleton ( 'auja.router' , function ( $ app ) { $ config = $ app [ 'config' ] [ 'auja-laravel' ] ? : $ app [ 'config' ] [ 'auja-laravel::config' ] ; return new AujaRouter ( $ app [ 'auja' ] , $ app [ 'router' ] , $ config [ 'route' ] ) ; } ) ; $ this -> app -> bind ( 'Label305\AujaLaravel\Routing\AujaRouter' , 'auja.router' ) ; }
5491	protected function describeDifference ( $ expected , $ parameters ) { if ( count ( $ expected ) != count ( $ parameters ) ) { return sprintf ( 'Expected %s arguments of [%s], but got %s arguments of [%s]' , count ( $ expected ) , $ this -> renderArguments ( $ expected ) , count ( $ parameters ) , $ this -> renderArguments ( $ parameters ) ) ; } $ messages = array ( ) ; for ( $ i = 0 ; $ i < count ( $ expected ) ; $ i ++ ) { $ comparison = $ this -> forceToExpectation ( $ expected [ $ i ] ) ; if ( ! $ comparison -> test ( $ parameters [ $ i ] ) ) { $ messages [ ] = 'parameter ' . ( $ i + 1 ) . ' with [' . $ comparison -> overlayMessage ( $ parameters [ $ i ] , $ this -> getDumper ( ) ) . ']' ; } } return 'Parameter expectation differs at ' . implode ( ' and ' , $ messages ) ; }
2329	public function delete ( ) { if ( $ this -> intIndex < 0 ) { $ this -> first ( ) ; } return $ this -> arrModels [ $ this -> intIndex ] -> delete ( ) ; }
983	public function process ( Plan $ plan ) { $ shop = ShopifyApp :: shop ( ) ; $ bp = new BillingPlan ( $ shop , $ plan ) ; $ bp -> setChargeId ( Request :: query ( 'charge_id' ) ) ; $ bp -> activate ( ) ; $ bp -> save ( ) ; $ shop -> update ( [ 'freemium' => false , 'plan_id' => $ plan -> id , ] ) ; return Redirect :: route ( 'home' ) -> with ( 'success' , 'billing' ) ; }
5802	public function indexViewObjects ( Response $ response , bool $ resetFilter = false ) { if ( $ resetFilter ) { return $ this -> resetFilter ( $ response , $ this -> indexRoute ) ; } try { $ permissions = $ this -> permissionsEntityMapper -> getObjects ( $ this -> getFilterColumnsInfo ( ) ) ; } catch ( QueryFailureException $ e ) { $ permissions = [ ] ; SlimPostgres :: setAdminNotice ( 'Query Failed' , 'failure' ) ; } return $ this -> indexView ( $ response , $ permissions ) ; }
11657	public function make ( ) { if ( count ( $ this -> headers ) > 0 ) { if ( ! $ this -> session -> exists ( 'headersInRedirect' , 'redirect' ) || ! $ this -> session -> get ( 'headersInRedirect' , 'redirect' ) ) { $ this -> session -> set ( 'redirectPath' , $ this -> path , 'redirect' ) ; $ this -> session -> set ( 'headersInRedirect' , $ this -> headers , 'redirect' ) ; } } header ( "Location: $this->path" ) ; exit ( ) ; }
7343	protected function initializeStock ( ) { $ this -> stockMode = StockSubjectModes :: MODE_AUTO ; $ this -> stockState = StockSubjectStates :: STATE_OUT_OF_STOCK ; $ this -> stockFloor = 0 ; $ this -> inStock = 0 ; $ this -> availableStock = 0 ; $ this -> virtualStock = 0 ; $ this -> replenishmentTime = 2 ; $ this -> minimumOrderQuantity = 1 ; $ this -> quoteOnly = false ; $ this -> endOfLife = false ; }
6447	public function getUserProfile ( ) { $ linkedin = $ this -> getClient ( ) ; $ response = $ linkedin -> get ( '/people/~:(id,first-name,last-name,picture-url,public-profile-url,email-address)' ) ; if ( isset ( $ response [ 'emailAddress' ] ) ) { return array ( 'userid' => $ response [ 'id' ] , 'name' => $ response [ 'firstName' ] . ' ' . $ response [ 'lastName' ] , 'email' => $ response [ 'emailAddress' ] , 'imageurl' => $ response [ 'pictureUrl' ] ) ; } }
7886	public function levels ( ) { if ( ! $ this -> levels ) { $ class = new ReflectionClass ( new LogLevel ( ) ) ; $ this -> levels = $ class -> getConstants ( ) ; } return $ this -> levels ; }
3449	public function setAttribute ( $ key , $ value ) { if ( in_array ( $ key , $ this -> multipleHighloadBlockFields ) ) { $ this -> attributes [ $ key ] = serialize ( $ value ) ; return $ this ; } parent :: setAttribute ( $ key , $ value ) ; return $ this ; }
11110	private function findExtensionsDirectories ( Container $ app ) { $ directories = $ app [ 'config.finder' ] -> ignoreUnreadableDirs ( ) -> directories ( ) -> name ( '*Extension' ) -> in ( $ app [ 'app.extensions.dir' ] ) -> depth ( '< 3' ) -> sortByName ( ) ; return $ directories ; }
9247	public function from ( Contract $ contract , string $ string , callable $ callback = null ) : string { $ string = ucwords ( $ contract -> recipe ( $ string , 'upperCaseFirst' , function ( $ string ) use ( $ contract ) { if ( $ contract instanceof Camel ) { return $ string ; } return strtolower ( $ string ) ; } ) ) ; return $ this -> callback ( $ string , $ callback ) ; }
11435	public function delete ( string $ sName ) { return unlink ( $ this -> _sFolder . $ this -> _getSubDirectory ( $ sName ) . md5 ( $ sName ) . '.fil.cac' ) ; }
6946	private function getRegularDueQueryBuilder ( ) { $ qb = $ this -> createQueryBuilder ( 'o' ) ; $ ex = $ qb -> expr ( ) ; return $ qb -> where ( $ ex -> andX ( $ ex -> eq ( 'o.sample' , ':not_sample' ) , $ ex -> lt ( 'o.paidTotal' , 'o.grandTotal' ) , $ ex -> notIn ( 'o.invoiceState' , ':canceled_or_refunded' ) , $ ex -> eq ( 'o.shipmentState' , ':shipped' ) , $ ex -> isNull ( 'o.paymentTerm' ) ) ) -> addOrderBy ( 'o.createdAt' , 'ASC' ) -> setParameter ( 'not_sample' , false ) -> setParameter ( 'shipped' , ShipmentStates :: STATE_COMPLETED ) -> setParameter ( 'canceled_or_refunded' , [ InvoiceStates :: STATE_CANCELED , InvoiceStates :: STATE_CREDITED ] ) ; }
4205	private function getParams ( \ ReflectionMethod $ reflectionMethod , $ phpDoc = array ( ) ) { $ paramArray = array ( ) ; $ params = $ reflectionMethod -> getParameters ( ) ; if ( empty ( $ phpDoc ) ) { $ phpDoc = $ this -> phpDoc -> getParsed ( $ reflectionMethod ) ; } foreach ( $ params as $ i => $ reflectionParameter ) { $ nameNoPrefix = $ reflectionParameter -> getName ( ) ; $ name = '$' . $ nameNoPrefix ; if ( \ method_exists ( $ reflectionParameter , 'isVariadic' ) && $ reflectionParameter -> isVariadic ( ) ) { $ name = '...' . $ name ; } if ( $ reflectionParameter -> isPassedByReference ( ) ) { $ name = '&' . $ name ; } $ constantName = null ; $ defaultValue = $ this -> abstracter -> UNDEFINED ; if ( $ reflectionParameter -> isDefaultValueAvailable ( ) ) { $ defaultValue = $ reflectionParameter -> getDefaultValue ( ) ; if ( \ version_compare ( PHP_VERSION , '5.4.6' , '>=' ) && $ reflectionParameter -> isDefaultValueConstant ( ) ) { $ constantName = $ reflectionParameter -> getDefaultValueConstantName ( ) ; } } $ paramInfo = array ( 'constantName' => $ constantName , 'defaultValue' => $ defaultValue , 'desc' => null , 'isOptional' => $ reflectionParameter -> isOptional ( ) , 'name' => $ name , 'type' => $ this -> getParamTypeHint ( $ reflectionParameter ) , ) ; if ( isset ( $ phpDoc [ 'param' ] [ $ i ] ) ) { $ paramInfo [ 'desc' ] = $ phpDoc [ 'param' ] [ $ i ] [ 'desc' ] ; if ( ! isset ( $ paramInfo [ 'type' ] ) ) { $ paramInfo [ 'type' ] = $ phpDoc [ 'param' ] [ $ i ] [ 'type' ] ; } } $ paramArray [ $ nameNoPrefix ] = $ paramInfo ; } return $ paramArray ; }
12279	public function moveUsers ( array $ openIds , $ groupId ) { $ params = [ 'openid_list' => $ openIds , 'to_groupid' => $ groupId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_MEMBER_BATCH_UPDATE , $ params ] ) ; }
6061	public function listDeploymentSites ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/media/' . $ id . '/deployment/sites' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new DeploymentSiteResponse ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
5474	protected function createAction ( $ action , $ page ) { if ( ( $ action === '' ) || ( $ action === false ) ) { return $ page -> expandUrl ( $ page -> getUrl ( ) ) ; } return $ page -> expandUrl ( new SimpleUrl ( $ action ) ) ; }
5646	public function createInvoker ( $ invoker ) { $ numberOfReporters = count ( $ this -> reporters ) ; for ( $ i = 0 ; $ i < $ numberOfReporters ; $ i ++ ) { $ invoker = $ this -> reporters [ $ i ] -> createInvoker ( $ invoker ) ; } return $ invoker ; }
6517	public function setParameterType ( $ method , $ name , $ type ) { if ( ! isset ( $ this -> parameterTypes [ $ method ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'A method with name "%s" is not defined' , $ name , $ method ) ) ; } if ( ! array_key_exists ( $ name , $ this -> parameterTypes [ $ method ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'A parameter with name "%s" for method "%s" is not defined' , $ name , $ method ) ) ; } $ this -> parameterTypes [ $ method ] [ $ name ] = $ type ; }
12968	protected function renderPage ( ) { $ page = $ this -> options [ "page" ] ; $ request = $ this -> options [ "request" ] ; $ username = $ this -> options [ "username" ] ; $ pageOptions = array ( 'page' => $ request -> get ( 'page' ) , 'language' => $ request -> get ( '_locale' ) , 'country' => $ request -> get ( 'country' ) , ) ; $ page -> render ( $ this -> configuration -> siteDir ( ) , $ pageOptions , $ username ) ; return $ page ; }
12386	public function parse ( ) { $ finder = new Finder ( ) ; $ pages = $ finder -> directories ( ) -> depth ( 0 ) -> sortByName ( ) -> in ( $ this -> pagesDir ) ; $ languages = $ this -> configurationHandler -> languages ( ) ; $ homepage = $ this -> configurationHandler -> homepage ( ) ; foreach ( $ pages as $ page ) { $ pageDir = ( string ) $ page ; $ pageName = basename ( $ pageDir ) ; $ pageDefinitionFile = $ pageDir . '/' . $ this -> pageFile ; if ( ! file_exists ( $ pageDefinitionFile ) ) { continue ; } $ seoDefinition = $ this -> fetchSeoDefinition ( $ this -> pagesDir . '/' . $ pageName , $ this -> seoFile , $ languages ) ; $ pageDefinition = json_decode ( file_get_contents ( $ pageDefinitionFile ) , true ) ; $ pageDefinition [ "seo" ] = $ seoDefinition ; $ pageDefinition [ "isHome" ] = $ homepage == $ pageName ; $ this -> pages [ $ pageName ] = $ pageDefinition ; } return $ this ; }
7442	public function showAction ( $ id ) { $ em = $ this -> getDoctrine ( ) -> getEntityManager ( ) ; $ group = $ em -> getRepository ( 'Orkestra\Bundle\ApplicationBundle\Entity\Group' ) -> find ( $ id ) ; if ( ! $ group ) { throw $ this -> createNotFoundException ( 'Unable to locate Group' ) ; } return array ( 'group' => $ group , ) ; }
12869	public function bind ( $ sUser , $ sPassword ) : Ldap { return $ this -> _bConnected = ldap_bind ( $ this -> _rConnect , $ sUser , $ sPassword ) ; return $ this ; }
6604	public function makeAccessToken ( Response $ response ) { parse_str ( $ response -> content ( ) , $ params ) ; $ this -> validateAccessTokenResponse ( $ params ) ; $ this -> credentials [ 'key' ] = $ params [ 'oauth_token' ] ; $ this -> credentials [ 'secret' ] = $ params [ 'oauth_token_secret' ] ; $ this -> credentials [ 'user_id' ] = $ params [ 'user_id' ] ; $ this -> credentials [ 'screen_name' ] = $ params [ 'screen_name' ] ; return $ this ; }
1005	public function toPsrResponse ( $ result , ResponseInterface $ response , StreamInterface $ writableBodyStream ) { if ( $ result instanceof Promise ) { return $ result -> then ( function ( $ actualResult ) use ( $ response , $ writableBodyStream ) { return $ this -> doConvertToPsrResponse ( $ actualResult , $ response , $ writableBodyStream ) ; } ) ; } return $ this -> doConvertToPsrResponse ( $ result , $ response , $ writableBodyStream ) ; }
10633	protected function getVars ( $ content , $ details = [ ] ) { $ defaults = [ 'title' => Translate :: t ( 'file.title' , [ ] , 'filefield' ) , 'file' => false , ] ; $ vars = array_merge ( $ defaults , $ content ) ; $ this -> getModel ( ) -> setVars ( $ vars ) ; }
2923	public function lines ( ) { $ content = [ ] ; $ lines = $ this -> readLinesFromFile ( ) ; foreach ( $ lines as $ row => $ line ) { $ data = [ 'line' => $ row + 1 , 'raw_data' => $ line , 'parsed_data' => $ this -> formatter -> parseLine ( $ line ) ] ; $ content [ ] = $ data ; } return $ content ; }
1324	public static function decode ( $ string , $ asArray ) { if ( version_compare ( PHP_VERSION , '5.4.0' , '>=' ) && ! ( defined ( 'JSON_C_VERSION' ) && PHP_INT_SIZE > 4 ) ) { return json_decode ( $ string , $ asArray , 512 , JSON_BIGINT_AS_STRING ) ; } return json_decode ( $ string , $ asArray ) ; }
11203	public function max ( $ key = false ) { $ collection = $ this -> getIterator ( ) ; $ max = 0 ; $ valueToReturn = 0 ; foreach ( $ collection as $ result ) { if ( $ key && isset ( $ result -> $ key ) ) { if ( $ result -> $ key > $ max ) { $ max = $ result -> $ key ; $ valueToReturn = $ result ; } } else if ( $ key && isset ( $ result [ $ key ] ) ) { if ( $ result [ $ key ] > $ max ) { $ max = $ result [ $ key ] ; $ valueToReturn = $ result ; } } else { if ( $ result > $ max ) { $ max = $ result ; $ valueToReturn = $ result ; } } } return $ valueToReturn ; }
8645	private function parseHttpHeader ( $ header ) { $ parsedHeader = array ( ) ; foreach ( explode ( "\n" , $ header ) as $ line ) { $ splitLine = preg_split ( '/:\s/' , $ line , 2 , PREG_SPLIT_NO_EMPTY ) ; if ( sizeof ( $ splitLine ) == 2 ) { $ k = strtolower ( trim ( $ splitLine [ 0 ] ) ) ; $ v = trim ( $ splitLine [ 1 ] ) ; if ( array_key_exists ( $ k , $ parsedHeader ) ) { $ parsedHeader [ $ k ] = $ parsedHeader [ $ k ] . "," . $ v ; } else { $ parsedHeader [ $ k ] = $ v ; } } } return $ parsedHeader ; }
631	public function batchInsert ( $ table , $ columns , $ rows ) { $ table = $ this -> db -> quoteSql ( $ table ) ; $ columns = array_map ( function ( $ column ) { return $ this -> db -> quoteSql ( $ column ) ; } , $ columns ) ; $ params = [ ] ; $ sql = $ this -> db -> getQueryBuilder ( ) -> batchInsert ( $ table , $ columns , $ rows , $ params ) ; $ this -> setRawSql ( $ sql ) ; $ this -> bindValues ( $ params ) ; return $ this ; }
5207	public function areActiveURLs ( array $ urls , $ output = "active" ) { foreach ( $ urls as $ url ) { if ( $ this -> isActiveURL ( $ url , true ) ) { return $ output ; } } return null ; }
790	public function getErrorSummary ( $ showAllErrors ) { $ lines = [ ] ; $ errors = $ showAllErrors ? $ this -> getErrors ( ) : $ this -> getFirstErrors ( ) ; foreach ( $ errors as $ es ) { $ lines = array_merge ( ( array ) $ es , $ lines ) ; } return $ lines ; }
2207	protected function compileYearlyMenu ( ) { $ arrData = array ( ) ; $ arrAllEvents = $ this -> getAllEvents ( $ this -> cal_calendar , 0 , 2145913200 ) ; foreach ( $ arrAllEvents as $ intDay => $ arrDay ) { foreach ( $ arrDay as $ arrEvents ) { $ arrData [ substr ( $ intDay , 0 , 4 ) ] += \ count ( $ arrEvents ) ; } } ( $ this -> cal_order == 'ascending' ) ? ksort ( $ arrData ) : krsort ( $ arrData ) ; $ arrItems = array ( ) ; $ count = 0 ; $ limit = \ count ( $ arrData ) ; foreach ( $ arrData as $ intYear => $ intCount ) { $ intDate = $ intYear ; $ quantity = sprintf ( ( ( $ intCount < 2 ) ? $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'entry' ] : $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'entries' ] ) , $ intCount ) ; $ arrItems [ $ intYear ] [ 'date' ] = $ intDate ; $ arrItems [ $ intYear ] [ 'link' ] = $ intYear ; $ arrItems [ $ intYear ] [ 'href' ] = $ this -> strLink . '?year=' . $ intDate ; $ arrItems [ $ intYear ] [ 'title' ] = StringUtil :: specialchars ( $ intYear . ' (' . $ quantity . ')' ) ; $ arrItems [ $ intYear ] [ 'class' ] = trim ( ( ( ++ $ count == 1 ) ? 'first ' : '' ) . ( ( $ count == $ limit ) ? 'last' : '' ) ) ; $ arrItems [ $ intYear ] [ 'isActive' ] = ( Input :: get ( 'year' ) == $ intDate ) ; $ arrItems [ $ intYear ] [ 'quantity' ] = $ quantity ; } $ this -> Template -> yearly = true ; $ this -> Template -> items = $ arrItems ; $ this -> Template -> showQuantity = ( $ this -> cal_showQuantity != '' ) ? true : false ; }
10305	private function recursiveReplace ( $ path ) { $ patterns = [ '/*.md' , '/*.php' , '/*.phtml' , '/*.txt' , '/*.TXT' , ] ; $ from = array_keys ( $ this -> getMapping ( ) ) ; $ to = array_values ( $ this -> getMapping ( ) ) ; foreach ( $ patterns as $ pattern ) { foreach ( glob ( $ path . $ pattern ) as $ file ) { $ original = file_get_contents ( $ file ) ; $ converted = str_replace ( $ from , $ to , $ original ) ; if ( $ original !== $ converted ) { echo $ file . " converted\n" ; file_put_contents ( $ file , $ converted ) ; } } } foreach ( glob ( $ path . '/*' , GLOB_ONLYDIR ) as $ subpath ) { if ( strpos ( $ subpath , $ path . '/' ) === 0 ) { $ this -> recursiveReplace ( $ subpath ) ; } } }
10702	public static function getPasswordComplexity ( $ password , $ minLength ) { $ group = [ 'upper' => '/[A-Z]/' , 'lower' => '/[a-z]/' , 'number' => '/[0-9]/' , 'special' => '/[^A-Za-z0-9]/' , ] ; $ score = 0 ; $ length = \ strlen ( $ password ) ; if ( $ length < $ minLength ) { return 0 ; } foreach ( $ group as $ pattern ) { if ( preg_match ( $ pattern , $ password ) ) { $ score ++ ; } } if ( $ score < 3 ) { $ score -- ; } if ( $ length > $ minLength ) { $ score += ( int ) floor ( ( $ length - $ minLength ) / 2 ) ; } return $ score ; }
10294	public static function excelToTimestamp ( $ excelTimestamp , $ timeZone = null ) { return ( int ) self :: excelToDateTimeObject ( $ excelTimestamp , $ timeZone ) -> format ( 'U' ) ; }
4722	public function setText ( $ text ) { $ this -> text = $ text ; if ( ! $ this -> text instanceof Text ) { $ this -> text = new Text ( $ this -> text ) ; } return $ this ; }
10699	public static function isBirthDate ( $ date ) { if ( $ date === null || $ date === '0000-00-00' ) { return true ; } if ( preg_match ( '/^(\d{4})-((?:0?[1-9])|(?:1[0-2]))-((?:0?[1-9])|(?:[1-2]\d)|(?:3[01]))(\d{2}:\d{2}:\d{2})?$/' , $ date , $ birth_date ) ) { return ! ( ( $ birth_date [ 1 ] > date ( 'Y' ) && $ birth_date [ 2 ] > date ( 'm' ) && $ birth_date [ 3 ] > date ( 'd' ) ) || ( $ birth_date [ 1 ] === date ( 'Y' ) && $ birth_date [ 2 ] === date ( 'm' ) && $ birth_date [ 3 ] > date ( 'd' ) ) || ( $ birth_date [ 1 ] === date ( 'Y' ) && $ birth_date [ 2 ] > date ( 'm' ) ) ) ; } return false ; }
9600	public function length ( ) { $ sumOfSquares = 0 ; foreach ( $ this -> components ( ) as $ component ) { $ sumOfSquares += pow ( $ component , 2 ) ; } return sqrt ( $ sumOfSquares ) ; }
1217	public static function slice ( $ value , $ start = null , $ stop = null , $ step = 1 ) { if ( ! Utils :: isArray ( $ value ) && ! is_string ( $ value ) ) { throw new \ InvalidArgumentException ( 'Expects string or array' ) ; } return self :: sliceIndices ( $ value , $ start , $ stop , $ step ) ; }
5789	protected function setRules ( bool $ skipUniqueForUnchanged = false , array $ record = null ) { $ this -> mapFieldsRules ( $ this -> databaseTableValidation -> getValidationRules ( ) ) ; $ uniqueColumns = $ this -> mapper -> getUniqueColumns ( ) ; if ( count ( $ uniqueColumns ) > 0 ) { $ this -> addUniqueRule ( ) ; foreach ( $ uniqueColumns as $ databaseColumnMapper ) { $ field = $ databaseColumnMapper -> getName ( ) ; if ( ! ( $ skipUniqueForUnchanged && $ this -> inputData [ $ field ] == $ record [ $ field ] ) ) { $ this -> rule ( 'unique' , $ field , $ databaseColumnMapper , $ this ) ; } } } }
646	public function checkIntegrity ( $ check = true , $ schema = '' , $ table = '' ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> checkIntegrity ( $ check , $ schema , $ table ) ; return $ this -> setSql ( $ sql ) ; }
3917	protected function sortByRandom ( ) { $ arrFiles = $ this -> foundFiles ; $ arrSource = $ this -> outputBuffer ; if ( ! $ arrFiles ) { return array ( 'files' => array ( ) , 'source' => array ( ) ) ; } $ keys = array_keys ( $ arrFiles ) ; $ files = array ( ) ; shuffle ( $ keys ) ; foreach ( $ keys as $ key ) { $ files [ $ key ] = $ arrFiles [ $ key ] ; } return $ this -> remapSorting ( $ files , $ arrSource ) ; }
5622	protected function chompPath ( & $ url ) { if ( preg_match ( '/(.*?)(\?|#|$)(.*)/' , $ url , $ matches ) ) { $ url = $ matches [ 2 ] . $ matches [ 3 ] ; return ( $ matches [ 1 ] ? $ matches [ 1 ] : '' ) ; } return '' ; }
6225	public function cd ( array $ path ) : void { array_unshift ( $ path , $ this -> path ) ; $ this -> path = new Path ( $ path ) ; }
5179	private function addNew ( string $ key , $ value ) : self { $ this -> props [ $ key ] = $ value ; return $ this ; }
1	public function buildDependencyInfo ( $ depArray ) { if ( ! is_array ( $ depArray ) ) { return new DependencyInfo ( array ( ) , array ( ) ) ; } if ( ! $ this -> isHash ( $ depArray ) ) { return new DependencyInfo ( $ this -> buildDependency10Info ( $ depArray ) , array ( ) ) ; } return $ this -> buildDependency20Info ( $ depArray ) ; }
6312	public function getTables ( $ schemaName = null ) { $ getTablesCommand = $ this -> container -> get ( 'rentgen.get_tables' ) ; if ( null !== $ schemaName ) { $ getTablesCommand -> setSchemaName ( $ schemaName ) ; } return $ getTablesCommand -> execute ( ) ; }
4366	protected function backtraceStr ( Event $ error ) { $ backtrace = $ error [ 'backtrace' ] ? $ error [ 'backtrace' ] : $ error -> getSubject ( ) -> backtrace ( ) ; if ( \ count ( $ backtrace ) < 2 ) { return '' ; } if ( $ backtrace && $ error [ 'vars' ] ) { $ backtrace [ 0 ] [ 'vars' ] = $ error [ 'vars' ] ; } if ( $ this -> cfg [ 'emailBacktraceDumper' ] ) { $ str = \ call_user_func ( $ this -> cfg [ 'emailBacktraceDumper' ] , $ backtrace ) ; } else { $ search = array ( ")\n\n" , ) ; $ replace = array ( ")\n" , ) ; $ str = \ print_r ( $ backtrace , true ) ; $ str = \ preg_replace ( '#\bArray\n\(#' , 'array(' , $ str ) ; $ str = \ preg_replace ( '/\barray\s+\(\s+\)/s' , 'array()' , $ str ) ; $ str = \ str_replace ( $ search , $ replace , $ str ) ; $ str = \ substr ( $ str , 0 , - 1 ) ; } return $ str ; }
2583	protected function prepareForNextMessage ( $ messageName , $ messageOptions ) { if ( ! $ this -> isAuthenticated && $ messageName !== 'Security_Authenticate' ) { throw new InvalidSessionException ( 'No active session' ) ; } $ this -> getSoapClient ( $ messageName ) -> __setSoapHeaders ( null ) ; if ( $ this -> isAuthenticated === true && is_int ( $ this -> sessionData [ 'sequenceNumber' ] ) ) { $ this -> sessionData [ 'sequenceNumber' ] ++ ; $ session = new Client \ Struct \ HeaderV2 \ Session ( $ this -> sessionData [ 'sessionId' ] , $ this -> sessionData [ 'sequenceNumber' ] , $ this -> sessionData [ 'securityToken' ] ) ; $ this -> getSoapClient ( $ messageName ) -> __setSoapHeaders ( new \ SoapHeader ( self :: CORE_WS_V2_SESSION_NS , self :: NODENAME_SESSION , $ session ) ) ; } }
4389	public function repay ( \ Aimeos \ MShop \ Order \ Item \ Iface $ order ) { $ base = $ this -> getOrderBase ( $ order -> getBaseId ( ) ) ; if ( ( $ cfg = $ this -> getCustomerData ( $ base -> getCustomerId ( ) , 'repay' ) ) === null ) { $ msg = sprintf ( 'No reoccurring payment data available for customer ID "%1$s"' , $ base -> getCustomerId ( ) ) ; throw new \ Aimeos \ MShop \ Service \ Exception ( $ msg ) ; } if ( ! isset ( $ cfg [ 'token' ] ) ) { $ msg = sprintf ( 'No payment token available for customer ID "%1$s"' , $ base -> getCustomerId ( ) ) ; throw new \ Aimeos \ MShop \ Service \ Exception ( $ msg ) ; } $ data = array ( 'transactionId' => $ order -> getId ( ) , 'currency' => $ base -> getPrice ( ) -> getCurrencyId ( ) , 'amount' => $ this -> getAmount ( $ base -> getPrice ( ) ) , 'cardReference' => $ cfg [ 'token' ] , 'paymentPage' => false , ) ; if ( isset ( $ cfg [ 'month' ] ) && isset ( $ cfg [ 'year' ] ) ) { $ data [ 'card' ] = new \ Omnipay \ Common \ CreditCard ( [ 'expiryMonth' => $ cfg [ 'month' ] , 'expiryYear' => $ cfg [ 'year' ] , ] ) ; } $ response = $ this -> getXmlProvider ( ) -> purchase ( $ data ) -> send ( ) ; if ( $ response -> isSuccessful ( ) ) { $ this -> saveTransationRef ( $ base , $ response -> getTransactionReference ( ) ) ; $ order -> setPaymentStatus ( \ Aimeos \ MShop \ Order \ Item \ Base :: PAY_RECEIVED ) ; $ this -> saveOrder ( $ order ) ; } else { $ msg = ( method_exists ( $ response , 'getMessage' ) ? $ response -> getMessage ( ) : '' ) ; throw new \ Aimeos \ MShop \ Service \ Exception ( sprintf ( 'Token based payment failed: %1$s' , $ msg ) ) ; } }
6423	public function isConfigured ( ) { if ( empty ( $ this -> options [ 'application_name' ] ) || empty ( $ this -> options [ 'client_id' ] ) || empty ( $ this -> options [ 'client_secret' ] ) ) { return false ; } return true ; }
12847	private function _loadController ( $ oControllerName , string $ sActionName , array $ aParams = array ( ) ) { $ aPhpDoc = PhpDoc :: getPhpDocOfMethod ( $ oControllerName , $ sActionName ) ; if ( isset ( $ aPhpDoc [ 'Cache' ] ) ) { if ( ! isset ( $ aPhpDoc [ 'Cache' ] [ 'maxage' ] ) ) { $ aPhpDoc [ 'Cache' ] [ 'maxage' ] = 0 ; } $ oMobileDetect = new \ Mobile_Detect ; if ( $ oMobileDetect -> isMobile ( ) ) { $ sCacheExt = '.mobi' ; } else { $ sCacheExt = '' ; } $ mCacheReturn = Cache :: get ( $ sActionName . $ sCacheExt , $ aPhpDoc [ 'Cache' ] [ 'maxage' ] ) ; if ( $ mCacheReturn !== false ) { return $ mCacheReturn ; } } if ( isset ( $ aPhpDoc [ 'Secure' ] ) ) { if ( isset ( $ aPhpDoc [ 'Secure' ] [ 'roles' ] ) && $ this -> _oSecurity -> getUserRole ( ) != $ aPhpDoc [ 'Secure' ] [ 'roles' ] ) { $ this -> _getPage403 ( ) ; } } $ oController = new $ oControllerName ; ob_start ( ) ; if ( ! defined ( 'PORTAL' ) ) { define ( 'PORTAL' , 'Batch' ) ; } if ( method_exists ( $ oController , 'beforeExecuteRoute' ) ) { call_user_func_array ( array ( $ oController , 'beforeExecuteRoute' ) , array ( ) ) ; } $ mReturnController = call_user_func_array ( array ( $ oController , $ sActionName ) , $ aParams ) ; if ( method_exists ( $ oController , 'afterExecuteRoute' ) ) { call_user_func_array ( array ( $ oController , 'afterExecuteRoute' ) , array ( ) ) ; } $ mReturn = ob_get_clean ( ) ; if ( $ mReturn == '' ) { $ mReturn = $ mReturnController ; } if ( isset ( $ aPhpDoc [ 'Cache' ] ) ) { $ oMobileDetect = new \ Mobile_Detect ; if ( $ oMobileDetect -> isMobile ( ) ) { $ sCacheExt = '.mobi' ; } else { $ sCacheExt = '' ; } if ( defined ( 'COMPRESS_HTML' ) && COMPRESS_HTML ) { $ mReturn = str_replace ( array ( "\t" , "\r" , " " ) , array ( "" , "" , "" , " " ) , $ mReturn ) ; } Cache :: set ( $ sActionName . $ sCacheExt , $ mReturn , $ aPhpDoc [ 'Cache' ] [ 'maxage' ] ) ; } return $ mReturn ; }
5323	public function registerHandler ( $ signal , $ handler ) { if ( ! is_callable ( $ handler ) ) { throw new \ InvalidArgumentException ( 'The handler is not callable' ) ; } if ( ! isset ( $ this -> handlers [ $ signal ] ) ) { $ this -> handlers [ $ signal ] = [ ] ; if ( ! pcntl_signal ( $ signal , [ $ this , 'handleSignal' ] ) ) { throw new \ RuntimeException ( sprintf ( 'Could not register signal %d with pcntl_signal' , $ signal ) ) ; } ; } ; $ this -> handlers [ $ signal ] [ ] = $ handler ; return $ this ; }
11337	public function getMigrationClassName ( ) { $ postfix = '_initial_' . $ this -> tableName ; if ( is_dir ( $ this -> migrationDirectory ) ) { $ searchExisting = FileHelper :: findFiles ( $ this -> migrationDirectory , [ 'only' => [ $ postfix . '.php' ] ] ) ; if ( ! empty ( $ searchExisting ) ) { return strstr ( basename ( $ searchExisting [ 0 ] ) , '.php' , true ) ; } } return 'm' . gmdate ( 'ymd_His' , $ this -> migrationTimestamp ) . $ postfix ; }
11058	protected function _getDataStore ( ) { return $ this -> dataStore === null ? $ this -> dataStore = $ this -> _createDataStore ( ) : $ this -> dataStore ; }
4169	public function tokenizePackageInfo ( ) { $ info = explode ( ':' , $ this -> argument ( 'package' ) ) ; return [ 'name' => $ info [ 0 ] , 'version' => ( count ( $ info ) > 1 ) ? last ( $ info ) : null , ] ; }
1781	public static function isInsecurePath ( $ strPath ) { $ strPath = strtr ( $ strPath , '\\' , '/' ) ; $ strPath = preg_replace ( '#//+#' , '/' , $ strPath ) ; if ( $ strPath == '..' ) { return true ; } if ( substr ( $ strPath , 0 , 2 ) == './' ) { return true ; } if ( substr ( $ strPath , 0 , 3 ) == '../' ) { return true ; } if ( substr ( $ strPath , - 2 ) == '/.' ) { return true ; } if ( substr ( $ strPath , - 3 ) == '/..' ) { return true ; } if ( strpos ( $ strPath , '/../' ) !== false ) { return true ; } return false ; }
3586	protected function unbindNumerics ( ArgumentBag $ args ) { if ( ( $ value = $ args -> get ( 'value' ) ) && ( is_int ( $ value ) || is_float ( $ value ) ) ) { $ args -> set ( 'value' , $ this -> raw ( $ value ) ) ; } elseif ( $ values = $ args -> get ( 'values' ) ) { foreach ( $ values as $ key => $ value ) { if ( is_int ( $ value ) || is_float ( $ value ) ) { $ values [ $ key ] = $ this -> raw ( $ value ) ; } } $ args -> set ( 'values' , $ values ) ; } }
6286	public static function hash ( $ s ) { $ h = 5381 ; $ len = strlen ( $ s ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ h5 = ( $ h << 5 ) & 0xffffffff ; $ sum = ( $ h & 0x3fffffff ) + ( $ h5 & 0x3fffffff ) ; $ h = ( ( $ sum & 0x40000000 ? 1 : 0 ) + ( $ h & 0x80000000 ? 2 : 0 ) + ( $ h & 0x40000000 ? 1 : 0 ) + ( $ h5 & 0x80000000 ? 2 : 0 ) + ( $ h5 & 0x40000000 ? 1 : 0 ) ) << 30 | ( $ sum & 0x3fffffff ) ; $ h ^= ord ( $ s [ $ i ] ) ; $ h &= 0xffffffff ; } return $ h ; }
7245	private function buildSaleItemRemaining ( Common \ SaleItemInterface $ saleItem , Shipment \ RemainingList $ list , array $ shipments ) { if ( ! ( $ saleItem -> isCompound ( ) && ! $ saleItem -> hasPrivateChildren ( ) ) ) { $ quantity = $ saleItem -> getTotalQuantity ( ) ; foreach ( $ shipments as $ shipment ) { foreach ( $ shipment -> getItems ( ) as $ item ) { if ( $ item -> getSaleItem ( ) === $ saleItem ) { $ quantity += $ shipment -> isReturn ( ) ? $ item -> getQuantity ( ) : - $ item -> getQuantity ( ) ; continue 2 ; } } } if ( 0 < $ quantity ) { $ entry = new Shipment \ RemainingEntry ( ) ; $ entry -> setSaleItem ( $ saleItem ) -> setQuantity ( $ quantity ) ; $ list -> addEntry ( $ entry ) ; } } foreach ( $ saleItem -> getChildren ( ) as $ child ) { $ this -> buildSaleItemRemaining ( $ child , $ list , $ shipments ) ; } }
12436	public function addExtra ( $ id , IFormField $ formField ) { $ formField -> setId ( $ id ) ; return $ this -> addFormField ( $ formField , true ) ; }
1349	public function any ( string ... $ resourceTypes ) : self { foreach ( $ resourceTypes as $ resourceType ) { $ this -> allow ( $ resourceType , null ) ; } return $ this ; }
10923	public function render ( ) { $ output = [ ] ; if ( count ( $ this -> rows ) > 0 ) { $ output [ ] = $ this -> renderLine ( ) ; } if ( count ( $ this -> columns ) > 0 ) { $ line = [ ] ; $ line [ ] = $ this -> charVertical ; $ columnNumber = 0 ; foreach ( $ this -> columns as $ index => $ column ) { $ title = $ column ; if ( isset ( $ this -> headers [ $ index ] ) ) { $ title = $ this -> headers [ $ index ] ; } $ line [ ] = $ this -> renderCell ( $ columnNumber , $ title , ' ' , 'info' ) ; $ line [ ] = $ this -> charVertical ; $ columnNumber ++ ; } $ output [ ] = implode ( '' , $ line ) ; } if ( count ( $ this -> rows ) > 0 ) { $ output [ ] = $ this -> renderLine ( ) ; foreach ( $ this -> rows as $ row ) { $ output [ ] = $ this -> renderRow ( $ row ) ; } $ output [ ] = $ this -> renderLine ( ) ; } return implode ( "\n" , $ output ) ; }
2835	public function completeRendering ( Mage_Core_Block_Abstract $ block ) { $ this -> isRendering = false ; $ this -> renderedCompletedAt = microtime ( true ) ; $ this -> renderedDuration += ( $ this -> renderedCompletedAt * 1000 - $ this -> renderedAt * 1000 ) ; $ this -> templateFile = $ block instanceof Mage_Core_Block_Template ? $ block -> getTemplateFile ( ) : '' ; self :: $ endRenderingTime = $ this -> renderedCompletedAt ; }
4613	public function withScalarValue ( $ value ) { $ this -> match = $ value ; $ this -> lowerBound = null ; $ this -> upperBound = null ; return $ this ; }
7117	protected function getFindBySubjectQuery ( ) { if ( null !== $ this -> findBySubjectQuery ) { return $ this -> findBySubjectQuery ; } $ qb = $ this -> createFindBySubjectQueryBuilder ( ) ; return $ this -> findBySubjectQuery = $ qb -> getQuery ( ) ; }
11866	public function lock ( string $ sessionIdentifier ) : bool { if ( in_array ( $ sessionIdentifier , self :: $ lockedIdentifiers ) ) { return true ; } self :: $ lockedIdentifiers [ ] = $ sessionIdentifier ; return true ; }
8021	public function payload ( array $ payload ) { $ client = new GuzzleClient ( [ 'base_uri' => $ this -> server ] ) ; $ client -> request ( 'POST' , $ this -> getUri ( ) , [ 'form_params' => [ 'payload' => json_encode ( $ payload ) ] ] ) ; }
3022	public function getBlogLikes ( $ blogName , $ options = null ) { $ path = $ this -> blogPath ( $ blogName , '/likes' ) ; return $ this -> getRequest ( $ path , $ options , true ) ; }
10584	public static function createDir ( string $ prefix = "tmp" , int $ mode = 0777 , int $ maxAttempts = 10 ) : entity \ DirEntity { $ tmpdir = static :: getDir ( ) ; $ prefix = \ sndsgd \ Fs :: sanitizeName ( $ prefix ) ; $ attempts = 0 ; do { $ attempts ++ ; if ( $ attempts > $ maxAttempts ) { throw new \ RuntimeException ( "failed to create temp directory; " . "reached max number ($maxAttempts) of attempts" ) ; } $ rand = \ sndsgd \ Str :: random ( 10 ) ; $ path = "$tmpdir/$prefix-$rand" ; } while ( @ mkdir ( $ path , $ mode ) === false ) ; $ dir = new entity \ DirEntity ( $ path ) ; static :: registerEntity ( $ dir ) ; return $ dir ; }
6227	public function removeOnFree ( bool $ activate = true ) : self { $ this -> storage -> removeOnFree ( $ activate ) ; return $ this ; }
3126	protected function isStartPoint ( TimePoint $ point ) { return $ point -> match ( null , TimePoint :: TARGET_ALL , TimePoint :: TYPE_START ) ; }
5159	private static function createGallery ( String $ body , int $ order , String $ photo , String $ source , string $ lead ) : \ One \ Model \ Gallery { return new Gallery ( $ body , $ order , $ photo , $ source , $ lead ) ; }
8238	protected function outputModulesConfiguration ( ParameterBag $ post ) { $ modulesClasses = array ( ) ; $ modulesNames = array ( ) ; foreach ( $ this -> modules as $ key => $ value ) { if ( $ post -> has ( $ key ) ) { $ modulesClasses [ ] = $ value ; $ modulesNames [ ] = $ key ; } } $ config = array ( self :: CONFIG_PLUGIN_KEY => array ( self :: CONFIG_MODULES_KEY => $ modulesClasses ) ) ; $ yaml = \ Symfony \ Component \ Yaml \ Yaml :: dump ( $ config , 2 , 4 ) ; $ this -> picoAuth -> addOutput ( "installer_modules_config" , $ yaml ) ; $ this -> picoAuth -> addOutput ( "installer_modules_names" , $ modulesNames ) ; }
488	public static function getInstances ( $ model , $ attribute ) { $ name = Html :: getInputName ( $ model , $ attribute ) ; return static :: getInstancesByName ( $ name ) ; }
10712	public function create ( array $ attributes = [ ] ) { $ model = $ this -> newModel ( ) ; $ model -> fill ( $ attributes ) ; $ this -> save ( $ model ) ; return $ model ; }
6831	protected function synchronizeWithProduct ( SupplierOrderItemInterface $ item ) { $ changed = false ; if ( null !== $ product = $ item -> getProduct ( ) ) { $ productSID = $ product -> getSubjectIdentity ( ) ; if ( $ productSID -> hasIdentity ( ) ) { $ itemSID = $ item -> getSubjectIdentity ( ) ; if ( $ itemSID -> hasIdentity ( ) ) { if ( ! $ itemSID -> equals ( $ productSID ) ) { throw new LogicException ( 'Breaking synchronization between supplier order item and supplier product is not supported.' ) ; } $ changed = false ; } else { $ itemSID -> copy ( $ productSID ) ; $ changed = true ; } } else { throw new InvalidArgumentException ( 'Supplier product subject identity is not set.' ) ; } if ( 0 == strlen ( $ item -> getDesignation ( ) ) ) { $ item -> setDesignation ( $ product -> getDesignation ( ) ) ; } if ( 0 == strlen ( $ item -> getReference ( ) ) ) { $ item -> setReference ( $ product -> getReference ( ) ) ; } if ( 0 == $ item -> getNetPrice ( ) ) { $ item -> setNetPrice ( $ product -> getNetPrice ( ) ) ; } } elseif ( $ item -> hasSubjectIdentity ( ) ) { throw new LogicException ( 'Breaking synchronization between supplier order item and supplier product is not supported.' ) ; } return $ changed ; }
3409	public function setLockPath ( string $ path ) : Application { if ( ! is_dir ( $ path ) ) { ( new Filesystem ( ) ) -> mkdir ( $ path ) ; } if ( ! $ realpath = realpath ( $ path ) ) { throw new \ InvalidArgumentException ( "The directory (" . $ path . ") is unavailable" ) ; } $ this -> lockPath = $ realpath ; return $ this ; }
6094	public function isUtf8 ( ) { $ pattern = array ( ) ; $ pattern [ ] = "[\xC2-\xDF][\x80-\xBF]" ; $ pattern [ ] = "\xE0[\xA0-\xBF][\x80-\xBF]" ; $ pattern [ ] = "[\xE1-\xEC\xEE\xEF][\x80-\xBF]{2}" ; $ pattern [ ] = "\xED[\x80-\x9F][\x80-\xBF]" ; $ pattern [ ] = "\xF0[\x90-\xBF][\x80-\xBF]{2}" ; $ pattern [ ] = "[\xF1-\xF3][\x80-\xBF]{3}" ; $ pattern [ ] = "\xF4[\x80-\x8F][\x80-\xBF]{2}" ; return preg_match ( "%(?:" . implode ( "|" , $ pattern ) . ")+%xs" , $ this -> string ) ; }
9621	protected function qsencode ( array $ data = array ( ) ) { $ req = '' ; if ( $ data ) { foreach ( $ data as $ key => $ value ) { $ req .= $ key . '=' . urlencode ( stripslashes ( $ value ) ) . '&' ; } $ req = substr ( $ req , 0 , strlen ( $ req ) - 1 ) ; } return $ req ; }
9432	protected static function random ( $ float_min , $ float_max ) { if ( $ float_max >= 0 ) { $ r = new Random ( ) ; while ( true ) { $ float_prov = $ float_max * $ r -> get ( ) ; if ( $ float_prov >= $ float_min ) { return $ float_prov ; } } } else { $ r = new Random ( ) ; while ( true ) { $ float_prov = $ float_min * $ r -> get ( ) ; if ( $ float_prov <= $ float_max ) { return $ float_prov ; } } } }
5696	protected function getFormActionFromRequest ( HTTPRequest $ r ) { $ action = $ r -> requestVar ( 'action' ) ; $ formAction = $ this -> record -> findActionByName ( $ action ) ; if ( ! $ formAction instanceof BetterButtonNestedForm ) { throw new Exception ( "Action $action doesn't exist or is not a BetterButtonNestedForm" ) ; } return $ formAction ; }
6171	protected function onAddFailure ( $ e ) { $ this -> writeProgressWithColor ( 'fg-red,bold' , 'F' ) ; $ this -> failure = $ e ; $ this -> lastTestFailed = true ; $ this -> flawless = false ; }
3825	protected function compile ( ) { $ objItemRenderer = new ItemList ( ) ; $ this -> Template -> searchable = ! $ this -> metamodel_donotindex ; $ sorting = $ this -> metamodel_sortby ; $ direction = $ this -> metamodel_sortby_direction ; if ( $ this -> metamodel_sort_override ) { if ( \ Input :: get ( 'orderBy' ) ) { $ sorting = \ Input :: get ( 'orderBy' ) ; } if ( \ Input :: get ( 'orderDir' ) ) { $ direction = \ Input :: get ( 'orderDir' ) ; } } $ objItemRenderer -> setServiceContainerFallback ( function ( ) { return $ this -> getServiceContainer ( ) ; } ) -> setFactory ( System :: getContainer ( ) -> get ( 'metamodels.factory' ) ) -> setFilterFactory ( System :: getContainer ( ) -> get ( 'metamodels.filter_setting_factory' ) ) -> setRenderSettingFactory ( System :: getContainer ( ) -> get ( 'metamodels.render_setting_factory' ) ) -> setEventDispatcher ( System :: getContainer ( ) -> get ( 'event_dispatcher' ) ) -> setMetaModel ( $ this -> metamodel , $ this -> metamodel_rendersettings ) -> setLimit ( $ this -> metamodel_use_limit , $ this -> metamodel_offset , $ this -> metamodel_limit ) -> setPageBreak ( $ this -> perPage ) -> setSorting ( $ sorting , $ direction ) -> setFilterSettings ( $ this -> metamodel_filtering ) -> setFilterParameters ( StringUtil :: deserialize ( $ this -> metamodel_filterparams , true ) , $ this -> getFilterParameters ( $ objItemRenderer ) ) -> setMetaTags ( $ this -> metamodel_meta_title , $ this -> metamodel_meta_description ) ; $ this -> Template -> items = \ StringUtil :: encodeEmail ( $ objItemRenderer -> render ( $ this -> metamodel_noparsing , $ this ) ) ; $ this -> Template -> numberOfItems = $ objItemRenderer -> getItems ( ) -> getCount ( ) ; $ this -> Template -> pagination = $ objItemRenderer -> getPagination ( ) ; }
6346	public static function concat ( Iterator $ a , Iterator $ b ) : Iterator { return self :: concatIterators ( new ArrayIterator ( [ $ a , $ b ] ) ) ; }
339	public function registerClientScript ( ) { $ id = $ this -> options [ 'id' ] ; $ options = Json :: htmlEncode ( $ this -> getClientOptions ( ) ) ; $ attributes = Json :: htmlEncode ( $ this -> attributes ) ; $ view = $ this -> getView ( ) ; ActiveFormAsset :: register ( $ view ) ; $ view -> registerJs ( "jQuery('#$id').yiiActiveForm($attributes, $options);" ) ; }
12905	public function index ( FilterRequest $ request ) { $ limit = $ request -> request -> get ( 'limit' , 15 ) ; $ limit = ( $ limit > 49 ) ? 50 : $ limit ; $ filter = $ this -> repository -> filter ( $ request ) ; if ( $ this -> list || $ request -> request -> get ( 'search_type' ) == 'list' ) { $ resources = $ filter -> get ( 1000 ) ; } else { $ resources = $ filter -> paginate ( $ limit ) ; } if ( $ resources -> count ( ) < 1 ) { } return $ this -> success ( $ resources ) ; }
11784	public function update ( $ pageId , $ title , $ description , $ pageUrl , $ iconUrl , $ comment = '' ) { $ params = [ 'page_id' => intval ( $ pageId ) , 'title' => $ title , 'description' => $ description , 'page_url' => $ pageUrl , 'icon_url' => $ iconUrl , ] ; if ( $ comment !== '' ) { $ params [ 'comment' ] = $ comment ; } return $ this -> parseJSON ( 'json' , [ self :: API_UPDATE , $ params ] ) ; }
12262	public function getCustomField ( $ class , $ slug = null ) { if ( ! $ slug ) { throw CustomFieldsHelperException :: slugIsMissing ( ) ; } $ resolveClass = ( is_string ( $ class ) ) ? $ class : get_class ( $ class ) ; if ( ! $ this -> cache [ $ resolveClass ] [ $ slug ] ) { $ this -> _cacheCustomFields ( $ resolveClass ) ; } return $ this -> cache [ $ resolveClass ] [ $ slug ] ; }
3843	private function parsePanelSearch ( PanelRowInterface $ row ) { if ( $ row -> hasElement ( 'search' ) ) { $ element = $ row -> getElement ( 'search' ) ; } else { $ element = new DefaultSearchElementInformation ( ) ; } if ( ! $ element instanceof SearchElementInformationInterface ) { throw new \ InvalidArgumentException ( 'Search element does not implement the correct interface.' ) ; } foreach ( $ this -> inputScreen [ 'properties' ] as $ value ) { if ( ! empty ( $ value [ 'search' ] ) ) { $ element -> addProperty ( $ value [ 'col_name' ] ) ; } } if ( $ element -> getPropertyNames ( ) && ! $ row -> hasElement ( 'search' ) ) { $ row -> addElement ( $ element ) ; } }
1139	public function shiftSiblingsForRestore ( ) { if ( is_null ( $ this -> getRight ( ) ) || is_null ( $ this -> getLeft ( ) ) ) return ; $ self = $ this ; $ this -> getConnection ( ) -> transaction ( function ( ) use ( $ self ) { $ lftCol = $ self -> getLeftColumnName ( ) ; $ rgtCol = $ self -> getRightColumnName ( ) ; $ lft = $ self -> getLeft ( ) ; $ rgt = $ self -> getRight ( ) ; $ diff = $ rgt - $ lft + 1 ; $ self -> newNestedSetQuery ( ) -> where ( $ lftCol , '>=' , $ lft ) -> increment ( $ lftCol , $ diff ) ; $ self -> newNestedSetQuery ( ) -> where ( $ rgtCol , '>=' , $ lft ) -> increment ( $ rgtCol , $ diff ) ; } ) ; }
11358	public function removeBlock ( $ blockFile ) { foreach ( $ this -> permalinks as $ permalink => $ associatedBlocks ) { $ tmp = array_flip ( $ associatedBlocks ) ; unset ( $ tmp [ $ blockFile ] ) ; if ( empty ( $ tmp ) ) { unset ( $ this -> permalinks [ $ permalink ] ) ; continue ; } $ this -> permalinks [ $ permalink ] = array_flip ( $ tmp ) ; } return $ this ; }
8866	private function runTask ( TaskInterface $ task , PayloadInterface $ payload ) { $ this -> logTask ( $ task , LogLevel :: INFO , 'Starting execution.' ) ; try { if ( ! $ task -> unless ( ) ) { $ this -> dispatch ( 'runner.task.unless' , $ task , $ payload ) ; $ this -> logTask ( $ task , LogLevel :: INFO , 'Skipping because unless() returned boolean false.' ) ; return ; } $ this -> dispatch ( 'runner.task.start' , $ task , $ payload ) ; $ task -> setUp ( ) ; $ exitCode = ( int ) $ task -> run ( $ payload ) ? : 0 ; $ task -> tearDown ( ) ; if ( $ task -> isFailOnError ( ) && $ exitCode !== 0 ) { throw new FailException ( sprintf ( 'Task: %s failed with exit code %s' , get_class ( $ task ) , $ exitCode ) ) ; } $ message = sprintf ( 'Task exited with status code %s' , $ exitCode ) ; if ( $ exitCode === 0 ) { $ this -> logTask ( $ task , LogLevel :: INFO , $ message ) ; } else { $ this -> logTask ( $ task , LogLevel :: WARNING , $ message ) ; } $ this -> dispatch ( 'runner.task.success' , $ task , $ payload , $ exitCode ) ; $ task -> markAsSuccessfullyExecuted ( ) ; } catch ( SkipException $ e ) { $ this -> logTask ( $ task , LogLevel :: INFO , 'Skipping.' ) ; $ this -> dispatch ( 'runner.task.skip' , $ task , $ payload ) ; } catch ( RetryException $ e ) { $ this -> logTask ( $ task , LogLevel :: NOTICE , 'Retry thrown. Starting again.' ) ; $ this -> dispatch ( 'runner.task.retry' , $ task , $ payload ) ; if ( ! $ task -> getMaxRetries ( ) ) { throw new LogicException ( 'A retry exception was thrown, but no retries instance was set.' ) ; } $ task -> getMaxRetries ( ) -> increase ( ) ; $ this -> runTask ( $ task , $ payload ) ; return ; } catch ( FailException $ e ) { $ this -> logTask ( $ task , LogLevel :: WARNING , sprintf ( 'Failure thrown. Given message: %s' , $ e -> getMessage ( ) ) ) ; $ exitCode = $ e -> getCode ( ) ; if ( is_int ( $ exitCode ) ) { $ this -> dispatch ( 'runner.task.failure' , $ task , $ payload , $ exitCode ) ; } else { $ this -> dispatch ( 'runner.task.failure' , $ task , $ payload ) ; } throw $ e ; } $ this -> logTask ( $ task , LogLevel :: INFO , 'Execution successful.' ) ; }
6195	protected function findControllerFiles ( ) { $ result = [ ] ; foreach ( $ this -> controllerDirs as $ dir ) { $ directoryIterator = new \ RecursiveDirectoryIterator ( $ dir ) ; $ iterator = new \ RecursiveIteratorIterator ( $ directoryIterator ) ; $ files = new \ RegexIterator ( $ iterator , '/\.php$/i' , \ RecursiveRegexIterator :: GET_MATCH ) ; foreach ( $ files as $ k => $ v ) { $ result [ $ k ] = filemtime ( $ k ) ; } } return $ result ; }
3154	public function getTraceVariable ( $ variableIdentifier , $ variableValue ) { if ( ! is_string ( $ variableValue ) && ! is_numeric ( $ variableValue ) ) { $ variableValue = json_encode ( $ variableValue ) ; } $ metaVariable = new \ taoResultServer_models_classes_TraceVariable ( ) ; $ metaVariable -> setIdentifier ( $ variableIdentifier ) ; $ metaVariable -> setBaseType ( 'string' ) ; $ metaVariable -> setCardinality ( Cardinality :: getNameByConstant ( Cardinality :: SINGLE ) ) ; $ metaVariable -> setTrace ( $ variableValue ) ; return $ metaVariable ; }
733	public function toArray ( array $ fields = [ ] , array $ expand = [ ] , $ recursive = true ) { $ data = [ ] ; foreach ( $ this -> resolveFields ( $ fields , $ expand ) as $ field => $ definition ) { $ attribute = is_string ( $ definition ) ? $ this -> $ definition : $ definition ( $ this , $ field ) ; if ( $ recursive ) { $ nestedFields = $ this -> extractFieldsFor ( $ fields , $ field ) ; $ nestedExpand = $ this -> extractFieldsFor ( $ expand , $ field ) ; if ( $ attribute instanceof Arrayable ) { $ attribute = $ attribute -> toArray ( $ nestedFields , $ nestedExpand ) ; } elseif ( is_array ( $ attribute ) ) { $ attribute = array_map ( function ( $ item ) use ( $ nestedFields , $ nestedExpand ) { if ( $ item instanceof Arrayable ) { return $ item -> toArray ( $ nestedFields , $ nestedExpand ) ; } return $ item ; } , $ attribute ) ; } } $ data [ $ field ] = $ attribute ; } if ( $ this instanceof Linkable ) { $ data [ '_links' ] = Link :: serialize ( $ this -> getLinks ( ) ) ; } return $ recursive ? ArrayHelper :: toArray ( $ data ) : $ data ; }
2920	public function deleteSetter ( $ key ) { $ pattern = "/^(export\h)?\h*{$key}=.*\n/m" ; $ this -> buffer = preg_replace ( $ pattern , null , $ this -> buffer ) ; return $ this ; }
2925	public function normaliseValue ( $ value , $ quote = '' ) { if ( strlen ( $ quote ) == 0 ) { return trim ( $ value ) ; } $ value = str_replace ( "\\$quote" , $ quote , $ value ) ; $ value = str_replace ( '\\\\' , '\\' , $ value ) ; return $ value ; }
8111	protected function queueNextRun ( ) { $ nextRun = new ContentReviewNotificationJob ( ) ; $ nextRunTime = mktime ( Config :: inst ( ) -> get ( __CLASS__ , 'next_run_hour' ) , Config :: inst ( ) -> get ( __CLASS__ , 'next_run_minute' ) , 0 , date ( "m" ) , date ( "d" ) + Config :: inst ( ) -> get ( __CLASS__ , 'next_run_in_days' ) , date ( "Y" ) ) ; singleton ( QueuedJobService :: class ) -> queueJob ( $ nextRun , date ( "Y-m-d H:i:s" , $ nextRunTime ) ) ; }
1240	private static function propertyToXml ( $ name , $ value ) { if ( is_subclass_of ( $ value , '\DTS\eBaySDK\Types\BaseType' , false ) ) { return $ value -> toXml ( $ name ) ; } else { return sprintf ( '<%s>%s</%s>' , $ name , self :: encodeValueXml ( $ value ) , $ name ) ; } }
6437	public function getLoginStartUrl ( $ redirecturl ) { $ connection = new TwitterOAuth ( $ this -> options [ 'consumer_key' ] , $ this -> options [ 'consumer_secret' ] ) ; $ connection -> setTimeouts ( 10 , 15 ) ; $ request_token = $ connection -> oauth ( 'oauth/request_token' , array ( 'oauth_callback' => $ redirecturl ) ) ; $ this -> request_token = array ( ) ; $ this -> request_token [ 'oauth_token' ] = $ request_token [ 'oauth_token' ] ; $ this -> request_token [ 'oauth_token_secret' ] = $ request_token [ 'oauth_token_secret' ] ; return $ connection -> url ( 'oauth/authorize' , array ( 'oauth_token' => $ request_token [ 'oauth_token' ] ) ) ; }
3324	public function advance ( ) { if ( $ this -> index >= $ this -> length ) { throw new LogicException ( "Argument index out of bounds." ) ; } return $ this -> argv [ $ this -> index ++ ] ; }
8957	public function redaction ( $ element , $ id , $ version , $ redactionId ) { if ( $ element != 'node' && $ element != 'way' && $ element != 'relation' ) { throw new \ DomainException ( 'Element should be a node, a way or a relation' ) ; } $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = $ element . '/' . $ id . '/' . $ version . '/redact?redaction=' . $ redactionId ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters ) ; return simplexml_load_string ( $ response -> body ) ; }
682	protected function validateOperatorCondition ( $ operator , $ condition , $ attribute = null ) { if ( $ attribute === null ) { $ this -> addError ( $ this -> filterAttributeName , $ this -> parseErrorMessage ( 'operatorRequireAttribute' , [ 'operator' => $ operator ] ) ) ; return ; } $ internalOperator = $ this -> filterControls [ $ operator ] ; $ operatorTypes = $ this -> operatorTypes [ $ internalOperator ] ; if ( $ operatorTypes !== '*' ) { $ attributeTypes = $ this -> getSearchAttributeTypes ( ) ; $ attributeType = $ attributeTypes [ $ attribute ] ; if ( ! in_array ( $ attributeType , $ operatorTypes , true ) ) { $ this -> addError ( $ this -> filterAttributeName , $ this -> parseErrorMessage ( 'unsupportedOperatorType' , [ 'attribute' => $ attribute , 'operator' => $ operator ] ) ) ; return ; } } if ( in_array ( $ internalOperator , $ this -> multiValueOperators , true ) ) { if ( ! is_array ( $ condition ) ) { $ this -> addError ( $ this -> filterAttributeName , $ this -> parseErrorMessage ( 'operatorRequireMultipleOperands' , [ 'operator' => $ operator ] ) ) ; } else { foreach ( $ condition as $ v ) { $ this -> validateAttributeValue ( $ attribute , $ v ) ; } } } else { $ this -> validateAttributeValue ( $ attribute , $ condition ) ; } }
2487	protected function search ( array $ parameters ) { $ queryString = $ this -> generateQueryString ( $ parameters ) ; $ response = $ this -> client -> request ( 'POST' , $ this -> endpointRegistry -> getEndpoint ( $ this -> endpointResolver -> getEntryEndpoint ( ) ) , '/select' , new Message ( [ 'Content-Type' => 'application/x-www-form-urlencoded' , ] , $ queryString ) ) ; $ result = json_decode ( $ response -> body ) ; if ( ! isset ( $ result -> response ) ) { throw new RuntimeException ( '->response not set: ' . var_export ( array ( $ result , $ parameters ) , true ) ) ; } return $ result ; }
946	public function handle ( Request $ request , Closure $ next ) { $ query = $ request -> query -> all ( ) ; $ signature = $ query [ 'signature' ] ; unset ( $ query [ 'signature' ] ) ; $ signatureLocal = ShopifyApp :: createHmac ( [ 'data' => $ query , 'buildQuery' => true ] ) ; if ( $ signature !== $ signatureLocal || ! isset ( $ query [ 'shop' ] ) ) { return Response :: make ( 'Invalid proxy signature.' , 401 ) ; } Session :: put ( 'shopify_domain' , ShopifyApp :: sanitizeShopDomain ( $ request -> get ( 'shop' ) ) ) ; return $ next ( $ request ) ; }
9761	function containOnlyInstancesOf ( string $ className ) : self { return $ this -> expect ( $ this -> target , containsOnlyInstancesOf ( $ className ) ) ; }
10193	public static function getQueryPreview ( QueryBuilder $ query = null ) { if ( empty ( $ query ) ) { return "" ; } $ sql = str_replace ( '?' , "'%s'" , $ query -> toSql ( ) ) ; $ bindings = $ query -> getBindings ( ) ; return vsprintf ( $ sql , $ bindings ) ; }
5401	public function isValidPath ( $ path ) { return ( strncmp ( $ this -> fixPath ( $ path ) , $ this -> getPath ( ) , strlen ( $ this -> getPath ( ) ) ) == 0 ) ; }
2544	protected function analyzeWithErrCodeCategoryMsgNodeName ( SendResult $ response , $ nodeErr , $ nodeCat , $ nodeMsg ) { $ analyzeResponse = new Result ( $ response ) ; $ domDoc = $ this -> loadDomDocument ( $ response -> responseXml ) ; $ errorCodeNode = $ domDoc -> getElementsByTagName ( $ nodeErr ) -> item ( 0 ) ; if ( ! is_null ( $ errorCodeNode ) ) { $ errorCatNode = $ domDoc -> getElementsByTagName ( $ nodeCat ) -> item ( 0 ) ; if ( $ errorCatNode instanceof \ DOMNode ) { $ analyzeResponse -> status = $ this -> makeStatusFromErrorQualifier ( $ errorCatNode -> nodeValue ) ; } else { $ analyzeResponse -> status = Result :: STATUS_ERROR ; } $ errorCode = $ errorCodeNode -> nodeValue ; $ errorTextNodeList = $ domDoc -> getElementsByTagName ( $ nodeMsg ) ; $ analyzeResponse -> messages [ ] = new Result \ NotOk ( $ errorCode , $ this -> makeMessageFromMessagesNodeList ( $ errorTextNodeList ) ) ; } return $ analyzeResponse ; }
2630	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ aclId = $ this -> getRequest ( ) -> getParam ( 'acl_id' ) ; $ value = $ this -> getRequest ( ) -> getParam ( 'item_value' ) ; $ comment = $ this -> getRequest ( ) -> getParam ( 'comment_value' ) ; $ negated = 0 ; if ( $ value [ 0 ] == '!' ) { $ negated = 1 ; $ value = ltrim ( $ value , '!' ) ; } $ ipParts = explode ( '/' , $ value ) ; $ subnet = false ; if ( ! empty ( $ ipParts [ 1 ] ) ) { if ( is_numeric ( $ ipParts [ 1 ] ) && ( int ) $ ipParts [ 1 ] < 129 ) { $ subnet = $ ipParts [ 1 ] ; } else { return $ result -> setData ( [ 'status' => false , 'msg' => 'Invalid IP subnet format.' ] ) ; } } if ( ! filter_var ( $ ipParts [ 0 ] , FILTER_VALIDATE_IP ) ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Invalid IP address format.' ] ) ; } $ createAclItem = $ this -> api -> upsertAclItem ( $ aclId , $ ipParts [ 0 ] , $ negated , $ comment , $ subnet ) ; if ( ! $ createAclItem ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to create Acl entry.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'id' => $ createAclItem -> id , 'comment' => $ createAclItem -> comment , 'created_at' => $ createAclItem -> created_at ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
3719	protected function wantToHandle ( AbstractEnvironmentAwareEvent $ event ) { if ( ! parent :: wantToHandle ( $ event ) ) { return false ; } if ( $ event -> getPropertyName ( ) !== 'type' ) { return false ; } $ request = $ this -> requestStack -> getCurrentRequest ( ) ; if ( $ request -> request -> get ( 'act' , null ) === 'select' && ! $ event -> getModel ( ) -> getId ( ) ) { return false ; } return true ; }
2204	public static function encodeSpecialChars ( $ varValue ) { if ( $ varValue === null || $ varValue == '' ) { return $ varValue ; } if ( \ is_array ( $ varValue ) ) { foreach ( $ varValue as $ k => $ v ) { $ varValue [ $ k ] = static :: encodeSpecialChars ( $ v ) ; } return $ varValue ; } $ arrSearch = array ( '#' , '<' , '>' , '(' , ')' , '\\' , '=' ) ; $ arrReplace = array ( '&#35;' , '&#60;' , '&#62;' , '&#40;' , '&#41;' , '&#92;' , '&#61;' ) ; return str_replace ( $ arrSearch , $ arrReplace , $ varValue ) ; }
8494	public function createFulfillmentOrder ( $ request ) { if ( ! ( $ request instanceof FBAOutboundServiceMWS_Model_CreateFulfillmentOrderRequest ) ) { $ request = new FBAOutboundServiceMWS_Model_CreateFulfillmentOrderRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'CreateFulfillmentOrder' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAOutboundServiceMWS_Model_CreateFulfillmentOrderResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
9270	public function load ( ContainerBuilder $ container ) { $ loader = $ this -> getContainerLoader ( $ container ) ; $ loader -> load ( $ this -> configFile ) ; }
7032	public function run ( $ prog = "migrate" ) { switch ( trim ( $ prog ) ) { case "migrate" : return $ this -> migrate ( ) ; case "drop" : return $ this -> drop ( ) ; case "reset" : return $ this -> drop ( ) & $ this -> migrate ( ) ; default : error_log ( "\n\e[1;31m!\e[0m program $prog not applicable\n" ) ; return false ; } }
6254	public function fetchShippingLabels ( $ trackingCodes ) { $ id = str_replace ( '.' , '' , microtime ( true ) ) ; $ xml = new \ SimpleXMLElement ( '<eChannel/>' ) ; $ routing = $ xml -> addChild ( 'ROUTING' ) ; $ routing -> addChild ( 'Routing.Account' , $ this -> api_key ) ; $ routing -> addChild ( 'Routing.Id' , $ id ) ; $ routing -> addChild ( 'Routing.Key' , md5 ( "{$this->api_key}{$id}{$this->secret}" ) ) ; $ label = $ xml -> addChild ( 'PrintLabel' ) ; $ label [ 'responseFormat' ] = 'File' ; foreach ( $ trackingCodes as $ trackingCode ) { $ label -> addChild ( 'TrackingCode' , $ trackingCode ) ; } $ response = $ this -> doPost ( '/prinetti/get-shipping-label' , null , $ xml -> asXML ( ) ) ; $ response_xml = @ simplexml_load_string ( $ response ) ; if ( ! $ response_xml ) { throw new \ Exception ( "Failed to load response xml" ) ; } $ this -> response = $ response_xml ; if ( $ response_xml -> { 'response.status' } != 0 ) { throw new \ Exception ( "Error: {$response_xml->{'response.status'}}, {$response_xml->{'response.message'}}" ) ; } return $ response_xml ; }
7286	public function getInvoices ( $ filter = null ) { if ( null === $ filter ) { return $ this -> invoices ; } return $ this -> invoices -> filter ( function ( InvoiceInterface $ invoice ) use ( $ filter ) { return $ filter xor InvoiceTypes :: isCredit ( $ invoice ) ; } ) ; }
1542	protected function query ( $ query ) { return new CursorBuilder ( $ query , $ this -> column , $ this -> identifier , $ this -> descending ) ; }
5875	public function containerAdd ( ServerRequestInterface $ request , ResponseInterface $ response ) : ResponseInterface { $ GLOBALS [ 'TCA' ] [ 'tx_imageautoresize' ] = include ( ExtensionManagementUtility :: extPath ( 'image_autoresize' ) . 'Configuration/TCA/Module/Options.php' ) ; $ GLOBALS [ 'TCA' ] [ 'tx_imageautoresize' ] [ 'ajax' ] = true ; $ dataProviders = & $ GLOBALS [ 'TYPO3_CONF_VARS' ] [ 'SYS' ] [ 'formEngine' ] [ 'formDataGroup' ] [ 'tcaDatabaseRecord' ] ; $ dataProviders [ \ Causal \ ImageAutoresize \ Backend \ Form \ FormDataProvider \ VirtualDatabaseEditRow :: class ] = [ 'before' => [ \ TYPO3 \ CMS \ Backend \ Form \ FormDataProvider \ DatabaseEditRow :: class , ] ] ; $ record = [ 'uid' => \ Causal \ ImageAutoresize \ Controller \ ConfigurationController :: virtualRecordId , 'pid' => 0 , ] ; \ Causal \ ImageAutoresize \ Backend \ Form \ FormDataProvider \ VirtualDatabaseEditRow :: initialize ( $ record ) ; $ response = parent :: containerAdd ( $ request , $ response ) ; return $ response -> withHeader ( 'Content-Type' , 'application/json; charset=utf-8' ) ; }
3551	public function parse ( InlineParserContext $ inlineContext ) { $ cursor = $ inlineContext -> getCursor ( ) ; $ previous = $ cursor -> peek ( - 1 ) ; if ( $ previous !== null && $ previous !== ' ' ) { return false ; } $ saved = $ cursor -> saveState ( ) ; $ cursor -> advance ( ) ; $ handle = $ cursor -> match ( '/^[a-z0-9\+\-_]+:/' ) ; if ( ! $ handle ) { $ cursor -> restoreState ( $ saved ) ; return false ; } $ next = $ cursor -> peek ( 0 ) ; if ( $ next !== null && $ next !== ' ' ) { $ cursor -> restoreState ( $ saved ) ; return false ; } $ key = substr ( $ handle , 0 , - 1 ) ; if ( $ this -> map === null ) { $ this -> map = $ this -> repo -> get ( ) ; } if ( ! array_key_exists ( $ key , $ this -> map ) ) { $ cursor -> restoreState ( $ saved ) ; return false ; } $ inline = new Image ( $ this -> map [ $ key ] , $ key ) ; $ inline -> data [ 'attributes' ] = [ 'class' => 'emoji' , 'data-emoji' => $ key ] ; $ inlineContext -> getContainer ( ) -> appendChild ( $ inline ) ; return true ; }
11280	public static function getErrorString ( int $ errno ) { $ errno = intval ( $ errno ) ; $ errors = array ( E_ERROR => 'E_ERROR' , E_WARNING => 'E_WARNING' , E_PARSE => 'E_PARSE' , E_NOTICE => 'E_NOTICE' , E_CORE_ERROR => 'E_CORE_ERROR' , E_CORE_WARNING => 'E_CORE_WARNING' , E_COMPILE_ERROR => 'E_COMPILE_ERROR' , E_COMPILE_WARNING => 'E_COMPILE_WARNING' , E_USER_ERROR => 'E_USER_ERROR' , E_USER_NOTICE => 'E_USER_NOTICE' , E_STRICT => 'E_STRICT' , E_RECOVERABLE_ERROR => 'E_RECOVERABLE_ERROR' , ) ; $ errors [ 8192 ] = 'E_DEPRECATED' ; $ errors [ 16384 ] = 'E_USER_DEPRECATED' ; $ errors_desc = array ( ) ; foreach ( $ errors as $ key => $ value ) { if ( ( $ errno & $ key ) != 0 ) { $ errors_desc [ ] = $ value ; } } return implode ( '|' , $ errors_desc ) ; }
11788	private function updateTv ( $ dwnl ) { $ entity = new EBonDwnl ( ) ; foreach ( $ dwnl as $ one ) { $ tv = $ one -> getTv ( ) ; $ calcId = $ one -> getCalculationRef ( ) ; $ custId = $ one -> getCustomerRef ( ) ; $ entity -> setTv ( $ tv ) ; $ id = [ EBonDwnl :: A_CALC_REF => $ calcId , EBonDwnl :: A_CUST_REF => $ custId ] ; $ this -> daoBonDwnl -> updateById ( $ id , $ entity ) ; } }
6553	public function unlock ( ) { try { if ( $ this -> pid === $ this -> getSerial ( ) && is_resource ( $ this -> fh ) ) { $ this -> removeLineFromFile ( $ this -> pid , $ this -> fh ) ; flock ( $ this -> fh , LOCK_UN ) ; fclose ( $ this -> fh ) ; if ( filesize ( $ filename = $ this -> getPidFilename ( ) ) === 0 ) { unlink ( $ filename ) ; } } } catch ( FileNotFoundException $ fnfe ) { $ this -> getSystemLogger ( ) -> notice ( sprintf ( 'PID file %s doesn\'t exist' , $ this -> getPidFilename ( ) ) ) ; } catch ( LineNotFoundException $ lnfe ) { $ this -> getSystemLogger ( ) -> notice ( sprintf ( 'PID %s is can not be found in PID file %s' , $ this -> pid , $ this -> getPidFilename ( ) ) ) ; } catch ( \ Exception $ e ) { throw new \ Exception ( sprintf ( 'Can\'t remove PID %s from PID file %s' , $ this -> pid , $ this -> getPidFilename ( ) ) , null , $ e ) ; } }
7753	public function serialize ( $ data , $ format , array $ context = array ( ) ) { if ( 'jsonld' !== $ format ) { throw new UnexpectedValueException ( 'Serialization for the format ' . $ format . ' is not supported' ) ; } if ( false === is_object ( $ data ) ) { throw new \ Exception ( 'Only objects can be serialized' ) ; } return JsonLD :: toString ( $ this -> doSerialize ( $ data , true ) , true ) ; }
8049	public function createCalendarEvent ( array $ data ) { $ eventData = $ this -> calendarEventsEngine -> buildEventData ( $ data ) ; $ eventDates = $ this -> calendarEventsEngine -> buildEventDates ( $ data ) ; $ cache = $ this -> cache ; $ calendarEvent = $ this -> calendarEvent -> create ( $ eventData ) ; $ this -> handleEventLocation ( $ data , $ calendarEvent ) ; foreach ( $ eventDates as $ date ) { $ calendarEventRepeatDate = clone $ this -> calendarEventRepeatDate ; $ calendarEventRepeatDate -> start = $ date [ 'start' ] ; $ calendarEventRepeatDate -> end = $ date [ 'end' ] ; $ calendarEventRepeatDate -> calendarEvent ( ) -> associate ( $ calendarEvent ) ; $ calendarEventRepeatDate -> save ( ) ; unset ( $ calendarEventRepeatDate ) ; } $ cache :: put ( self :: CACHE_KEY . $ calendarEvent -> id , $ calendarEvent , $ this -> cacheTimeToLive ) ; $ allEvents = $ this -> getAllEvents ( ) ; $ allEvents [ $ calendarEvent -> id ] = $ calendarEvent ; $ cache :: put ( self :: ALL_EVENTS_KEY , $ allEvents , $ this -> cacheTimeToLive ) ; return true ; }
5493	public function add ( $ parameters , $ action ) { $ place = count ( $ this -> map ) ; $ this -> map [ $ place ] = array ( ) ; $ this -> map [ $ place ] [ 'params' ] = new ParametersExpectation ( $ parameters ) ; $ this -> map [ $ place ] [ 'content' ] = $ action ; }
9503	public function joinCommand ( array $ parts ) { $ command = 'php ' . implode ( ' ' , $ parts ) ; $ stripped = str_replace ( '--watch' , '' , $ command ) ; return trim ( $ stripped ) ; }
2679	public function queryHistoricStats ( array $ parameters ) { $ uri = $ this -> _getHistoricalEndpoint ( ) . '?region=' . $ parameters [ 'region' ] . '&from=' . $ parameters [ 'from' ] . '&to=' . $ parameters [ 'to' ] . '&by=' . $ parameters [ 'sample_rate' ] ; $ result = $ this -> _fetch ( $ uri ) ; return $ result ; }
12842	static public function removeFiles ( $ directory ) { $ scan = glob ( rtrim ( $ directory , '/' ) . '/*' ) ; foreach ( $ scan as $ file ) { if ( is_file ( $ file ) ) { unlink ( $ file ) ; } } return true ; }
12387	private static function showErrors ( ) { if ( count ( static :: $ errors ) > 0 ) { $ errorsList = '' ; foreach ( static :: $ errors as $ error ) { $ errorsList .= 'Tipo: ' . $ error [ 'type' ] . '<br>' ; $ errorsList .= 'Mensaje: ' . $ error [ 'message' ] . '<br>' ; $ errorsList .= 'Archivo: ' . $ error [ 'file' ] . '<br>' ; $ errorsList .= 'Line: ' . $ error [ 'line' ] . '<br><br>' ; } static :: viewException ( 1 , $ errorsList ) ; } }
2598	public function moveNext ( ) { $ this -> peek = 0 ; $ this -> token = $ this -> lookahead ; $ this -> lookahead = ( isset ( $ this -> tokens [ $ this -> position ] ) ) ? $ this -> tokens [ $ this -> position ++ ] : null ; return $ this -> lookahead !== null ; }
9410	protected function collect ( ) { $ collector = new RouteCollector ; foreach ( $ this -> router -> routes ( ) as $ route ) { $ collector -> addRoute ( $ route [ 0 ] , $ route [ 1 ] , $ route [ 2 ] ) ; } return $ collector -> getData ( ) ; }
6987	protected function fillFromCustomer ( ContextInterface $ context , CustomerInterface $ customer ) : void { if ( null === $ context -> getCustomerGroup ( ) ) { $ context -> setCustomerGroup ( $ customer -> getCustomerGroup ( ) ) ; } if ( null === $ context -> getInvoiceCountry ( ) ) { if ( null !== $ address = $ customer -> getDefaultInvoiceAddress ( true ) ) { $ context -> setInvoiceCountry ( $ address -> getCountry ( ) ) ; } } if ( null === $ context -> getDeliveryCountry ( ) ) { if ( null !== $ address = $ customer -> getDefaultDeliveryAddress ( true ) ) { $ context -> setDeliveryCountry ( $ address -> getCountry ( ) ) ; } } }
6088	public function createMoodboard ( Moodboard $ moodboard ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'moodboard' => $ moodboard ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/moodboards' , $ parameters ) ; $ result = new MoodboardResponse ( $ result ) ; return $ result ; }
2476	private function logWarning ( OutputInterface $ output , ProgressBar $ progress , $ message ) { $ progress -> clear ( ) ; $ this -> logger -> warning ( $ message ) ; $ progress -> display ( ) ; }
2212	public function fetchField ( $ intOffset = 0 ) { $ arrFields = array_values ( $ this -> resultSet [ $ this -> intIndex ] ) ; return $ arrFields [ $ intOffset ] ; }
4819	public function getIterator ( IteratorFilter $ itf = null ) { if ( is_null ( $ itf ) ) { return new AnyIterator ( $ this -> collection ) ; } return new AnyIterator ( $ itf -> match ( $ this -> collection ) ) ; }
3607	protected function getTableNames ( ) { $ schemas = DB :: getConfig ( 'used_schemas' ) ? : [ DB :: getConfig ( 'schema' ) ] ; $ schemaCount = count ( $ schemas ) ; $ binds = implode ( ',' , array_fill ( 0 , $ schemaCount , '?' ) ) ; return collect ( DB :: select ( "SELECT schemaname || '.' || tablename AS table FROM pg_catalog.pg_tables WHERE schemaname IN (" . $ binds . ')' , $ schemas ) ) -> pluck ( 'table' ) -> reject ( function ( $ value , $ key ) { $ tableName = explode ( '.' , $ value ) [ 1 ] ; return $ tableName === 'spatial_ref_sys' ; } ) ; }
565	public function getScriptFile ( ) { if ( $ this -> _scriptFile === null ) { if ( isset ( $ _SERVER [ 'SCRIPT_FILENAME' ] ) ) { $ this -> setScriptFile ( $ _SERVER [ 'SCRIPT_FILENAME' ] ) ; } else { throw new InvalidConfigException ( 'Unable to determine the entry script file path.' ) ; } } return $ this -> _scriptFile ; }
4582	public function created ( JWTCreatedEvent $ event ) { $ payload = $ event -> getData ( ) ; $ user = $ event -> getUser ( ) ; $ payload [ $ this -> attribute ] = $ user -> getTenant ( ) ; $ event -> setData ( $ payload ) ; }
6257	public function authorize ( $ user , Request $ request ) { $ roleField = $ this -> _config [ 'roleField' ] ; if ( ! isset ( $ user [ $ roleField ] ) ) { throw new RuntimeException ( sprintf ( 'The role field `%s` does not exist!' , $ roleField ) ) ; } if ( is_string ( $ user [ $ roleField ] ) ) { $ user [ $ roleField ] = array ( $ user [ $ roleField ] ) ; } if ( $ this -> authorizeByPrefix ( $ user [ $ roleField ] , $ request ) ) { return true ; } if ( $ this -> authorizeByControllerAndAction ( $ user , $ request ) ) { return true ; } return false ; }
920	private function fixDescription ( DocBlock $ doc ) { foreach ( $ doc -> getLines ( ) as $ index => $ line ) { if ( $ line -> containsATag ( ) ) { break ; } if ( $ line -> containsUsefulContent ( ) ) { $ next = $ doc -> getLine ( $ index + 1 ) ; if ( $ next -> containsATag ( ) ) { $ line -> addBlank ( ) ; break ; } } } }
915	public static function camelCaseToUnderscore ( $ string ) { return Preg :: replaceCallback ( '/(^|[a-z0-9])([A-Z])/' , static function ( array $ matches ) { return strtolower ( '' !== $ matches [ 1 ] ? $ matches [ 1 ] . '_' . $ matches [ 2 ] : $ matches [ 2 ] ) ; } , $ string ) ; }
3966	public function getInputScreen ( ) { return new InputScreen ( \ System :: getContainer ( ) -> get ( 'cca.legacy_dic' ) -> getService ( 'metamodels-service-container' ) , $ this -> inputScreen [ 'meta' ] , $ this -> inputScreen [ 'properties' ] , $ this -> inputScreen [ 'conditions' ] , $ this -> inputScreen [ 'groupSort' ] ) ; }
11098	public static function secondsBetweenWorkingDays ( $ dateFrom , $ dateTo , $ workDayFrom , $ workDayTo , $ weekends = false , $ holidays = false , $ timeZone = 'Europe/Prague' ) { $ timeZoneObj = new \ DateTimeZone ( $ timeZone ) ; $ dateFromObj = new DateTime ( $ dateFrom , $ timeZoneObj ) ; $ dateToObj = new DateTime ( $ dateTo , $ timeZoneObj ) ; $ workDayFromObj = new DateTime ( $ workDayFrom , $ timeZoneObj ) ; $ workDayToObj = new DateTime ( $ workDayTo , $ timeZoneObj ) ; $ workDayLength = self :: secondsBetweenDates ( $ workDayFrom , $ workDayTo , true , $ timeZone ) ; $ period = new \ DatePeriod ( new DateTime ( $ dateFromObj -> format ( 'Y-m-d 00:00:00' ) , $ timeZoneObj ) , new \ DateInterval ( 'P1D' ) , new DateTime ( $ dateToObj -> format ( 'Y-m-d 23:59:59' ) , $ timeZoneObj ) ) ; $ workedTime = 0 ; foreach ( $ period as $ date ) { if ( ( ! $ weekends && ( int ) $ date -> format ( 'N' ) > 5 ) || ( ! $ holidays && self :: isCzechHoliday ( $ date ) ) ) { continue ; } if ( $ date -> format ( 'Y-m-d' ) === $ dateFromObj -> format ( 'Y-m-d' ) ) { $ endOfDay = new DateTime ( $ date -> format ( 'Y-m-d ' . $ workDayToObj -> format ( 'H:i:s' ) ) , $ timeZoneObj ) ; if ( $ dateFromObj < $ endOfDay && $ dateFromObj -> format ( 'Y-m-d' ) === $ dateToObj -> format ( 'Y-m-d' ) ) { $ diff = $ dateToObj -> diff ( $ dateFromObj ) -> format ( '%H:%I:%S' ) ; } else { $ diff = $ endOfDay -> diff ( $ dateFromObj ) -> format ( '%H:%I:%S' ) ; } $ diff = explode ( ':' , $ diff ) ; $ diff = $ diff [ 0 ] * 3600 + $ diff [ 1 ] * 60 + $ diff [ 0 ] ; $ workedTime += $ diff ; } elseif ( $ date -> format ( 'Y-m-d' ) === $ dateToObj -> format ( 'Y-m-d' ) ) { $ startOfDay = new DateTime ( $ date -> format ( 'Y-m-d ' . $ workDayFromObj -> format ( 'H:i:s' ) ) , $ timeZoneObj ) ; if ( $ dateToObj > $ startOfDay ) { $ diff = $ startOfDay -> diff ( $ dateToObj ) -> format ( '%H:%I:%S' ) ; $ diff = explode ( ':' , $ diff ) ; $ diff = $ diff [ 0 ] * 3600 + $ diff [ 1 ] * 60 + $ diff [ 0 ] ; $ workedTime += $ diff ; } } else { $ workedTime += $ workDayLength ; } } return $ workedTime ; }
7444	public function createAction ( ) { $ group = new Group ( ) ; $ form = $ this -> createForm ( GroupType :: class , $ group ) ; $ form -> bindRequest ( $ this -> getRequest ( ) ) ; if ( $ form -> isValid ( ) ) { $ em = $ this -> getDoctrine ( ) -> getEntityManager ( ) ; $ em -> persist ( $ group ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'success' , 'The group has been created.' ) ; return $ this -> redirect ( $ this -> generateUrl ( 'orkestra_group_show' , array ( 'id' => $ group -> getId ( ) ) ) ) ; } return array ( 'group' => $ group , 'form' => $ form -> createView ( ) ) ; }
7207	public function finalize ( ) : void { $ this -> round ( ) ; $ old = $ this -> taxes ; usort ( $ old , function ( Adjustment $ a , Adjustment $ b ) : int { if ( $ a -> getAmount ( ) == $ b -> getAmount ( ) ) { return 0 ; } return $ a -> getAmount ( ) > $ b -> getAmount ( ) ? 1 : - 1 ; } ) ; $ new = [ ] ; $ total = 0 ; foreach ( $ old as $ tax ) { $ amount = Money :: round ( $ tax -> getAmount ( ) , $ this -> currency ) ; if ( $ total + $ amount > $ this -> tax ) { $ amount = $ this -> tax - $ total ; } $ total += $ amount ; $ new [ ] = new Adjustment ( $ tax -> getName ( ) , $ amount , $ tax -> getRate ( ) ) ; } usort ( $ new , function ( Adjustment $ a , Adjustment $ b ) : int { return $ a -> getRate ( ) > $ b -> getRate ( ) ? 1 : - 1 ; } ) ; $ this -> taxes = $ new ; }
6526	public static function resolveId ( SchemaId $ id ) : string { $ curieMajor = $ id -> getCurieMajor ( ) ; if ( isset ( self :: $ curies [ $ curieMajor ] ) ) { return self :: $ classes [ self :: $ curies [ $ curieMajor ] ] ; } $ curie = $ id -> getCurie ( ) -> toString ( ) ; if ( isset ( self :: $ curies [ $ curie ] ) ) { return self :: $ classes [ self :: $ curies [ $ curie ] ] ; } throw new NoMessageForSchemaId ( $ id ) ; }
6405	public function consume ( $ remaining_taf ) { $ chunk_regexp = $ this -> getRegexp ( ) ; if ( preg_match ( $ chunk_regexp , $ remaining_taf , $ matches ) ) { $ found = $ matches ; } else { $ found = null ; } $ new_remaining_taf = preg_replace ( $ chunk_regexp , '' , $ remaining_taf , 1 ) ; return array ( 'found' => $ found , 'remaining' => $ new_remaining_taf , ) ; }
4453	public function isPaused ( ) : bool { $ stat = json_decode ( $ this -> client -> queues ( $ this -> name ) , true ) ; return isset ( $ stat [ 'name' ] ) && $ stat [ 'name' ] === $ this -> name && $ stat [ 'paused' ] == true ; }
11451	public function getParentKeyName ( ) { if ( $ this -> getParentName ( ) ) { $ func = $ this -> getParentName ( ) ; $ relat = $ this -> $ func ( ) ; $ field = $ relat -> getForeignKey ( ) ; return $ field ; } return 'id' ; }
6020	public function removeMediaFromDeploymentSite ( $ id , $ mediaIds ) { $ parameters = [ 'query' => [ 'mediaIds' => $ mediaIds ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> delete ( 'v1/deployment/' . $ id . '/media' , $ parameters ) ; return $ result ; }
8797	public function trigger ( $ event , array $ params = [ ] , $ method = 'handle' ) { $ listeners = config ( 'services.listeners' ) ; foreach ( $ listeners [ $ event ] as $ listener ) { if ( ! class_exists ( $ listener ) ) { throw new ExceptionHandler ( 'Event class not found.' , $ listener ) ; } if ( ! method_exists ( $ listener , $ method ) ) { throw new ExceptionHandler ( 'Method not found in Event class.' , $ listener . '::' . $ method . '()' ) ; } call_user_func_array ( [ new $ listener , $ method ] , $ params ) ; } }
10211	function fromXML ( $ xmlElement ) { if ( isset ( $ xmlElement -> id ) ) $ this -> id = $ xmlElement -> id ; $ this -> email = ( string ) $ xmlElement -> email ; if ( isset ( $ xmlElement -> permission ) ) $ this -> permission = Permission :: getPermission ( ( string ) $ xmlElement -> permission ) ; if ( isset ( $ xmlElement -> external_id ) ) ( string ) $ this -> external_id = $ xmlElement -> external_id ; if ( isset ( $ xmlElement -> anonymous ) ) ( string ) $ this -> anonymous = $ xmlElement -> anonymous ; if ( isset ( $ xmlElement [ 'anonymous' ] ) ) $ this -> anonymous = $ xmlElement [ 'anonymous' ] ; if ( isset ( $ xmlElement -> created ) ) $ this -> created = $ xmlElement -> created ; if ( isset ( $ xmlElement -> updated ) ) $ this -> updated = $ xmlElement -> updated ; if ( isset ( $ xmlElement -> standard_fields ) ) { $ this -> standard_fields = array ( ) ; foreach ( $ xmlElement -> standard_fields -> children ( ) as $ field ) { $ this -> standard_fields [ trim ( $ field -> name ) ] = ( string ) $ field -> value ; } } if ( isset ( $ xmlElement -> custom_fields ) ) { foreach ( $ xmlElement -> custom_fields -> children ( ) as $ field ) { $ this -> custom_fields [ trim ( $ field -> name ) ] = ( string ) $ field -> value ; } } }
8707	public function getLastFolderID ( ) { $ request = Controller :: curr ( ) -> getRequest ( ) ; $ session = $ request -> getSession ( ) ; return $ session -> get ( self :: class . '.FolderID' ) ; }
777	private function defaultTimeTypeMap ( ) { $ map = [ Schema :: TYPE_DATETIME => 'datetime' , Schema :: TYPE_TIMESTAMP => 'timestamp' , Schema :: TYPE_TIME => 'time' , ] ; if ( $ this -> supportsFractionalSeconds ( ) ) { $ map = [ Schema :: TYPE_DATETIME => 'datetime(0)' , Schema :: TYPE_TIMESTAMP => 'timestamp(0)' , Schema :: TYPE_TIME => 'time(0)' , ] ; } return $ map ; }
6451	public function isLoggedIn ( ) { $ cookieName = session_name ( ) ; $ cookie = $ this -> getSession ( ) -> getCookie ( $ cookieName ) ; if ( null !== $ cookie ) { $ this -> getSession ( 'goutte' ) -> setCookie ( $ cookieName , $ cookie ) ; return true ; } return false ; }
3174	private function getTimeConstraint ( TestSession $ session , QtiComponent $ source , $ navigationMode ) { $ constraint = new QtiTimeConstraint ( $ source , $ session -> getTimerDuration ( $ source -> getIdentifier ( ) ) , $ navigationMode , true , true , $ session -> getTimerTarget ( ) ) ; $ constraint -> setTimer ( $ session -> getTimer ( ) ) ; return $ constraint ; }
3321	public function getSuggestions ( ) { if ( $ this -> suggestions ) { if ( is_callable ( $ this -> suggestions ) ) { return call_user_func ( $ this -> suggestions ) ; } return $ this -> suggestions ; } return ; }
4603	public function decrypt ( string $ data , string $ key = null ) { $ key = $ this -> createKey ( $ key ) ; $ data = unserialize ( Crypto :: decrypt ( $ data , $ key ) ) ; return $ data ; }
4224	public function handleException ( $ exception ) { $ this -> uncaughtException = $ exception ; \ http_response_code ( 500 ) ; $ this -> handleError ( E_ERROR , 'Uncaught exception \'' . \ get_class ( $ exception ) . '\' with message ' . $ exception -> getMessage ( ) , $ exception -> getFile ( ) , $ exception -> getLine ( ) ) ; $ this -> uncaughtException = null ; if ( $ this -> cfg [ 'continueToPrevHandler' ] && $ this -> prevExceptionHandler ) { \ call_user_func ( $ this -> prevErrorHandler , $ exception ) ; } }
12571	public function previewVoice ( $ message , $ to , $ by = self :: PREVIEW_BY_OPENID ) { return $ this -> preview ( self :: MSG_TYPE_VOICE , $ message , $ to , $ by ) ; }
12790	public static function createView ( string $ actionName , ? string $ ctrlName = null ) : ? View { $ viewsRoot = AppHelper :: getInstance ( ) -> getComponentRoot ( 'views' ) ; $ addPath = '' ; if ( ! empty ( $ ctrlName ) ) { $ addPath .= \ DIRECTORY_SEPARATOR . strtolower ( $ ctrlName ) ; } $ viewFile = $ viewsRoot . $ addPath . \ DIRECTORY_SEPARATOR . strtolower ( $ actionName ) . '.php' ; if ( is_readable ( $ viewFile ) ) { return new View ( $ viewFile ) ; } return null ; }
5811	public function updateCMSFields ( FieldList $ fields ) { $ fields -> removeByName ( 'FusionTags' ) ; $ types = array ( ) ; foreach ( singleton ( 'FusionService' ) -> getFusionTagTypes ( ) as $ type => $ field ) { $ types [ $ type ] = $ type ; } $ types = array_intersect ( $ this -> owner -> many_many ( ) , $ types ) ; if ( empty ( $ types ) ) { $ fields -> addFieldToTab ( 'Root.Tagging' , ListboxField :: create ( 'FusionTags' , 'Tags' , FusionTag :: get ( ) -> map ( ) -> toArray ( ) ) -> setMultiple ( true ) ) ; } $ this -> owner -> extend ( 'updateTaggingExtensionCMSFields' , $ fields ) ; }
2333	public function onKernelRequest ( GetResponseEvent $ event ) : void { if ( ! $ this -> tokenChecker -> hasBackendUser ( ) ) { return ; } $ request = $ event -> getRequest ( ) ; $ request -> attributes -> set ( $ this -> requestAttribute , true ) ; }
7468	protected function colorize ( $ str , $ attrs ) { $ start = $ this -> start ( $ attrs ) ; return $ start . $ str . $ this -> end ( ) ; }
8081	public function error ( $ message ) { if ( $ message ) { if ( is_int ( $ message ) && isset ( $ this -> errorList [ $ message ] ) ) { $ errorMessage = $ this -> errorList [ $ message ] ; $ this -> report ( "Error[{$message}]: {$errorMessage}" ) ; } else { $ errorMessage = $ message ; $ this -> report ( "Error: {$errorMessage}" ) ; } $ errors = & $ this -> getErrors ( ) ; $ errors [ ] = $ errorMessage ; } return $ this ; }
3856	protected function prepareMetaModel ( ) { $ factory = $ this -> getFactory ( ) ; $ this -> objMetaModel = $ factory -> getMetaModel ( $ factory -> translateIdToMetaModelName ( $ this -> intMetaModel ) ) ; if ( ! $ this -> objMetaModel ) { throw new \ RuntimeException ( 'Could get metamodel id: ' . $ this -> intMetaModel ) ; } }
12076	public function childStore ( $ idParent , FilterRequest $ filters , $ relation ) { $ idParent = $ this -> getRealId ( $ idParent ) ; $ resource = $ this -> repository -> storeChild ( $ idParent , $ relation , $ filters -> all ( ) ) ; if ( ! $ resource ) { } return $ this -> success ( $ resource ) ; }
5773	public function isUpdatable ( ) : bool { if ( is_null ( $ this -> authorization ) ) { throw new \ Exception ( "Authorization must be set" ) ; } if ( $ this -> authorization -> hasTopRole ( ) ) { return true ; } if ( ! $ this -> hasTopRole ( ) ) { return true ; } return false ; }
12640	public function init ( $ adapter , $ client = null ) { $ this -> adapter = $ adapter ; if ( ! $ client ) { $ client = new \ PeterColes \ Cluster \ HttpClients \ GuzzleHttp ; } $ client -> initClient ( $ this -> adapter -> getHeaders ( ) ) ; $ this -> adapter -> setClient ( $ client ) ; }
11272	protected function handleResponseContent ( ResponseInterface $ response , $ contentType = null ) { $ contents = $ response -> getBody ( ) -> getContents ( ) ; if ( ! $ contentType ) { $ contentTypeHeaderLine = $ response -> getHeaderLine ( 'Content-Type' ) ; if ( stripos ( $ contentTypeHeaderLine , 'application/json' ) !== false ) { $ contentType = 'json' ; } elseif ( stripos ( $ contentTypeHeaderLine , 'application/xml' ) !== false ) { $ contentType = 'xml' ; } } if ( $ contentType ) { return Parser :: data ( $ contents ) -> from ( $ contentType ) -> toArray ( ) ; } return $ contents ; }
714	public function float ( $ precision = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_FLOAT , $ precision ) ; }
266	protected function loadMessages ( $ category , $ language ) { if ( $ this -> enableCaching ) { $ key = [ __CLASS__ , $ category , $ language , ] ; $ messages = $ this -> cache -> get ( $ key ) ; if ( $ messages === false ) { $ messages = $ this -> loadMessagesFromDb ( $ category , $ language ) ; $ this -> cache -> set ( $ key , $ messages , $ this -> cachingDuration ) ; } return $ messages ; } return $ this -> loadMessagesFromDb ( $ category , $ language ) ; }
9629	protected function getRouteIdentifier ( Route $ route ) : string { return empty ( $ route -> getName ( ) ) ? $ route -> getTarget ( ) : $ route -> getName ( ) ; }
4904	protected function createValueOptions ( NodeInterface $ node , $ allowSelectNodes = false , $ isRoot = true ) { $ key = $ isRoot ? $ node -> getValue ( ) : $ node -> getValueWithParents ( ) ; $ name = $ node -> getName ( ) ; if ( $ node -> hasChildren ( ) ) { $ leafOptions = [ ] ; if ( $ allowSelectNodes && ! $ isRoot ) { $ leafOptions [ $ key ] = $ name ; $ key = "$key-group" ; } foreach ( $ node -> getChildren ( ) as $ child ) { $ leafOptions += $ this -> createValueOptions ( $ child , $ allowSelectNodes , false ) ; } $ value = [ 'label' => $ name , 'options' => $ leafOptions ] ; } else { $ value = $ name ; } return [ $ key => $ value ] ; }
9964	public function getComment ( $ pCellCoordinate ) { $ pCellCoordinate = strtoupper ( $ pCellCoordinate ) ; if ( Coordinate :: coordinateIsRange ( $ pCellCoordinate ) ) { throw new Exception ( 'Cell coordinate string can not be a range of cells.' ) ; } elseif ( strpos ( $ pCellCoordinate , '$' ) !== false ) { throw new Exception ( 'Cell coordinate string must not be absolute.' ) ; } elseif ( $ pCellCoordinate == '' ) { throw new Exception ( 'Cell coordinate can not be zero-length string.' ) ; } if ( isset ( $ this -> comments [ $ pCellCoordinate ] ) ) { return $ this -> comments [ $ pCellCoordinate ] ; } $ newComment = new Comment ( ) ; $ this -> comments [ $ pCellCoordinate ] = $ newComment ; return $ newComment ; }
8842	private function stringToArray ( string $ string ) : array { $ lines = preg_split ( '/\R/' , $ string ) ; if ( 1 === count ( $ lines ) && '' === $ lines [ 0 ] ) { $ lines = [ ] ; } return $ lines ; }
11716	public static function entry ( $ argv ) : void { self :: initialize ( ) ; if ( isset ( $ argv [ 1 ] ) ) { $ command = $ argv [ 1 ] ; } else { return ; } if ( ! in_array ( $ command , array_keys ( self :: $ commands ) ) ) { return ; } $ arguments = [ ] ; $ options = [ ] ; for ( $ index = 2 ; $ index < count ( $ argv ) ; $ index ++ ) { list ( $ key , $ value ) = Service :: parse ( $ argv [ $ index ] ) ; if ( Service :: determineTypeOfWord ( $ argv [ $ index ] ) == Service :: OPTION_TYPE ) { if ( ! $ value ) { $ options [ $ key ] = true ; } else { $ options [ $ key ] = $ value ; } } else { $ arguments [ ] = $ key ; } } Service :: runCommand ( self :: $ commands [ $ command ] , $ arguments , $ options ) ; }
1597	protected function validateRelationships ( ) : bool { if ( ! $ this -> dataHas ( 'relationships' ) ) { return true ; } $ relationships = $ this -> dataGet ( 'relationships' ) ; if ( ! is_object ( $ relationships ) ) { $ this -> memberNotObject ( '/data' , 'relationships' ) ; return false ; } $ disallowed = collect ( [ 'type' , 'id' ] ) -> filter ( function ( $ field ) use ( $ relationships ) { return property_exists ( $ relationships , $ field ) ; } ) ; $ valid = $ disallowed -> isEmpty ( ) ; $ this -> memberFieldsNotAllowed ( '/data' , 'relationships' , $ disallowed ) ; foreach ( $ relationships as $ field => $ relation ) { if ( ! $ this -> validateRelationship ( $ relation , $ field ) ) { $ valid = false ; } } return $ valid ; }
5537	public function setFrame ( $ path , $ page ) { $ name = array_shift ( $ path ) ; if ( isset ( $ this -> names [ $ name ] ) ) { $ index = $ this -> names [ $ name ] ; } else { $ index = $ name - 1 ; } if ( count ( $ path ) === 0 ) { $ this -> frames [ $ index ] = $ page ; return ; } $ this -> frames [ $ index ] -> setFrame ( $ path , $ page ) ; }
2159	public function run210Update ( ) { $ this -> Database -> query ( "ALTER TABLE `tl_style` ADD `positioning` char(1) NOT NULL default ''" ) ; $ this -> Database -> query ( "UPDATE `tl_style` SET `positioning`=`size`" ) ; $ this -> Database -> query ( "UPDATE `tl_module` SET `guests`=1 WHERE `type`='lostPassword' OR `type`='registration'" ) ; $ this -> Database -> query ( "UPDATE `tl_news` SET `teaser`=CONCAT('<p>', teaser, '</p>') WHERE `teaser`!='' AND `teaser` NOT LIKE '<p>%'" ) ; }
9354	public function subMatrix ( $ int_m , $ int_n ) { $ sm = new self ( $ this -> size -> rows - 1 , $ this -> size -> cols - 1 ) ; foreach ( $ this -> arr as $ m => $ row ) { if ( $ m != $ int_m ) { $ arr_row = array ( ) ; foreach ( $ row as $ n => $ v ) { if ( $ n != $ int_n ) { $ arr_row [ ] = $ v ; } } $ sm -> addRow ( $ arr_row ) ; } } return $ sm ; }
2018	private function setImagineService ( array $ config , ContainerBuilder $ container ) : void { $ imagineServiceId = $ config [ 'image' ] [ 'imagine_service' ] ; if ( null === $ imagineServiceId ) { $ class = $ this -> getImagineImplementation ( ) ; $ imagineServiceId = 'contao.image.imagine.' . ContainerBuilder :: hash ( $ class ) ; $ container -> setDefinition ( $ imagineServiceId , new Definition ( $ class ) ) ; } $ container -> setAlias ( 'contao.image.imagine' , $ imagineServiceId ) -> setPublic ( true ) ; }
2304	public function createPageList ( ) { $ this -> import ( BackendUser :: class , 'User' ) ; if ( $ this -> User -> isAdmin ) { return $ this -> doCreatePageList ( ) ; } $ return = '' ; $ processed = array ( ) ; foreach ( $ this -> eliminateNestedPages ( $ this -> User -> pagemounts ) as $ page ) { $ objPage = PageModel :: findWithDetails ( $ page ) ; if ( $ objPage -> type == 'root' ) { $ title = $ objPage -> title ; $ start = $ objPage -> id ; } else { $ title = $ objPage -> rootTitle ; $ start = $ objPage -> rootId ; } if ( \ in_array ( $ start , $ processed ) ) { continue ; } if ( $ objPage -> domain && $ objPage -> domain != Environment :: get ( 'host' ) ) { continue ; } $ processed [ ] = $ start ; $ return .= '<optgroup label="' . $ title . '">' . $ this -> doCreatePageList ( $ start ) . '</optgroup>' ; } return $ return ; }
6116	public function serverGetByName ( $ name ) { foreach ( $ this -> serverList ( ) as $ server ) { if ( $ server [ "virtualserver_name" ] == $ name ) { return $ server ; } } throw new Ts3Exception ( "invalid serverID" , 0x400 ) ; }
12050	public function initClient ( $ headers ) { try { $ this -> request = new Client ( $ headers ) ; } catch ( Exception $ e ) { echo 'Unable to initialise http client because ' . $ e -> getMessage ( ) . "\n" ; } }
10379	protected static function is_modified_file ( $ filepath ) { $ actual = filemtime ( $ filepath ) ; $ last = isset ( self :: $ files [ $ filepath ] ) ? self :: $ files [ $ filepath ] : 0 ; if ( $ actual !== $ last ) { self :: $ files [ $ filepath ] = $ actual ; self :: $ changes = true ; return self :: $ changes ; } return false ; }
6198	public function parseGets ( ) { $ request = preg_replace ( '!' . $ this -> uri . '(.*)$!i' , '$1' , $ _SERVER [ 'REQUEST_URI' ] ) ; if ( defined ( 'MOD_REWRITE' ) and MOD_REWRITE === true ) { if ( substr ( $ request , - 1 ) != '/' ) { $ request .= '/' ; } $ parseUrl = $ this -> parseUrl ( $ request ) ; $ this -> namespace = $ parseUrl [ 'v' ] [ 'namespace' ] ?? '' ; parse_str ( $ parseUrl [ 'sVars' ] , $ gets ) ; $ this -> controller = ! empty ( $ gets [ 'task' ] ) ? $ gets [ 'task' ] : $ this -> routeMap [ 'NAME_CONTROLLER' ] ; unset ( $ gets [ 'task' ] ) ; $ this -> action = ! empty ( $ gets [ 'action' ] ) ? $ gets [ 'action' ] : $ this -> routeMap [ 'NAME_METHOD' ] ; unset ( $ gets [ 'action' ] ) ; $ _GET = array_merge ( $ _GET , $ gets ) ; } else { $ this -> controller = ! empty ( $ _GET [ 'task' ] ) ? $ _GET [ 'task' ] : $ this -> routeMap [ 'NAME_CONTROLLER' ] ; $ this -> action = ! empty ( $ _GET [ 'action' ] ) ? $ _GET [ 'action' ] : $ this -> routeMap [ 'NAME_METHOD' ] ; } $ _GET [ 'task' ] = $ this -> controller ; $ _GET [ 'action' ] = $ this -> action ; }
12120	public function onViewCreate ( ContentfulViewEvent $ e ) { $ viewMeta = $ e -> getView ( ) -> cfMeta ; $ updated = $ viewMeta [ 'updatedAt' ] ; $ this -> itemIds [ $ viewMeta [ 'itemId' ] ] = true ; if ( $ this -> lastModifiedContent === null ) { $ this -> lastModifiedContent = $ updated ; } else { if ( $ this -> lastModifiedContent < $ updated ) { $ this -> lastModifiedContent = $ updated ; } } }
10808	public static function isRender ( $ request ) { return true ; $ accept = $ request -> header ( 'accept' ) ?? '' ; if ( static :: isHas ( $ accept , 'json' ) || static :: isHas ( $ accept , 'api' ) ) { return true ; } else if ( static :: isHas ( $ accept , 'html' ) || static :: isHas ( $ accept , 'xml' ) || static :: isHas ( $ accept , 'text' ) ) { return false ; } else if ( $ request -> header ( 'x-ddv-restful-api' ) ) { return true ; } else if ( $ request -> header ( 'authorization' ) ) { foreach ( $ request -> headers -> keys ( ) as $ value ) { if ( static :: isHas ( $ accept , 'x-ddv-' ) ) { return true ; } } } return false ; }
2455	public function copyAll ( ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notCopyable' ] ) { throw new InternalServerErrorException ( 'Table "' . $ this -> strTable . '" is not copyable.' ) ; } $ objSession = System :: getContainer ( ) -> get ( 'session' ) ; $ arrClipboard = $ objSession -> get ( 'CLIPBOARD' ) ; if ( isset ( $ arrClipboard [ $ this -> strTable ] ) && \ is_array ( $ arrClipboard [ $ this -> strTable ] [ 'id' ] ) ) { foreach ( $ arrClipboard [ $ this -> strTable ] [ 'id' ] as $ id ) { $ this -> intId = $ id ; $ id = $ this -> copy ( true ) ; Input :: setGet ( 'pid' , $ id ) ; Input :: setGet ( 'mode' , 1 ) ; } } $ this -> redirect ( $ this -> getReferer ( ) ) ; }
428	public function init ( ) { if ( $ this -> controllerNamespace === null ) { $ class = get_class ( $ this ) ; if ( ( $ pos = strrpos ( $ class , '\\' ) ) !== false ) { $ this -> controllerNamespace = substr ( $ class , 0 , $ pos ) . '\\controllers' ; } } }
12367	protected function getOption ( $ name ) { if ( ! isset ( $ this -> options [ $ name ] ) ) { throw new ValueNotFoundException ( $ name ) ; } return $ this -> options [ $ name ] ; }
3841	private function parsePanelFilter ( PanelRowInterface $ row ) { foreach ( $ this -> inputScreen [ 'properties' ] as $ value ) { if ( ! empty ( $ value [ 'filter' ] ) ) { $ element = new DefaultFilterElementInformation ( ) ; $ element -> setPropertyName ( $ value [ 'col_name' ] ) ; if ( ! $ row -> hasElement ( $ element -> getName ( ) ) ) { $ row -> addElement ( $ element ) ; } } } }
11485	protected function resolveClassArg ( ReflectionClass $ class , ReflectionParameter $ param , array $ params ) { $ name = '$' . $ param -> getName ( ) ; $ class = $ class -> getName ( ) ; while ( $ name !== null ) { if ( $ params && array_key_exists ( $ name , $ params ) ) { $ class = $ params [ $ name ] ; } if ( $ class instanceof Factory \ FactoryInterface ) { return $ class -> invoke ( $ this ) ; } if ( is_object ( $ class ) ) { return $ class ; } $ name = ( $ name != $ class ) ? $ class : null ; } try { return $ this -> resolve ( $ class ) ; } catch ( ReflectionException $ exception ) { if ( $ param -> isOptional ( ) ) { return null ; } throw $ exception ; } }
2548	private function findHandlerForMessage ( $ messageName ) { $ handler = null ; if ( array_key_exists ( $ messageName , $ this -> responseHandlers ) && $ this -> responseHandlers [ $ messageName ] instanceof MessageResponseHandler ) { $ handler = $ this -> responseHandlers [ $ messageName ] ; } else { $ section = substr ( $ messageName , 0 , strpos ( $ messageName , '_' ) ) ; $ message = substr ( $ messageName , strpos ( $ messageName , '_' ) + 1 ) ; $ handlerClass = __NAMESPACE__ . '\\' . $ section . '\\Handler' . $ message ; if ( class_exists ( $ handlerClass ) ) { $ handler = new $ handlerClass ( ) ; $ this -> responseHandlers [ $ messageName ] = $ handler ; } } return $ handler ; }
949	public function sanitizeShopDomain ( $ domain ) { if ( empty ( $ domain ) ) { return ; } $ configEndDomain = Config :: get ( 'shopify-app.myshopify_domain' ) ; $ domain = strtolower ( preg_replace ( '/https?:\/\//i' , '' , trim ( $ domain ) ) ) ; if ( strpos ( $ domain , $ configEndDomain ) === false && strpos ( $ domain , '.' ) === false ) { $ domain .= ".{$configEndDomain}" ; } return parse_url ( "http://{$domain}" , PHP_URL_HOST ) ; }
613	protected function build ( $ class , $ params , $ config ) { list ( $ reflection , $ dependencies ) = $ this -> getDependencies ( $ class ) ; foreach ( $ params as $ index => $ param ) { $ dependencies [ $ index ] = $ param ; } $ dependencies = $ this -> resolveDependencies ( $ dependencies , $ reflection ) ; if ( ! $ reflection -> isInstantiable ( ) ) { throw new NotInstantiableException ( $ reflection -> name ) ; } if ( empty ( $ config ) ) { return $ reflection -> newInstanceArgs ( $ dependencies ) ; } $ config = $ this -> resolveDependencies ( $ config ) ; if ( ! empty ( $ dependencies ) && $ reflection -> implementsInterface ( 'yii\base\Configurable' ) ) { $ dependencies [ count ( $ dependencies ) - 1 ] = $ config ; return $ reflection -> newInstanceArgs ( $ dependencies ) ; } $ object = $ reflection -> newInstanceArgs ( $ dependencies ) ; foreach ( $ config as $ name => $ value ) { $ object -> $ name = $ value ; } return $ object ; }
4072	private function scanFiles ( $ extension ) { $ files = [ ] ; foreach ( Finder :: create ( ) -> in ( $ this -> uploadPath ) -> name ( '*.' . $ extension ) -> getIterator ( ) as $ item ) { $ files [ ] = 'files/' . Path :: normalize ( $ item -> getRelativePathname ( ) ) ; } return $ files ; }
11662	public static function saveToString ( $ properties ) { $ xn = new \ SimpleXMLElement ( self :: XML_ROOT_OPEN . self :: XML_ROOT_CLOSE , LIBXML_NOXMLDECL ) ; foreach ( $ properties as $ key => $ value ) { $ xn -> addChild ( "entry" , htmlspecialchars ( $ value , ENT_XML1 ) ) -> addAttribute ( "key" , htmlspecialchars ( $ key , ENT_XML1 ) ) ; } return preg_replace ( '/\<\?.*\?\>/' , self :: XML_PRELUDE , $ xn -> asXML ( ) ) ; }
7045	private function getColumnNamesFromTable ( $ tableName , $ typeFilter = null ) { if ( ! $ this -> connection -> getSchemaManager ( ) -> tablesExist ( [ $ tableName ] ) ) { return [ ] ; } $ result = [ ] ; foreach ( $ this -> connection -> getSchemaManager ( ) -> listTableColumns ( $ tableName ) as $ column ) { if ( ( $ typeFilter === null ) || \ in_array ( $ column -> getType ( ) -> getName ( ) , $ typeFilter , true ) ) { $ result [ $ column -> getName ( ) ] = $ column -> getName ( ) ; } } if ( ! empty ( $ result ) ) { \ asort ( $ result ) ; return $ result ; } return $ result ; }
1835	public static function findByIdOrAlias ( $ varId , array $ arrOptions = array ( ) ) { $ isAlias = ! preg_match ( '/^[1-9]\d*$/' , $ varId ) ; if ( ! $ isAlias && empty ( $ arrOptions ) ) { $ objModel = Registry :: getInstance ( ) -> fetch ( static :: $ strTable , $ varId ) ; if ( $ objModel !== null ) { return $ objModel ; } } $ t = static :: $ strTable ; $ arrOptions = array_merge ( array ( 'limit' => 1 , 'column' => $ isAlias ? array ( "$t.alias=?" ) : array ( "$t.id=?" ) , 'value' => $ varId , 'return' => 'Model' ) , $ arrOptions ) ; return static :: find ( $ arrOptions ) ; }
5135	public function extract ( Collection $ resources , Closure $ callback ) { foreach ( $ resources as $ resource ) { $ callback ( $ resource , [ 'record' => $ resource ] ) ; } }
12249	public function xpathByAttribute ( $ strXpathQuery , $ strIndexAttribute = 'name' ) { $ arrOut = array ( ) ; $ objResult = $ this -> xpath ( $ strXpathQuery ) ; foreach ( $ objResult as $ intIndex => $ objNode ) { $ strIndex = ( string ) $ objNode -> attributes ( ) -> $ strIndexAttribute ; $ arrOut [ $ strIndex ] = $ objResult [ $ intIndex ] ; } return $ arrOut ; }
12246	static public function sort ( array & $ nodes ) { $ args = func_get_args ( ) ; unset ( $ args [ 0 ] ) ; $ sort = array ( ) ; $ tmp = array ( ) ; foreach ( $ args as $ k => $ arg ) { if ( is_string ( $ arg ) ) { $ tmp [ $ k ] = array ( ) ; if ( preg_match ( '#^@?[a-z_0-9]+$#Di' , $ arg ) ) { if ( $ arg [ 0 ] === '@' ) { $ name = substr ( $ arg , 1 ) ; foreach ( $ nodes as $ node ) { $ tmp [ $ k ] [ ] = ( string ) $ node [ $ name ] ; } } else { foreach ( $ nodes as $ node ) { $ tmp [ $ k ] [ ] = ( string ) $ node -> $ arg ; } } } elseif ( preg_match ( '#^current\\(\\)|text\\(\\)|\\.$#i' , $ arg ) ) { foreach ( $ nodes as $ node ) { $ tmp [ $ k ] [ ] = dom_import_simplexml ( $ node ) -> textContent ; } } else { foreach ( $ nodes as $ node ) { $ _nodes = $ node -> xpath ( $ arg ) ; $ tmp [ $ k ] [ ] = ( empty ( $ _nodes ) ) ? '' : ( string ) $ _nodes [ 0 ] ; } } } else { $ tmp [ $ k ] = $ arg ; } $ sort [ ] = & $ tmp [ $ k ] ; } $ sort [ ] = & $ nodes ; call_user_func_array ( 'array_multisort' , $ sort ) ; }
8700	public function append ( $ element ) { if ( true === $ element instanceof \ SVGCreator \ Element ) { $ this -> childElements [ ] = $ element ; return $ element ; } else { $ elementCreated = $ this -> factoryElement ( $ element ) ; $ this -> childElements [ ] = $ elementCreated ; return $ elementCreated ; } }
9484	public function fromArray ( array $ array ) { foreach ( $ array as $ k => $ v ) { if ( ! is_null ( $ v ) && property_exists ( get_class ( $ this ) , $ k ) ) { $ meta = new \ ReflectionProperty ( get_class ( $ this ) , $ k ) ; $ info = $ this -> parsePropertyDocComment ( $ meta -> getDocComment ( ) ) ; $ type = $ info [ 'type' ] ; if ( strtolower ( $ type ) == "array" && $ elementType = $ info [ 'array_element' ] ) { if ( class_exists ( $ elementType ) ) { $ children = array ( ) ; foreach ( $ v as $ subV ) { $ newElement = new $ elementType ( ) ; $ children [ ] = $ newElement -> fromArray ( $ subV ) ; } $ this -> $ k = $ children ; } else { throw new \ Exception ( '@element Class Not Found:' . $ elementType ) ; } } else if ( class_exists ( $ type ) ) { $ typeObject = new $ type ( ) ; $ this -> $ k = $ typeObject -> fromArray ( $ v ) ; } else { $ this -> $ k = $ v ; } } } return $ this ; }
5515	public function expectAtLeastOnce ( $ method , $ args = false , $ message = '%s' ) { $ this -> expectMinimumCallCount ( $ method , 1 , $ message ) ; if ( $ args !== false ) { $ this -> expect ( $ method , $ args , $ message ) ; } }
4519	public function get ( string $ key ) { $ parameter = $ this -> repository -> findOneBy ( [ 'key' => $ key ] ) ; if ( ! $ parameter ) { throw new OutOfRangeException ( 'Parameter "' . $ key . '" does not exist.' ) ; } $ this -> manager -> detach ( $ parameter ) ; return $ parameter -> getValue ( ) ; }
4841	public function fetch_sub_resource ( $ type , $ params = array ( ) ) { $ endpoint = preg_replace ( '/api\/v[0-9]+\//' , '' , parse_url ( $ this -> sub_resource_uris [ $ type ] , PHP_URL_PATH ) ) ; $ sub_resource_params = array ( ) ; if ( $ param_string = parse_url ( $ this -> sub_resource_uris [ $ type ] , PHP_URL_QUERY ) ) { $ split_params = explode ( '&' , $ param_string ) ; foreach ( $ split_params as $ split_param ) { $ parts = explode ( '=' , $ split_param ) ; $ sub_resource_params [ $ parts [ 0 ] ] = $ parts [ 1 ] ; } } $ params = array_merge ( $ params , $ sub_resource_params ) ; $ class = 'GoCardless_' . GoCardless_Utils :: camelize ( GoCardless_Utils :: singularize ( $ type ) ) ; $ objects = array ( ) ; foreach ( $ this -> client -> request ( 'get' , $ endpoint , $ params ) as $ value ) { $ objects [ ] = new $ class ( $ this -> client , $ value ) ; } return $ objects ; }
6774	protected function didDeliveryCountryChanged ( SaleInterface $ sale ) { $ saleCs = $ this -> persistenceHelper -> getChangeSet ( $ sale ) ; $ oldCountry = $ newCountry = null ; $ oldSameAddress = isset ( $ saleCs [ 'sameAddress' ] ) ? $ saleCs [ 'sameAddress' ] [ 0 ] : $ sale -> isSameAddress ( ) ; if ( $ oldSameAddress ) { $ oldAddress = isset ( $ saleCs [ 'invoiceAddress' ] ) ? $ saleCs [ 'invoiceAddress' ] [ 0 ] : $ sale -> getInvoiceAddress ( ) ; } else { $ oldAddress = isset ( $ saleCs [ 'deliveryAddress' ] ) ? $ saleCs [ 'deliveryAddress' ] [ 0 ] : $ sale -> getDeliveryAddress ( ) ; } if ( null !== $ oldAddress ) { $ oldAddressCs = $ this -> persistenceHelper -> getChangeSet ( $ oldAddress ) ; $ oldCountry = isset ( $ oldAddressCs [ 'country' ] ) ? $ oldAddressCs [ 'country' ] [ 0 ] : $ oldAddress -> getCountry ( ) ; } $ newAddress = $ sale -> isSameAddress ( ) ? $ sale -> getInvoiceAddress ( ) : $ sale -> getDeliveryAddress ( ) ; if ( null !== $ newAddress ) { $ newCountry = $ newAddress -> getCountry ( ) ; } if ( $ oldCountry !== $ newCountry ) { return true ; } return false ; }
10387	public function newApp ( ) : ApplicationInterface { $ app = new CalgamoApplication ( $ this -> filesystem ) ; $ app -> requireModule ( CalgamoLogExceptionHandlerModule :: class ) ; $ app -> requireModule ( CalgamoRouterModule :: class ) ; $ app -> requireModule ( CalgamoDiModule :: class ) ; $ app -> requireModule ( Wa72SimpleLoggerModule :: class ) ; return $ app ; }
2762	public function log ( GitEvent $ gitEvent , string $ message , array $ context = [ ] , ? string $ eventName = null ) : void { if ( $ eventName === null && method_exists ( $ gitEvent , 'getName' ) ) { $ eventName = $ gitEvent -> getName ( ) ; } $ method = $ this -> getLogLevelMapping ( $ eventName ) ; $ context += [ 'command' => $ gitEvent -> getProcess ( ) -> getCommandLine ( ) ] ; $ this -> logger -> { $ method } ( $ message , $ context ) ; }
11665	private function filterElement ( ElementInterface $ element ) { $ value = $ element -> getValue ( ) ; foreach ( $ this -> filters as $ scope => $ filter ) { $ elementIds = array_map ( 'trim' , explode ( ',' , $ scope ) ) ; if ( $ scope === '*' || in_array ( $ element -> getID ( ) , $ elementIds ) ) { $ value = $ filter -> filter ( $ value ) ; } } $ element -> setValue ( $ value ) ; }
10691	public function shutdown ( ) { if ( ! $ this -> is_shutdown ) { $ this -> is_shutdown = true ; if ( ! empty ( $ this -> autoloader ) ) spl_autoload_unregister ( array ( $ this -> autoloader , 'autoload' ) ) ; ErrorInterceptor :: unregisterErrorHandler ( ) ; restore_exception_handler ( ) ; } }
5353	public function getSupportedAuthentication ( ) { if ( empty ( $ this -> data -> authentication ) || empty ( $ this -> data -> authentication ) ) { return array ( ) ; } return ( array ) $ this -> data -> authentication ; }
3422	public function count ( ) { if ( $ this -> queryShouldBeStopped ) { return 0 ; } $ queryType = 'UserQuery::count' ; $ filter = $ this -> normalizeFilter ( ) ; $ callback = function ( ) use ( $ filter ) { return ( int ) $ this -> bxObject -> getList ( $ order = 'ID' , $ by = 'ASC' , $ filter , [ 'NAV_PARAMS' => [ 'nTopCount' => 0 , ] , ] ) -> NavRecordCount ; } ; return $ this -> handleCacheIfNeeded ( compact ( 'queryType' , 'filter' ) , $ callback ) ; }
5261	public function mergeQuery ( array $ query ) { $ types = [ Filter :: MERGE_AND => 'must' , Filter :: MERGE_OR => 'should' ] ; $ type = $ this -> getMergeType ( ) ; $ query [ 'body' ] [ 'filter' ] [ 'bool' ] [ $ types [ $ type ] ] [ ] = $ this -> makeQuery ( ) ; return $ query ; }
12766	public function run ( ) : void { $ this -> isRan = true ; foreach ( $ this -> getAll ( ) as $ header ) { header ( $ header ) ; } }
12895	public function setPerson ( \ Chill \ PersonBundle \ Entity \ Person $ person = null ) { $ this -> person = $ person ; return $ this ; }
9870	private function writePageSetup ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { $ objWriter -> startElement ( 'pageSetup' ) ; $ objWriter -> writeAttribute ( 'paperSize' , $ pSheet -> getPageSetup ( ) -> getPaperSize ( ) ) ; $ objWriter -> writeAttribute ( 'orientation' , $ pSheet -> getPageSetup ( ) -> getOrientation ( ) ) ; if ( $ pSheet -> getPageSetup ( ) -> getScale ( ) !== null ) { $ objWriter -> writeAttribute ( 'scale' , $ pSheet -> getPageSetup ( ) -> getScale ( ) ) ; } if ( $ pSheet -> getPageSetup ( ) -> getFitToHeight ( ) !== null ) { $ objWriter -> writeAttribute ( 'fitToHeight' , $ pSheet -> getPageSetup ( ) -> getFitToHeight ( ) ) ; } else { $ objWriter -> writeAttribute ( 'fitToHeight' , '0' ) ; } if ( $ pSheet -> getPageSetup ( ) -> getFitToWidth ( ) !== null ) { $ objWriter -> writeAttribute ( 'fitToWidth' , $ pSheet -> getPageSetup ( ) -> getFitToWidth ( ) ) ; } else { $ objWriter -> writeAttribute ( 'fitToWidth' , '0' ) ; } if ( $ pSheet -> getPageSetup ( ) -> getFirstPageNumber ( ) !== null ) { $ objWriter -> writeAttribute ( 'firstPageNumber' , $ pSheet -> getPageSetup ( ) -> getFirstPageNumber ( ) ) ; $ objWriter -> writeAttribute ( 'useFirstPageNumber' , '1' ) ; } $ objWriter -> endElement ( ) ; }
7883	public function getDelete ( $ date ) { try { LogViewer :: delete ( $ date ) ; $ today = Carbon :: today ( ) -> format ( 'Y-m-d' ) ; return Redirect :: to ( 'logviewer/' . $ today . '/all' ) -> with ( 'success' , 'Log deleted successfully!' ) ; } catch ( \ Exception $ e ) { return Redirect :: to ( 'logviewer/' . $ date . '/all' ) -> with ( 'error' , 'There was an error while deleting the log.' ) ; } }
3611	public function getNextScheduledEvent ( $ serial_number = NULL ) { $ schedule = $ this -> getDeviceSchedule ( $ serial_number ) ; $ next_event = FALSE ; $ time = date ( 'H' ) * 60 + date ( 'i' ) ; for ( $ i = 0 , $ day = date ( 'D' ) ; $ i ++ < 7 ; $ day = date ( 'D' , strtotime ( "+ $i days" ) ) ) { if ( isset ( $ schedule [ $ day ] ) ) { foreach ( $ schedule [ $ day ] as $ event ) { if ( $ event -> time > $ time ) { return $ event ; } } } $ time = 0 ; } return $ next_event ; }
5574	public function clickSubmit ( $ label = 'Submit' , $ additional = false ) { if ( ! ( $ form = $ this -> page -> getFormBySubmit ( new SelectByLabel ( $ label ) ) ) ) { return false ; } $ success = $ this -> load ( $ form -> getAction ( ) , $ form -> submitButton ( new SelectByLabel ( $ label ) , $ additional ) ) ; return ( $ success ? $ this -> getContent ( ) : $ success ) ; }
3985	private function isActive ( $ route , $ params , Request $ request ) { if ( '/contao' === $ request -> getPathInfo ( ) || ! ( $ request -> attributes -> get ( '_route' ) === $ route ) ) { return false ; } $ attributes = $ request -> attributes -> get ( '_route_params' ) ; $ query = $ request -> query ; foreach ( $ params as $ param => $ value ) { if ( isset ( $ attributes [ $ param ] ) && ( $ value !== $ request -> attributes [ '_route_params' ] [ $ param ] ) ) { return false ; } if ( $ query -> has ( $ param ) && ( $ value !== $ query -> get ( $ param ) ) ) { return false ; } } return true ; }
12410	public function delete ( $ groupId ) { $ params = [ 'group_id' => intval ( $ groupId ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_DELETE , $ params ] ) ; }
8644	public function getReportRequestCount ( $ request ) { if ( ! $ request instanceof MarketplaceWebService_Model_GetReportRequestCountRequest ) { $ request = new MarketplaceWebService_Model_GetReportRequestCountRequest ( $ request ) ; } $ httpResponse = $ this -> invoke ( $ this -> convertGetReportRequestCount ( $ request ) ) ; $ response = MarketplaceWebService_Model_GetReportRequestCountResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
8744	protected function runLoop ( ) { while ( $ this -> isListening ) { $ this -> stream -> select ( ) ; if ( true === $ this -> charSequenceEnabled && null !== $ this -> escapePressedAt ) { if ( $ this -> escapeKeyHasExpired ( ) ) { $ this -> disableKeySequence ( ) ; $ this -> setCurrentKey ( $ this -> matcher -> getKey ( $ this -> matcher -> getEscapeKey ( ) ) ) ; $ this -> dispatchKeyPressEvents ( $ this -> getCurrentKey ( ) ) ; } } if ( $ this -> stream -> isAvailable ( ) ) { $ char = $ this -> stream -> getChar ( ) ; if ( $ this -> matcher -> getEscapeKey ( ) === $ char ) { $ this -> enableKeySequence ( ) ; $ this -> setCurrentKey ( $ char ) ; } else { $ this -> escapePressedAt = null ; if ( $ this -> charSequenceEnabled ) { $ this -> concatCurrentKey ( $ char ) ; $ mapped = $ this -> matcher -> getKey ( $ this -> getCurrentKey ( ) ) ; if ( $ mapped ) { $ this -> setCurrentKey ( $ mapped ) ; $ this -> disableKeySequence ( ) ; } else { continue ; } } else { if ( $ this -> matcher -> isBasicLatin ( $ char ) ) { continue ; } else { $ this -> setCurrentKey ( $ this -> matcher -> getKey ( $ char ) ? : $ char ) ; } } $ this -> dispatchKeyPressEvents ( $ this -> getCurrentKey ( ) ) ; } } } return $ this ; }
9766	function instanceOf ( string $ className ) : self { return $ this -> expect ( $ this -> target , isInstanceOf ( $ className ) ) ; }
759	public function setChildren ( $ children ) { $ this -> _children = [ ] ; foreach ( $ children as $ child ) { $ child -> parent = $ this ; $ this -> _children [ ] = $ child ; } $ this -> updateCollectionOffsets ( ) ; }
1028	private function resolveField ( ObjectType $ parentType , $ source , $ fieldNodes , $ path ) { $ exeContext = $ this -> exeContext ; $ fieldNode = $ fieldNodes [ 0 ] ; $ fieldName = $ fieldNode -> name -> value ; $ fieldDef = $ this -> getFieldDef ( $ exeContext -> schema , $ parentType , $ fieldName ) ; if ( ! $ fieldDef ) { return self :: $ UNDEFINED ; } $ returnType = $ fieldDef -> getType ( ) ; $ info = new ResolveInfo ( $ fieldName , $ fieldNodes , $ returnType , $ parentType , $ path , $ exeContext -> schema , $ exeContext -> fragments , $ exeContext -> rootValue , $ exeContext -> operation , $ exeContext -> variableValues ) ; if ( $ fieldDef -> resolveFn !== null ) { $ resolveFn = $ fieldDef -> resolveFn ; } elseif ( $ parentType -> resolveFieldFn !== null ) { $ resolveFn = $ parentType -> resolveFieldFn ; } else { $ resolveFn = $ this -> exeContext -> fieldResolver ; } $ context = $ exeContext -> contextValue ; $ result = $ this -> resolveOrError ( $ fieldDef , $ fieldNode , $ resolveFn , $ source , $ context , $ info ) ; $ result = $ this -> completeValueCatchingError ( $ returnType , $ fieldNodes , $ info , $ path , $ result ) ; return $ result ; }
5885	protected function renderDropdown ( ) { $ config = $ this -> dropdown ; $ config [ 'clientOptions' ] = false ; $ config [ 'view' ] = $ this -> getView ( ) ; return Dropdown :: widget ( $ config ) ; }
1662	public function reply ( $ message ) { if ( is_string ( $ message ) ) { $ this -> messages [ ] = Text :: create ( ) -> text ( $ message ) -> setAgentVersion ( $ this -> agentVersion ) -> setRequestSource ( $ this -> requestSource ) ; if ( ! $ this -> doesSupportRichMessage ( ) ) { $ this -> text = $ message ; } } elseif ( $ message instanceof RichMessage ) { if ( ! $ this -> doesSupportRichMessage ( ) ) { $ this -> text = $ message -> getFallbackText ( ) ; } $ message -> setAgentVersion ( $ this -> agentVersion ) -> setRequestSource ( $ this -> requestSource ) ; $ this -> messages [ ] = $ message ; } elseif ( $ message instanceof Conversation ) { $ this -> messages [ ] = Payload :: create ( $ message -> render ( ) ) -> setAgentVersion ( $ this -> agentVersion ) -> setRequestSource ( $ this -> requestSource ) ; } return $ this ; }
10553	public static function findVirtualHost ( URL $ url , array $ sites ) { foreach ( $ sites as $ site ) { $ vhost = $ site -> match ( $ url ) ; if ( $ vhost !== null ) return $ vhost ; } return null ; }
8486	public static function getCpuVendor ( ) { $ wmi = Windows :: getInstance ( ) ; $ object = $ wmi -> ExecQuery ( "SELECT Manufacturer FROM Win32_Processor" ) ; foreach ( $ object as $ cpu ) { return $ cpu -> Manufacturer ; } return 'Unknown' ; }
7148	public function getTotal ( $ discounted = true ) { $ base = $ this -> base ; if ( $ discounted && $ this -> hasDiscounts ( ) ) { foreach ( $ this -> discounts as $ discount ) { $ base -= $ this -> calculateAdjustment ( $ discount , $ base ) ; } } $ total = $ base ; if ( ! empty ( $ this -> taxes ) && $ this -> mode === VatDisplayModes :: MODE_ATI ) { foreach ( $ this -> taxes as $ tax ) { $ total += $ this -> calculateAdjustment ( $ tax , $ base ) ; } } return $ total ; }
1115	public function getQualifiedScopedColumns ( ) { if ( ! $ this -> isScoped ( ) ) return $ this -> getScopedColumns ( ) ; $ prefix = $ this -> getTable ( ) . '.' ; return array_map ( function ( $ c ) use ( $ prefix ) { return $ prefix . $ c ; } , $ this -> getScopedColumns ( ) ) ; }
8970	protected function toJson ( RateInterface $ rate ) { return json_encode ( array ( 'sourceName' => $ rate -> getSourceName ( ) , 'value' => $ rate -> getValue ( ) , 'currencyCode' => $ rate -> getCurrencyCode ( ) , 'rateType' => $ rate -> getRateType ( ) , 'date' => $ rate -> getDate ( ) -> format ( \ DateTime :: ATOM ) , 'baseCurrencyCode' => $ rate -> getBaseCurrencyCode ( ) , 'createdAt' => $ rate -> getCreatedAt ( ) -> format ( \ DateTime :: ATOM ) , 'modifiedAt' => $ rate -> getModifiedAt ( ) -> format ( \ DateTime :: ATOM ) , ) ) ; }
1658	private function getDateTime ( $ argument ) { $ datetimeValue = $ argument [ 'datetimeValue' ] ; $ year = $ datetimeValue [ 'date' ] [ 'year' ] ; $ month = $ datetimeValue [ 'date' ] [ 'month' ] ; $ day = $ datetimeValue [ 'date' ] [ 'day' ] ; $ hours = $ datetimeValue [ 'time' ] [ 'hours' ] ; $ minutes = isset ( $ datetimeValue [ 'time' ] [ 'minutes' ] ) ? $ datetimeValue [ 'time' ] [ 'minutes' ] : 0 ; return Carbon :: create ( $ year , $ month , $ day , $ hours , $ minutes , 0 ) ; }
10763	public function setPaymentType ( $ paymentType ) { if ( self :: PAYMENT_PEER_TO_PEER !== $ paymentType ) { throw new RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'Invalid payment type.' ) ) ; } return $ this -> add ( 'PT' , $ paymentType ) ; }
2274	public function getEditableMemberProperties ( ) { $ return = array ( ) ; Contao \ System :: loadLanguageFile ( 'tl_member' ) ; $ this -> loadDataContainer ( 'tl_member' ) ; foreach ( $ GLOBALS [ 'TL_DCA' ] [ 'tl_member' ] [ 'fields' ] as $ k => $ v ) { if ( $ v [ 'eval' ] [ 'feEditable' ] ) { $ return [ $ k ] = $ GLOBALS [ 'TL_DCA' ] [ 'tl_member' ] [ 'fields' ] [ $ k ] [ 'label' ] [ 0 ] ; } } return $ return ; }
3096	public function process ( ) { $ this -> validate ( ) ; $ itemIdentifier = $ this -> hasRequestParameter ( 'itemDefinition' ) ? $ this -> getRequestParameter ( 'itemDefinition' ) : null ; if ( ! is_array ( $ itemIdentifier ) ) { $ itemIdentifier = [ $ itemIdentifier ] ; } try { if ( ! $ this -> getRunnerService ( ) -> getTestConfig ( ) -> getConfigValue ( 'itemCaching.enabled' ) ) { common_Logger :: w ( 'Attempt to disclose the next items without the configuration' ) ; throw new common_exception_Unauthorized ( ) ; } $ response = [ ] ; foreach ( $ itemIdentifier as $ itemId ) { $ response [ 'items' ] [ ] = $ this -> getItemData ( $ itemId ) ; } if ( isset ( $ response [ 'items' ] ) ) { $ response [ 'success' ] = true ; } } catch ( \ Exception $ e ) { $ response = $ this -> getErrorResponse ( $ e ) ; } return $ response ; }
6782	public function setFormParameters ( $ optionNames ) { foreach ( ( array ) $ optionNames as $ option ) { $ this -> formParameters [ $ option ] = true ; } return $ this ; }
3374	protected function getFilename ( $ filename ) { $ callback = $ this -> fileCallback ; if ( null === $ callback || substr ( $ filename , 0 , 1 ) == '/' ) { return $ filename ; } return $ callback ( $ filename ) ; }
3863	private function getCaptionText ( $ langKey ) { $ tableName = $ this -> getMetaModel ( ) -> getTableName ( ) ; if ( isset ( $ this -> objView ) && isset ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ tableName ] [ $ this -> objView -> get ( 'id' ) ] [ $ langKey ] ) ) { return $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ tableName ] [ $ this -> objView -> get ( 'id' ) ] [ $ langKey ] ; } elseif ( isset ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ tableName ] [ $ langKey ] ) ) { return $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ tableName ] [ $ langKey ] ; } return $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ langKey ] ; }
5281	public function selectFunc ( $ func , $ field , $ alias = null ) { $ field = "$func({$field})" ; if ( ! is_null ( $ alias ) ) { $ field .= " as {$alias}" ; } $ this -> statements [ 'select' ] [ ] = $ field ; return $ this ; }
2065	public function checkJumpTo ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ varValue == $ dc -> id ) { throw new Exception ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'circularReference' ] ) ; } return $ varValue ; }
5707	public function getButtonLink ( ) { $ link = Controller :: join_links ( 'customaction' , $ this -> actionName ) ; return $ this -> gridFieldRequest -> Link ( $ link ) ; }
11471	public function edit ( ResponseRequest $ request , Response $ response ) { return $ this -> response -> title ( trans ( 'app.edit' ) . ' ' . trans ( 'forum::response.name' ) ) -> view ( 'forum::response.edit' , true ) -> data ( compact ( 'response' ) ) -> output ( ) ; }
1495	public static function createCustom ( ... $ mediaTypes ) : self { $ encodings = new self ( ) ; $ encodings -> stack = collect ( $ mediaTypes ) -> map ( function ( $ mediaType ) { return Encoding :: custom ( $ mediaType ) ; } ) -> all ( ) ; return $ encodings ; }
12362	public function database ( $ db ) { $ connection = $ this -> connection ; $ connection -> db = $ db ; $ this -> constructConnections = $ connection ; $ connection = class_exists ( "Clusterpoint\Connection" ) ? new Connection ( $ this -> constructConnections ) : new StandartConnection ( $ this -> constructConnections ) ; return new Service ( $ connection ) ; }
9736	public function setWorksheet ( Worksheet $ pValue = null , $ pOverrideOld = false ) { if ( $ this -> worksheet === null ) { $ this -> worksheet = $ pValue ; $ this -> worksheet -> getCell ( $ this -> coordinates ) ; $ this -> worksheet -> getDrawingCollection ( ) -> append ( $ this ) ; } else { if ( $ pOverrideOld ) { $ iterator = $ this -> worksheet -> getDrawingCollection ( ) -> getIterator ( ) ; while ( $ iterator -> valid ( ) ) { if ( $ iterator -> current ( ) -> getHashCode ( ) == $ this -> getHashCode ( ) ) { $ this -> worksheet -> getDrawingCollection ( ) -> offsetUnset ( $ iterator -> key ( ) ) ; $ this -> worksheet = null ; break ; } } $ this -> setWorksheet ( $ pValue ) ; } else { throw new PhpSpreadsheetException ( 'A Worksheet has already been assigned. Drawings can only exist on one \\PhpOffice\\PhpSpreadsheet\\Worksheet.' ) ; } } return $ this ; }
580	public static function current ( array $ params = [ ] , $ scheme = false ) { $ currentParams = Yii :: $ app -> getRequest ( ) -> getQueryParams ( ) ; $ currentParams [ 0 ] = '/' . Yii :: $ app -> controller -> getRoute ( ) ; $ route = array_replace_recursive ( $ currentParams , $ params ) ; return static :: toRoute ( $ route , $ scheme ) ; }
9470	protected function loadingGroups ( ) : void { foreach ( $ this -> groups as $ group ) { $ this -> addPattern ( $ group -> toArray ( ) ) ; } }
7934	public function alreadyLoaded ( $ name ) { foreach ( $ this -> loaded as $ item ) { if ( $ item [ 'name' ] === $ name ) { return true ; } } return false ; }
6044	public function view ( $ sessionId , $ mediaId ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'sessionId' => $ sessionId , 'mediaId' => $ mediaId ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/events/view' , $ parameters , true ) ; return $ result ; }
6035	public function setCommands ( array $ commands ) { $ this -> commands = [ ] ; foreach ( $ commands as $ item ) { $ this -> addCommand ( $ item ) ; } return $ this ; }
11634	public function bindPage ( array $ deviceIdentifier , array $ pageIds ) { $ params = [ 'device_identifier' => $ deviceIdentifier , 'page_ids' => $ pageIds , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_DEVICE_BINDPAGE , $ params ] ) ; }
11080	public static function getDayName ( $ day ) { if ( $ day < self :: DOW_MONDAY || $ day > self :: DOW_SUNDAY ) { return '' ; } $ dayNames = [ self :: DOW_MONDAY => self :: poorManTranslate ( 'fts-shared' , 'Monday' ) , self :: DOW_TUESDAY => self :: poorManTranslate ( 'fts-shared' , 'Tuesday' ) , self :: DOW_WEDNESDAY => self :: poorManTranslate ( 'fts-shared' , 'Wednesday' ) , self :: DOW_THURSDAY => self :: poorManTranslate ( 'fts-shared' , 'Thursday' ) , self :: DOW_FRIDAY => self :: poorManTranslate ( 'fts-shared' , 'Friday' ) , self :: DOW_SATURDAY => self :: poorManTranslate ( 'fts-shared' , 'Saturday' ) , self :: DOW_SUNDAY => self :: poorManTranslate ( 'fts-shared' , 'Sunday' ) , ] ; return $ dayNames [ $ day ] ; }
7334	private function getSubjectIdentityMapper ( EntityManagerInterface $ em ) { if ( null === $ this -> subjectIdentityMapper ) { $ this -> subjectIdentityMapper = new EmbeddableMapper ( $ em , SubjectIdentity :: class ) ; } return $ this -> subjectIdentityMapper ; }
3507	private function doDiff ( $ from_text , $ to_text ) { $ this -> last_edit = false ; $ this -> stackpointer = 0 ; $ this -> from_text = $ from_text ; $ this -> from_offset = 0 ; if ( empty ( $ this -> granularityStack ) ) { return ; } $ this -> _processGranularity ( $ from_text , $ to_text ) ; }
7919	protected function renderInput ( $ options = [ ] , $ resultsOptions = [ ] ) { Html :: addCssClass ( $ options , 'prompt' ) ; $ lines = [ ] ; $ input = $ this -> hasModel ( ) ? Html :: activeTextInput ( $ this -> model , $ this -> attribute , $ options ) : Html :: textInput ( $ this -> name , $ this -> value , $ options ) ; if ( ! empty ( $ this -> displayIcon ) ) { $ lines [ ] = Html :: beginTag ( 'div' , [ 'class' => 'ui icon input' ] ) ; $ lines [ ] = $ input ; $ lines [ ] = Html :: tag ( 'i' , '' , [ 'class' => 'icon search' ] ) ; $ lines [ ] = Html :: endTag ( 'div' ) ; } else { $ lines [ ] = $ input ; } $ lines [ ] = Html :: tag ( 'div' , '' , $ resultsOptions ) ; return implode ( "\n" , $ lines ) ; }
1621	public function buildColumn ( $ query , $ column ) { $ modelClass = $ query -> modelClass ; $ key = $ this -> quoteValue ( $ modelClass :: keyPrefix ( ) . ':a:' ) ; return $ this -> build ( $ query , "n=n+1 pks[n]=redis.call('HGET',$key .. pk," . $ this -> quoteValue ( $ column ) . ")" , 'pks' ) ; }
497	public function calculateTimings ( $ messages ) { $ timings = [ ] ; $ stack = [ ] ; foreach ( $ messages as $ i => $ log ) { list ( $ token , $ level , $ category , $ timestamp , $ traces ) = $ log ; $ memory = isset ( $ log [ 5 ] ) ? $ log [ 5 ] : 0 ; $ log [ 6 ] = $ i ; $ hash = md5 ( json_encode ( $ token ) ) ; if ( $ level == self :: LEVEL_PROFILE_BEGIN ) { $ stack [ $ hash ] = $ log ; } elseif ( $ level == self :: LEVEL_PROFILE_END ) { if ( isset ( $ stack [ $ hash ] ) ) { $ timings [ $ stack [ $ hash ] [ 6 ] ] = [ 'info' => $ stack [ $ hash ] [ 0 ] , 'category' => $ stack [ $ hash ] [ 2 ] , 'timestamp' => $ stack [ $ hash ] [ 3 ] , 'trace' => $ stack [ $ hash ] [ 4 ] , 'level' => count ( $ stack ) - 1 , 'duration' => $ timestamp - $ stack [ $ hash ] [ 3 ] , 'memory' => $ memory , 'memoryDiff' => $ memory - ( isset ( $ stack [ $ hash ] [ 5 ] ) ? $ stack [ $ hash ] [ 5 ] : 0 ) , ] ; unset ( $ stack [ $ hash ] ) ; } } } ksort ( $ timings ) ; return array_values ( $ timings ) ; }
6228	protected function goToIFDEntries ( ) { fseek ( $ this -> FileResource , 4 ) ; $ ifdOffsetFormat = $ this -> isLittleEndian ( ) ? 'VIFDoffset' : 'NIFDoffset' ; $ data = unpack ( $ ifdOffsetFormat , fread ( $ this -> FileResource , 4 ) ) ; fseek ( $ this -> FileResource , $ data [ 'IFDoffset' ] ) ; }
3339	public function getGroupsChunk ( $ options = array ( ) , $ reverse = false ) { $ data = $ this -> __preparedRequest ( 'group_list' , 'GET' , $ options ) ; $ groups_raw = ( array ) $ data -> results ; $ resultArr = array ( ) ; foreach ( $ groups_raw as $ group_raw ) { $ resultArr [ ] = new Group ( $ group_raw -> id , $ this ) ; } return $ this -> __preparePagedParams ( $ data , $ reverse , $ resultArr ) ; }
11437	protected function init ( array $ options = null ) { $ this -> boot ( ) ; if ( ! is_null ( $ options ) ) { $ this -> setOptions ( array_merge ( $ this -> getOptions ( ) , $ options ) ) ; } }
5609	public function paintGroupStart ( $ message , $ size ) { parent :: paintGroupStart ( $ message , $ size ) ; $ node = new TreemapNode ( 'Group' , $ message ) ; $ this -> _stack -> push ( $ node ) ; }
8409	public static function clear ( ) { $ keys = array_keys ( $ _COOKIE ) ; foreach ( $ keys as $ key ) { setcookie ( $ key , '' , time ( ) - 1 ) ; } }
2359	public function isPreviewMode ( ) : bool { $ token = $ this -> getToken ( FrontendUser :: SECURITY_SESSION_KEY ) ; return $ token instanceof FrontendPreviewToken && $ token -> showUnpublished ( ) ; }
8219	protected function getIp ( $ config ) { $ remoteAddr = $ _SERVER [ 'REMOTE_ADDR' ] ; if ( filter_var ( $ remoteAddr , FILTER_VALIDATE_IP , FILTER_FLAG_IPV4 ) ) { $ netmask = ( isset ( $ config [ "netmask_IPv4" ] ) ) ? $ config [ "netmask_IPv4" ] : self :: DEFAULT_NETMASK_IPV4 ; } else { $ netmask = ( isset ( $ config [ "netmask_IPv6" ] ) ) ? $ config [ "netmask_IPv6" ] : self :: DEFAULT_NETMASK_IPV6 ; } $ ipSubnet = $ this -> getSubnet ( $ remoteAddr , $ netmask ) ; return $ ipSubnet ; }
8157	public function prependPath ( $ path , $ namespace = self :: MAIN_NAMESPACE ) { $ this -> cache = $ this -> errorCache = array ( ) ; $ checkPath = $ this -> isAbsolutePath ( $ path ) ? $ path : $ this -> rootPath . $ path ; if ( ! is_dir ( $ checkPath ) ) { throw new Twig_Error_Loader ( sprintf ( 'The "%s" directory does not exist ("%s").' , $ path , $ checkPath ) ) ; } $ path = rtrim ( $ path , '/\\' ) ; if ( ! isset ( $ this -> paths [ $ namespace ] ) ) { $ this -> paths [ $ namespace ] [ ] = $ path ; } else { array_unshift ( $ this -> paths [ $ namespace ] , $ path ) ; } }
3134	public function getItemData ( RunnerServiceContext $ context , $ itemRef ) { if ( $ context instanceof QtiRunnerServiceContext ) { return $ this -> loadItemData ( $ itemRef , QtiJsonItemCompiler :: ITEM_FILE_NAME ) ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'getItemData' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } }
9510	public function download ( Log $ log ) { $ this -> authorize ( LogViewerPolicy :: PERMISSION_DOWNLOAD ) ; return $ this -> logViewer -> download ( $ log -> date ) ; }
9691	private function compile ( $ file ) { if ( ! file_exists ( $ file ) ) { throw new \ Exception ( "Could not compile $file, file not found" ) ; } if ( ! file_exists ( $ this -> views_cache ) && ! mkdir ( $ this -> views_cache ) ) { throw new \ Exception ( "Could no create cache directory." . " Make sure you have write permissions." ) ; } $ hash = md5 ( $ file ) ; $ compiled_file = $ this -> views_cache . '/' . $ hash ; $ compiled = null ; if ( $ this -> debug || ( ! file_exists ( $ compiled_file ) || filemtime ( $ compiled_file ) < filemtime ( $ file ) ) ) { $ source = file_get_contents ( $ file ) ; $ compiled = $ this -> compileString ( $ source ) ; $ compiled = "<?php\nfunction katar_" . $ hash . "(\$args) {\nextract(\$args);\n\$output = null;\n" . $ compiled . "\nreturn \$output;\n}\n" ; file_put_contents ( $ compiled_file , $ compiled ) ; } else { $ compiled = file_get_contents ( $ cache_file ) ; } return $ compiled ; }
3343	public function createLocalCopy ( $ source , $ store = true ) { $ data = $ this -> __preparedRequest ( 'file_copy' , 'POST' , array ( ) , array ( 'source' => $ source , 'store' => $ store ) ) ; if ( array_key_exists ( 'result' , ( array ) $ data ) == true ) { if ( $ data -> type == 'file' ) { return new File ( ( string ) $ data -> result -> uuid , $ this ) ; } else { return ( string ) $ data -> result ; } } else { return ( string ) $ data -> detail ; } }
9650	public function delete ( ) { $ options = $ this -> Options ( ) ; if ( $ options ) { foreach ( $ options as $ option ) { $ option -> delete ( ) ; } } parent :: delete ( ) ; }
10590	public static function isTypeOf ( FormInterface $ form , $ typeName ) { $ typeNames = ( array ) $ typeName ; $ type = $ form -> getConfig ( ) -> getType ( ) ; while ( $ type ) { $ actualTypeName = $ type -> getName ( ) ; if ( in_array ( $ actualTypeName , $ typeNames , true ) ) { return true ; } $ type = $ type -> getParent ( ) ; } return false ; }
9794	public function getDataValidation ( ) { if ( ! isset ( $ this -> parent ) ) { throw new Exception ( 'Cannot get data validation for cell that is not bound to a worksheet' ) ; } return $ this -> getWorksheet ( ) -> getDataValidation ( $ this -> getCoordinate ( ) ) ; }
882	private function normalizeType ( $ type ) { if ( '[]' === substr ( $ type , - 2 ) ) { return $ this -> normalize ( substr ( $ type , 0 , - 2 ) ) . '[]' ; } return $ this -> normalize ( $ type ) ; }
2057	public function checkRootType ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ varValue != 'root' && $ dc -> activeRecord -> pid == 0 ) { throw new Exception ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'topLevelRoot' ] ) ; } return $ varValue ; }
2396	protected function unixToHex ( $ intTime = 0 ) { $ arrTime = $ intTime ? getdate ( $ intTime ) : getdate ( ) ; $ hexTime = dechex ( ( ( $ arrTime [ 'year' ] - 1980 ) << 25 ) | ( $ arrTime [ 'mon' ] << 21 ) | ( $ arrTime [ 'mday' ] << 16 ) | ( $ arrTime [ 'hours' ] << 11 ) | ( $ arrTime [ 'minutes' ] << 5 ) | ( $ arrTime [ 'seconds' ] >> 1 ) ) ; return pack ( "H*" , $ hexTime [ 6 ] . $ hexTime [ 7 ] . $ hexTime [ 4 ] . $ hexTime [ 5 ] . $ hexTime [ 2 ] . $ hexTime [ 3 ] . $ hexTime [ 0 ] . $ hexTime [ 1 ] ) ; }
11813	public function lists ( $ type , $ offset = 0 , $ count = 20 ) { $ params = [ 'type' => $ type , 'offset' => intval ( $ offset ) , 'count' => min ( 20 , $ count ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_LISTS , $ params ] ) ; }
6167	protected function writePerformance ( $ time ) { $ ms = round ( $ time * 1000 ) ; foreach ( self :: $ performanceThresholds as $ colour => $ threshold ) { if ( $ ms > $ threshold ) { break ; } } $ this -> writeWithColor ( $ colour , " ($ms ms)" ) ; }
11647	function parseAndAddServiceFromFile ( $ serviceFilename ) { $ service = require $ serviceFilename ; if ( $ service == false ) { throw new APIBuilderException ( "Failed to open service file `$serviceFilename`." ) ; } if ( is_array ( $ service ) == false ) { throw new APIBuilderException ( "File `$serviceFilename` did not return a service array. Cannot build API from it." ) ; } $ this -> parseAndAddService ( $ service ) ; }
6810	public function rates ( Adjustment ... $ adjustments ) : string { return implode ( ', ' , array_map ( function ( Adjustment $ adjustment ) { return $ this -> percent ( $ adjustment -> getRate ( ) ) ; } , $ adjustments ) ) ; }
12417	static function run_copy_paste_report ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getReportDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; $ phpcpd = self :: getTool ( 'phpcpd' , $ opts , true ) ; try { $ out = pake_sh ( "$phpcpd " . escapeshellarg ( self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ) ) ; } catch ( pakeException $ e ) { $ out = preg_replace ( '/^Problem executing command/' , '' , $ e -> getMessage ( ) ) ; } pake_mkdirs ( $ destdir ) ; pake_write_file ( $ destdir . '/phpcpd.txt' , $ out , true ) ; SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; }
2152	public function synchronize ( $ varValue , $ objUser , $ objModule = null ) { if ( $ objUser === null ) { return $ varValue ; } $ blnIsFrontend = true ; if ( $ objUser instanceof DataContainer ) { $ objUser = $ this -> Database -> prepare ( "SELECT * FROM tl_member WHERE id=?" ) -> limit ( 1 ) -> execute ( $ objUser -> id ) ; if ( $ objUser -> numRows < 1 ) { return $ varValue ; } $ blnIsFrontend = false ; } if ( $ varValue == $ objUser -> newsletter || $ objUser -> email == '' ) { return $ varValue ; } $ time = time ( ) ; $ varValue = StringUtil :: deserialize ( $ varValue , true ) ; if ( $ blnIsFrontend && $ objModule instanceof Module ) { $ arrChannel = StringUtil :: deserialize ( $ objModule -> newsletters , true ) ; } else { $ arrChannel = $ this -> Database -> query ( "SELECT id FROM tl_newsletter_channel" ) -> fetchEach ( 'id' ) ; } $ arrDelete = array_values ( array_diff ( $ arrChannel , $ varValue ) ) ; if ( ! empty ( $ arrDelete ) && \ is_array ( $ arrDelete ) ) { $ this -> Database -> prepare ( "DELETE FROM tl_newsletter_recipients WHERE pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrDelete ) ) . ") AND email=?" ) -> execute ( $ objUser -> email ) ; } foreach ( $ varValue as $ intId ) { $ intId = ( int ) $ intId ; if ( $ intId < 1 ) { continue ; } $ objRecipient = $ this -> Database -> prepare ( "SELECT COUNT(*) AS count FROM tl_newsletter_recipients WHERE pid=? AND email=?" ) -> execute ( $ intId , $ objUser -> email ) ; if ( $ objRecipient -> count < 1 ) { $ this -> Database -> prepare ( "INSERT INTO tl_newsletter_recipients SET pid=?, tstamp=$time, email=?, active=?, addedOn=?" ) -> execute ( $ intId , $ objUser -> email , ( $ objUser -> disable ? '' : 1 ) , ( $ blnIsFrontend ? $ time : '' ) ) ; } } return serialize ( $ varValue ) ; }
2488	protected function getSortFieldName ( SortClause $ sortClause , $ contentTypeIdentifier , $ fieldDefinitionIdentifier ) { return $ this -> fieldNameResolver -> getSortFieldName ( $ sortClause , $ contentTypeIdentifier , $ fieldDefinitionIdentifier ) ; }
6236	public static function try ( array $ paths ) : Storage { foreach ( $ paths as $ diskpath ) { if ( is_string ( $ diskpath ) ) { if ( file_exists ( $ diskpath ) ) { return new Storage \ Disk ( $ diskpath ) ; } } elseif ( $ diskpath instanceof Path ) { if ( $ diskpath -> fileInfo ( ) -> isFile ( ) || $ diskpath -> fileInfo ( ) -> isDir ( ) ) { return new Storage \ Disk ( $ diskpath ) ; } } elseif ( $ diskpath instanceof Storage ) { if ( $ diskpath -> isFile ( ) || $ diskpath -> isDir ( ) ) { return $ diskpath ; } } elseif ( $ diskpath instanceof FileSystem ) { if ( $ diskpath -> isFile ( ) || $ diskpath -> isDir ( ) ) { return $ diskpath -> storage ( ) ; } } else { throw new UnexpectedValueException ( sprintf ( 'invalid search-path of type \'%s\'' , is_object ( $ diskpath ) ? get_class ( $ diskpath ) : gettype ( $ diskpath ) ) , 500 ) ; } } throw new FileNotFoundException ( 'file not found' , 404 ) ; }
1274	private function createRequestLandedCost ( LandedCostRequest $ landedCostRequest ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ tradeabilityRequest = $ xml -> appendChild ( $ xml -> createElement ( 'LandedCostRequest' ) ) ; $ tradeabilityRequest -> setAttribute ( 'xml:lang' , 'en-US' ) ; $ request = $ tradeabilityRequest -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , 'LandedCost' ) ) ; if ( $ landedCostRequest -> getQueryRequest ( ) !== null ) { $ tradeabilityRequest -> appendChild ( $ landedCostRequest -> getQueryRequest ( ) -> toNode ( $ xml ) ) ; } return $ xml -> saveXML ( ) ; }
5075	public function writeLog ( $ sLine ) { if ( ! is_string ( $ sLine ) ) { $ sLine = print_r ( $ sLine , true ) ; } $ sLine = ' [' . $ this -> sModuleName . '->' . $ this -> sMethod . '] ' . $ sLine ; $ this -> oLogger -> line ( $ sLine ) ; }
7294	public function inform_about_posts ( $ post_id = FALSE ) { if ( ! $ post_id ) { return $ post_id ; } if ( ! isset ( $ this -> transit_posts [ $ post_id ] ) ) { return $ post_id ; } $ transit = $ this -> transit_posts [ $ post_id ] ; if ( 'publish' != $ transit [ 'new_status' ] || 'publish' == $ transit [ 'old_status' ] ) { return $ post_id ; } $ post_data = get_post ( $ post_id ) ; $ user = get_userdata ( $ post_data -> post_author ) ; $ to = $ this -> get_members ( $ user -> data -> user_email , 'post' ) ; if ( empty ( $ to ) ) { return $ post_id ; } $ subject = get_option ( 'blogname' ) . ': ' . get_the_title ( $ post_data -> ID ) ; $ message = $ post_data -> post_content ; $ headers = array ( ) ; $ headers [ 'From' ] = get_the_author_meta ( 'display_name' , $ user -> ID ) . ' (' . get_bloginfo ( 'name' ) . ')' . ' <' . $ user -> data -> user_email . '>' ; if ( $ this -> options [ 'send_by_bcc' ] ) { $ bcc = $ to ; $ to = empty ( $ this -> options [ 'bcc_to_recipient' ] ) ? get_bloginfo ( 'admin_email' ) : $ this -> options [ 'bcc_to_recipient' ] ; $ headers [ 'Bcc' ] = $ bcc ; } $ to = apply_filters ( 'iac_post_to' , $ to , $ this -> options , $ post_id ) ; $ subject = apply_filters ( 'iac_post_subject' , $ subject , $ this -> options , $ post_id ) ; $ message = apply_filters ( 'iac_post_message' , $ message , $ this -> options , $ post_id ) ; $ headers = apply_filters ( 'iac_post_headers' , $ headers , $ this -> options , $ post_id ) ; $ attachments = apply_filters ( 'iac_post_attachments' , array ( ) , $ this -> options , $ post_id ) ; $ signature = apply_filters ( 'iac_post_signature' , '' , $ this -> options , $ post_id ) ; $ this -> options [ 'static_options' ] [ 'object' ] = array ( 'id' => $ post_id , 'type' => 'post' ) ; $ this -> send_mail ( $ to , $ subject , $ this -> append_signature ( $ message , $ signature ) , $ headers , $ attachments ) ; return $ post_id ; }
6449	private function compareAcceptLanguageHeaders ( AcceptLanguageHeaderValue $ a , AcceptLanguageHeaderValue $ b ) : int { $ aQuality = $ a -> getQuality ( ) ; $ bQuality = $ b -> getQuality ( ) ; if ( $ aQuality < $ bQuality ) { return 1 ; } if ( $ aQuality > $ bQuality ) { return - 1 ; } $ aValue = $ a -> getLanguage ( ) ; $ bValue = $ b -> getLanguage ( ) ; if ( $ aValue === '*' ) { if ( $ bValue === '*' ) { return 0 ; } return 1 ; } if ( $ bValue === '*' ) { return - 1 ; } return 0 ; }
2036	public function getAbsoluteUrl ( $ strParams = null ) { $ this -> loadDetails ( ) ; $ objUrlGenerator = System :: getContainer ( ) -> get ( 'contao.routing.url_generator' ) ; $ strUrl = $ objUrlGenerator -> generate ( ( $ this -> alias ? : $ this -> id ) . $ strParams , array ( '_locale' => $ this -> rootLanguage , '_domain' => $ this -> domain , '_ssl' => ( bool ) $ this -> rootUseSSL , ) , UrlGeneratorInterface :: ABSOLUTE_URL ) ; $ strUrl = $ this -> applyLegacyLogic ( $ strUrl , $ strParams ) ; return $ strUrl ; }
1085	private function parseName ( ) { $ token = $ this -> expect ( Token :: NAME ) ; return new NameNode ( [ 'value' => $ token -> value , 'loc' => $ this -> loc ( $ token ) , ] ) ; }
8653	private function convertUpdateReportAcknowledgements ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'UpdateReportAcknowledgements' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetReportIdList ( ) ) { $ reportIdList = $ request -> getReportIdList ( ) ; foreach ( $ reportIdList -> getId ( ) as $ idIndex => $ id ) { $ parameters [ 'ReportIdList' . '.' . 'Id' . '.' . ( $ idIndex + 1 ) ] = $ id ; } } if ( $ request -> isSetAcknowledged ( ) ) { $ parameters [ 'Acknowledged' ] = $ request -> getAcknowledged ( ) ? "true" : "false" ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
2126	protected function handleCss ( $ content , $ arrFile ) { $ content = $ this -> fixPaths ( $ content , $ arrFile ) ; if ( $ arrFile [ 'media' ] != '' && $ arrFile [ 'media' ] != 'all' && strpos ( $ content , '@media' ) === false ) { $ content = '@media ' . $ arrFile [ 'media' ] . "{\n" . $ content . "\n}" ; } return $ content ; }
4009	public function collectMetaModelAttributeInformation ( CollectMetaModelAttributeInformationEvent $ event ) { $ metaModelName = $ event -> getMetaModel ( ) -> getTableName ( ) ; if ( ! array_key_exists ( $ metaModelName , $ this -> attributeInformation ) ) { $ attributes = $ this -> database -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel_attribute' ) -> where ( 'pid=:pid' ) -> setParameter ( 'pid' , $ event -> getMetaModel ( ) -> get ( 'id' ) ) -> orderBy ( 'sorting' ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; $ this -> attributeInformation [ $ metaModelName ] = [ ] ; foreach ( $ attributes as $ attribute ) { $ colName = $ attribute [ 'colname' ] ; $ this -> attributeInformation [ $ metaModelName ] [ $ colName ] = $ attribute ; } } foreach ( $ this -> attributeInformation [ $ metaModelName ] as $ name => $ information ) { $ event -> addAttributeInformation ( $ name , $ information ) ; } }
8859	private function _hardCopy ( string $ originDir , string $ targetDir ) : string { $ this -> filesystem -> mkdir ( $ targetDir , 0777 ) ; $ this -> filesystem -> mirror ( $ originDir , $ targetDir , Finder :: create ( ) -> ignoreDotFiles ( false ) -> in ( $ originDir ) ) ; return AssetsInstallCommand :: METHOD_COPY ; }
10704	public function getModel ( ) { if ( null === $ this -> model ) { $ mainService = $ this -> getServiceLocator ( ) -> get ( 'neobazaar.service.main' ) ; $ this -> model = $ mainService -> getUserEntityRepository ( ) ; } return $ this -> model ; }
205	public static function wrapText ( $ text , $ indent = 0 , $ refresh = false ) { $ size = static :: getScreenSize ( $ refresh ) ; if ( $ size === false || $ size [ 0 ] <= $ indent ) { return $ text ; } $ pad = str_repeat ( ' ' , $ indent ) ; $ lines = explode ( "\n" , wordwrap ( $ text , $ size [ 0 ] - $ indent , "\n" , true ) ) ; $ first = true ; foreach ( $ lines as $ i => $ line ) { if ( $ first ) { $ first = false ; continue ; } $ lines [ $ i ] = $ pad . $ line ; } return implode ( "\n" , $ lines ) ; }
6158	protected function renderItem ( $ link , $ template ) { if ( isset ( $ link [ 'label' ] ) ) { $ label = $ this -> encodeLabels ? Html :: encode ( $ link [ 'label' ] ) : $ link [ 'label' ] ; } else { throw new InvalidConfigException ( 'The "label" element is required for each link.' ) ; } if ( $ link [ 'options' ] [ 'class' ] ) { $ label = Html :: tag ( 'i' , '' , $ link [ 'options' ] ) . $ label ; } if ( isset ( $ link [ 'url' ] ) ) { return strtr ( $ template , [ '{link}' => Html :: a ( $ label , $ link [ 'url' ] ) ] ) ; } else { return strtr ( $ template , [ '{link}' => $ label ] ) ; } }
11963	private function setParam ( $ key , $ value , $ allowed_keys ) { if ( in_array ( $ key , $ allowed_keys ) ) { $ this -> { $ key } = $ value ; } }
6261	public function getActionMap ( ) { $ actionMap = ( array ) Configure :: read ( 'SimpleRbac.actionMap' ) ; if ( empty ( $ actionMap ) && $ this -> _config [ 'allowEmptyActionMap' ] === false ) { throw new \ RuntimeException ( 'SimpleRbac.actionMap configuration is empty!' ) ; } return $ actionMap ; }
5286	private function reset ( ) { $ this -> distinct = false ; $ this -> found_rows = false ; $ this -> limit = null ; $ this -> statements = [ 'select' => [ ] , 'wheres' => [ ] , 'orders' => [ ] , 'values' => [ ] , 'groups' => [ ] , 'having' => '' , ] ; return $ this ; }
3703	protected function getProperty ( $ name , $ legend ) { foreach ( $ legend -> getProperties ( ) as $ property ) { if ( $ property -> getName ( ) === $ name ) { return $ property ; } } $ property = new Property ( $ name ) ; $ legend -> addProperty ( $ property ) ; return $ property ; }
5892	public static function logEntry ( $ entry ) { $ parts = explode ( "|" , $ entry , 5 ) ; $ array = array ( ) ; if ( count ( $ parts ) != 5 ) { $ array [ "timestamp" ] = 0 ; $ array [ "level" ] = TeamSpeak3 :: LOGLEVEL_ERROR ; $ array [ "channel" ] = "ParamParser" ; $ array [ "server_id" ] = "" ; $ array [ "msg" ] = StringHelper :: factory ( "convert error (" . trim ( $ entry ) . ")" ) ; $ array [ "msg_plain" ] = $ entry ; $ array [ "malformed" ] = true ; } else { $ array [ "timestamp" ] = strtotime ( trim ( $ parts [ 0 ] ) ) ; $ array [ "level" ] = self :: logLevel ( trim ( $ parts [ 1 ] ) ) ; $ array [ "channel" ] = trim ( $ parts [ 2 ] ) ; $ array [ "server_id" ] = trim ( $ parts [ 3 ] ) ; $ array [ "msg" ] = StringHelper :: factory ( trim ( $ parts [ 4 ] ) ) ; $ array [ "msg_plain" ] = $ entry ; $ array [ "malformed" ] = false ; } return $ array ; }
4331	public static function unserializeLog ( $ str ) { $ strStart = 'START DEBUG' ; $ strEnd = 'END DEBUG' ; if ( \ preg_match ( '/' . $ strStart . '[\r\n]+(.+)[\r\n]+' . $ strEnd . '/s' , $ str , $ matches ) ) { $ str = $ matches [ 1 ] ; } $ str = self :: isBase64Encoded ( $ str ) ? \ base64_decode ( $ str ) : false ; if ( $ str && \ function_exists ( 'gzinflate' ) ) { $ strInflated = \ gzinflate ( $ str ) ; if ( $ strInflated ) { $ str = $ strInflated ; } } $ data = \ unserialize ( $ str ) ; return $ data ; }
8844	private function log ( string $ message , array $ context = [ ] ) : void { $ this -> logger -> log ( $ this -> logLevel , $ message , $ context ) ; }
1057	public static function findTypesThatChangedKind ( Schema $ schemaA , Schema $ schemaB ) : iterable { $ schemaATypeMap = $ schemaA -> getTypeMap ( ) ; $ schemaBTypeMap = $ schemaB -> getTypeMap ( ) ; $ breakingChanges = [ ] ; foreach ( $ schemaATypeMap as $ typeName => $ schemaAType ) { if ( ! isset ( $ schemaBTypeMap [ $ typeName ] ) ) { continue ; } $ schemaBType = $ schemaBTypeMap [ $ typeName ] ; if ( $ schemaAType instanceof $ schemaBType ) { continue ; } if ( $ schemaBType instanceof $ schemaAType ) { continue ; } $ schemaATypeKindName = self :: typeKindName ( $ schemaAType ) ; $ schemaBTypeKindName = self :: typeKindName ( $ schemaBType ) ; $ breakingChanges [ ] = [ 'type' => self :: BREAKING_CHANGE_TYPE_CHANGED_KIND , 'description' => "${typeName} changed from ${schemaATypeKindName} to ${schemaBTypeKindName}." , ] ; } return $ breakingChanges ; }
8341	public static function init ( ) { if ( self :: $ isInit === false ) { self :: $ prettyPageHandler = new PrettyPageHandler ( ) ; self :: $ prettyPageHandler -> setPageTitle ( 'I just broke a string... - strayFw' ) ; $ whoops = new Run ( ) ; $ whoops -> pushHandler ( new JsonResponseHandler ( ) ) ; $ whoops -> pushHandler ( self :: $ prettyPageHandler ) ; $ whoops -> register ( ) ; self :: $ isInit = true ; } }
11132	public function exec ( ) { if ( $ this -> customQuery ) { return $ this -> execCustom ( ) ; } $ this -> last_wheres = $ this -> wheres ; $ this -> last_distinct = $ this -> distinct ; $ this -> last_ins = $ this -> ins ; $ this -> last_groupBys = $ this -> groupBys ; $ this -> last_havings = $ this -> havings ; $ this -> last_joins = $ this -> joins ; $ this -> calculate ( ) ; try { $ result = $ this -> db -> query ( $ this -> query ) ; } catch ( \ PDOException $ e ) { if ( $ this -> config [ 'mode' ] == 'development' ) { echo $ this -> getQuery ( ) ; } $ this -> reset ( ) ; throw $ e ; } $ this -> reset ( ) ; $ dbResult = new Db_MySQLResult ( $ result , $ this -> db ) ; return $ dbResult ; }
5981	protected function buildBasepath ( $ url ) { if ( ! preg_match ( '#(\w+:)?//#' , $ url ) ) { $ url = '//' . $ url ; } $ urlParts = parse_url ( $ url ) ; if ( false === $ urlParts ) { throw new \ InvalidArgumentException ( 'Could not parse QBank URL.' ) ; } if ( empty ( $ urlParts [ 'scheme' ] ) ) { $ urlParts [ 'scheme' ] = 'http' ; } if ( ( empty ( $ urlParts [ 'path' ] ) || '/' == $ urlParts [ 'path' ] ) && 'qbank.se' == substr ( $ urlParts [ 'host' ] , - strlen ( 'qbank.se' ) ) ) { $ urlParts [ 'path' ] = '/api/' ; } if ( '/' != substr ( $ urlParts [ 'path' ] , - 1 ) ) { $ urlParts [ 'path' ] .= '/' ; } return $ urlParts [ 'scheme' ] . '://' . $ urlParts [ 'host' ] . ( ! empty ( $ urlParts [ 'port' ] ) ? ':' . $ urlParts [ 'port' ] : '' ) . $ urlParts [ 'path' ] ; }
217	public function asImage ( $ value , $ options = [ ] ) { if ( $ value === null ) { return $ this -> nullDisplay ; } return Html :: img ( $ value , $ options ) ; }
12418	static function run_php_loc_report ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getReportDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; $ phploc = self :: getTool ( 'phploc' , $ opts , true ) ; $ out = pake_sh ( "$phploc -n " . escapeshellarg ( self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ) ) ; pake_mkdirs ( $ destdir ) ; pake_write_file ( $ destdir . '/phploc.txt' , $ out , true ) ; SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; }
6145	public function checkFragment ( $ fragment = null ) { if ( $ fragment === null ) { $ fragment = $ this -> fragment ; } if ( strlen ( $ fragment ) == 0 ) { return true ; } $ pattern = "/^" . $ this -> regex [ "uric" ] . "*$/" ; $ status = @ preg_match ( $ pattern , $ fragment ) ; if ( $ status === false ) { throw new Ts3Exception ( "URI fragment validation failed" ) ; } return ( $ status == 1 ) ; }
12940	private function assertClient ( ClientInterface $ client ) { if ( $ client -> getConnection ( ) instanceof AggregateConnectionInterface ) { throw new NotSupportedException ( 'Cannot initialize a monitor consumer over aggregate connections.' ) ; } if ( $ client -> getCommandFactory ( ) -> supportsCommand ( 'MONITOR' ) === false ) { throw new NotSupportedException ( "'MONITOR' is not supported by the current command factory." ) ; } }
6216	public static function realmNameToSlug ( string $ name ) : string { $ name = \ mb_strtolower ( $ name , 'UTF-8' ) ; $ slug = \ str_replace ( static :: $ replaceTable [ 0 ] , static :: $ replaceTable [ 1 ] , $ name ) ; $ slug = \ preg_replace ( static :: $ regexTable [ 0 ] , static :: $ regexTable [ 1 ] , $ slug ) ; return \ trim ( ( string ) $ slug , '-' ) ; }
2587	protected function loadCreatePnr ( PnrCreatePnrOptions $ params ) { $ this -> pnrActions = new AddMultiElements \ PnrActions ( $ params -> actionCode ) ; $ tattooCounter = 0 ; if ( $ params -> travellerGroup !== null ) { $ this -> addTravellerGroup ( $ params -> travellerGroup ) ; } else { $ this -> addTravellers ( $ params -> travellers ) ; } $ this -> addItineraries ( $ params -> itineraries , $ params -> tripSegments , $ tattooCounter ) ; $ this -> addElements ( $ params -> elements , $ tattooCounter , $ params -> autoAddReceivedFrom , $ params -> defaultReceivedFrom , $ params -> receivedFrom ) ; }
8697	protected function validateMandatoryAttribs ( ) { foreach ( static :: $ mandatoryFields as $ field ) { if ( ! array_key_exists ( $ field , $ this -> attributes ) ) { throw new \ SVGCreator \ SVGException ( "The field " . $ field . " does not exist for " . static :: TYPE . "." , 1 ) ; } } }
12499	public static function insertMany ( $ document , $ connection ) { if ( gettype ( $ document ) != "array" && gettype ( $ document ) != "object" ) { throw new ClusterpointException ( "\"->insert()\" function: parametr passed " . json_encode ( self :: escape_string ( $ document ) ) . " is not in valid document format." , 9002 ) ; } if ( gettype ( $ document ) == "object" ) { $ document_array = array ( ) ; foreach ( $ document as $ value ) { $ document_array [ ] = $ value ; } $ document = $ document_array ; } $ connection -> query = json_encode ( array_values ( $ document ) ) ; $ connection -> multiple = true ; return self :: insert ( $ connection ) ; }
12104	public function handleRequest ( ) : void { global $ argv ; if ( ! is_array ( $ argv ) || empty ( $ argv ) ) { throw new Exception ( 'Invalid value of the cli args array was given.' ) ; } ( new CliCtrlResolver ( $ argv ) ) -> run ( ) ; }
9622	public function getPdo ( $ connection = null ) { if ( $ connection === null ) { $ connection = $ this -> defaultConnection ; } if ( isset ( $ this -> instances [ $ connection ] ) ) { return $ this -> instances [ $ connection ] ; } $ config = $ this -> getConnectionConfig ( $ connection ) ; return $ this -> instances [ $ connection ] = $ this -> factory -> makePdo ( $ config , $ connection ) ; }
1032	private function completeValue ( Type $ returnType , $ fieldNodes , ResolveInfo $ info , $ path , & $ result ) { $ promise = $ this -> getPromise ( $ result ) ; if ( $ promise ) { return $ promise -> then ( function ( & $ resolved ) use ( $ returnType , $ fieldNodes , $ info , $ path ) { return $ this -> completeValue ( $ returnType , $ fieldNodes , $ info , $ path , $ resolved ) ; } ) ; } if ( $ result instanceof Exception || $ result instanceof Throwable ) { throw $ result ; } if ( $ returnType instanceof NonNull ) { $ completed = $ this -> completeValue ( $ returnType -> getWrappedType ( ) , $ fieldNodes , $ info , $ path , $ result ) ; if ( $ completed === null ) { throw new InvariantViolation ( 'Cannot return null for non-nullable field ' . $ info -> parentType . '.' . $ info -> fieldName . '.' ) ; } return $ completed ; } if ( $ result === null ) { return null ; } if ( $ returnType instanceof ListOfType ) { return $ this -> completeListValue ( $ returnType , $ fieldNodes , $ info , $ path , $ result ) ; } if ( $ returnType !== $ this -> exeContext -> schema -> getType ( $ returnType -> name ) ) { $ hint = '' ; if ( $ this -> exeContext -> schema -> getConfig ( ) -> typeLoader ) { $ hint = sprintf ( 'Make sure that type loader returns the same instance as defined in %s.%s' , $ info -> parentType , $ info -> fieldName ) ; } throw new InvariantViolation ( sprintf ( 'Schema must contain unique named types but contains multiple types named "%s". %s ' . '(see http://webonyx.github.io/graphql-php/type-system/#type-registry).' , $ returnType , $ hint ) ) ; } if ( $ returnType instanceof LeafType ) { return $ this -> completeLeafValue ( $ returnType , $ result ) ; } if ( $ returnType instanceof AbstractType ) { return $ this -> completeAbstractValue ( $ returnType , $ fieldNodes , $ info , $ path , $ result ) ; } if ( $ returnType instanceof ObjectType ) { return $ this -> completeObjectValue ( $ returnType , $ fieldNodes , $ info , $ path , $ result ) ; } throw new RuntimeException ( sprintf ( 'Cannot complete value of unexpected type "%s".' , $ returnType ) ) ; }
9743	public function setCountry ( $ country ) { if ( ! ( $ country instanceof Country ) ) { $ country = new Country ( $ country ) ; } if ( $ country -> isEmpty ( ) ) { $ this -> invalidArguments ( '10001' ) ; } return $ this -> setParameter ( 'country' , $ country ) ; }
2621	public function sendValidationRequest ( $ validatedFlag , $ serviceId = null ) { if ( $ serviceId != null ) { $ this -> validationServiceId = $ serviceId ; } if ( $ validatedFlag ) { $ validationState = self :: FASTLY_VALIDATED_FLAG ; } else { $ validationState = self :: FASTLY_NON_VALIDATED_FLAG ; } $ pageViewParams = [ 'dl' => self :: GA_PAGEVIEW_URL . $ validationState , 'dh' => preg_replace ( '#^https?://#' , '' , rtrim ( self :: GA_PAGEVIEW_URL , '/' ) ) , 'dp' => '/' . $ validationState , 'dt' => ucfirst ( $ validationState ) , 't' => self :: GA_HITTYPE_PAGEVIEW , ] ; $ this -> sendReqToGA ( $ pageViewParams ) ; $ eventParams = [ 'ec' => self :: GA_FASTLY_SETUP , 'ea' => 'Fastly ' . $ validationState , 'el' => $ this -> getWebsiteName ( ) , 'ev' => $ this -> daysFromInstallation ( ) , 't' => self :: GA_HITTYPE_EVENT ] ; $ result = $ this -> sendReqToGA ( array_merge ( $ pageViewParams , $ eventParams ) ) ; return $ result ; }
7830	public function getRightBordersWith ( $ border ) { $ space = str_repeat ( ' ' , static :: MIN_SPACE_FROM_BORDER_X ) ; $ border = str_repeat ( $ border , static :: BORDER_WIDTH ) ; return str_repeat ( "{$space}{$border}" , $ this -> nesting ) ; }
9027	public function isQuestion ( $ string ) { $ probability = 0 ; if ( strpos ( $ string , '?' ) ) { $ probability += 1 ; } $ words = $ this -> getWords ( $ string ) ; foreach ( $ this -> inquiryWords as $ queryWord ) { if ( ! strncmp ( strtolower ( $ string ) , $ queryWord , strlen ( $ queryWord ) ) ) { $ probability += 1 ; } elseif ( stristr ( strtolower ( $ string ) , $ queryWord ) ) { $ probability += 0.5 ; } } if ( $ probability >= 2 ) { return true ; } return false ; }
7501	public function clearCache ( string $ namespace = null ) { if ( null !== $ namespace ) { $ this -> cacheStore -> remove ( self :: APP_CACHE_PREFIX . $ namespace , array ( ) ) ; return ; } $ this -> cacheStore -> clear ( ) ; }
10812	protected function callAPI ( $ data ) { $ apiUtility = new PipedriveApi ( $ this -> apiEndpoint ) ; $ apiUtility -> setData ( $ data ) ; $ formState = $ this -> finisherContext -> getFormRuntime ( ) -> getFormState ( ) ; $ response = $ apiUtility -> execute ( ) ; if ( $ response -> data -> id ) { $ formState -> setFormValue ( $ this -> getIdentifier ( ) . ".ID" , $ response -> data -> id ) ; return true ; } else { throw new FinisherException ( "Something went wrong while calling the API!" ) ; } }
12564	public function sendVoice ( $ message , $ to = null ) { return $ this -> send ( self :: MSG_TYPE_VOICE , $ message , $ to ) ; }
7581	protected function verifyData ( ) { if ( isset ( $ this -> _DATA_TYPE ) || ! empty ( $ this -> _DATA_TYPE ) ) { $ this -> verifyDataType ( ) ; } if ( ! empty ( $ this -> _REQUIRED_DATA ) ) { $ this -> verifyRequiredData ( ) ; } return true ; }
3351	private function __setRequestType ( $ ch , $ type = 'GET' ) { $ this -> current_method = strtoupper ( $ type ) ; switch ( $ type ) { case 'GET' : break ; case 'POST' : curl_setopt ( $ ch , CURLOPT_POST , true ) ; break ; case 'PUT' : curl_setopt ( $ ch , CURLOPT_CUSTOMREQUEST , 'PUT' ) ; break ; case 'DELETE' : curl_setopt ( $ ch , CURLOPT_CUSTOMREQUEST , 'DELETE' ) ; break ; case 'HEAD' : curl_setopt ( $ ch , CURLOPT_CUSTOMREQUEST , 'HEAD' ) ; curl_setopt ( $ ch , CURLOPT_NOBODY , true ) ; break ; case 'OPTIONS' : curl_setopt ( $ ch , CURLOPT_CUSTOMREQUEST , 'OPTIONS' ) ; break ; default : throw new \ Exception ( 'No request type is provided for request. Use post, put, delete, get or appropriate constants.' ) ; } }
5899	public function listFunctionalities ( $ includeDeleted = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'includeDeleted' => $ includeDeleted ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/functionalities' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new Functionality ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
10845	protected function refreshProductBuyPrices ( ProductInterface $ product ) { $ buyPrice = $ product -> getBuyPrice ( ) ; $ grossAmount = $ buyPrice -> getGrossAmount ( ) ; $ taxRate = $ product -> getBuyPriceTax ( ) -> getValue ( ) ; $ netAmount = TaxHelper :: calculateNetPrice ( $ grossAmount , $ taxRate ) ; $ buyPrice -> setTaxRate ( $ taxRate ) ; $ buyPrice -> setTaxAmount ( $ grossAmount - $ netAmount ) ; $ buyPrice -> setNetAmount ( $ netAmount ) ; }
10127	private function writeWsbool ( ) { $ record = 0x0081 ; $ length = 0x0002 ; $ grbit = 0x0000 ; $ grbit |= 0x0001 ; if ( $ this -> outlineStyle ) { $ grbit |= 0x0020 ; } if ( $ this -> phpSheet -> getShowSummaryBelow ( ) ) { $ grbit |= 0x0040 ; } if ( $ this -> phpSheet -> getShowSummaryRight ( ) ) { $ grbit |= 0x0080 ; } if ( $ this -> phpSheet -> getPageSetup ( ) -> getFitToPage ( ) ) { $ grbit |= 0x0100 ; } if ( $ this -> outlineOn ) { $ grbit |= 0x0400 ; } $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ grbit ) ; $ this -> append ( $ header . $ data ) ; }
11195	public function asArray ( ) { $ result = array ( ) ; foreach ( $ this -> collection as $ response ) { $ result [ ] = $ response -> getResultAsArray ( ) ; } return $ result ; }
2380	public static function trimsplit ( $ strPattern , $ strString ) { if ( \ strlen ( $ strPattern ) == 1 ) { $ arrFragments = array_map ( 'trim' , explode ( $ strPattern , $ strString ) ) ; } else { $ arrFragments = array_map ( 'trim' , preg_split ( '/' . $ strPattern . '/ui' , $ strString ) ) ; } if ( \ count ( $ arrFragments ) < 2 && ! \ strlen ( $ arrFragments [ 0 ] ) ) { $ arrFragments = array ( ) ; } return $ arrFragments ; }
9943	public function setCellValueExplicit ( $ pCoordinate , $ pValue , $ pDataType ) { $ this -> getCell ( $ pCoordinate ) -> setValueExplicit ( $ pValue , $ pDataType ) ; return $ this ; }
6628	public function get ( $ key , $ default = null ) { return ArrayHelper :: getValue ( $ this -> parsedResponse , sprintf ( '%s.%s' , self :: RESPONSE_DATA_PARAM , $ key ) , $ default ) ; }
9071	protected function prepareException ( Exception $ e ) { $ e = parent :: prepareException ( $ e ) ; if ( $ e instanceof PermissionDoesNotExist || $ e instanceof AuthorizationException ) { $ e = new AuthenticationException ( $ e -> getMessage ( ) ) ; } return $ e ; }
534	protected function fixFileDoc ( & $ lines ) { $ namespace = false ; $ namespaceLine = '' ; $ contentAfterNamespace = false ; foreach ( $ lines as $ i => $ line ) { $ line = trim ( $ line ) ; if ( ! empty ( $ line ) ) { if ( strncmp ( $ line , 'namespace' , 9 ) === 0 ) { $ namespace = $ i ; $ namespaceLine = $ line ; } elseif ( $ namespace !== false ) { $ contentAfterNamespace = $ i ; break ; } } } if ( $ namespace !== false && $ contentAfterNamespace !== false ) { while ( $ contentAfterNamespace > 0 ) { array_shift ( $ lines ) ; $ contentAfterNamespace -- ; } $ lines = array_merge ( [ '<?php' , '/**' , ' * @link http://www.yiiframework.com/' , ' * @copyright Copyright (c) 2008 Yii Software LLC' , ' * @license http://www.yiiframework.com/license/' , ' */' , '' , $ namespaceLine , '' , ] , $ lines ) ; } }
8052	public function getAllEventsAsJson ( ) { $ cache = $ this -> cache ; if ( $ cache :: has ( self :: ALL_EVENTS_TO_JSON_KEY ) ) { return $ cache :: get ( self :: ALL_EVENTS_TO_JSON_KEY ) ; } $ allEvents = $ this -> calendarEventsEngine -> formatEventsToJson ( $ this -> getAllEvents ( ) ) ; $ allEventsToJson = json_encode ( $ allEvents ) ; $ cache :: put ( self :: ALL_EVENTS_TO_JSON_KEY , $ allEventsToJson , $ this -> cacheTimeToLive ) ; return $ allEventsToJson ; }
3088	public function isAssessmentSectionAdaptive ( AssessmentSection $ section ) { $ assessmentItemRefs = $ section -> getComponentsByClassName ( 'assessmentItemRef' ) ; return count ( $ assessmentItemRefs ) === 1 && $ this -> isAdaptivePlaceholder ( $ assessmentItemRefs [ 0 ] ) ; }
8070	private function getDomainControllerStrategy ( array $ domain_controller ) { $ protocol = $ this -> ssl ? $ this :: PROTOCOL_SSL : $ this :: PROTOCOL ; if ( count ( $ domain_controller ) === 1 ) { return new SingleDomainController ( $ protocol , $ domain_controller ) ; } if ( $ this -> backup === true ) { return new RebindDomainController ( $ protocol , $ domain_controller ) ; } else { return new LoadBalancingDomainController ( $ protocol , $ domain_controller ) ; } }
2731	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ backends = $ this -> api -> getBackends ( $ activeVersion ) ; if ( ! $ backends ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to check Backend details.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'backends' => $ backends ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
9496	public function getCollection ( $ end_point , $ collectionName , $ page = 1 , $ per_page = 100 , $ sort_by = null , $ sort_order = 'asc' ) { $ end_point = strtolower ( $ end_point ) ; if ( strpos ( $ end_point , 'http' ) !== 0 ) { $ end_point = $ this -> api -> getApiUrl ( ) . $ end_point ; } $ request = $ this -> api -> get ( $ end_point ) ; $ query = $ request -> getQuery ( ) -> set ( 'page' , $ page ) -> set ( 'per_page' , $ per_page ) ; if ( $ sort_by ) { $ query -> set ( 'sort_by' , $ sort_by ) -> set ( 'sort_order' , $ sort_order == 'asc' ? 'asc' : 'desc' ) ; } $ response = $ this -> processRequest ( $ request ) ; $ values = $ response -> json ( ) ; $ result = new PaginatedResult ( ) ; $ result -> setClient ( $ this ) ; if ( array_key_exists ( 'count' , $ values ) ) { $ result -> setCount ( $ values [ 'count' ] ) ; } $ result -> setCurrentPage ( $ page ) ; $ result -> setPerPage ( $ per_page ) ; $ result -> setEndPoint ( $ end_point ) ; $ type = $ this -> getType ( ) ; if ( array_key_exists ( $ collectionName , $ values ) && is_array ( $ values [ $ collectionName ] ) ) { foreach ( $ values [ $ collectionName ] as $ value ) { $ entity = new $ type ( ) ; $ this -> manage ( $ entity ) ; $ result [ ] = $ entity -> fromArray ( $ value ) ; } } return $ result ; }
2394	public function addString ( $ strData , $ strName , $ intTime = 0 ) { ++ $ this -> intCount ; $ strName = strtr ( $ strName , '\\' , '/' ) ; $ arrFile [ 'file_signature' ] = self :: FILE_SIGNATURE ; $ arrFile [ 'version_needed_to_extract' ] = "\x14\x00" ; $ arrFile [ 'general_purpose_bit_flag' ] = "\x00\x00" ; $ arrFile [ 'compression_method' ] = "\x08\x00" ; $ arrFile [ 'last_mod_file_hex' ] = $ this -> unixToHex ( $ intTime ) ; $ arrFile [ 'crc-32' ] = pack ( 'V' , crc32 ( $ strData ) ) ; $ intUncompressed = \ strlen ( $ strData ) ; $ strData = gzcompress ( $ strData ) ; $ strData = substr ( substr ( $ strData , 0 , - 4 ) , 2 ) ; $ intCompressed = \ strlen ( $ strData ) ; $ arrFile [ 'compressed_size' ] = pack ( 'V' , $ intCompressed ) ; $ arrFile [ 'uncompressed_size' ] = pack ( 'V' , $ intUncompressed ) ; $ arrFile [ 'file_name_length' ] = pack ( 'v' , \ strlen ( $ strName ) ) ; $ arrFile [ 'extra_field_length' ] = "\x00\x00" ; $ arrFile [ 'file_name' ] = $ strName ; $ arrFile [ 'extra_field' ] = '' ; $ intOffset = @ ftell ( $ this -> resFile ) ; fwrite ( $ this -> resFile , implode ( '' , $ arrFile ) ) ; fwrite ( $ this -> resFile , $ strData ) ; $ arrHeader [ 'header_signature' ] = self :: CENTRAL_DIR_START ; $ arrHeader [ 'version_made_by' ] = "\x00\x00" ; $ arrHeader [ 'version_needed_to_extract' ] = $ arrFile [ 'version_needed_to_extract' ] ; $ arrHeader [ 'general_purpose_bit_flag' ] = $ arrFile [ 'general_purpose_bit_flag' ] ; $ arrHeader [ 'compression_method' ] = $ arrFile [ 'compression_method' ] ; $ arrHeader [ 'last_mod_file_hex' ] = $ arrFile [ 'last_mod_file_hex' ] ; $ arrHeader [ 'crc-32' ] = $ arrFile [ 'crc-32' ] ; $ arrHeader [ 'compressed_size' ] = $ arrFile [ 'compressed_size' ] ; $ arrHeader [ 'uncompressed_size' ] = $ arrFile [ 'uncompressed_size' ] ; $ arrHeader [ 'file_name_length' ] = $ arrFile [ 'file_name_length' ] ; $ arrHeader [ 'extra_field_length' ] = $ arrFile [ 'extra_field_length' ] ; $ arrHeader [ 'file_comment_length' ] = "\x00\x00" ; $ arrHeader [ 'disk_number_start' ] = "\x00\x00" ; $ arrHeader [ 'internal_file_attributes' ] = "\x00\x00" ; $ arrHeader [ 'external_file_attributes' ] = pack ( 'V' , 32 ) ; $ arrHeader [ 'offset_of_local_header' ] = pack ( 'V' , $ intOffset ) ; $ arrHeader [ 'file_name' ] = $ arrFile [ 'file_name' ] ; $ arrHeader [ 'extra_field' ] = $ arrFile [ 'extra_field' ] ; $ arrHeader [ 'file_comment' ] = '' ; $ this -> strCentralDir .= implode ( '' , $ arrHeader ) ; }
12202	public function create ( int $ status = 200 , array $ headers = [ ] , $ body = null ) : ResponseInterface { return new Response ( $ status , $ headers , $ body ) ; }
431	public function getModule ( $ id , $ load = true ) { if ( ( $ pos = strpos ( $ id , '/' ) ) !== false ) { $ module = $ this -> getModule ( substr ( $ id , 0 , $ pos ) ) ; return $ module === null ? null : $ module -> getModule ( substr ( $ id , $ pos + 1 ) , $ load ) ; } if ( isset ( $ this -> _modules [ $ id ] ) ) { if ( $ this -> _modules [ $ id ] instanceof self ) { return $ this -> _modules [ $ id ] ; } elseif ( $ load ) { Yii :: debug ( "Loading module: $id" , __METHOD__ ) ; $ module = Yii :: createObject ( $ this -> _modules [ $ id ] , [ $ id , $ this ] ) ; $ module -> setInstance ( $ module ) ; return $ this -> _modules [ $ id ] = $ module ; } } return null ; }
7238	protected function fixDeliveryDefault ( CustomerAddressInterface $ address ) { if ( ! $ this -> persistenceHelper -> isChanged ( $ address , [ 'deliveryDefault' ] ) ) { return ; } $ customer = $ address -> getCustomer ( ) ; if ( $ address -> isDeliveryDefault ( ) ) { foreach ( $ customer -> getAddresses ( ) as $ a ) { if ( $ a === $ address ) { continue ; } if ( $ a -> isDeliveryDefault ( ) ) { $ a -> setDeliveryDefault ( false ) ; $ this -> persistenceHelper -> persistAndRecompute ( $ a , false ) ; } } } elseif ( null === $ customer -> getDefaultDeliveryAddress ( true ) ) { $ address -> setDeliveryDefault ( true ) ; $ this -> persistenceHelper -> persistAndRecompute ( $ address , false ) ; } }
5256	public function setParent ( ElasticsearchModel $ parent ) { $ this -> _parent = $ parent ; $ this -> setParentId ( $ parent -> getId ( ) ) ; }
8183	public function getMemoryUsage ( ) { return isset ( $ this -> ends [ 'mu' ] ) && isset ( $ this -> starts [ 'mu' ] ) ? $ this -> ends [ 'mu' ] - $ this -> starts [ 'mu' ] : 0 ; }
929	public function clean ( ) { foreach ( $ this -> files as $ file => $ value ) { $ this -> unlink ( $ file ) ; } $ this -> files = [ ] ; }
11483	public function getFactory ( $ class , array $ params = array ( ) ) { if ( ! isset ( $ this -> factories [ $ class ] ) && $ this -> autowire ) { $ this -> factories [ $ class ] = Definition :: getDefaultForClass ( $ class ) ; } $ factory = $ this -> factories [ $ class ] ; if ( $ params ) { $ factory = $ factory -> getFactory ( $ params ) ; } return $ factory ; }
3146	public function resume ( RunnerServiceContext $ context ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ context -> getTestSession ( ) -> resume ( ) ; $ this -> persist ( $ context ) ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'resume' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return true ; }
11546	public function changeSecurityQuestion ( $ data ) { if ( ! ( $ user = $ this -> hydrate ( $ data , $ this -> getChangeSecurityQuestionForm ( ) ) ) ) { return ; } $ eventManager = $ this -> getEventManager ( ) ; $ eventManager -> trigger ( __METHOD__ , $ this , $ user ) ; $ this -> getMapper ( ) -> update ( $ user ) -> save ( ) ; $ eventManager -> trigger ( __METHOD__ . '.post' , $ this , $ user ) ; return $ user ; }
1593	protected function validateTypeAndId ( ) : bool { if ( ! ( $ this -> validateType ( ) && $ this -> validateId ( ) ) ) { return false ; } $ type = $ this -> dataGet ( 'type' ) ; $ id = $ this -> dataGet ( 'id' ) ; if ( $ id && ! $ this -> isNotFound ( $ type , $ id ) ) { $ this -> resourceExists ( $ type , $ id ) ; return false ; } return true ; }
9613	public function register ( Container $ app ) { $ app [ 'guzzle.handler_stack' ] = function ( ) { $ stack = HandlerStack :: create ( ) ; return $ stack ; } ; $ app [ 'guzzle' ] = function ( ) use ( $ app ) { $ client = new HttpClient ( [ 'handler' => $ app [ 'guzzle.handler_stack' ] ] ) ; return $ client ; } ; }
3718	protected function getMetaModelFromModel ( ModelInterface $ model ) { if ( ! ( ( $ model -> getProviderName ( ) == 'tl_metamodel_dca_sortgroup' ) && $ model -> getProperty ( 'pid' ) ) ) { throw new DcGeneralInvalidArgumentException ( sprintf ( 'Model must originate from tl_metamodel_dca_sortgroup and be saved, this one originates from %s ' . 'and has pid %s' , $ model -> getProviderName ( ) , $ model -> getProperty ( 'pid' ) ) ) ; } $ metaModelId = $ this -> connection -> createQueryBuilder ( ) -> select ( 'pid' ) -> from ( 'tl_metamodel_dca' ) -> where ( 'id=:id' ) -> setParameter ( 'id' , $ model -> getProperty ( 'pid' ) ) -> execute ( ) -> fetchColumn ( ) ; $ tableName = $ this -> factory -> translateIdToMetaModelName ( $ metaModelId ) ; return $ this -> factory -> getMetaModel ( $ tableName ) ; }
12093	public function getDomainUrl ( $ address , $ scheme = false ) { $ this -> urlAddress -> setAddress ( $ address ) ; return $ this -> urlAddress -> getDomain ( $ scheme ) ; }
9732	public function writeFont ( ) { $ font_outline = 0 ; $ font_shadow = 0 ; $ icv = $ this -> colorIndex ; if ( $ this -> font -> getSuperscript ( ) ) { $ sss = 1 ; } elseif ( $ this -> font -> getSubscript ( ) ) { $ sss = 2 ; } else { $ sss = 0 ; } $ bFamily = 0 ; $ bCharSet = \ PhpOffice \ PhpSpreadsheet \ Shared \ Font :: getCharsetFromFontName ( $ this -> font -> getName ( ) ) ; $ record = 0x31 ; $ reserved = 0x00 ; $ grbit = 0x00 ; if ( $ this -> font -> getItalic ( ) ) { $ grbit |= 0x02 ; } if ( $ this -> font -> getStrikethrough ( ) ) { $ grbit |= 0x08 ; } if ( $ font_outline ) { $ grbit |= 0x10 ; } if ( $ font_shadow ) { $ grbit |= 0x20 ; } $ data = pack ( 'vvvvvCCCC' , $ this -> font -> getSize ( ) * 20 , $ grbit , $ icv , self :: mapBold ( $ this -> font -> getBold ( ) ) , $ sss , self :: mapUnderline ( $ this -> font -> getUnderline ( ) ) , $ bFamily , $ bCharSet , $ reserved ) ; $ data .= StringHelper :: UTF8toBIFF8UnicodeShort ( $ this -> font -> getName ( ) ) ; $ length = strlen ( $ data ) ; $ header = pack ( 'vv' , $ record , $ length ) ; return $ header . $ data ; }
11481	public function save ( BlockManagerApprover $ approver , array $ options , $ saveCommonSlots = true ) { $ this -> contributorDefined ( ) ; $ filesystem = new Filesystem ( ) ; $ pageDir = $ this -> pagesDir . '/' . $ options [ "page" ] ; $ filesystem -> copy ( $ pageDir . '/' . $ this -> pageFile , $ pageDir . '/page.json' , true ) ; $ pageDir .= '/' . $ options [ "language" ] . '_' . $ options [ "country" ] ; if ( $ this -> seoFile != "seo.json" ) { $ sourceFile = $ pageDir . '/' . $ this -> seoFile ; $ values = json_decode ( file_get_contents ( $ sourceFile ) , true ) ; if ( array_key_exists ( "current_permalink" , $ values ) ) { $ values [ "changed_permalinks" ] [ ] = $ values [ "current_permalink" ] ; unset ( $ values [ "current_permalink" ] ) ; file_put_contents ( $ sourceFile , json_encode ( $ values ) ) ; } $ filesystem -> copy ( $ sourceFile , $ pageDir . '/seo.json' , true ) ; } $ approvedBlocks = $ this -> saveBlocks ( $ approver , $ pageDir , $ options ) ; if ( $ saveCommonSlots ) { $ slotsDir = $ this -> baseDir . '/slots' ; $ approvedCommonBlocks = $ this -> saveBlocks ( $ approver , $ slotsDir , $ options ) ; $ approvedBlocks = array_merge ( $ approvedBlocks , $ approvedCommonBlocks ) ; } Dispatcher :: dispatch ( PageEvents :: PAGE_SAVED , new PageSavedEvent ( $ pageDir , null , $ approvedBlocks ) ) ; DataLogger :: log ( sprintf ( 'Page "%s" was successfully saved in production' , $ options [ "page" ] ) ) ; }
6551	static function send ( $ channel_code = null ) { try { if ( is_numeric ( $ channel_code ) ) { $ channel_id = $ channel_code ; } else { $ channel_id = env ( 'telegram.' . $ channel_code ) ; $ channel_id = $ channel_id ? : env ( 'telegram' ) ; } if ( ! $ channel_id ) { echo 'No channel' ; return ; } if ( is_array ( $ channel_code ) ) { foreach ( $ channel_code as $ _code ) { self :: send ( $ _code ) ; } return ; } $ ch = curl_init ( ) ; curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , true ) ; curl_setopt ( $ ch , CURLOPT_TIMEOUT , 3 ) ; curl_setopt ( $ ch , CURLOPT_HEADER , 0 ) ; $ partials = [ ] ; $ current = '' ; foreach ( static :: $ messages as $ message ) { if ( mb_strlen ( $ current ) + mb_strlen ( $ message ) < self :: MAX ) { $ current .= PHP_EOL . $ message ; } else { $ partials [ ] = $ current ; $ current = '' ; if ( mb_strlen ( $ message ) > self :: MAX ) { $ strlen = mb_strlen ( $ message ) ; while ( $ strlen ) { $ partials [ ] = mb_substr ( $ message , 0 , self :: MAX , "UTF-8" ) ; $ message = mb_substr ( $ message , self :: MAX , mb_strlen ( $ message ) , "UTF-8" ) ; $ strlen = mb_strlen ( $ message ) ; } } else { $ current = $ message ; } } } $ partials [ ] = $ current ; foreach ( $ partials as $ partial ) { $ params = http_build_query ( [ 'disable_web_page_preview' => 'true' , 'parse_mode' => 'HTML' , 'chat_id' => $ channel_id , 'text' => $ partial , ] ) ; $ url = 'https://api.telegram.org/bot' . env ( 'telegram.key' ) . '/sendMessage?' ; curl_setopt ( $ ch , CURLOPT_URL , $ url . $ params ) ; curl_exec ( $ ch ) ; } curl_close ( $ ch ) ; } catch ( \ Exception $ e ) { echo $ e -> getMessage ( ) ; } }
11526	public function resolve ( $ templatePath ) { $ templatePathReal = realpath ( $ templatePath ) ; if ( $ templatePathReal === false ) { throw new \ Exception ( 'Template file does not exist: ' . $ templatePath ) ; } if ( $ this -> hasCache ( $ templatePathReal ) ) { return $ this -> getCache ( $ templatePathReal ) ; } $ template = file_get_contents ( $ templatePathReal ) ; $ this -> setCache ( $ templatePathReal , $ template ) ; return $ template ; }
7698	function MsPowerpoint_SlideIsIt ( $ FileName ) { $ this -> MsPowerpoint_InitSlideLst ( ) ; foreach ( $ this -> OpenXmlSlideLst as $ i => $ s ) { if ( $ FileName == $ s [ 'file' ] ) return true ; } return false ; }
9867	private function writeMergeCells ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { if ( count ( $ pSheet -> getMergeCells ( ) ) > 0 ) { $ objWriter -> startElement ( 'mergeCells' ) ; foreach ( $ pSheet -> getMergeCells ( ) as $ mergeCell ) { $ objWriter -> startElement ( 'mergeCell' ) ; $ objWriter -> writeAttribute ( 'ref' , $ mergeCell ) ; $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; } }
458	public function dropCheck ( $ name , $ table ) { return 'ALTER TABLE ' . $ this -> db -> quoteTableName ( $ table ) . ' DROP CONSTRAINT ' . $ this -> db -> quoteColumnName ( $ name ) ; }
2215	public function next ( ) { if ( $ this -> blnDone ) { return false ; } if ( $ this -> fetchAssoc ( ) !== false ) { return $ this ; } $ this -> blnDone = true ; return false ; }
9956	public function protectCells ( $ pRange , $ pPassword , $ pAlreadyHashed = false ) { $ pRange = strtoupper ( $ pRange ) ; if ( ! $ pAlreadyHashed ) { $ pPassword = Shared \ PasswordHasher :: hashPassword ( $ pPassword ) ; } $ this -> protectedCells [ $ pRange ] = $ pPassword ; return $ this ; }
12319	public function redirect ( string $ shortURLKey ) { $ record = HCShortURL :: where ( 'short_url_key' , $ shortURLKey ) -> first ( ) ; if ( ! $ record ) abort ( 404 ) ; $ record -> increment ( 'clicks' ) ; return redirect ( $ record -> url ) ; }
4977	public function send ( \ Zend \ Mail \ Message $ message ) { $ options = $ this -> options ; $ filename = call_user_func ( $ options -> getCallback ( ) , $ this ) ; $ file = $ options -> getPath ( ) . DIRECTORY_SEPARATOR . $ filename ; $ contents = $ message -> toString ( ) ; $ umask = umask ( ) ; umask ( 022 ) ; if ( false === file_put_contents ( $ file , $ contents , LOCK_EX ) ) { throw new RuntimeException ( sprintf ( 'Unable to write mail to file (directory "%s")' , $ options -> getPath ( ) ) ) ; } umask ( $ umask ) ; $ this -> lastFile = $ file ; }
7691	function OpenMXL_GarbageCollector ( ) { if ( ( count ( $ this -> IdxToCheck ) == 0 ) && ( count ( $ this -> OtbsSheetSlidesDelete ) == 0 ) ) return ; $ pic_path = $ this -> ExtInfo [ 'pic_path' ] ; $ pic_path_len = strlen ( $ pic_path ) ; $ rels_ext = '.rels' ; $ rels_ext_len = strlen ( $ rels_ext ) ; $ pictures = array ( ) ; $ rels = array ( ) ; foreach ( $ this -> CdFileLst as $ idx => $ f ) { $ n = $ f [ 'v_name' ] ; if ( substr ( $ n , 0 , $ pic_path_len ) == $ pic_path ) { $ short = basename ( $ pic_path ) . '/' . basename ( $ n ) ; $ pictures [ ] = array ( 'name' => $ n , 'idx' => $ idx , 'nbr' => 0 , 'short' => $ short ) ; } elseif ( substr ( $ n , - $ rels_ext_len ) == $ rels_ext ) { if ( $ this -> FileGetState ( $ idx ) != 'd' ) $ rels [ $ n ] = $ idx ; } } foreach ( $ rels as $ n => $ idx ) { $ txt = $ this -> TbsStoreGet ( $ idx , 'GarbageCollector' ) ; foreach ( $ pictures as $ i => $ info ) { if ( strpos ( $ txt , $ info [ 'short' ] . '"' ) !== false ) $ pictures [ $ i ] [ 'nbr' ] ++ ; } } foreach ( $ pictures as $ info ) { if ( $ info [ 'nbr' ] == 0 ) $ this -> FileReplace ( $ info [ 'idx' ] , false ) ; } }
3606	public function get ( $ name ) { if ( ! isset ( $ this -> httpHandlers [ $ name ] ) ) { throw new \ Exception ( "HttpHandler {$name} not found" ) ; } return $ this -> httpHandlers [ $ name ] ; }
1125	public function isDescendantOf ( $ other ) { return ( $ this -> getLeft ( ) > $ other -> getLeft ( ) && $ this -> getLeft ( ) < $ other -> getRight ( ) && $ this -> inSameScope ( $ other ) ) ; }
9585	public function Nice ( ) { if ( $ this -> value && $ parts = parse_url ( $ this -> URL ( ) ) ) { $ remove = array ( 'scheme' , 'user' , 'pass' , 'port' , 'query' , 'fragment' ) ; foreach ( $ remove as $ part ) { unset ( $ parts [ $ part ] ) ; } return rtrim ( http_build_url ( $ parts ) , "/" ) ; } }
9435	public function theta ( $ float_min , $ float_max ) { self :: checkOrder ( $ float_min , $ float_max ) ; if ( $ this -> r || $ this -> i ) { throw new \ RuntimeException ( 'You cannot set theta value, because algebraic form is in use.' ) ; } $ this -> theta = new \ stdClass ( ) ; $ this -> theta -> min = $ float_min ; $ this -> theta -> max = $ float_max ; return $ this ; }
2675	public function aclItemsList ( $ aclId ) { $ url = $ this -> _getApiServiceUri ( ) . 'acl/' . $ aclId . '/entries' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; }
11423	public function batchGet ( array $ openIds , $ lang = 'zh_CN' ) { $ params = [ ] ; $ params [ 'user_list' ] = array_map ( function ( $ openId ) use ( $ lang ) { return [ 'openid' => $ openId , 'lang' => $ lang , ] ; } , $ openIds ) ; return $ this -> parseJSON ( 'json' , [ self :: API_BATCH_GET , $ params ] ) ; }
12743	public function buildSlotMap ( ) { $ this -> slotmap -> reset ( ) ; foreach ( $ this -> pool as $ connectionID => $ connection ) { $ parameters = $ connection -> getParameters ( ) ; if ( ! isset ( $ parameters -> slots ) ) { continue ; } foreach ( explode ( ',' , $ parameters -> slots ) as $ slotRange ) { $ slots = explode ( '-' , $ slotRange , 2 ) ; if ( ! isset ( $ slots [ 1 ] ) ) { $ slots [ 1 ] = $ slots [ 0 ] ; } $ this -> slotmap -> setSlots ( $ slots [ 0 ] , $ slots [ 1 ] , $ connectionID ) ; } } }
12853	public function import ( Package $ package , $ id = null ) { $ id = is_null ( $ id ) ? $ package -> id : $ id ; $ this -> symbols = array_merge ( $ package -> symbols , $ this -> symbols ) ; $ this -> macros = array_merge ( $ package -> macros , $ this -> macros ) ; $ this -> packages [ $ id ] = $ package ; }
10035	function unsubscribeContactByExternalId ( $ externalId , $ mailingId = "" , $ reasons = null ) { $ queryParameters = array ( ) ; if ( ! empty ( $ mailingId ) ) { $ queryParameters [ 'mailingId' ] = $ mailingId ; } if ( ! empty ( $ reasons ) ) { if ( is_array ( $ reasons ) ) { $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'reason' , $ reasons ) ; } else { $ queryParameters [ 'reason' ] = urlencode ( $ reasons ) ; } } $ encodedExternalId = utf8_encode ( $ externalId ) ; return $ this -> delete ( "contacts/externalid/${encodedExternalId}/unsubscribe" , $ queryParameters ) ; }
180	protected function loadDummyBundle ( $ name ) { if ( ! isset ( $ this -> _dummyBundles [ $ name ] ) ) { $ this -> _dummyBundles [ $ name ] = $ this -> loadBundle ( $ name , [ 'sourcePath' => null , 'js' => [ ] , 'css' => [ ] , 'depends' => [ ] , ] ) ; } return $ this -> _dummyBundles [ $ name ] ; }
5175	public function set ( string $ key , $ value ) : self { if ( ! isset ( $ this -> props [ $ key ] ) ) { throw new \ Exception ( 'Cannot add new property from set. Use add()' ) ; } $ this -> props [ $ key ] = $ value ; return $ this ; }
12334	private function _checkPasswordIsGood ( ) : bool { $ sLogin = self :: $ _sLogin ; $ sPassword = Config :: get ( 'security' ) -> users -> $ sLogin -> password ; if ( $ sPassword == self :: $ _sPassword ) { return true ; } else if ( $ sPassword == md5 ( self :: $ _sPassword ) ) { return true ; } else { return false ; } }
3662	private function parseTable ( ) { $ this -> queryString = str_replace ( '{{table}}' , $ this -> collection -> getMetaModel ( ) -> getTableName ( ) , $ this -> queryString ) ; }
4816	public function appendRow ( $ singleRow = null ) { if ( ! is_null ( $ singleRow ) ) { if ( $ singleRow instanceof Row ) { $ this -> collection [ ] = $ singleRow ; $ singleRow -> acceptChanges ( ) ; } elseif ( is_array ( $ singleRow ) ) { $ this -> collection [ ] = new Row ( $ singleRow ) ; } else { throw new InvalidArgumentException ( "You must pass an array or a Row object" ) ; } } else { $ singleRow = new Row ( ) ; $ this -> collection [ ] = $ singleRow ; $ singleRow -> acceptChanges ( ) ; } $ this -> currentRow = count ( $ this -> collection ) - 1 ; }
4940	public function setIsMultiple ( $ flag ) { $ this -> isMultiple = ( bool ) $ flag ; if ( $ flag ) { $ this -> setAttribute ( 'multiple' , true ) ; } else { $ this -> removeAttribute ( 'multiple' ) ; } return $ this ; }
798	public function insertAt ( $ index , Token $ token ) { $ this -> setSize ( $ this -> getSize ( ) + 1 ) ; for ( $ i = $ this -> getSize ( ) - 1 ; $ i > $ index ; -- $ i ) { $ this [ $ i ] = isset ( $ this [ $ i - 1 ] ) ? $ this [ $ i - 1 ] : new Token ( ) ; } $ this [ $ index ] = $ token ; }
12522	public function renderWidget ( array $ fields , $ customFieldOrClass , $ documentType = 'html' , $ slug = null ) { return $ this -> container -> get ( 'chill.custom_field.helper' ) -> renderCustomField ( $ fields , $ customFieldOrClass , $ documentType , $ slug ) ; }
4439	public static function unregister ( ? array $ signals = null ) : void { if ( empty ( $ signals ) ) { $ signals = self :: KNOWN_SIGNALS ; } foreach ( $ signals as $ signal ) { if ( is_string ( $ signal ) ) { if ( ! defined ( $ signal ) ) { continue ; } $ signal = constant ( $ signal ) ; } pcntl_signal ( $ signal , SIG_DFL ) ; } }
10728	public function getMonth ( ) { if ( $ this -> value !== null ) { preg_match ( '/^(?P<year>[0-9]{4,4})-(?P<month>[0-9]{2,2})-(?P<day>[0-9]{2,2}) (?P<hour>[0-9]{2,2}):(?P<minute>[0-9]{2,2}):(?P<second>[0-9]{2,2})$/ui' , $ this -> value , $ m ) ; return ( int ) $ m [ 'month' ] ; } }
2655	public function createCondition ( $ version , array $ condition ) { $ checkIfExists = $ this -> getCondition ( $ version , $ condition [ 'name' ] ) ; $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/condition' ; if ( ! $ checkIfExists ) { $ verb = \ Zend_Http_Client :: POST ; } else { $ verb = \ Zend_Http_Client :: PUT ; $ url .= '/' . $ condition [ 'name' ] ; } $ result = $ this -> _fetch ( $ url , $ verb , $ condition ) ; if ( ! $ result ) { throw new LocalizedException ( __ ( 'Failed to create a REQUEST condition.' ) ) ; } return $ result ; }
5829	public function newRawRequest ( $ method , $ url , $ data = '' ) { return $ this -> newRequest ( $ method , $ url , $ data , Request :: ENCODING_RAW ) ; }
6203	public static function start ( $ apiKey , $ notifyOnWarning = false , array $ options = array ( ) ) { if ( ! isset ( self :: $ instance ) ) { $ config = new Configuration ( $ apiKey , $ options ) ; $ client = new Client ( $ config ) ; self :: $ instance = new self ( $ client , $ notifyOnWarning ) ; if ( null !== $ config -> get ( 'errorReportingLevel' ) ) { self :: $ instance -> addErrorFilter ( new ErrorReporting ( $ config ) ) ; } self :: $ instance -> addExceptionFilter ( new AirbrakeExceptionFilter ( ) ) ; set_error_handler ( array ( self :: $ instance , 'onError' ) ) ; set_exception_handler ( array ( self :: $ instance , 'onException' ) ) ; register_shutdown_function ( array ( self :: $ instance , 'onShutdown' ) ) ; } return self :: $ instance ; }
12466	private function createEditForm ( CustomFieldsGroup $ entity ) { $ form = $ this -> createForm ( 'custom_fields_group' , $ entity , array ( 'action' => $ this -> generateUrl ( 'customfieldsgroup_update' , array ( 'id' => $ entity -> getId ( ) ) ) , 'method' => 'PUT' , ) ) ; $ form -> add ( 'submit' , 'submit' , array ( 'label' => 'Update' ) ) ; return $ form ; }
1780	public function generate ( ) { if ( TL_MODE == 'BE' ) { $ objTemplate = new BackendTemplate ( 'be_wildcard' ) ; $ objTemplate -> wildcard = '### ' . Utf8 :: strtoupper ( $ GLOBALS [ 'TL_LANG' ] [ 'FMD' ] [ 'calendar' ] [ 0 ] ) . ' ###' ; $ objTemplate -> title = $ this -> headline ; $ objTemplate -> id = $ this -> id ; $ objTemplate -> link = $ this -> name ; $ objTemplate -> href = 'contao/main.php?do=themes&amp;table=tl_module&amp;act=edit&amp;id=' . $ this -> id ; return $ objTemplate -> parse ( ) ; } $ this -> cal_calendar = $ this -> sortOutProtected ( StringUtil :: deserialize ( $ this -> cal_calendar , true ) ) ; if ( empty ( $ this -> cal_calendar ) || ! \ is_array ( $ this -> cal_calendar ) ) { return '' ; } $ this -> strUrl = preg_replace ( '/\?.*$/' , '' , Environment :: get ( 'request' ) ) ; $ this -> strLink = $ this -> strUrl ; if ( ( $ objTarget = $ this -> objModel -> getRelated ( 'jumpTo' ) ) instanceof PageModel ) { $ this -> strLink = $ objTarget -> getFrontendUrl ( ) ; } return parent :: generate ( ) ; }
12875	public static function getJSON ( $ src ) { $ src = file_get_contents ( $ src ) ; $ out = json_decode ( $ src , true ) ; return $ out ; }
4969	public function fromEvent ( $ param = null , $ default = null ) { if ( null === $ param ) { return $ this -> event -> getParams ( ) ; } return $ this -> event -> getParam ( $ param , $ default ) ; }
7430	public function addRegion ( RegionInterface $ region ) { $ region -> setCountry ( $ this ) ; $ this -> regions -> add ( $ region ) ; }
3928	private function getOptionsViaDcGeneral ( $ metaModel , $ environment , $ attribute ) { $ factory = DcGeneralFactory :: deriveEmptyFromEnvironment ( $ environment ) -> setContainerName ( $ metaModel -> getTableName ( ) ) ; $ dcGeneral = $ factory -> createDcGeneral ( ) ; $ subEnv = $ dcGeneral -> getEnvironment ( ) ; $ optEv = new GetPropertyOptionsEvent ( $ subEnv , $ subEnv -> getDataProvider ( ) -> getEmptyModel ( ) ) ; $ optEv -> setPropertyName ( $ attribute -> getColName ( ) ) ; $ subEnv -> getEventDispatcher ( ) -> dispatch ( GetPropertyOptionsEvent :: NAME , $ optEv ) ; $ options = $ optEv -> getOptions ( ) ; return $ options ; }
8124	protected function findRecord ( $ data ) { if ( empty ( $ data [ "ID" ] ) ) { throw new HTTPResponse_Exception ( "No record ID" , 404 ) ; } $ page = null ; $ id = $ data [ "ID" ] ; if ( is_numeric ( $ id ) ) { $ page = SiteTree :: get ( ) -> byID ( $ id ) ; } if ( ! $ page || ! $ page -> ID ) { throw new HTTPResponse_Exception ( "Bad record ID #{$id}" , 404 ) ; } return $ page ; }
3115	public function storeItemHrefIndex ( $ testSessionId , $ table ) { $ extendedState = $ this -> getExtendedState ( $ testSessionId ) ; $ extendedState -> setItemHrefIndex ( $ table ) ; $ extendedState -> save ( ) ; }
2801	protected static function generateNonLazyBeanCode ( string $ padding , string $ beanId , string $ beanType , Bean $ beanMetadata , string $ methodParams , ForceLazyInitProperty $ forceLazyInitProperty , SessionBeansProperty $ sessionBeansProperty , BeanPostProcessorsProperty $ postProcessorsProperty , WrapBeanAsLazy $ wrapBeanAsLazy ) : string { $ content = $ padding . '$backupForceLazyInit = $this->' . $ forceLazyInitProperty -> getName ( ) . ';' . PHP_EOL ; if ( $ beanMetadata -> isSession ( ) ) { $ content .= $ padding . 'if($this->' . $ sessionBeansProperty -> getName ( ) . '->has("' . $ beanId . '")) {' . PHP_EOL ; if ( $ beanMetadata -> isSingleton ( ) ) { $ content .= $ padding . ' $sessionInstance = clone $this->' . $ sessionBeansProperty -> getName ( ) . '->get("' . $ beanId . '");' . PHP_EOL ; } else { $ content .= $ padding . ' $sessionInstance = $this->' . $ sessionBeansProperty -> getName ( ) . '->get("' . $ beanId . '");' . PHP_EOL ; } $ content .= $ padding . ' return ($backupForceLazyInit) ? $this->' . $ wrapBeanAsLazy -> getName ( ) . '("' . $ beanId . '", "' . $ beanType . '", $sessionInstance) : $sessionInstance;' . PHP_EOL ; $ content .= $ padding . '}' . PHP_EOL ; } if ( $ beanMetadata -> isSingleton ( ) ) { $ content .= $ padding . 'static $instance = null;' . PHP_EOL ; $ content .= $ padding . 'if ($instance !== null) {' . PHP_EOL ; $ content .= $ padding . ' return ($backupForceLazyInit) ? $this->' . $ wrapBeanAsLazy -> getName ( ) . '("' . $ beanId . '", "' . $ beanType . '", $instance) : $instance;' . PHP_EOL ; $ content .= $ padding . '}' . PHP_EOL ; } if ( $ beanMetadata -> isSession ( ) ) { $ content .= $ padding . '$this->' . $ forceLazyInitProperty -> getName ( ) . ' = true;' . PHP_EOL ; } $ content .= self :: generateBeanCreationCode ( $ padding , $ beanId , $ methodParams , $ postProcessorsProperty ) ; if ( $ beanMetadata -> isSession ( ) ) { $ content .= $ padding . '$this->' . $ forceLazyInitProperty -> getName ( ) . ' = $backupForceLazyInit;' . PHP_EOL ; $ content .= $ padding . '$this->' . $ sessionBeansProperty -> getName ( ) . '->add("' . $ beanId . '", $instance);' . PHP_EOL ; } $ content .= $ padding . 'return ($backupForceLazyInit) ? $this->' . $ wrapBeanAsLazy -> getName ( ) . '("' . $ beanId . '", "' . $ beanType . '", $instance) : $instance;' . PHP_EOL ; return $ content ; }
6222	public function getElevation ( $ latitude , $ longitude ) { if ( $ latitude === 0.0 && $ longitude === 0.0 ) { return false ; } if ( ! $ this -> locationIsInBounds ( $ latitude , $ longitude ) ) { throw new InvalidArgumentException ( sprintf ( 'Location (%f, %f) is out of bounds ([-%f, %f], [-%f, %f]).' , $ latitude , $ longitude , static :: MAX_LATITUDE , static :: MAX_LATITUDE , static :: MAX_LONGITUDE , static :: MAX_LONGITUDE ) ) ; } $ filename = $ this -> getFilenameFor ( $ latitude , $ longitude ) ; if ( $ this -> CurrentFilename !== $ filename ) { $ this -> openResource ( $ filename ) ; } return $ this -> getElevationFromResource ( $ latitude , $ longitude ) ; }
10793	public function delete ( $ idOrUser , $ forceLogout = true ) { $ main = $ this -> getServiceLocator ( ) -> get ( 'neobazaar.service.main' ) ; $ em = $ main -> getEntityManager ( ) ; $ user = $ this -> getEntity ( $ idOrUser ) ; $ classifiedService = $ this -> getServiceLocator ( ) -> get ( 'document.service.classified' ) ; if ( ! $ this -> checkIfOwnerOrAdmin ( $ user ) ) { throw new \ Exception ( 'Non possiedi i permessi per agire su questo documento' ) ; } $ this -> getEventManager ( ) -> trigger ( __FUNCTION__ , $ this , array ( 'user' => $ user ) ) ; $ user -> setState ( UserEntity :: USER_STATE_DELETED ) ; $ em -> persist ( $ user ) ; $ em -> flush ( ) ; $ documents = $ user -> getDocument ( ) ; foreach ( $ documents as $ document ) { try { $ classifiedService -> delete ( $ document ) ; } catch ( \ Exception $ e ) { } } $ this -> getEventManager ( ) -> trigger ( __FUNCTION__ . '.post' , $ this , array ( 'user' => $ user ) ) ; if ( $ forceLogout ) { $ this -> logout ( ) ; } return $ user ; }
380	public function renderCallStack ( $ exception ) { $ out = '<ul>' ; $ out .= $ this -> renderCallStackItem ( $ exception -> getFile ( ) , $ exception -> getLine ( ) , null , null , [ ] , 1 ) ; for ( $ i = 0 , $ trace = $ exception -> getTrace ( ) , $ length = count ( $ trace ) ; $ i < $ length ; ++ $ i ) { $ file = ! empty ( $ trace [ $ i ] [ 'file' ] ) ? $ trace [ $ i ] [ 'file' ] : null ; $ line = ! empty ( $ trace [ $ i ] [ 'line' ] ) ? $ trace [ $ i ] [ 'line' ] : null ; $ class = ! empty ( $ trace [ $ i ] [ 'class' ] ) ? $ trace [ $ i ] [ 'class' ] : null ; $ function = null ; if ( ! empty ( $ trace [ $ i ] [ 'function' ] ) && $ trace [ $ i ] [ 'function' ] !== 'unknown' ) { $ function = $ trace [ $ i ] [ 'function' ] ; } $ args = ! empty ( $ trace [ $ i ] [ 'args' ] ) ? $ trace [ $ i ] [ 'args' ] : [ ] ; $ out .= $ this -> renderCallStackItem ( $ file , $ line , $ class , $ function , $ args , $ i + 2 ) ; } $ out .= '</ul>' ; return $ out ; }
8536	public function setRentalChargeList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'RentalChargeList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
8512	public function listInboundShipmentItemsByNextToken ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_ListInboundShipmentItemsByNextTokenRequest ) ) { $ request = new FBAInboundServiceMWS_Model_ListInboundShipmentItemsByNextTokenRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListInboundShipmentItemsByNextToken' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_ListInboundShipmentItemsByNextTokenResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
1424	protected function load ( $ record , EncodingParametersInterface $ parameters ) { $ relationshipPaths = $ this -> getRelationshipPaths ( $ parameters -> getIncludePaths ( ) ) ; $ record -> loadMissing ( $ relationshipPaths ) ; }
4965	public function fromFiles ( $ name = null , $ default = null ) { if ( $ name === null ) { return $ this -> event -> getRequest ( ) -> getFiles ( $ name , $ default ) -> toArray ( ) ; } return $ this -> event -> getRequest ( ) -> getFiles ( $ name , $ default ) ; }
953	public function authenticate ( AuthShop $ request ) { $ validated = $ request -> validated ( ) ; $ shopDomain = ShopifyApp :: sanitizeShopDomain ( $ validated [ 'shop' ] ) ; $ shop = ShopifyApp :: shop ( $ shopDomain ) ; $ auth = new AuthShopHandler ( $ shop ) ; $ session = new ShopSession ( $ shop ) ; if ( ! $ request -> has ( 'code' ) ) { $ authUrl = $ auth -> buildAuthUrl ( $ shop -> hasOfflineAccess ( ) ? Config :: get ( 'shopify-app.api_grant_mode' ) : ShopSession :: GRANT_OFFLINE ) ; return View :: make ( 'shopify-app::auth.fullpage_redirect' , compact ( 'authUrl' , 'shopDomain' ) ) ; } $ access = $ auth -> getAccess ( $ validated [ 'code' ] ) ; $ session -> setDomain ( $ shopDomain ) ; $ session -> setAccess ( $ access ) ; $ auth -> postProcess ( ) ; $ auth -> dispatchJobs ( $ session ) ; return $ this -> returnTo ( ) ; }
3356	public function getPath ( $ postfix = null ) { $ url = sprintf ( '/%s/' , $ this -> uuid ) ; if ( $ this -> default_effects ) { $ url = sprintf ( '%s-/%s' , $ url , $ this -> default_effects ) ; } if ( $ this -> filename && $ postfix === null ) { $ postfix = $ this -> filename ; } $ operations = array ( ) ; foreach ( $ this -> operations as $ i => $ operation_item ) { $ part = array ( ) ; foreach ( array_keys ( $ operation_item ) as $ operation_type ) { $ operation_params = $ operation_item [ $ operation_type ] ; $ part [ ] = $ operation_type ; switch ( $ operation_type ) { case 'crop' : $ part = $ this -> __addPartSize ( $ part , $ operation_params ) ; $ part = $ this -> __addPartCenter ( $ part , $ operation_params ) ; $ part = $ this -> __addPartFillColor ( $ part , $ operation_params ) ; break ; case 'resize' : $ part = $ this -> __addPartSize ( $ part , $ operation_params ) ; break ; case 'scale_crop' : $ part = $ this -> __addPartSize ( $ part , $ operation_params ) ; $ part = $ this -> __addPartCenter ( $ part , $ operation_params ) ; break ; case 'effect' : $ part = $ this -> __addPartEffect ( $ part , $ operation_params ) ; break ; case 'preview' : $ part = $ this -> __addPartSize ( $ part , $ operation_params ) ; break ; case 'custom' : $ part = array ( $ operation_params ) ; break ; } $ part_str = join ( '/' , $ part ) ; $ operations [ ] = $ part_str ; } } if ( count ( $ operations ) ) { $ operations_part = join ( '/-/' , $ operations ) ; return $ url . '-/' . $ operations_part . '/' . $ postfix ; } else { return $ url . $ postfix ; } }
2759	protected function getStorageKey ( $ key , $ limit , $ milliseconds ) { $ window = $ milliseconds * ( floor ( ( microtime ( 1 ) * 1000 ) / $ milliseconds ) ) ; $ date = date ( 'YmdHis' , $ window / 1000 ) ; return $ date . '::' . $ key . '::' . $ limit . '::' . $ milliseconds . '::COUNT' ; }
12170	public function createTables ( Database $ database ) { $ this -> database = $ database ; $ this -> database -> startTransaction ( ) ; $ this -> createAuthorityTable ( ) ; $ this -> createAuthorityPermissionsTable ( ) ; $ this -> createMenutable ( ) ; $ this -> createMenuGroupTable ( ) ; $ this -> createOptionsTable ( ) ; $ this -> createSessionTable ( ) ; $ this -> createTaxonomyTable ( ) ; $ this -> createObjectsTable ( ) ; $ this -> createGroupsTable ( ) ; $ this -> createObjectsAuthorityTable ( ) ; $ this -> createObjectsGroupTable ( ) ; $ this -> createObjectsEdgesTable ( ) ; $ this -> createPropertiesTable ( ) ; $ this -> createPropertyDatatypeTable ( ) ; $ this -> createPropertyValuesTable ( ) ; $ this -> createIndices ( ) ; $ this -> insertPropertyDatatypes ( ) ; $ this -> createObjectsRatingTable ( ) ; $ this -> createPropertyValuesProxyTable ( "attachment" ) ; $ this -> createPropertyValuesProxyTable ( "media" ) ; $ this -> createPropertyValuesProxyTable ( "user" ) ; $ this -> createPropertyValuesProxyTable ( "page" ) ; if ( ! $ this -> database -> commitTransaction ( ) ) { return false ; } return true ; }
4452	public function stats ( ? int $ date = null ) : array { $ date = $ date ? : time ( ) ; return json_decode ( $ this -> client -> stats ( $ this -> name , $ date ) , true ) ; }
3696	protected function extractIdFrom ( EnvironmentInterface $ environment , $ parameterName = 'pid' ) { $ parameter = $ environment -> getInputProvider ( ) -> getParameter ( $ parameterName ) ; return ModelId :: fromSerialized ( $ parameter ) -> getId ( ) ; }
3352	public function getUserAgentHeader ( ) { $ userAgentName = $ this -> getUserAgentName ( ) ; if ( $ userAgentName ) { return $ userAgentName ; } $ userAgent = sprintf ( '%s/%s/%s (PHP/%s.%s.%s' , $ this -> getLibraryName ( ) , $ this -> getVersion ( ) , $ this -> getPublicKey ( ) , PHP_MAJOR_VERSION , PHP_MINOR_VERSION , PHP_RELEASE_VERSION ) ; $ framework = $ this -> getFramework ( ) ; if ( $ framework ) { $ userAgent .= '; ' . $ framework ; } $ extension = $ this -> getExtension ( ) ; if ( $ extension ) { $ userAgent .= '; ' . $ extension ; } $ userAgent .= ')' ; return $ userAgent ; }
8656	private function convertGetFeedSubmissionListByNextToken ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetFeedSubmissionListByNextToken' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetNextToken ( ) ) { $ parameters [ 'NextToken' ] = $ request -> getNextToken ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
6221	public function setHttpClient ( $ httpClient ) { if ( is_null ( $ httpClient ) ) { $ httpClient = new Curl ; $ threeScaleVersion = new ThreeScaleVersion ( ) ; $ version = $ threeScaleVersion -> getVersion ( ) ; $ httpClient -> options [ 'CURLOPT_FOLLOWLOCATION' ] = false ; $ httpClient -> headers [ 'X-3scale-User-Agent' ] = 'plugin-php-v' . $ version ; } $ this -> httpClient = $ httpClient ; }
1058	public static function findTypesRemovedFromUnions ( Schema $ oldSchema , Schema $ newSchema ) { $ oldTypeMap = $ oldSchema -> getTypeMap ( ) ; $ newTypeMap = $ newSchema -> getTypeMap ( ) ; $ typesRemovedFromUnion = [ ] ; foreach ( $ oldTypeMap as $ typeName => $ oldType ) { $ newType = $ newTypeMap [ $ typeName ] ?? null ; if ( ! ( $ oldType instanceof UnionType ) || ! ( $ newType instanceof UnionType ) ) { continue ; } $ typeNamesInNewUnion = [ ] ; foreach ( $ newType -> getTypes ( ) as $ type ) { $ typeNamesInNewUnion [ $ type -> name ] = true ; } foreach ( $ oldType -> getTypes ( ) as $ type ) { if ( isset ( $ typeNamesInNewUnion [ $ type -> name ] ) ) { continue ; } $ typesRemovedFromUnion [ ] = [ 'type' => self :: BREAKING_CHANGE_TYPE_REMOVED_FROM_UNION , 'description' => sprintf ( '%s was removed from union type %s.' , $ type -> name , $ typeName ) , ] ; } } return $ typesRemovedFromUnion ; }
9571	public function bootConsole ( ) { $ this -> console = new ConsoleApplication ( 'Autarky' , static :: VERSION ) ; $ this -> console -> setAutarkyApplication ( $ this ) ; $ this -> boot ( ) ; return $ this -> console ; }
6594	public function getMethodDocumentation ( \ ReflectionMethod $ method ) { $ comment = $ this -> getMethodComment ( $ method ) ; $ summary = $ this -> getSummary ( $ comment ) ; $ parameters = $ this -> getParameters ( $ comment ) ; $ returnType = $ this -> getReturnType ( $ comment ) ; $ documentation = [ ] ; if ( $ summary ) { $ documentation [ 'summary' ] = $ summary ; $ description = $ this -> getDescription ( $ comment ) ; if ( $ description ) { $ documentation [ 'description' ] = $ description ; } } $ documentation [ 'parameters' ] = $ parameters ; $ documentation [ 'returnType' ] = $ returnType ; return $ documentation ; }
3942	private static function buildLanguageArray ( IMetaModel $ metaModel , TranslatorInterface $ translator ) { $ languages = array ( ) ; foreach ( ( array ) $ metaModel -> getAvailableLanguages ( ) as $ langCode ) { $ languages [ $ langCode ] = $ translator -> translate ( 'LNG.' . $ langCode , 'languages' ) ; } asort ( $ languages ) ; return $ languages ; }
6815	protected function buildFile ( array $ orders , string $ name ) { if ( false === $ path = tempnam ( sys_get_temp_dir ( ) , $ name ) ) { throw new RuntimeException ( "Failed to create temporary file." ) ; } if ( false === $ handle = fopen ( $ path , "w" ) ) { throw new RuntimeException ( "Failed to open '$path' for writing." ) ; } if ( ! empty ( $ headers = $ this -> buildHeaders ( ) ) ) { fputcsv ( $ handle , $ headers , ';' , '"' ) ; } $ supplierTotal = 0 ; $ forwarderTotal = 0 ; foreach ( $ orders as $ order ) { if ( ! empty ( $ row = $ this -> buildRow ( $ order ) ) ) { fputcsv ( $ handle , $ row , ';' , '"' ) ; $ supplierTotal += $ row [ 'payment_total' ] ; $ forwarderTotal += $ row [ 'forwarder_total' ] ; } } fputcsv ( $ handle , [ 'id' => '' , 'number' => '' , 'state' => '' , 'ordered_at' => '' , 'completed_at' => '' , 'supplier' => '' , 'payment_total' => $ supplierTotal , 'payment_date' => '' , 'payment_due_date' => '' , 'carrier' => '' , 'forwarder_total' => $ forwarderTotal , 'forwarder_date' => '' , 'forwarder_due_date' => '' , ] , ';' , '"' ) ; fclose ( $ handle ) ; return $ path ; }
7337	public function createClient ( ) : TgLog { $ this -> loop = Factory :: create ( ) ; $ handler = new HttpClientRequestHandler ( $ this -> loop ) ; return new TgLog ( $ this -> token , $ handler ) ; }
9548	public function validate ( UploadedFile $ file ) { foreach ( $ this -> constraints as $ constraint ) { if ( ! $ constraint -> validate ( $ file ) ) { throw new ConstraintException ( $ constraint , $ file ) ; } } return true ; }
4728	private function setCache ( $ singular , $ plural = null ) { $ singular = StringHelper :: strtolower ( $ singular ) ; if ( $ plural === null ) { $ plural = $ singular ; } else { $ plural = StringHelper :: strtolower ( $ plural ) ; } $ this -> cache [ $ singular ] = $ plural ; }
12823	protected function createContributorDir ( $ sourceDir , array $ options , $ username ) { if ( null === $ username ) { return ; } $ this -> init ( $ sourceDir , $ options , $ username ) ; if ( is_dir ( $ this -> contributorDir ) ) { return ; } $ this -> filesystem -> copy ( $ this -> productionDir . '/slot.json' , $ this -> contributorDir . '/slot.json' , true ) ; $ this -> filesystem -> mirror ( $ this -> productionDir . '/blocks' , $ this -> contributorDir . '/blocks' ) ; }
4294	public static function getType ( $ val , & $ typeMore = null ) { if ( \ is_string ( $ val ) ) { $ type = 'string' ; if ( \ is_numeric ( $ val ) ) { $ typeMore = 'numeric' ; } elseif ( $ val === self :: UNDEFINED ) { $ type = 'undefined' ; } elseif ( $ val === self :: RECURSION ) { $ type = 'recursion' ; } } elseif ( \ is_array ( $ val ) ) { if ( \ in_array ( self :: ABSTRACTION , $ val , true ) ) { $ type = $ val [ 'type' ] ; $ typeMore = 'abstraction' ; } elseif ( AbstractArray :: isCallable ( $ val ) ) { $ type = 'callable' ; $ typeMore = 'raw' ; } else { $ type = 'array' ; $ typeMore = 'raw' ; } } elseif ( \ is_bool ( $ val ) ) { $ type = 'bool' ; $ typeMore = \ json_encode ( $ val ) ; } elseif ( \ is_float ( $ val ) ) { $ type = 'float' ; } elseif ( \ is_int ( $ val ) ) { $ type = 'int' ; } elseif ( \ is_null ( $ val ) ) { $ type = 'null' ; } elseif ( \ is_object ( $ val ) ) { $ type = 'object' ; $ typeMore = 'raw' ; } elseif ( \ is_resource ( $ val ) || \ strpos ( \ print_r ( $ val , true ) , 'Resource' ) === 0 ) { $ type = 'resource' ; $ typeMore = 'raw' ; } return $ type ; }
657	public function release ( $ name ) { if ( $ this -> releaseLock ( $ name ) ) { $ index = array_search ( $ name , $ this -> _locks ) ; if ( $ index !== false ) { unset ( $ this -> _locks [ $ index ] ) ; } return true ; } return false ; }
2270	public function getSizeOf ( $ strTable ) { $ statement = $ this -> resConnection -> executeQuery ( 'SHOW TABLE STATUS LIKE ' . $ this -> resConnection -> quote ( $ strTable ) ) ; $ status = $ statement -> fetch ( \ PDO :: FETCH_ASSOC ) ; return $ status [ 'Data_length' ] + $ status [ 'Index_length' ] ; }
5364	protected function fix ( $ directory ) { if ( ! class_exists ( 'PhpCsFixer\Config' ) ) { return ; } $ fixerConfig = $ this -> fixerConfig ; if ( null === $ fixerConfig ) { $ fixerConfig = Config :: create ( ) -> setRiskyAllowed ( true ) -> setRules ( array ( '@Symfony' => true , 'array_syntax' => array ( 'syntax' => 'short' ) , 'simplified_null_return' => false , 'ordered_imports' => true , 'phpdoc_order' => true , 'binary_operator_spaces' => array ( 'align_equals' => true ) , 'concat_space' => false , 'yoda_style' => false , 'header_comment' => [ 'header' => <<<EOHThis file has been auto generated by Jane,Do no edit it directly.EOH , ] ) ) ; } $ resolverOptions = array ( 'allow-risky' => true ) ; $ resolver = new ConfigurationResolver ( $ fixerConfig , $ resolverOptions , $ directory , new ToolInfo ( ) ) ; $ finder = new Finder ( ) ; $ finder -> in ( $ directory ) ; $ fixerConfig -> setFinder ( $ finder ) ; $ runner = new Runner ( $ resolver -> getConfig ( ) -> getFinder ( ) , $ resolver -> getFixers ( ) , new NullDiffer ( ) , null , new ErrorsManager ( ) , new Linter ( ) , false , new NullCacheManager ( ) ) ; return $ runner -> fix ( ) ; }
10995	public function write ( string $ contents , int $ opts = 0 ) : bool { if ( $ this -> prepareWrite ( ) !== true ) { $ this -> error = "failed to write '{$this->path}; {$this->error}" ; return false ; } return $ this -> writeFile ( $ contents , $ opts ) ; }
720	public function binary ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_BINARY , $ length ) ; }
7519	function parse_doctype ( ) { $ start = $ this -> pos ; if ( $ this -> next_search ( '[>' , false ) === self :: TOK_UNKNOWN ) { if ( $ this -> doc [ $ this -> pos ] === '[' ) { if ( ( $ this -> next_pos ( ']' , false ) !== self :: TOK_UNKNOWN ) || ( $ this -> next_pos ( '>' , false ) !== self :: TOK_UNKNOWN ) ) { $ this -> addError ( 'Invalid doctype' ) ; return false ; } } $ this -> token_start = $ start ; $ this -> status [ 'dtd' ] = $ this -> getTokenString ( 2 , - 1 ) ; $ this -> status [ 'last_pos' ] = $ this -> pos ; return true ; } else { $ this -> addError ( 'Invalid doctype' ) ; return false ; } }
8780	protected function scheme ( ) { if ( $ this -> cachedHttps === true ) { $ this -> https = true ; } return "http" . ( $ this -> https === true ? 's' : '' ) . "://" ; }
1267	private function createRequest ( $ labelRecoveryRequest ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ trackRequest = $ xml -> appendChild ( $ xml -> createElement ( 'LabelRecoveryRequest' ) ) ; $ trackRequest -> setAttribute ( 'xml:lang' , 'en-US' ) ; $ request = $ trackRequest -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , 'LabelRecovery' ) ) ; $ labelSpecificationNode = $ trackRequest -> appendChild ( $ xml -> createElement ( 'LabelSpecification' ) ) ; if ( isset ( $ labelRecoveryRequest -> LabelSpecification ) ) { $ labelSpecificationNode -> appendChild ( $ xml -> createElement ( 'HTTPUserAgent' , $ labelRecoveryRequest -> LabelSpecification -> HTTPUserAgent ) ) ; $ labelImageFormatNode = $ labelSpecificationNode -> appendChild ( $ xml -> createElement ( 'LabelImageFormat' ) ) ; $ labelImageFormatNode -> appendChild ( $ xml -> createElement ( 'Code' , $ labelRecoveryRequest -> LabelSpecification -> LabelImageFormat -> Code ) ) ; } if ( isset ( $ labelRecoveryRequest -> Translate ) ) { $ translateNode = $ trackRequest -> appendChild ( $ xml -> createElement ( 'Translate' ) ) ; $ translateNode -> appendChild ( $ xml -> createElement ( 'LanguageCode' , $ labelRecoveryRequest -> Translate -> LanguageCode ) ) ; $ translateNode -> appendChild ( $ xml -> createElement ( 'DialectCode' , $ labelRecoveryRequest -> Translate -> DialectCode ) ) ; $ translateNode -> appendChild ( $ xml -> createElement ( 'Code' , $ labelRecoveryRequest -> Translate -> Code ) ) ; } if ( isset ( $ labelRecoveryRequest -> LabelLinkIndicator ) ) { $ labelLinkIndicatorNode = $ trackRequest -> appendChild ( $ xml -> createElement ( 'LabelLinkIndicator' ) ) ; $ labelLinkIndicatorNode -> appendChild ( $ xml -> createElement ( 'LabelLinkIndicator' ) ) ; } if ( isset ( $ labelRecoveryRequest -> TrackingNumber ) ) { $ trackRequest -> appendChild ( $ xml -> createElement ( 'TrackingNumber' , $ labelRecoveryRequest -> TrackingNumber ) ) ; } if ( isset ( $ labelRecoveryRequest -> ReferenceNumber ) ) { $ referenceNumberNode = $ trackRequest -> appendChild ( $ xml -> createElement ( 'ReferenceNumber' ) ) ; $ referenceNumberNode -> appendChild ( $ xml -> createElement ( 'Value' , $ labelRecoveryRequest -> ReferenceNumber -> getValue ( ) ) ) ; } if ( isset ( $ labelRecoveryRequest -> ShipperNumber ) ) { $ trackRequest -> appendChild ( $ xml -> createElement ( 'ShipperNumber' , $ labelRecoveryRequest -> ShipperNumber ) ) ; } return $ xml -> saveXML ( ) ; }
6833	public function userHasRight ( array $ user , $ right ) { $ hasRight = false ; if ( isset ( $ user [ 'role' ] ) && ! empty ( $ right ) && isset ( $ this -> _rightsConfig [ $ right ] ) ) { if ( in_array ( $ user [ 'role' ] , $ this -> _rightsConfig [ $ right ] ) ) { $ hasRight = true ; } } return $ hasRight ; }
1817	public function deleteElement ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { $ objElement = $ this -> Database -> prepare ( "SELECT id FROM tl_content WHERE cteAlias=? AND type='alias'" ) -> limit ( 1 ) -> execute ( $ row [ 'id' ] ) ; return $ objElement -> numRows ? Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' : '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' ; }
12371	public function addItem ( array $ item ) : self { if ( count ( $ item ) < 2 ) { throw new Exception ( 'Invalid count of item elements.' ) ; } $ this -> items [ ] = $ item ; return $ this ; }
12567	public function sendCard ( $ message , $ to = null ) { return $ this -> send ( self :: MSG_TYPE_CARD , $ message , $ to ) ; }
11863	public function setHandledDataItem ( $ value ) { if ( isset ( $ this -> _pairedDataItem ) ) { $ this -> pairedDataItem -> handledDataItem = $ value ; } if ( ! $ this -> _handledDataItem && $ value ) { $ this -> dataSource -> reduceRemaining ( $ this ) ; } $ this -> clean ( ) ; return $ this -> _handledDataItem = $ value ; }
1585	public function withLinks ( $ links ) : self { $ copy = clone $ this ; $ copy -> links = collect ( $ links ) -> all ( ) ; return $ copy ; }
12505	public static function commitTransaction ( $ connection ) { $ connection -> query = 'COMMIT' ; $ connection -> method = 'POST' ; $ connection -> action = '/_query' ; return self :: sendQuery ( $ connection ) ; }
10832	public function actionIndex ( ) { $ searchModel = new SearchState ( Yii :: $ app -> request -> get ( ) ) ; $ dataProvider = $ searchModel -> search ( Yii :: $ app -> request -> queryParams ) ; return $ this -> render ( 'index' , [ 'searchModel' => $ searchModel , 'dataProvider' => $ dataProvider ] ) ; }
7770	public function errors ( ) { $ messages = [ ] ; foreach ( $ this -> errors as $ rule => $ items ) { foreach ( $ items as $ item ) { $ field = $ item [ 'field' ] ; $ message = $ this -> fetchMessage ( $ field , $ rule ) ; if ( isset ( $ this -> fieldAliases [ $ field ] ) ) { $ item [ 'field' ] = $ this -> fieldAliases [ $ field ] ; } $ messages [ $ field ] [ ] = $ this -> replaceMessageFormat ( $ message , $ item ) ; } } return new MessageBag ( $ messages ) ; }
10436	public function channel ( string $ channel_id ) : LoggerChannelInterface { $ logger = $ this -> log_manager -> get ( $ channel_id ) ; if ( ! $ logger ) { return new NullLoggerChannel ( ) ; } return new CalgamoLoggerChannelAdapter ( $ logger ) ; }
10830	public static function file ( string $ path ) : fs \ entity \ FileEntity { return ( new fs \ entity \ FileEntity ( $ path ) ) -> normalize ( ) ; }
5851	protected function addToolbarButtons ( ) { $ buttonBar = $ this -> moduleTemplate -> getDocHeaderComponent ( ) -> getButtonBar ( ) ; $ saveSplitButton = $ buttonBar -> makeSplitButton ( ) ; $ saveButton = $ buttonBar -> makeInputButton ( ) -> setTitle ( htmlspecialchars ( $ this -> languageService -> sL ( 'LLL:EXT:lang/Resources/Private/Language/locallang_core.xlf:rm.saveDoc' ) ) ) -> setName ( '_savedok' ) -> setValue ( '1' ) -> setForm ( 'EditDocumentController' ) -> setIcon ( $ this -> moduleTemplate -> getIconFactory ( ) -> getIcon ( 'actions-document-save' , \ TYPO3 \ CMS \ Core \ Imaging \ Icon :: SIZE_SMALL ) ) ; $ saveSplitButton -> addItem ( $ saveButton , true ) ; $ saveAndCloseButton = $ buttonBar -> makeInputButton ( ) -> setTitle ( htmlspecialchars ( $ this -> languageService -> sL ( 'LLL:EXT:lang/Resources/Private/Language/locallang_core.xlf:rm.saveCloseDoc' ) ) ) -> setName ( '_saveandclosedok' ) -> setValue ( '1' ) -> setForm ( 'EditDocumentController' ) -> setClasses ( 't3js-editform-submitButton' ) -> setIcon ( $ this -> moduleTemplate -> getIconFactory ( ) -> getIcon ( 'actions-document-save-close' , \ TYPO3 \ CMS \ Core \ Imaging \ Icon :: SIZE_SMALL ) ) ; $ saveSplitButton -> addItem ( $ saveAndCloseButton ) ; $ buttonBar -> addButton ( $ saveSplitButton , \ TYPO3 \ CMS \ Backend \ Template \ Components \ ButtonBar :: BUTTON_POSITION_LEFT , 2 ) ; $ closeButton = $ buttonBar -> makeLinkButton ( ) -> setTitle ( htmlspecialchars ( $ this -> languageService -> sL ( 'LLL:EXT:lang/Resources/Private/Language/locallang_core.xlf:rm.closeDoc' ) ) ) -> setHref ( '#' ) -> setClasses ( 't3js-editform-close' ) -> setIcon ( $ this -> moduleTemplate -> getIconFactory ( ) -> getIcon ( 'actions-view-go-back' , \ TYPO3 \ CMS \ Core \ Imaging \ Icon :: SIZE_SMALL ) ) ; $ buttonBar -> addButton ( $ closeButton ) ; }
7109	static public function getRoundingIncrement ( $ currency ) { if ( isset ( static :: $ increments [ $ currency ] ) ) { return static :: $ increments [ $ currency ] ; } return static :: $ increments [ $ currency ] = static :: getCurrencyBundle ( ) -> getRoundingIncrement ( $ currency ) ; }
7926	public function fireEvent ( $ event , array $ args = [ ] ) { if ( isset ( $ this -> eventListeners [ $ event ] ) === false ) return $ args ; foreach ( $ this -> eventListeners [ $ event ] as $ listener ) call_user_func_array ( $ listener , $ args ) ; return $ args ; }
7030	public function toArray ( ) { return [ 'o_msg' => $ this -> overflowMessage , 'min_qty' => $ this -> minimumQuantity , 'min_msg' => $ this -> minimumMessage , 'max_qty' => INF === $ this -> maximumQuantity ? 'INF' : $ this -> maximumQuantity , 'max_msg' => $ this -> maximumMessage , 'a_qty' => INF === $ this -> availableQuantity ? 'INF' : $ this -> availableQuantity , 'a_msg' => $ this -> availableMessage , 'r_qty' => $ this -> resupplyQuantity , 'r_msg' => $ this -> resupplyMessage , ] ; }
6393	public static function run ( callable $ tryBlock , array $ exceptions = [ ] , callable $ finallyBlock = null ) : TryTo { try { return Success :: of ( Functions :: call ( $ tryBlock ) ) ; } catch ( Exception $ e ) { if ( count ( $ exceptions ) === 0 ) { return Failure :: of ( $ e ) ; } $ error = FluentIterable :: of ( $ exceptions ) -> filter ( Predicates :: assignableFrom ( get_class ( $ e ) ) ) -> first ( ) ; if ( $ error -> isPresent ( ) ) { return Failure :: of ( $ e ) ; } throw $ e ; } finally { if ( $ finallyBlock !== null ) { Functions :: call ( $ finallyBlock ) ; } } }
2624	private function sendReqToGA ( $ body = '' , $ method = \ Zend_Http_Client :: POST , $ uri = self :: GA_API_ENDPOINT ) { $ reqGAData = ( array ) $ this -> getGAReqData ( ) ; if ( $ body != '' && is_array ( $ body ) && ! empty ( $ body ) ) { $ body = array_merge ( $ reqGAData , $ body ) ; } try { $ client = $ this -> curlFactory -> create ( ) ; $ client -> addOption ( CURLOPT_TIMEOUT , 10 ) ; $ client -> write ( $ method , $ uri , '1.1' , null , http_build_query ( $ body ) ) ; $ response = $ client -> read ( ) ; $ responseCode = \ Zend_Http_Response :: extractCode ( $ response ) ; $ client -> close ( ) ; if ( $ responseCode != '200' ) { throw new LocalizedException ( __ ( 'Return status ' . $ responseCode ) ) ; } return true ; } catch ( \ Exception $ e ) { return false ; } }
569	protected function encrypt ( $ data , $ passwordBased , $ secret , $ info ) { if ( ! extension_loaded ( 'openssl' ) ) { throw new InvalidConfigException ( 'Encryption requires the OpenSSL PHP extension' ) ; } if ( ! isset ( $ this -> allowedCiphers [ $ this -> cipher ] [ 0 ] , $ this -> allowedCiphers [ $ this -> cipher ] [ 1 ] ) ) { throw new InvalidConfigException ( $ this -> cipher . ' is not an allowed cipher' ) ; } list ( $ blockSize , $ keySize ) = $ this -> allowedCiphers [ $ this -> cipher ] ; $ keySalt = $ this -> generateRandomKey ( $ keySize ) ; if ( $ passwordBased ) { $ key = $ this -> pbkdf2 ( $ this -> kdfHash , $ secret , $ keySalt , $ this -> derivationIterations , $ keySize ) ; } else { $ key = $ this -> hkdf ( $ this -> kdfHash , $ secret , $ keySalt , $ info , $ keySize ) ; } $ iv = $ this -> generateRandomKey ( $ blockSize ) ; $ encrypted = openssl_encrypt ( $ data , $ this -> cipher , $ key , OPENSSL_RAW_DATA , $ iv ) ; if ( $ encrypted === false ) { throw new \ yii \ base \ Exception ( 'OpenSSL failure on encryption: ' . openssl_error_string ( ) ) ; } $ authKey = $ this -> hkdf ( $ this -> kdfHash , $ key , null , $ this -> authKeyInfo , $ keySize ) ; $ hashed = $ this -> hashData ( $ iv . $ encrypted , $ authKey ) ; return $ keySalt . $ hashed ; }
9634	public function getFormField ( ) { if ( null === $ this -> field ) { $ this -> field = $ this -> initFormField ( ) ; } return $ this -> field ; }
11594	public function postAction ( ) { $ request = $ this -> environment -> getRequestHelper ( ) ; $ id = $ request -> getIdentifierParam ( 'name' ) ; try { $ this -> pageList -> getPage ( $ id ) ; } catch ( InvalidParameterException $ e ) { $ page = $ this -> pageList -> addPageFromRequest ( $ id , $ request ) ; $ this -> environment -> sendJSONResult ( $ page -> getJSON ( ) ) ; return ; } throw new InvalidParameterException ( "Page already exists" ) ; }
8295	public function open ( ) { if ( $ this -> isOpened ( ) ) { return ; } $ this -> handle = @ fopen ( $ this -> filePath , self :: OPEN_MODE ) ; if ( $ this -> handle === false ) { throw new \ RuntimeException ( "Could not open file for writing: " . $ this -> filePath ) ; } if ( ! $ this -> lock ( LOCK_EX ) ) { $ this -> close ( ) ; throw new \ RuntimeException ( "Could not aquire an exclusive lock for " . $ this -> filePath ) ; } if ( $ this -> options [ "backup" ] ) { $ this -> createBkFile ( ) ; } $ this -> writeErrors = false ; }
8322	public function getLoad ( $ paramsList = [ 'waiting' , 'load' , 'minbid' , 'averageRecognitionTime' ] ) { $ parser = $ this -> getLoadXml ( ) ; if ( is_string ( $ paramsList ) ) { return $ parser -> $ paramsList -> __toString ( ) ; } $ statusData = [ ] ; foreach ( $ paramsList as $ item ) { $ statusData [ $ item ] = $ parser -> $ item -> __toString ( ) ; } return $ statusData ; }
4700	protected function handleInput ( InputInterface $ input ) { if ( $ file = $ input -> getArgument ( 'file' ) ) { if ( ! file_exists ( $ file ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The input file "%s" not found' , $ file ) ) ; } return file_get_contents ( $ file ) ; } else { $ contents = '' ; if ( $ stdin = fopen ( 'php://stdin' , 'r' ) ) { if ( stream_set_blocking ( $ stdin , false ) ) { $ contents = stream_get_contents ( $ stdin ) ; } fclose ( $ stdin ) ; } if ( $ contents ) { return $ contents ; } } throw new \ InvalidArgumentException ( 'No input file' ) ; }
6248	public function getAll ( ) { $ permissions = $ this -> modules -> getAllPermissions ( ) ; $ permissions = array_merge ( $ permissions , $ this -> getCustom ( ) ) ; return array_unique ( $ permissions ) ; }
416	public function getAcceptableLanguages ( ) { if ( $ this -> _languages === null ) { if ( $ this -> headers -> has ( 'Accept-Language' ) ) { $ this -> _languages = array_keys ( $ this -> parseAcceptHeader ( $ this -> headers -> get ( 'Accept-Language' ) ) ) ; } else { $ this -> _languages = [ ] ; } } return $ this -> _languages ; }
4407	public function getCurrentMenuPlugin ( ) { $ currentRequest = $ this -> requestStack -> getCurrentRequest ( ) ; if ( ! $ currentRequest instanceof Request ) { return false ; } foreach ( $ this -> menuPluginRegistry -> getMenuPlugins ( ) as $ identifier => $ menuPlugin ) { if ( $ menuPlugin -> matches ( $ currentRequest ) ) { return $ identifier ; } } return false ; }
12018	protected function setup ( \ AMQPQueue $ queue ) { $ queue -> declareQueue ( ) ; foreach ( $ this -> binds as $ exchange => $ params ) { $ queue -> bind ( $ exchange , $ params [ 'routing_key' ] , $ params [ 'arguments' ] ) ; } }
4930	public function detach ( EventManagerInterface $ events ) { foreach ( $ this -> listeners as $ i => $ listener ) { if ( $ events -> detach ( $ listener ) ) { unset ( $ this -> listeners [ $ i ] ) ; } } return empty ( $ this -> listeners ) ; }
11408	public function onBootstrap ( MvcEvent $ e ) { if ( ! $ e -> getRequest ( ) instanceof HttpRequest ) { return ; } $ app = $ e -> getApplication ( ) ; $ services = $ app -> getServiceManager ( ) ; $ eventManager = $ app -> getEventManager ( ) ; $ sharedEventManager = $ eventManager -> getSharedManager ( ) ; $ sharedEventManager -> attach ( UserService :: class , 'register' , function ( $ e ) use ( $ services ) { $ user = $ e -> getParam ( 'user' ) ; if ( $ user instanceof RoleableInterface && $ services -> has ( AuthorizationModuleOptions :: class ) ) { $ config = $ services -> get ( PermissionsModuleOptions :: class ) ; $ roleClass = $ config -> getRoleEntityClass ( ) ; $ mapper = $ services -> get ( 'MapperManager' ) -> get ( $ roleClass ) ; if ( $ defaultRole = $ mapper -> find ( $ config -> getAuthenticatedRole ( ) ) ) { $ user -> addRole ( $ defaultRole ) ; } } } , 100 ) ; }
8274	public function assertUsername ( $ username , $ config ) { if ( ! is_string ( $ username ) ) { throw new ConfigurationException ( "Username $username must be a string." ) ; } $ len = strlen ( $ username ) ; $ minLen = $ config [ "registration" ] [ "nameLenMin" ] ; $ maxLen = $ config [ "registration" ] [ "nameLenMax" ] ; if ( $ len < $ minLen || $ len > $ maxLen ) { throw new ConfigurationException ( sprintf ( "Length of a username $username must be between %d-%d characters." , $ minLen , $ maxLen ) ) ; } if ( ! $ this -> checkValidNameFormat ( $ username ) ) { throw new ConfigurationException ( "Username $username contains invalid character/s." ) ; } }
6258	public function authorizeByControllerAndAction ( $ user , Request $ request ) { $ roleField = $ this -> _config [ 'roleField' ] ; extract ( $ this -> getControllerNameAndAction ( $ request ) ) ; $ actionMap = $ this -> getActionMap ( ) ; if ( isset ( $ actionMap [ $ name ] [ '*' ] ) ) { if ( $ this -> _isAllowedRole ( $ user [ $ roleField ] , $ actionMap [ $ name ] [ '*' ] ) ) { return true ; } } if ( isset ( $ actionMap [ $ name ] [ $ action ] ) ) { if ( $ this -> _isAllowedRole ( $ user [ $ roleField ] , $ actionMap [ $ name ] [ $ action ] ) ) { return true ; } } if ( $ this -> config ( 'undefinedActionsAreAllowed' ) === true ) { return true ; } return false ; }
9387	public function restful ( $ route , $ class , $ middlewares = array ( ) ) { $ middlewares = ( is_string ( $ middlewares ) ) ? array ( $ middlewares ) : $ middlewares ; $ this -> add ( 'GET' , '/' . $ route , $ class . '@index' , $ middlewares ) ; $ this -> add ( 'POST' , '/' . $ route , $ class . '@store' , $ middlewares ) ; $ this -> add ( 'DELETE' , '/' . $ route . '/:id' , $ class . '@delete' , $ middlewares ) ; $ this -> add ( 'GET' , '/' . $ route . '/:id' , $ class . '@show' , $ middlewares ) ; $ this -> add ( 'PATCH' , '/' . $ route . '/:id' , $ class . '@update' , $ middlewares ) ; $ this -> add ( 'PUT' , '/' . $ route . '/:id' , $ class . '@update' , $ middlewares ) ; return $ this ; }
4909	public function renderForm ( SummaryFormInterface $ form , $ layout = Form :: LAYOUT_HORIZONTAL , $ parameter = array ( ) ) { $ renderer = $ this -> getView ( ) ; $ formHelper = $ renderer -> plugin ( 'form' ) ; $ fieldset = $ form -> getBaseFieldset ( ) ; $ resetPartial = false ; if ( $ fieldset instanceof ViewPartialProviderInterface ) { $ origPartial = $ fieldset -> getViewPartial ( ) ; $ partial = "$origPartial.form" ; if ( $ renderer -> resolver ( $ partial ) ) { $ fieldset -> setViewPartial ( $ partial ) ; $ resetPartial = true ; } } $ markup = $ formHelper -> renderBare ( $ form , $ layout , $ parameter ) ; if ( $ resetPartial ) { $ fieldset -> setViewPartial ( $ origPartial ) ; } return $ markup ; }
3166	public function getCurrentAssessmentSession ( RunnerServiceContext $ context ) { if ( $ context -> isAdaptive ( ) ) { return new AssessmentItemSession ( $ context -> getCurrentAssessmentItemRef ( ) , new SessionManager ( ) ) ; } else { return $ context -> getTestSession ( ) ; } }
8913	protected function _set_where ( $ params ) { if ( count ( $ params ) == 1 ) { $ this -> _database -> where ( $ params [ 0 ] ) ; } else if ( count ( $ params ) == 2 ) { $ this -> _database -> where ( $ params [ 0 ] , $ params [ 1 ] ) ; } else if ( count ( $ params ) == 3 ) { $ this -> _database -> where ( $ params [ 0 ] , $ params [ 1 ] , $ params [ 2 ] ) ; } else { $ this -> _database -> where ( $ params ) ; } }
6777	protected function updateVatData ( SaleInterface $ sale ) { $ changed = false ; if ( null !== $ customer = $ sale -> getCustomer ( ) ) { if ( 0 == strlen ( $ sale -> getVatNumber ( ) ) && 0 < strlen ( $ customer -> getVatNumber ( ) ) ) { $ sale -> setVatNumber ( $ customer -> getVatNumber ( ) ) ; $ changed = true ; } if ( empty ( $ sale -> getVatDetails ( ) ) && ! empty ( $ customer -> getVatDetails ( ) ) ) { $ sale -> setVatDetails ( $ customer -> getVatDetails ( ) ) ; $ changed = true ; } if ( ! $ sale -> isVatValid ( ) && $ customer -> isVatValid ( ) ) { $ sale -> setVatValid ( true ) ; $ changed = true ; } } return $ changed ; }
7787	public function setAccountClass ( $ accountClass ) { if ( ! is_callable ( $ accountClass ) && ! class_exists ( $ accountClass ) ) { throw new \ InvalidArgumentException ( '$accountClass must be a valid classname or a PHP callable' ) ; } $ this -> accountClass = $ accountClass ; return $ this ; }
9814	public function addEntriesToBlacklist ( $ id , $ entries , $ importName = null ) { if ( $ importName == null ) { $ importName = "phpclient_import_" . uniqid ( ) ; } $ action = new AddEntriesAction ( ) ; $ action -> importName = $ importName ; $ action -> entries = $ entries ; return $ this -> post ( "blacklists/" . $ id . "/actions" , $ action -> toXMLString ( ) ) ; }
8451	public function setProfilePhoto ( $ mediaUri ) { $ processedMedia = $ this -> processMediaUri ( $ mediaUri ) ; if ( ! $ processedMedia ) { return false ; } $ result = $ this -> exec ( 'set_profile_photo ' . $ processedMedia [ 'filepath' ] ) ; $ this -> cleanUpMedia ( $ processedMedia ) ; return $ result ; }
11694	protected function getCompiler ( SplFileInfo $ file ) : Compiler { $ source_type = $ this -> getSourceType ( $ file ) ; $ compiler_type = '\Gears\Asset\Compilers\\' ; $ compiler_type .= ucfirst ( $ source_type ) ; if ( ! class_exists ( $ compiler_type ) ) { throw new RuntimeException ( 'The source file type is not supported! - (' . $ file . ')' ) ; } return new $ compiler_type ( $ file , $ this -> destination , $ this -> debug , $ this -> autoprefix ) ; }
10235	private function getImageMimeType ( $ pFile ) { if ( File :: fileExists ( $ pFile ) ) { $ image = getimagesize ( $ pFile ) ; return image_type_to_mime_type ( $ image [ 2 ] ) ; } throw new WriterException ( "File $pFile does not exist" ) ; }
7260	protected function createPercentAdjustment ( Model \ AdjustmentInterface $ data , float $ base , string $ currency ) : Adjustment { $ this -> assertAdjustmentMode ( $ data , Model \ AdjustmentModes :: MODE_PERCENT ) ; $ rate = ( float ) $ data -> getAmount ( ) ; if ( $ data -> getType ( ) === Model \ AdjustmentTypes :: TYPE_TAXATION ) { $ amount = Money :: round ( $ base * ( 1 + $ rate / 100 ) , $ currency ) - Money :: round ( $ base , $ currency ) ; } else { $ amount = Money :: round ( $ base * $ rate / 100 , $ currency ) ; } return new Adjustment ( ( string ) $ data -> getDesignation ( ) , $ amount , $ rate ) ; }
1210	public function split ( ItemInterface $ item , $ length ) { return array ( 'primary' => $ this -> slice ( $ item , 0 , $ length ) , 'secondary' => $ this -> slice ( $ item , $ length ) , ) ; }
12928	public function update ( $ poiId , array $ data ) { $ data = array_merge ( $ data , [ 'poi_id' => $ poiId ] ) ; $ params = [ 'business' => [ 'base_info' => $ data ] , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_UPDATE , $ params ] ) ; }
8832	public function tokenise ( $ pattern , $ expand = false ) { preg_match_all ( ' / (?<class_U_explicit>\\\U) \{ (?<class_U_repetition>[0-9]+) \} | (?<class_U_implicit>\\\U) | \[ (?<range_token_explicit>[^]]+) \] \{ (?<range_repetition>[0-9]+) \} | \[ (?<range_token_implicit>[^]]+) \] | (?<literal_string>[^\\\[]+) /x ' , $ pattern , $ matches , \ PREG_SET_ORDER ) ; $ tokens = [ ] ; foreach ( $ matches as $ match ) { if ( ! empty ( $ match [ 'class_U_explicit' ] ) ) { $ token = [ 'type' => 'class' , 'class' => static :: CLASS_UPPERCASE_UNAMBIGUOUS , 'repetition' => ( int ) $ match [ 'class_U_repetition' ] ] ; if ( $ expand ) { $ token [ 'haystack' ] = 'ABCDEFGHKMNOPRSTUVWXYZ23456789' ; } $ tokens [ ] = $ token ; } else if ( ! empty ( $ match [ 'class_U_implicit' ] ) ) { $ token = [ 'type' => 'class' , 'class' => static :: CLASS_UPPERCASE_UNAMBIGUOUS , 'repetition' => 1 ] ; if ( $ expand ) { $ token [ 'haystack' ] = 'ABCDEFGHKMNOPRSTUVWXYZ23456789' ; } $ tokens [ ] = $ token ; } else if ( ! empty ( $ match [ 'range_token_explicit' ] ) ) { $ token = [ 'type' => 'range' , 'token' => $ match [ 'range_token_explicit' ] , 'repetition' => ( int ) $ match [ 'range_repetition' ] ] ; if ( $ expand ) { $ token [ 'haystack' ] = static :: expandRange ( $ match [ 'range_token_explicit' ] ) ; } $ tokens [ ] = $ token ; } else if ( ! empty ( $ match [ 'range_token_implicit' ] ) ) { $ token = [ 'type' => 'range' , 'token' => $ match [ 'range_token_implicit' ] , 'repetition' => 1 ] ; if ( $ expand ) { $ token [ 'haystack' ] = static :: expandRange ( $ match [ 'range_token_implicit' ] ) ; } $ tokens [ ] = $ token ; } else if ( ! empty ( $ match [ 'literal_string' ] ) ) { $ tokens [ ] = [ 'type' => 'literal' , 'string' => $ match [ 'literal_string' ] ] ; } } return $ tokens ; }
11165	protected function getDurationFormat ( array $ config ) { if ( isset ( $ config [ 'durationFormat' ] ) ) { if ( ! is_string ( $ config [ 'durationFormat' ] ) ) { throw new \ DomainException ( 'durationFormat must reference a string' , self :: ERR_INVALID_DURATIONFORMAT ) ; } return $ config [ 'durationFormat' ] ; } return '%im%ss' ; }
12591	protected function checkParams ( $ params , $ operator ) { if ( ! is_array ( $ params ) ) { throw new Exception ( 'Web2All_Table_MultiValueOperator: first param must be an array' ) ; } if ( $ operator == 'IN' ) { if ( count ( $ params ) < 1 ) { throw new Exception ( 'Web2All_Table_MultiValueOperator: IN operator requires at least one param' ) ; } } elseif ( $ operator == 'BETWEEN' ) { if ( count ( $ params ) != 2 ) { throw new Exception ( 'Web2All_Table_MultiValueOperator: BETWEEN operator requires exactly two params' ) ; } } else { throw new Exception ( 'Web2All_Table_MultiValueOperator: unsupported operator "' . $ operator . '"' ) ; } }
3130	public function getServiceContext ( $ testDefinitionUri , $ testCompilationUri , $ testExecutionUri , $ userUri = null ) { $ serviceContext = new QtiRunnerServiceContext ( $ testDefinitionUri , $ testCompilationUri , $ testExecutionUri ) ; $ serviceContext -> setServiceManager ( $ this -> getServiceManager ( ) ) ; $ serviceContext -> setTestConfig ( $ this -> getTestConfig ( ) ) ; $ serviceContext -> setUserUri ( $ userUri ) ; $ sessionService = $ this -> getServiceManager ( ) -> get ( TestSessionService :: SERVICE_ID ) ; $ sessionService -> registerTestSession ( $ serviceContext -> getTestSession ( ) , $ serviceContext -> getStorage ( ) , $ serviceContext -> getCompilationDirectory ( ) ) ; return $ serviceContext ; }
9876	public function writeWorkbook ( Spreadsheet $ spreadsheet , $ recalcRequired = false ) { if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ objWriter -> startElement ( 'workbook' ) ; $ objWriter -> writeAttribute ( 'xml:space' , 'preserve' ) ; $ objWriter -> writeAttribute ( 'xmlns' , 'http://schemas.openxmlformats.org/spreadsheetml/2006/main' ) ; $ objWriter -> writeAttribute ( 'xmlns:r' , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships' ) ; $ this -> writeFileVersion ( $ objWriter ) ; $ this -> writeWorkbookPr ( $ objWriter ) ; $ this -> writeWorkbookProtection ( $ objWriter , $ spreadsheet ) ; if ( $ this -> getParentWriter ( ) -> getOffice2003Compatibility ( ) === false ) { $ this -> writeBookViews ( $ objWriter , $ spreadsheet ) ; } $ this -> writeSheets ( $ objWriter , $ spreadsheet ) ; $ this -> writeDefinedNames ( $ objWriter , $ spreadsheet ) ; $ this -> writeCalcPr ( $ objWriter , $ recalcRequired ) ; $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
6722	public function fetchAccessToken ( $ code ) { $ this -> validateTokenParams ( ) ; $ this -> oauth2 -> tokenUrl = $ this -> tokenUrl ; $ this -> oauth2 -> clientId = $ this -> clientId ; $ this -> oauth2 -> clientSecret = $ this -> clientSecret ; try { $ response = $ this -> oauth2 -> fetchAccessToken ( $ code ) ; } catch ( Exception $ ex ) { throw new Oauth2ClientException ( $ ex -> getMessage ( ) ) ; } return $ this -> handleTokenResponse ( $ response ) ; }
12315	public function sortAction ( Request $ request ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; if ( $ request -> isXmlHttpRequest ( ) ) { $ this -> get ( 'admin_manager' ) -> sort ( 'BlogBundle:Category' , $ request -> get ( 'values' ) ) ; return new Response ( 0 , 200 ) ; } $ categories = $ em -> getRepository ( 'BlogBundle:Category' ) -> findBy ( array ( 'parentCategory' => NULL ) , array ( 'order' => 'asc' ) ) ; return array ( 'categories' => $ categories ) ; }
1183	protected function getSessionToken ( ) { $ token = null ; if ( $ session = $ this -> app -> __get ( 'session' ) ) { $ token = $ session -> token ( ) ; } if ( $ encrypter = $ this -> app -> __get ( 'encrypter' ) ) { $ token = $ encrypter -> encrypt ( $ token ) ; } return $ token ; }
438	public function __isset ( $ name ) { $ getter = 'get' . $ name ; if ( method_exists ( $ this , $ getter ) ) { return $ this -> $ getter ( ) !== null ; } $ this -> ensureBehaviors ( ) ; foreach ( $ this -> _behaviors as $ behavior ) { if ( $ behavior -> canGetProperty ( $ name ) ) { return $ behavior -> $ name !== null ; } } return false ; }
12745	protected function move ( NodeConnectionInterface $ connection , $ slot ) { $ this -> pool [ ( string ) $ connection ] = $ connection ; $ this -> slots [ ( int ) $ slot ] = $ connection ; $ this -> slotmap [ ( int ) $ slot ] = $ connection ; }
7740	public function validate ( $ entity ) { if ( ! $ this -> container -> has ( 'validator' ) ) { throw new \ LogicException ( 'The validator service is not available.' ) ; } $ errors = $ this -> container -> get ( 'validator' ) -> validate ( $ entity ) ; if ( count ( $ errors ) === 0 ) { return false ; } return new JsonLdResponse ( '{ "error": "Validation error" }' , 400 ) ; }
9164	protected function parseNode ( RuleCollection $ collection , \ DOMElement $ node , $ path , $ file ) { if ( self :: NAMESPACE_URI !== $ node -> namespaceURI ) { return ; } switch ( $ node -> localName ) { case 'rule' : $ this -> parseRule ( $ collection , $ node , $ path ) ; break ; case 'import' : $ this -> parseImport ( $ collection , $ node , $ path , $ file ) ; break ; default : throw new \ InvalidArgumentException ( sprintf ( 'Unknown tag "%s" used in file "%s". Expected "rule" or "import".' , $ node -> localName , $ path ) ) ; } }
12817	public function fetchAll ( ) { $ list = [ ] ; foreach ( $ this -> cache as $ domain => $ values ) { foreach ( $ values as $ key => $ value ) $ list [ sprintf ( "%s.%s" , $ domain != '<NULL>' ? $ domain : '' , $ key ) ] = $ value ; } return $ list ; }
9349	public function multiplyAllow ( $ matrix ) { if ( is_numeric ( $ matrix ) ) { return true ; } if ( $ matrix instanceof Complex ) { return true ; } if ( $ matrix instanceof Matrix ) { return $ this -> size -> cols == $ matrix -> rows ; } return false ; }
6711	protected function urlToParameters ( $ url ) { $ urlParameters = [ ] ; $ url = parse_url ( $ url , PHP_URL_PATH ) ; $ urlParts = explode ( '/' , $ url ) ; reset ( $ urlParts ) ; $ key = next ( $ urlParts ) ; while ( ( $ value = next ( $ urlParts ) ) !== false ) { $ urlParameters [ $ key ] = $ value ; $ key = $ value ; } return $ urlParameters ; }
10860	protected function createObject ( string $ typeName , ? bool $ nullable = false , ? bool $ checkCycles = true , ? bool $ treatAsNotFound = true ) : ? object { if ( $ checkCycles ) { $ this -> underConstruction [ $ typeName ] = true ; } try { if ( ! isset ( $ this -> typeCache [ $ typeName ] ) ) { if ( \ class_exists ( $ typeName ) || \ interface_exists ( $ typeName , false ) ) { $ this -> typeCache [ $ typeName ] = new \ ReflectionClass ( $ typeName ) ; } else { $ this -> typeCache [ $ typeName ] = false ; } } if ( $ this -> typeCache [ $ typeName ] === false ) { if ( $ nullable ) { return null ; } if ( $ treatAsNotFound ) { throw new NotFoundException ( \ sprintf ( 'Cannot load type: %s' , $ typeName ) ) ; } throw new ContainerException ( \ sprintf ( 'Cannot load type: %s' , $ typeName ) ) ; } if ( ! $ this -> typeCache [ $ typeName ] -> isInstantiable ( ) ) { if ( $ nullable ) { return null ; } throw new NotFoundException ( \ sprintf ( 'Type is not instantiable: %s' , $ typeName ) ) ; } if ( isset ( $ this -> constructorCache [ $ typeName ] ) ) { $ con = $ this -> constructorCache [ $ typeName ] ; } else { $ con = $ this -> constructorCache [ $ typeName ] = $ this -> typeCache [ $ typeName ] -> getConstructor ( ) ? : false ; } return ( $ con === false ) ? new $ typeName ( ) : new $ typeName ( ... $ this -> populateArguments ( $ con , null , $ typeName ) ) ; } finally { if ( $ checkCycles ) { unset ( $ this -> underConstruction [ $ typeName ] ) ; } } }
8856	public function increase ( ) { $ this -> retries ++ ; if ( $ this -> retries > $ this -> maxRetries ) { throw new MaxRetriesExceededException ( sprintf ( 'Max allowed retries exceeded. Allowed: %s. Tried: %s.' , $ this -> maxRetries , $ this -> retries ) ) ; } return $ this ; }
7562	protected function parse_pipe ( ) { if ( ( ( $ this -> pos + 1 ) < $ this -> size ) && ( $ this -> doc [ $ this -> pos + 1 ] === '=' ) ) { ++ $ this -> pos ; return ( $ this -> token = self :: TOK_COMPARE_PREFIX ) ; } else { return ( $ this -> token = self :: TOK_PIPE ) ; } }
7115	protected function getOneQueryBuilder ( $ alias = null , $ indexBy = null ) { return $ this -> createQueryBuilder ( $ alias , $ indexBy ) -> select ( $ alias , 'customer' , 'customer_group' , 'invoice_address' , 'delivery_address' , 'shipment_method' , 'currency' ) -> leftJoin ( $ alias . '.customer' , 'customer' ) -> leftJoin ( $ alias . '.customerGroup' , 'customer_group' ) -> leftJoin ( $ alias . '.invoiceAddress' , 'invoice_address' ) -> leftJoin ( $ alias . '.deliveryAddress' , 'delivery_address' ) -> leftJoin ( $ alias . '.shipmentMethod' , 'shipment_method' ) -> leftJoin ( $ alias . '.currency' , 'currency' ) -> setMaxResults ( 1 ) ; }
1352	protected function notAllowed ( string $ resourceType , string $ fields ) : Collection { $ fields = collect ( explode ( ',' , $ fields ) ) ; if ( ! $ this -> allowed -> has ( $ resourceType ) ) { return $ fields ; } $ allowed = $ this -> allowed -> get ( $ resourceType ) ; if ( is_null ( $ allowed ) ) { return collect ( ) ; } $ allowed = collect ( ( array ) $ allowed ) ; return $ fields -> reject ( function ( $ value ) use ( $ allowed ) { return $ allowed -> contains ( $ value ) ; } ) ; }
533	public function actionFix ( $ root = null ) { $ files = $ this -> findFiles ( $ root , false ) ; $ nFilesTotal = 0 ; $ nFilesUpdated = 0 ; foreach ( $ files as $ file ) { $ contents = file_get_contents ( $ file ) ; $ hash = $ this -> hash ( $ contents ) ; $ lines = preg_split ( '/(\r\n|\n|\r)/' , $ contents ) ; if ( ! $ this -> skipFrameworkRequirements ) { $ this -> fixFileDoc ( $ lines ) ; } $ this -> fixDocBlockIndentation ( $ lines ) ; $ lines = array_values ( $ this -> fixLineSpacing ( $ lines ) ) ; $ newContent = implode ( "\n" , $ lines ) ; if ( $ hash !== $ this -> hash ( $ newContent ) ) { file_put_contents ( $ file , $ newContent ) ; $ nFilesUpdated ++ ; } $ nFilesTotal ++ ; } $ this -> stdout ( "\nParsed $nFilesTotal files.\n" ) ; $ this -> stdout ( "Updated $nFilesUpdated files.\n" ) ; }
3268	protected function closeFile ( SplFileObject & $ file ) { if ( ! $ this -> getConfig ( ) -> useGzip ( ) && ! $ file -> flock ( LOCK_UN ) ) { $ file = null ; throw new Exception ( 'Could not unlock file' ) ; } $ file = null ; }
372	public function stderr ( $ string ) { if ( $ this -> isColorEnabled ( \ STDERR ) ) { $ args = func_get_args ( ) ; array_shift ( $ args ) ; $ string = Console :: ansiFormat ( $ string , $ args ) ; } return fwrite ( \ STDERR , $ string ) ; }
4884	public function addDependencies ( $ name , $ entities = null , array $ options = null ) { return $ this -> dependencyResultCollection -> add ( $ name , $ entities , $ options ) ; }
12736	public function mapModelToLangName ( $ modelName , $ langName ) { $ modelName = $ this -> getClassName ( $ modelName ) ; $ this -> modelToLangName [ $ modelName ] = $ langName ; }
2716	public function addTextInput ( $ id , $ label , $ comment , $ required = true ) { $ this -> children [ $ id ] = [ 'id' => $ id , 'type' => 'text' , 'translate' => 'label comment' , 'showInDefault' => 1 , 'showInWebsite' => 0 , 'showInStore' => 0 , 'sortOrder' => count ( $ this -> children ) , 'label' => $ label , 'comment' => $ comment , 'validate' => ( $ required == true ) ? 'required-entry' : '' , '_elementType' => 'field' , 'path' => self :: BASE_CONFIG_PATH . '/' . $ this -> id ] ; }
7613	public function sendEmail ( ) { $ user = User :: findOne ( [ 'status' => User :: STATUS_ACTIVE , 'email' => $ this -> email , ] ) ; if ( $ user ) { $ user -> generatePasswordResetToken ( ) ; if ( $ user -> save ( ) ) { return \ Yii :: $ app -> mailer -> compose ( '@auth/views/mail/passwordResetToken' , [ 'user' => $ user ] ) -> setFrom ( [ \ Yii :: $ app -> getModule ( 'auth' ) -> supportEmail => \ Yii :: $ app -> name ] ) -> setTo ( $ this -> email ) -> setSubject ( Yii :: t ( 'auth.reset-password' , 'Password reset for {name}' , [ 'name' => \ Yii :: $ app -> name ] ) ) -> send ( ) ; } } return false ; }
9384	public function getIcons ( ) { $ icons = [ ] ; foreach ( $ this -> getGroupedIcons ( ) as $ name => $ group ) { foreach ( $ group as $ id => $ icon ) { if ( ! isset ( $ icons [ $ id ] ) ) { $ icons [ $ id ] = isset ( $ icon [ 'name' ] ) ? $ icon [ 'name' ] : $ id ; } } } ksort ( $ icons ) ; return $ icons ; }
6638	protected function initContainer ( $ module ) { $ map = [ ] ; $ defaultClassMap = [ 'AddPermissionForm' => AddPermissionForm :: class , 'AssignRoleForm' => AssignRoleForm :: class , 'LoginForm' => LoginForm :: class , 'RequestPasswordResetForm' => RequestPasswordResetForm :: class , 'ResetPasswordForm' => ResetPasswordForm :: class , 'AuthAssignment' => AuthAssignment :: class , 'AuthItem' => AuthItem :: class , 'AuthItemChild' => AuthItemChild :: class , 'AuthRule' => AuthRule :: class , 'Message' => Message :: class , 'SourceMessage' => SourceMessage :: class , 'User' => User :: class , 'MessageQuery' => MessageQuery :: class , 'SourceMessageQuery' => SourceMessageQuery :: class , 'UserQuery' => UserQuery :: class , 'SourceMessageSearch' => SourceMessageSearch :: class , 'UserSearch' => UserSearch :: class , ] ; $ routes = [ 'mrstroz\\wavecms\\forms' => [ 'AddPermissionForm' , 'AssignRoleForm' , 'LoginForm' , 'RequestPasswordResetForm' , 'ResetPasswordForm' , ] , 'mrstroz\\wavecms\\models' => [ 'AuthAssignment' , 'AuthItem' , 'AuthItemChild' , 'AuthRule' , 'Message' , 'SourceMessage' , 'User' , ] , 'mrstroz\\wavecms\\models\\query' => [ 'MessageQuery' , 'SourceMessageQuery' , 'UserQuery' , ] , 'mrstroz\\wavecms\\models\\search' => [ 'SourceMessageSearch' , 'UserSearch' , ] ] ; $ mapping = array_merge ( $ defaultClassMap , $ module -> classMap ) ; foreach ( $ mapping as $ name => $ definition ) { $ map [ $ this -> getContainerRoute ( $ routes , $ name ) . "\\$name" ] = $ definition ; } $ di = Yii :: $ container ; foreach ( $ map as $ class => $ definition ) { if ( ! $ di -> has ( $ class ) ) { $ di -> set ( $ class , $ definition ) ; } } }
8841	public function generateURLSegment ( $ increment = null ) { $ filter = new URLSegmentFilter ( ) ; $ this -> owner -> URLSegment = $ filter -> filter ( $ this -> owner -> Title ) ; if ( is_int ( $ increment ) ) $ this -> owner -> URLSegment .= '-' . $ increment ; $ duplicate = DataList :: create ( $ this -> owner -> ClassName ) -> filter ( array ( "URLSegment" => $ this -> owner -> URLSegment , "BlogID" => $ this -> owner -> BlogID ) ) ; if ( $ this -> owner -> ID ) $ duplicate = $ duplicate -> exclude ( "ID" , $ this -> owner -> ID ) ; if ( $ duplicate -> count ( ) > 0 ) { $ increment = is_int ( $ increment ) ? $ increment + 1 : 0 ; $ this -> owner -> generateURLSegment ( ( int ) $ increment ) ; } return $ this -> owner -> URLSegment ; }
2019	private function overwriteImageTargetDir ( array $ config , ContainerBuilder $ container ) : void { if ( ! isset ( $ config [ 'image' ] [ 'target_path' ] ) ) { return ; } $ container -> setParameter ( 'contao.image.target_dir' , $ container -> getParameter ( 'kernel.project_dir' ) . '/' . $ config [ 'image' ] [ 'target_path' ] ) ; @ trigger_error ( 'Using the contao.image.target_path parameter has been deprecated and will no longer work in Contao 5.0. Use the contao.image.target_dir parameter instead.' , E_USER_DEPRECATED ) ; }
7258	protected function mergeItemsResults ( Model \ SaleItemInterface $ item , Amount $ result ) : void { foreach ( $ item -> getChildren ( ) as $ child ) { if ( $ child -> isPrivate ( ) ) { continue ; } if ( ! ( $ child -> isCompound ( ) && ! $ child -> hasPrivateChildren ( ) ) ) { $ result -> merge ( $ child -> getResult ( ) ) ; } if ( $ child -> hasChildren ( ) ) { $ this -> mergeItemsResults ( $ child , $ result ) ; } } }
1113	protected function mapTreeRecursive ( array $ tree , $ parentKey = null , & $ affectedKeys = array ( ) ) { foreach ( $ tree as $ attributes ) { $ node = $ this -> firstOrNew ( $ this -> getSearchAttributes ( $ attributes ) ) ; $ data = $ this -> getDataAttributes ( $ attributes ) ; if ( ! is_null ( $ parentKey ) ) $ data [ $ node -> getParentColumnName ( ) ] = $ parentKey ; $ node -> fill ( $ data ) ; $ result = $ node -> save ( ) ; if ( ! $ result ) return false ; $ affectedKeys [ ] = $ node -> getKey ( ) ; if ( array_key_exists ( $ this -> getChildrenKeyName ( ) , $ attributes ) ) { $ children = $ attributes [ $ this -> getChildrenKeyName ( ) ] ; if ( count ( $ children ) > 0 ) { $ result = $ this -> mapTreeRecursive ( $ children , $ node -> getKey ( ) , $ affectedKeys ) ; if ( ! $ result ) return false ; } } } return true ; }
8853	public function getCurrentCategory ( ) { $ category = $ this -> request -> param ( "Category" ) ; if ( $ category ) { return $ this -> dataRecord -> Categories ( ) -> filter ( "URLSegment" , $ category ) -> first ( ) ; } return null ; }
5463	protected function getCommonPath ( $ first , $ second ) { $ first = explode ( '/' , $ first ) ; $ second = explode ( '/' , $ second ) ; for ( $ i = 0 ; $ i < min ( count ( $ first ) , count ( $ second ) ) ; $ i ++ ) { if ( $ first [ $ i ] != $ second [ $ i ] ) { return implode ( '/' , array_slice ( $ first , 0 , $ i ) ) . '/' ; } } return implode ( '/' , $ first ) . '/' ; }
8839	private function readStreams ( \ Closure $ callback = null ) : void { $ stdOut = $ this -> readOutput ( self :: STDOUT ) ; $ stdErr = $ this -> readOutput ( self :: STDERR ) ; $ this -> fullStdOut .= $ stdOut ; $ this -> fullStdErr .= $ stdErr ; if ( ! is_null ( $ callback ) ) { $ callback ( $ stdOut , $ stdErr ) ; } $ this -> observer -> stdOutRead ( $ this -> pid , $ stdOut ) ; $ this -> observer -> stdErrRead ( $ this -> pid , $ stdErr ) ; }
1569	public function getResourceIdentifier ( ) : ? ResourceIdentifierInterface { if ( ! $ resourceId = $ this -> getResourceId ( ) ) { return null ; } return ResourceIdentifier :: create ( $ this -> getResourceType ( ) , $ resourceId ) ; }
11970	public function extendExpiration ( ) { if ( null === $ this -> ttl ) { throw new DomainException ( 'There is no TTL set for this Lock.' ) ; } if ( ! $ this -> expiresAt ) { $ this -> expiresAt = new \ DateTime ( ) ; $ this -> expiresAt -> setTimestamp ( time ( ) ) ; } $ this -> expiresAt -> add ( $ this -> ttl ) ; }
2940	public static function addUnit ( UnitOfMeasureInterface $ unit ) { if ( static :: unitNameOrAliasesAlreadyRegistered ( $ unit ) ) { throw new Exception \ DuplicateUnitNameOrAlias ( [ ':labels' => implode ( ', ' , array_merge ( [ $ unit -> getName ( ) ] , $ unit -> getAliases ( ) ) ) ] ) ; } static :: $ unitDefinitions [ ] = $ unit ; }
5442	protected function dispatchTokens ( $ unmatched , $ matched , $ mode = false ) { if ( ! $ this -> invokeParser ( $ unmatched , LEXER_UNMATCHED ) ) { return false ; } if ( is_bool ( $ mode ) ) { return $ this -> invokeParser ( $ matched , LEXER_MATCHED ) ; } if ( $ this -> isModeEnd ( $ mode ) ) { if ( ! $ this -> invokeParser ( $ matched , LEXER_EXIT ) ) { return false ; } return $ this -> mode -> leave ( ) ; } if ( $ this -> isSpecialMode ( $ mode ) ) { $ this -> mode -> enter ( $ this -> decodeSpecial ( $ mode ) ) ; if ( ! $ this -> invokeParser ( $ matched , LEXER_SPECIAL ) ) { return false ; } return $ this -> mode -> leave ( ) ; } $ this -> mode -> enter ( $ mode ) ; return $ this -> invokeParser ( $ matched , LEXER_ENTER ) ; }
5735	public function getMatchesForTeam ( int $ teamID , array $ filter = [ 'dateFrom' => '' , 'dateTo' => '' , 'status' => '' , 'venue' => '' ] ) { $ matches = $ this -> run ( "v2/teams/{$teamID}/matches" . "?" . http_build_query ( $ filter ) ) ; return collect ( $ matches -> matches ) ; }
6496	public function getCurrentId ( ) { $ args = arg ( ) ; return count ( $ args ) > 1 && $ this -> entityType ( ) === $ args [ 0 ] && $ args [ 1 ] > 0 ? ( int ) $ args [ 1 ] : 0 ; }
6718	protected function setParameter ( $ name , $ value ) { if ( ! is_scalar ( $ name ) ) { throw new \ Exception ( 'Parameter name must be scalar' ) ; } $ this -> parameters [ $ name ] = $ value ; return $ this ; }
12062	protected function migrate ( Module $ module ) { $ path = str_replace ( base_path ( ) , '' , ( new Migrator ( $ module ) ) -> getPath ( ) ) ; if ( $ this -> option ( 'subpath' ) ) { $ path = $ path . "/" . $ this -> option ( "subpath" ) ; } $ this -> call ( 'migrate' , [ '--path' => $ path , '--database' => $ this -> option ( 'database' ) , '--pretend' => $ this -> option ( 'pretend' ) , '--force' => $ this -> option ( 'force' ) , ] ) ; if ( $ this -> option ( 'seed' ) ) { $ this -> call ( 'component:seed' , [ 'module' => $ module -> getName ( ) ] ) ; } }
12958	public function inject ( ... $ injects ) : void { $ container = new Container ; $ requested = [ ] ; foreach ( $ injects as $ inject ) { if ( is_string ( $ inject ) ) { $ requested [ ] = $ inject ; } elseif ( is_callable ( $ inject ) ) { $ reflection = new ReflectionFunction ( $ inject ) ; foreach ( $ reflection -> getParameters ( ) as $ param ) { $ requested [ ] = $ param -> name ; } } } foreach ( $ requested as $ dependency ) { $ this -> $ dependency = $ container -> get ( $ dependency ) ; } }
10772	public function getMediaTypeMatch ( $ data ) { foreach ( $ this -> getMediaTypes ( ) as $ mediaTypeClass ) { $ instance = forward_static_call ( array ( $ mediaTypeClass , 'check' ) , $ data ) ; if ( $ instance ) { return $ instance ; } } }
9459	public function getByIds ( array $ ids , $ page = 1 , $ per_page = 100 ) { return $ this -> getCollection ( 'tickets/show_many.json?ids=' . implode ( ',' , $ ids ) , 'tickets' , $ page , $ per_page ) ; }
12934	public function move ( $ baseDir , array $ options , $ username ) { $ this -> resolveMoveOptions ( $ options ) ; if ( array_key_exists ( "targetSlot" , $ options ) ) { $ options [ "slot" ] = $ options [ "targetSlot" ] ; $ block = $ this -> moveBlockToAnotherSlot ( $ baseDir , $ options , $ username ) ; return $ block ; } $ options [ "slot" ] = $ options [ "sourceSlot" ] ; $ block = $ this -> moveBlockToSameSlot ( $ baseDir , $ options , $ username ) ; return $ block ; }
9271	protected function setUri ( $ uriToSet ) { $ uri_parts = [ ] ; array_push ( $ uri_parts , 'api' ) ; array_push ( $ uri_parts , config ( 'ckan_api.api_version' ) ) ; array_push ( $ uri_parts , trim ( $ uriToSet , '/' ) ) ; $ uri_parts = array_filter ( $ uri_parts ) ; $ this -> uri = implode ( '/' , $ uri_parts ) ; }
9170	public function updateCompany ( \ Unite \ Contacts \ Http \ Requests \ UpdateRequest $ request ) { $ this -> service -> saveCompanyProfile ( $ request -> all ( ) ) ; return $ this -> successJsonResponse ( ) ; }
2123	public function addMultiple ( array $ arrFiles , $ strVersion = null , $ strMedia = 'screen' ) { foreach ( $ arrFiles as $ strFile ) { $ this -> add ( $ strFile , $ strVersion , $ strMedia ) ; } }
10282	public static function splitRange ( $ pRange ) { if ( empty ( $ pRange ) ) { $ pRange = self :: DEFAULT_RANGE ; } $ exploded = explode ( ',' , $ pRange ) ; $ counter = count ( $ exploded ) ; for ( $ i = 0 ; $ i < $ counter ; ++ $ i ) { $ exploded [ $ i ] = explode ( ':' , $ exploded [ $ i ] ) ; } return $ exploded ; }
7163	private function buildSaleItemsLinesViews ( Model \ SaleInterface $ sale ) { if ( ! $ sale -> hasItems ( ) ) { return ; } foreach ( $ sale -> getItems ( ) as $ item ) { $ this -> view -> addItem ( $ this -> buildSaleItemLineView ( $ item ) ) ; } }
9809	private function readClientTextbox ( ) { $ recInstance = ( 0xFFF0 & Xls :: getUInt2d ( $ this -> data , $ this -> pos ) ) >> 4 ; $ length = Xls :: getInt4d ( $ this -> data , $ this -> pos + 4 ) ; $ recordData = substr ( $ this -> data , $ this -> pos + 8 , $ length ) ; $ this -> pos += 8 + $ length ; }
6985	protected function createSaleContext ( SaleInterface $ sale ) : ContextInterface { $ context = $ this -> createContext ( ) ; if ( null !== $ group = $ sale -> getCustomerGroup ( ) ) { $ context -> setCustomerGroup ( $ group ) -> setBusiness ( $ group -> isBusiness ( ) ) ; } if ( null !== $ address = $ sale -> getInvoiceAddress ( ) ) { $ context -> setInvoiceCountry ( $ address -> getCountry ( ) ) ; } $ address = $ sale -> isSameAddress ( ) ? $ sale -> getInvoiceAddress ( ) : $ sale -> getDeliveryAddress ( ) ; if ( null !== $ address ) { $ context -> setDeliveryCountry ( $ address -> getCountry ( ) ) ; } if ( null !== $ currency = $ sale -> getCurrency ( ) ) { $ context -> setCurrency ( $ currency ) ; } if ( null !== $ mode = $ sale -> getVatDisplayMode ( ) ) { $ context -> setVatDisplayMode ( $ mode ) ; } if ( $ sale instanceof OrderInterface && null !== $ date = $ sale -> getCreatedAt ( ) ) { $ context -> setDate ( $ date ) ; } $ context -> setTaxExempt ( $ sale -> isTaxExempt ( ) ) ; if ( null !== $ customer = $ sale -> getCustomer ( ) ) { $ this -> fillFromCustomer ( $ context , $ customer ) ; } elseif ( $ this -> customerProvider -> hasCustomer ( ) ) { $ this -> fillFromCustomer ( $ context , $ this -> customerProvider -> getCustomer ( ) ) ; } $ this -> finalize ( $ context ) ; $ sale -> setContext ( $ context ) ; return $ context ; }
3784	public function handle ( EncodePropertyValueFromWidgetEvent $ event ) { if ( ( 'tl_metamodel_dca_combine' !== $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getName ( ) ) || ( 'rows' !== $ event -> getProperty ( ) ) ) { return ; } $ environment = $ event -> getEnvironment ( ) ; $ dataProvider = $ environment -> getDataProvider ( ) ; $ properties = $ environment -> getDataDefinition ( ) -> getPropertiesDefinition ( ) ; $ values = ( array ) $ event -> getValue ( ) ; foreach ( $ values as $ row => $ current ) { $ values [ $ row ] = $ this -> updateValues ( $ current , $ properties , $ dataProvider ) ; } $ event -> setValue ( $ values ) ; }
4018	protected function initializeWidget ( & $ arrField , $ strRow , $ strKey , $ varValue ) { $ xlabel = $ this -> getHelpWizard ( $ strKey , $ arrField ) ; if ( isset ( $ arrField [ 'input_field_callback' ] ) && is_array ( $ arrField [ 'input_field_callback' ] ) ) { if ( ! is_object ( $ this -> $ arrField [ 'input_field_callback' ] [ 0 ] ) ) { $ this -> import ( $ arrField [ 'input_field_callback' ] [ 0 ] ) ; } return $ this -> { $ arrField [ 'input_field_callback' ] [ 0 ] } -> $ arrField [ 'input_field_callback' ] [ 1 ] ( $ this , $ xlabel ) ; } $ strClass = $ this -> getWidgetClass ( $ arrField ) ; if ( empty ( $ strClass ) ) { return null ; } $ varValue = $ this -> handleLoadCallback ( $ arrField , $ varValue ) ; $ arrField = $ this -> makeMandatory ( $ arrField , $ strRow , $ strKey ) ; $ arrField [ 'name' ] = $ this -> strName . '[' . $ strRow . '][' . $ strKey . ']' ; $ arrField [ 'id' ] = $ this -> strId . '_' . $ strRow . '_' . $ strKey ; $ arrField [ 'value' ] = ( $ varValue !== '' ) ? $ varValue : $ arrField [ 'default' ] ; $ arrField [ 'eval' ] [ 'tableless' ] = true ; $ event = new GetAttributesFromDcaEvent ( $ arrField , $ arrField [ 'name' ] , $ arrField [ 'value' ] , null , $ this -> strTable , $ this -> objDca ) ; $ this -> getEventDispatcher ( ) -> dispatch ( ContaoEvents :: WIDGET_GET_ATTRIBUTES_FROM_DCA , $ event ) ; $ objWidget = new $ strClass ( $ event -> getResult ( ) ) ; $ objWidget -> strId = $ arrField [ 'id' ] ; $ objWidget -> storeValues = true ; $ objWidget -> xlabel = $ xlabel ; return $ objWidget ; }
6010	public function setDateRange ( $ dateRange ) { if ( $ dateRange instanceof DateTimeRange ) { $ this -> dateRange = $ dateRange ; } elseif ( is_array ( $ dateRange ) ) { $ this -> dateRange = new DateTimeRange ( $ dateRange ) ; } else { $ this -> dateRange = null ; trigger_error ( 'Argument must be an object of class DateTimeRange. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
3650	protected function getTemplate ( $ strTemplate , $ strFormat = 'html5' , $ blnFailIfNotFound = false ) { $ strTemplate = basename ( $ strTemplate ) ; $ strCustom = 'templates' ; if ( TL_MODE == 'FE' ) { $ tmpDir = str_replace ( '../' , '' , $ GLOBALS [ 'objPage' ] -> templateGroup ) ; if ( ! empty ( $ tmpDir ) ) { $ strCustom = $ tmpDir ; } } try { return \ TemplateLoader :: getPath ( $ strTemplate , $ strFormat , $ strCustom ) ; } catch ( \ Exception $ exception ) { if ( $ blnFailIfNotFound ) { throw new \ RuntimeException ( sprintf ( 'Could not find template %s.%s' , $ strTemplate , $ strFormat ) , 1 , $ exception ) ; } } return null ; }
6554	public function removeLineFromFile ( $ line , $ fh ) { $ lines = array ( ) ; $ found = false ; rewind ( $ fh ) ; while ( ( $ buffer = fgets ( $ fh , 4096 ) ) !== false ) { $ buffer = trim ( $ buffer ) ; if ( $ line === $ buffer ) { $ found = true ; continue ; } $ lines [ ] = $ buffer ; } if ( ! $ found ) { throw new LineNotFoundException ( sprintf ( 'Line %s can not be found' , $ line ) ) ; } ftruncate ( $ fh , 0 ) ; rewind ( $ fh ) ; foreach ( $ lines as $ ln ) { if ( fwrite ( $ fh , $ ln . PHP_EOL ) === false ) { throw new \ Exception ( sprintf ( 'Can\'t write %s to file' , $ ln ) ) ; } } }
1669	public function delete ( ) { $ this -> Files -> rrdir ( $ this -> strFolder ) ; if ( Dbafs :: shouldBeSynchronized ( $ this -> strFolder ) ) { Dbafs :: deleteResource ( $ this -> strFolder ) ; } }
2104	public function getTemplates ( ) : array { $ finder = Finder :: create ( ) -> files ( ) -> name ( '*.sql' ) -> in ( $ this -> rootDir . '/templates' ) ; $ templates = [ ] ; foreach ( $ finder as $ file ) { $ templates [ ] = $ file -> getRelativePathname ( ) ; } return $ templates ; }
4835	public function merchant ( $ id = null ) { if ( $ id == null ) { $ id = $ this -> account_details [ 'merchant_id' ] ; } return GoCardless_Merchant :: find_with_client ( $ this , $ id ) ; }
321	public function normalizePathInfo ( $ pathInfo , $ suffix , & $ normalized = false ) { if ( empty ( $ pathInfo ) ) { return $ pathInfo ; } $ sourcePathInfo = $ pathInfo ; if ( $ this -> collapseSlashes ) { $ pathInfo = $ this -> collapseSlashes ( $ pathInfo ) ; } if ( $ this -> normalizeTrailingSlash === true ) { $ pathInfo = $ this -> normalizeTrailingSlash ( $ pathInfo , $ suffix ) ; } $ normalized = $ sourcePathInfo !== $ pathInfo ; return $ pathInfo ; }
12642	public function set ( $ key , $ value ) { if ( ! is_string ( $ key ) ) throw new InvalidArgumentException ( 'First parameter has to be a string' ) ; if ( ! $ this -> isTypeSupported ( gettype ( $ value ) ) ) throw new UnsupportedException ( 'First parameter has to be an int, a double, a bool or a string' ) ; try { $ this -> getRecursive ( $ key , $ this -> data ) ; $ this -> data = $ this -> setRecursive ( $ key , $ value ) ; } catch ( ElementNotFoundException $ e ) { $ this -> data = array_merge_recursive ( $ this -> data , $ this -> setRecursive ( $ key , $ value ) ) ; } }
6073	public function group ( $ id , array $ children ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'children' => $ children ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/media/' . $ id . '/group' , $ parameters ) ; return $ result ; }
430	public function getBasePath ( ) { if ( $ this -> _basePath === null ) { $ class = new \ ReflectionClass ( $ this ) ; $ this -> _basePath = dirname ( $ class -> getFileName ( ) ) ; } return $ this -> _basePath ; }
3131	public function persist ( QtiRunnerServiceContext $ context ) { $ testSession = $ context -> getTestSession ( ) ; $ sessionId = $ testSession -> getSessionId ( ) ; \ common_Logger :: d ( "Persisting QTI Assessment Test Session '${sessionId}'..." ) ; $ context -> getStorage ( ) -> persist ( $ testSession ) ; if ( $ this -> isTerminated ( $ context ) ) { $ userId = \ common_session_SessionManager :: getSession ( ) -> getUser ( ) -> getIdentifier ( ) ; $ eventManager = $ this -> getServiceManager ( ) -> get ( EventManager :: SERVICE_ID ) ; $ eventManager -> trigger ( new AfterAssessmentTestSessionClosedEvent ( $ testSession , $ userId ) ) ; } }
351	public static function getInputName ( $ model , $ attribute ) { $ formName = $ model -> formName ( ) ; if ( ! preg_match ( static :: $ attributeRegex , $ attribute , $ matches ) ) { throw new InvalidArgumentException ( 'Attribute name must contain word characters only.' ) ; } $ prefix = $ matches [ 1 ] ; $ attribute = $ matches [ 2 ] ; $ suffix = $ matches [ 3 ] ; if ( $ formName === '' && $ prefix === '' ) { return $ attribute . $ suffix ; } elseif ( $ formName !== '' ) { return $ formName . $ prefix . "[$attribute]" . $ suffix ; } throw new InvalidArgumentException ( get_class ( $ model ) . '::formName() cannot be empty for tabular inputs.' ) ; }
1408	protected function attributeKeys ( Model $ model ) { if ( is_array ( $ this -> attributes ) ) { return $ this -> attributes ; } return $ model -> getVisible ( ) ; }
5371	public function attach ( $ key , $ content , $ filename ) { $ this -> request [ ] = new SimpleAttachment ( $ key , $ content , $ filename ) ; }
5976	public function media ( ) { if ( ! $ this -> media instanceof MediaController ) { $ this -> media = new MediaController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> media -> setLogger ( $ this -> logger ) ; } return $ this -> media ; }
7769	public function passes ( ) { foreach ( $ this -> after as $ after ) { call_user_func_array ( $ after , [ $ this ] ) ; } return empty ( $ this -> errors ) ; }
12513	public static function copy ( $ src , $ dest , $ force = false , $ delete = false ) { $ src = Path :: clean ( $ src ) ; $ dest = Path :: clean ( $ dest ) ; $ fs = new Filesystem ( ) ; try { $ fs -> mirror ( $ src , $ dest , null , [ 'override' => $ force , 'delete' => $ delete , 'copy_on_windows' => true ] ) ; } catch ( IOExceptionInterface $ e ) { throw new Exception ( Helper :: getTranslation ( 'CANNOT_FIND_SOURCE' ) . ' ' . $ e -> getPath ( ) ) ; } return true ; }
10739	public function supports ( $ query ) { foreach ( $ this -> engines as $ eachEngine ) { if ( $ eachEngine -> supports ( $ query ) ) { return true ; } } return false ; }
11855	public function getUrlPath ( ) : ? string { $ uri = $ this -> getServerParam ( 'REQUEST_URI' , \ FILTER_SANITIZE_URL ) ; if ( ! is_null ( $ uri ) ) { return parse_url ( $ uri , \ PHP_URL_PATH ) ; } return null ; }
6032	public function getDeployedFile ( $ templateId , $ templateType = self :: TEMPLATE_IMAGE , $ siteId = null ) { foreach ( $ this -> deployedFiles as $ deployedFile ) { if ( null === $ siteId || $ siteId == $ deployedFile -> getDeployMentSiteId ( ) ) { if ( self :: TEMPLATE_VIDEO == $ templateType ) { if ( $ templateId == $ deployedFile -> getVideoTemplateId ( ) && null === $ deployedFile -> getImageTemplateId ( ) ) { return $ deployedFile ; } } elseif ( self :: TEMPLATE_IMAGE == $ templateType && $ templateId == $ deployedFile -> getImageTemplateId ( ) || ( null === $ templateId && null === $ deployedFile -> getImageTemplateId ( ) && null === $ deployedFile -> getVideoTemplateId ( ) ) ) { return $ deployedFile ; } } } throw new NotFoundException ( 'No DeploymentFile with the id "' . $ templateId . '" exists.' ) ; }
5849	protected function moduleContent ( array $ row ) { $ this -> formResultCompiler = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Backend \ Form \ FormResultCompiler :: class ) ; $ wizard = $ this -> formResultCompiler -> addCssFiles ( ) ; $ wizard .= $ this -> buildForm ( $ row ) ; $ wizard .= $ this -> formResultCompiler -> printNeededJSFunctions ( ) ; $ this -> content .= $ wizard ; }
369	public function getViewNames ( $ schema = '' , $ refresh = false ) { if ( ! isset ( $ this -> _viewNames [ $ schema ] ) || $ refresh ) { $ this -> _viewNames [ $ schema ] = $ this -> findViewNames ( $ schema ) ; } return $ this -> _viewNames [ $ schema ] ; }
7212	public function generateLoginToken ( array $ redirectUrl = null , string $ expireInterval = '1 day' , bool $ addRememberMeCookie = true ) : string { $ data = [ 'url' => $ redirectUrl , 'timestamp' => Time :: now ( ) -> toUnixString ( ) , 'expireInterval' => $ expireInterval , 'addRememberMeCookie' => $ addRememberMeCookie ] ; $ serializedData = serialize ( $ data ) ; $ token = Security :: encrypt ( $ serializedData , $ this -> getKey ( ) , $ this -> getSalt ( ) ) ; return base64_encode ( $ token ) ; }
6721	private function handleTokenResponse ( $ response ) { $ params = ( $ response instanceof OAuthToken ) ? $ response -> getParams ( ) : $ response ; $ status = ArrayHelper :: getValue ( $ params , 'status' ) ; if ( ! is_null ( $ status ) && $ status == 'success' ) { $ token = ArrayHelper :: getValue ( $ params , 'data' ) ; if ( is_null ( $ token ) ) { throw new Oauth2ClientException ( self :: CODE_NOT_SET ) ; } return $ token ; } else { $ message = ArrayHelper :: getValue ( $ params , 'message' , self :: DEFAULT_ERROR ) ; throw new Oauth2ClientException ( $ message ) ; } }
3010	public function setConsumer ( $ consumerKey , $ consumerSecret ) { $ this -> apiKey = $ consumerKey ; $ this -> requestHandler -> setConsumer ( $ consumerKey , $ consumerSecret ) ; }
2047	public function onSchemaIndexDefinition ( SchemaIndexDefinitionEventArgs $ event ) : void { if ( method_exists ( AbstractPlatform :: class , 'supportsColumnLengthIndexes' ) ) { return ; } $ connection = $ event -> getConnection ( ) ; if ( ! $ connection -> getDatabasePlatform ( ) instanceof MySqlPlatform ) { return ; } $ data = $ event -> getTableIndex ( ) ; if ( 'PRIMARY' === $ data [ 'name' ] ) { return ; } $ columns = [ ] ; $ query = sprintf ( "SHOW INDEX FROM %s WHERE Key_name='%s'" , $ event -> getTable ( ) , $ data [ 'name' ] ) ; $ result = $ connection -> executeQuery ( $ query ) ; while ( $ row = $ result -> fetch ( ) ) { if ( null !== $ row [ 'Sub_part' ] ) { $ columns [ ] = sprintf ( '%s(%s)' , $ row [ 'Column_name' ] , $ row [ 'Sub_part' ] ) ; } else { $ columns [ ] = $ row [ 'Column_name' ] ; } } $ event -> setIndex ( new Index ( $ data [ 'name' ] , $ columns , $ data [ 'unique' ] , $ data [ 'primary' ] , $ data [ 'flags' ] , $ data [ 'options' ] ) ) ; $ event -> preventDefault ( ) ; }
12419	static function run_php_pdepend_report ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getReportDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; $ pdepend = self :: getTool ( 'pdepend' , $ opts , true ) ; pake_mkdirs ( $ destdir ) ; $ out = pake_sh ( $ pdepend . " --jdepend-chart=" . escapeshellarg ( self :: getReportDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] . '/jdependchart.svg' ) . " --overview-pyramid=" . escapeshellarg ( self :: getReportDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] . '/overview-pyramid.svg' ) . " --summary-xml=" . escapeshellarg ( self :: getReportDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] . '/summary.xml' ) . " " . escapeshellarg ( self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ) ) ; SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; }
9834	public static function pixelsToCellDimension ( $ pValue , \ PhpOffice \ PhpSpreadsheet \ Style \ Font $ pDefaultFont ) { $ name = $ pDefaultFont -> getName ( ) ; $ size = $ pDefaultFont -> getSize ( ) ; if ( isset ( Font :: $ defaultColumnWidths [ $ name ] [ $ size ] ) ) { $ colWidth = $ pValue * Font :: $ defaultColumnWidths [ $ name ] [ $ size ] [ 'width' ] / Font :: $ defaultColumnWidths [ $ name ] [ $ size ] [ 'px' ] ; } else { $ colWidth = $ pValue * 11 * Font :: $ defaultColumnWidths [ 'Calibri' ] [ 11 ] [ 'width' ] / Font :: $ defaultColumnWidths [ 'Calibri' ] [ 11 ] [ 'px' ] / $ size ; } return $ colWidth ; }
8010	private static function expand56BitKeyTo64BitKey ( $ string_key , $ set_parity = true ) { $ byte_array_56 = new SplFixedArray ( 7 ) ; $ byte_array_64 = new SplFixedArray ( 8 ) ; $ key_64bit = '' ; for ( $ i = 0 ; $ i < $ byte_array_56 -> getSize ( ) ; $ i ++ ) { $ byte_array_56 [ $ i ] = isset ( $ string_key [ $ i ] ) ? ord ( $ string_key [ $ i ] ) : 0 ; } $ byte_array_64 [ 0 ] = $ byte_array_56 [ 0 ] & 254 ; $ byte_array_64 [ 1 ] = ( $ byte_array_56 [ 0 ] << 7 ) | ( $ byte_array_56 [ 1 ] >> 1 ) ; $ byte_array_64 [ 2 ] = ( $ byte_array_56 [ 1 ] << 6 ) | ( $ byte_array_56 [ 2 ] >> 2 ) ; $ byte_array_64 [ 3 ] = ( $ byte_array_56 [ 2 ] << 5 ) | ( $ byte_array_56 [ 3 ] >> 3 ) ; $ byte_array_64 [ 4 ] = ( $ byte_array_56 [ 3 ] << 4 ) | ( $ byte_array_56 [ 4 ] >> 4 ) ; $ byte_array_64 [ 5 ] = ( $ byte_array_56 [ 4 ] << 3 ) | ( $ byte_array_56 [ 5 ] >> 5 ) ; $ byte_array_64 [ 6 ] = ( $ byte_array_56 [ 5 ] << 2 ) | ( $ byte_array_56 [ 6 ] >> 6 ) ; $ byte_array_64 [ 7 ] = $ byte_array_56 [ 6 ] << 1 ; foreach ( $ byte_array_64 as $ byte_val ) { $ byte_val = $ set_parity ? self :: setParityBit ( $ byte_val ) : $ byte_val ; $ key_64bit .= chr ( $ byte_val ) ; } return $ key_64bit ; }
6745	private function applyResponseEncoding ( Request $ request , Response $ response ) { $ allowedCompressionAsString = $ request -> headers -> get ( 'Accept-Encoding' ) ; if ( ! $ allowedCompressionAsString ) { return ; } $ allowedCompression = explode ( ',' , $ allowedCompressionAsString ) ; $ allowedCompression = array_map ( 'trim' , $ allowedCompression ) ; if ( in_array ( 'gzip' , $ allowedCompression ) ) { $ response -> setContent ( gzencode ( $ response -> getContent ( ) ) ) ; $ response -> headers -> set ( 'Content-Encoding' , 'gzip' ) ; return ; } if ( in_array ( 'deflate' , $ allowedCompression ) ) { $ response -> setContent ( gzdeflate ( $ response -> getContent ( ) ) ) ; $ response -> headers -> set ( 'Content-Encoding' , 'deflate' ) ; return ; } }
3323	protected function consumeOptionToken ( Option $ spec , $ arg , $ next , & $ success = false ) { if ( $ spec -> isFlag ( ) ) { if ( $ spec -> isIncremental ( ) ) { $ spec -> increaseValue ( ) ; } else { $ spec -> setValue ( true ) ; } return 0 ; } else if ( $ spec -> isRequired ( ) ) { if ( $ next && ! $ next -> isEmpty ( ) && ! $ next -> anyOfOptions ( $ this -> specs ) ) { $ spec -> setValue ( $ next -> arg ) ; return 1 ; } else { throw new RequireValueException ( "Option '{$arg->getOptionName()}' requires a value." ) ; } } else if ( $ spec -> isMultiple ( ) ) { if ( $ next && ! $ next -> isEmpty ( ) && ! $ next -> anyOfOptions ( $ this -> specs ) ) { $ this -> pushOptionValue ( $ spec , $ arg , $ next ) ; return 1 ; } } else if ( $ spec -> isOptional ( ) && $ next && ! $ next -> isEmpty ( ) && ! $ next -> anyOfOptions ( $ this -> specs ) ) { $ spec -> setValue ( $ next -> arg ) ; return 1 ; } return 0 ; }
2966	public function createRequest ( $ method , $ path , $ options ) { if ( $ this -> isPsr7Version ( ) ) { $ headers = [ 'Content-Type' => 'application/json' , 'Authorization' => 'Bearer ' . $ this -> getAccessToken ( ) , ] ; $ body = ArrayUtils :: get ( $ options , 'body' , null ) ; $ uri = UriResolver :: resolve ( new Uri ( $ this -> getBaseEndpoint ( ) . '/' ) , new Uri ( $ path ) ) ; if ( $ body ) { $ body = json_encode ( $ body ) ; } if ( ArrayUtils :: has ( $ options , 'query' ) ) { $ query = $ options [ 'query' ] ; if ( is_array ( $ query ) ) { $ query = http_build_query ( $ query , null , '&' , PHP_QUERY_RFC3986 ) ; } if ( ! is_string ( $ query ) ) { throw new \ InvalidArgumentException ( 'query must be a string or array' ) ; } $ uri = $ uri -> withQuery ( $ query ) ; } $ request = new Request ( $ method , $ uri , $ headers , $ body ) ; } else { $ options [ 'auth' ] = [ $ this -> accessToken , '' ] ; $ request = $ this -> httpClient -> createRequest ( $ method , $ path , $ options ) ; $ query = ArrayUtils :: get ( $ options , 'query' ) ; if ( $ query ) { $ q = $ request -> getQuery ( ) ; foreach ( $ query as $ key => $ value ) { $ q -> set ( $ key , $ value ) ; } } } return $ request ; }
85	public function getPackageFilename ( PackageInterface $ package ) { $ nameParts = array ( preg_replace ( '#[^a-z0-9-_]#i' , '-' , $ package -> getName ( ) ) ) ; if ( preg_match ( '{^[a-f0-9]{40}$}' , $ package -> getDistReference ( ) ) ) { array_push ( $ nameParts , $ package -> getDistReference ( ) , $ package -> getDistType ( ) ) ; } else { array_push ( $ nameParts , $ package -> getPrettyVersion ( ) , $ package -> getDistReference ( ) ) ; } if ( $ package -> getSourceReference ( ) ) { $ nameParts [ ] = substr ( sha1 ( $ package -> getSourceReference ( ) ) , 0 , 6 ) ; } $ name = implode ( '-' , array_filter ( $ nameParts , function ( $ p ) { return ! empty ( $ p ) ; } ) ) ; return str_replace ( '/' , '-' , $ name ) ; }
2280	protected static function httpAcceptLanguage ( ) { $ arrAccepted = array ( ) ; $ arrLanguages = array ( ) ; preg_match_all ( '/([a-z]{1,8}(-[a-z]{1,8})?)\s*(;\s*q\s*=\s*(1|0\.[0-9]+))?/i' , $ _SERVER [ 'HTTP_ACCEPT_LANGUAGE' ] , $ arrAccepted ) ; foreach ( $ arrAccepted [ 1 ] as $ v ) { $ chunks = explode ( '-' , $ v ) ; if ( isset ( $ chunks [ 1 ] ) ) { $ locale = $ chunks [ 0 ] . '-' . strtoupper ( $ chunks [ 1 ] ) ; if ( preg_match ( '/^[a-z]{2}(-[A-Z]{2})?$/' , $ locale ) ) { $ arrLanguages [ ] = $ locale ; } } $ locale = $ chunks [ 0 ] ; if ( preg_match ( '/^[a-z]{2}$/' , $ locale ) ) { $ arrLanguages [ ] = $ locale ; } } return \ array_slice ( array_unique ( $ arrLanguages ) , 0 , 8 ) ; }
4081	public function getRenderSetting ( $ metaModel ) { $ metaModelName = $ this -> getMetaModelName ( $ metaModel ) ; return isset ( $ this -> information [ $ metaModelName ] [ self :: COMBINATION ] [ 'view_id' ] ) ? $ this -> information [ $ metaModelName ] [ self :: COMBINATION ] [ 'view_id' ] : null ; }
8668	public function setSelf ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'Self' ] [ 'FieldValue' ] = $ value ; return $ this ; }
808	private function sortAlphabetically ( array $ first , array $ second ) { $ firstNamespace = str_replace ( '\\' , ' ' , $ this -> prepareNamespace ( $ first [ 'namespace' ] ) ) ; $ secondNamespace = str_replace ( '\\' , ' ' , $ this -> prepareNamespace ( $ second [ 'namespace' ] ) ) ; return strcasecmp ( $ firstNamespace , $ secondNamespace ) ; }
6500	public function afterStep ( Scope \ StepScope $ scope ) { if ( ! empty ( $ this -> mainWindow ) && count ( $ this -> getWindowNames ( ) ) == 1 ) { $ this -> iSwitchToWindow ( ) ; } if ( self :: hasTag ( 'javascript' ) && self :: isStepImpliesJsEvent ( $ scope ) ) { $ this -> waitAjaxAndAnimations ( ) ; } }
8369	public function archiveAction ( string $ production_slug , AuthorizationCheckerInterface $ auth , PaginatorInterface $ paginator , Request $ request ) : Response { $ production_repo = $ this -> em -> getRepository ( Production :: class ) ; if ( null === $ production = $ production_repo -> findOneBy ( [ 'slug' => $ production_slug ] ) ) { throw new NotFoundHttpException ( ) ; } if ( ! $ auth -> isGranted ( 'GROUP_ROLE_EDITOR' , $ production ) ) { throw new AccessDeniedException ( ) ; } $ query = $ this -> em -> getRepository ( Post :: class ) -> getAllInactiveQuery ( $ production ) ; $ posts = $ paginator -> paginate ( $ query , $ request -> query -> getInt ( 'page' , 1 ) ) ; return new Response ( $ this -> templating -> render ( '@BkstgNoticeBoard/Board/archive.html.twig' , [ 'production' => $ production , 'posts' => $ posts , ] ) ) ; }
12978	protected function detectMetadataDriver ( $ dir , $ configPath ) { foreach ( ( array ) $ configPath as $ cPath ) { $ path = $ dir . DS . $ cPath . DS ; if ( ( $ files = glob ( $ path . '*.dcm.xml' ) ) && count ( $ files ) ) { return 'xml' ; } elseif ( ( $ files = glob ( $ path . '*.orm.xml' ) ) && count ( $ files ) ) { return 'simplified_xml' ; } elseif ( ( $ files = glob ( $ path . '*.dcm.yml' ) ) && count ( $ files ) ) { return 'yml' ; } elseif ( ( $ files = glob ( $ path . '*.orm.yml' ) ) && count ( $ files ) ) { return 'simplified_yml' ; } elseif ( ( $ files = glob ( $ path . '*.php' ) ) && count ( $ files ) ) { return 'php' ; } } if ( is_dir ( $ dir . DS . $ this -> getClassPath ( ) . $ this -> getObjectName ( ) ) ) { return 'annotation' ; } return false ; }
11520	protected function GenerateWindowsPinicon ( SiteConfig $ config , SiteTree $ owner , & $ metadata , Image $ WindowsPinicon ) { $ metadata .= $ owner -> MarkupComment ( 'Windows Pinned Icon' ) ; $ appName = $ config -> fetchPiniconTitle ( ) ; if ( ! $ appName ) { $ appName = $ config -> Title ; } $ metadata .= $ owner -> MarkupMeta ( 'application-name' , $ appName ) ; if ( $ config -> fetchWindowsPiniconBackgroundColor ( ) ) { $ metadata .= $ owner -> MarkupMeta ( 'msapplication-TileColor' , $ config -> fetchWindowsPiniconBackgroundColor ( ) ) ; } $ metadata .= $ owner -> MarkupMeta ( 'msapplication-square70x70logo' , $ WindowsPinicon -> Fill ( 70 , 70 ) -> getAbsoluteURL ( ) ) ; $ metadata .= $ owner -> MarkupMeta ( 'msapplication-square150x150logo' , $ WindowsPinicon -> Fill ( 150 , 150 ) -> getAbsoluteURL ( ) ) ; }
9128	private function checkContentLengthExceeded ( ) : bool { if ( isset ( $ this -> headers [ 'Content-Length' ] ) ) { if ( $ this -> payload -> count ( ) >= $ this -> headers [ 'Content-Length' ] ) { return true ; } } return false ; }
222	protected function isNormalizedValueMispresented ( $ value , $ normalizedValue ) { if ( empty ( $ value ) ) { $ value = 0 ; } return ( string ) $ normalizedValue !== $ this -> normalizeNumericStringValue ( ( string ) $ value ) ; }
4486	public function broadcast ( Message $ message , ? string $ platform = null ) { if ( null !== $ platform && ! isset ( $ this -> arns [ $ platform ] ) ) { throw new PlatformNotConfiguredException ( "There is no configured ARN for $platform" ) ; } if ( $ platform ) { $ this -> broadcastToPlatform ( $ message , $ platform ) ; } else { foreach ( $ this -> arns as $ platform => $ arn ) { $ this -> broadcastToPlatform ( $ message , $ platform ) ; } } }
12520	protected function getWhereFromParameter ( ParameterInterface $ parameter ) { if ( $ parameter instanceof IdAwareParameterInterface && $ parameter -> getId ( ) ) { return [ 'id' => $ parameter -> getId ( ) ] ; } else { return [ 'namespace' => $ parameter -> getNamespace ( ) , 'name' => $ parameter -> getName ( ) ] ; } }
1387	protected function resourceTypeNotSupported ( string $ actual , string $ path = '/data' ) : void { $ this -> errors -> add ( $ this -> translator -> resourceTypeNotSupported ( $ actual , $ path ) ) ; }
5343	public function build ( SoapClientBuilderInterface $ builder ) { $ builder -> createWsdl ( $ this -> endpoint ) ; $ builder -> createSoapClient ( ) ; $ builder -> setLogin ( $ this -> login ) ; $ builder -> setMode ( $ this -> mode ) ; $ builder -> setClientVersion ( self :: CLIENT_VERSION ) ; return $ builder -> getSoapClient ( ) ; }
2262	public function query ( $ strQuery ) { $ objStatement = new Statement ( $ this -> resConnection , $ this -> blnDisableAutocommit ) ; return $ objStatement -> query ( $ strQuery ) ; }
3243	public function getShopUrlAttribute ( ) { if ( $ this -> hasObject ) return $ this -> object -> shopUrl ; if ( ! property_exists ( $ this , 'itemRouteName' ) && ! property_exists ( $ this , 'itemRouteParams' ) ) return '#' ; $ params = [ ] ; foreach ( array_keys ( $ this -> attributes ) as $ attribute ) { if ( in_array ( $ attribute , $ this -> itemRouteParams ) ) $ params [ $ attribute ] = $ this -> attributes [ $ attribute ] ; } return empty ( $ this -> itemRouteName ) ? '#' : \ route ( $ this -> itemRouteName , $ params ) ; }
4496	private function getGcmJson ( ) : string { return json_encode ( [ 'collapse_key' => $ this -> collapseKey , 'time_to_live' => $ this -> ttl , 'delay_while_idle' => $ this -> delayWhileIdle , 'priority' => $ this -> priority , 'data' => $ this -> getTrimmedJson ( [ $ this , 'getGcmJsonInner' ] , static :: GCM_MAX_LENGTH , 'You message for GCM is too long' ) , ] , JSON_UNESCAPED_UNICODE ) ; }
12269	protected function generateEventNames ( $ baseEventName , Page $ page ) { $ pageName = $ page -> getPageName ( ) ; $ language = $ page -> getCurrentLanguage ( ) ; return array ( $ baseEventName , $ baseEventName . '.' . $ language , $ baseEventName . '.' . $ pageName , $ baseEventName . '.' . $ language . '.' . $ pageName , ) ; }
10173	public function has ( $ pCoord ) { if ( $ pCoord === $ this -> currentCoordinate ) { return true ; } return isset ( $ this -> index [ $ pCoord ] ) ; }
12242	public function asPrettyXML ( $ filepath = null ) { $ xml = dom_import_simplexml ( new SimpleXMLElement ( $ this -> asXML ( ) ) ) ; $ xsl = new DOMDocument ; $ xsl -> loadXML ( '<?xml version="1.0" encoding="utf-8"?><xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"> <xsl:output method="xml" indent="yes" /> <xsl:template match="text()"> <!-- remove everything that contains only whitespace, with at least one LF ) ; $ xslt = new XSLTProcessor ; $ xslt -> importStylesheet ( $ xsl ) ; $ result = trim ( $ xslt -> transformToXML ( $ xml ) ) ; if ( isset ( $ filepath ) ) { return ( bool ) file_put_contents ( $ filepath , $ result ) ; } return $ result ; }
5857	protected function localize ( $ input ) { if ( TYPO3_MODE === 'FE' ) { $ output = is_object ( $ GLOBALS [ 'TSFE' ] ) ? $ GLOBALS [ 'TSFE' ] -> sL ( $ input ) : $ input ; } else { $ output = $ GLOBALS [ 'LANG' ] -> sL ( $ input ) ; } return $ output ; }
9240	public function renderLanguageSwitcher ( ) { return $ this -> _View -> element ( $ this -> config ( 'element' ) , [ 'availableLanguages' => $ this -> config ( 'availableLanguages' ) , 'displayNames' => $ this -> config ( 'displayNames' ) , 'imageMapping' => $ this -> config ( 'imageMapping' ) , 'renderToggleButtonDisplayName' => $ this -> config ( 'renderToggleButtonDisplayName' ) ] ) ; }
8231	public static function getItemByUrl ( $ items , $ url ) { if ( ! isset ( $ items ) ) { return null ; } if ( array_key_exists ( "/" . $ url , $ items ) ) { return $ items [ "/" . $ url ] ; } $ urlParts = explode ( "/" , trim ( $ url , "/" ) ) ; $ urlPartsLen = count ( $ urlParts ) ; while ( $ urlPartsLen > 0 ) { unset ( $ urlParts [ -- $ urlPartsLen ] ) ; $ subUrl = "/" . join ( "/" , $ urlParts ) ; if ( array_key_exists ( $ subUrl , $ items ) && ( ! isset ( $ items [ $ subUrl ] [ "recursive" ] ) || $ items [ $ subUrl ] [ "recursive" ] === true ) ) { return $ items [ $ subUrl ] ; } } return null ; }
10030	function updateContact ( $ contact , $ checksum = "" , $ src = null , $ subscriptionPage = null , $ triggerDoi = FALSE , $ doiMailingKey = null , $ ignoreChecksum = false ) { $ queryParameters = array ( 'id' => $ contact -> id , 'checksum' => $ checksum , 'triggerdoi' => ( $ triggerDoi == TRUE ) ? "true" : "false" , 'ignore_checksum' => $ ignoreChecksum ? "true" : "false" ) ; if ( isset ( $ contact -> permission ) ) $ queryParameters [ 'permission' ] = $ contact -> permission -> getCode ( ) ; if ( isset ( $ src ) ) $ queryParameters [ 'src' ] = $ src ; if ( isset ( $ subscriptionPage ) ) $ queryParameters [ 'page_key' ] = $ subscriptionPage ; $ doiMailingKey = trim ( $ doiMailingKey ) ; if ( ! empty ( $ doiMailingKey ) ) $ queryParameters [ 'doimailing' ] = $ doiMailingKey ; $ contactToSend = new Contact ( null , $ contact -> email , null , $ contact -> external_id , null , $ contact -> standard_fields , $ contact -> custom_fields ) ; return $ this -> put ( "contacts/contact" , $ contactToSend -> toXMLString ( ) , $ queryParameters ) ; }
1600	public function serialize ( $ record , $ meta = null , array $ links = [ ] ) { $ serializer = clone $ this -> serializer ; $ serializer -> withMeta ( $ meta ) -> withLinks ( $ links ) ; $ serialized = $ serializer -> serializeData ( $ record , $ this -> createEncodingParameters ( ) ) ; $ resourceLinks = null ; if ( empty ( $ serialized [ 'data' ] [ 'id' ] ) ) { unset ( $ serialized [ 'data' ] [ 'id' ] ) ; $ resourceLinks = false ; } $ resource = $ this -> parsePrimaryResource ( $ serialized [ 'data' ] , $ resourceLinks ) ; $ document = [ 'data' => $ resource ] ; if ( isset ( $ serialized [ 'included' ] ) && $ this -> doesSerializeCompoundDocuments ( ) ) { $ document [ 'included' ] = $ this -> parseIncludedResources ( $ serialized [ 'included' ] ) ; } return $ document ; }
604	protected function substring ( $ length , $ caseSensitive = true , $ offset = null ) { if ( $ offset === null ) { $ offset = $ this -> offset ; } if ( $ offset + $ length > $ this -> length ) { return '' ; } $ cacheKey = $ offset . ',' . $ length ; if ( ! isset ( $ this -> _substrings [ $ cacheKey . ',1' ] ) ) { $ this -> _substrings [ $ cacheKey . ',1' ] = mb_substr ( $ this -> sql , $ offset , $ length , 'UTF-8' ) ; } if ( ! $ caseSensitive && ! isset ( $ this -> _substrings [ $ cacheKey . ',0' ] ) ) { $ this -> _substrings [ $ cacheKey . ',0' ] = mb_strtoupper ( $ this -> _substrings [ $ cacheKey . ',1' ] , 'UTF-8' ) ; } return $ this -> _substrings [ $ cacheKey . ',' . ( int ) $ caseSensitive ] ; }
7175	public static function set_path ( & $ array , $ path , $ value , $ delimiter = null ) : void { if ( ! $ delimiter ) { $ delimiter = static :: $ delimiter ; } $ keys = $ path ; if ( ! is_array ( $ path ) ) { $ keys = explode ( $ delimiter , $ path ) ; } while ( count ( $ keys ) > 1 ) { $ key = array_shift ( $ keys ) ; if ( is_string ( $ key ) && ctype_digit ( $ key ) ) { $ key = ( int ) $ key ; } if ( ! isset ( $ array [ $ key ] ) ) { $ array [ $ key ] = array ( ) ; } $ array = & $ array [ $ key ] ; } $ array [ array_shift ( $ keys ) ] = $ value ; }
4026	public function modelToLabel ( ModelToLabelEvent $ event ) { if ( ! $ this -> scopeMatcher -> currentScopeIsBackend ( ) ) { return ; } $ model = $ event -> getModel ( ) ; if ( ( $ model -> getProviderName ( ) !== 'tl_metamodel_filtersetting' ) || ! in_array ( $ event -> getModel ( ) -> getProperty ( 'type' ) , $ this -> getTypes ( ) ) ) { return ; } $ environment = $ event -> getEnvironment ( ) ; $ event -> setLabel ( $ this -> getLabelPattern ( $ environment , $ model ) ) -> setArgs ( $ this -> getLabelParameters ( $ environment , $ model ) ) ; }
12190	public function getActive ( ) { return ( isset ( $ this -> _child ) and $ this -> _child -> active ) and ( isset ( $ this -> _parent ) and $ this -> _parent -> active ) ; }
354	private static function tokenizePattern ( $ pattern ) { $ charset = Yii :: $ app ? Yii :: $ app -> charset : 'UTF-8' ; $ depth = 1 ; if ( ( $ start = $ pos = mb_strpos ( $ pattern , '{' , 0 , $ charset ) ) === false ) { return [ $ pattern ] ; } $ tokens = [ mb_substr ( $ pattern , 0 , $ pos , $ charset ) ] ; while ( true ) { $ open = mb_strpos ( $ pattern , '{' , $ pos + 1 , $ charset ) ; $ close = mb_strpos ( $ pattern , '}' , $ pos + 1 , $ charset ) ; if ( $ open === false && $ close === false ) { break ; } if ( $ open === false ) { $ open = mb_strlen ( $ pattern , $ charset ) ; } if ( $ close > $ open ) { $ depth ++ ; $ pos = $ open ; } else { $ depth -- ; $ pos = $ close ; } if ( $ depth === 0 ) { $ tokens [ ] = explode ( ',' , mb_substr ( $ pattern , $ start + 1 , $ pos - $ start - 1 , $ charset ) , 3 ) ; $ start = $ pos + 1 ; $ tokens [ ] = mb_substr ( $ pattern , $ start , $ open - $ start , $ charset ) ; $ start = $ open ; } if ( $ depth !== 0 && ( $ open === false || $ close === false ) ) { break ; } } if ( $ depth !== 0 ) { return false ; } return $ tokens ; }
7920	private function openZipFile ( $ zipFile ) { $ zipArchive = new \ ZipArchive ; if ( $ zipArchive -> open ( $ zipFile ) !== true ) { throw new \ Exception ( 'Error opening ' . $ zipFile ) ; } return $ zipArchive ; }
221	protected function normalizeNumericValue ( $ value ) { if ( empty ( $ value ) ) { return 0 ; } if ( is_string ( $ value ) && is_numeric ( $ value ) ) { $ value = ( float ) $ value ; } if ( ! is_numeric ( $ value ) ) { throw new InvalidArgumentException ( "'$value' is not a numeric value." ) ; } return $ value ; }
391	protected static function filterValidAliases ( Query $ query ) { $ tables = $ query -> getTablesUsedInFrom ( ) ; $ aliases = array_diff ( array_keys ( $ tables ) , $ tables ) ; return array_map ( function ( $ alias ) { return preg_replace ( '/{{([\w]+)}}/' , '$1' , $ alias ) ; } , array_values ( $ aliases ) ) ; }
1322	private function parseHeaders ( $ header ) { $ headers = [ ] ; foreach ( explode ( "\r\n" , $ header ) as $ line ) { if ( strpos ( $ line , ':' ) !== false ) { list ( $ key , $ value ) = explode ( ': ' , $ line ) ; $ key = str_replace ( '-' , '_' , strtolower ( $ key ) ) ; $ headers [ $ key ] = trim ( $ value ) ; } } return $ headers ; }
11500	protected function _setupDatabaseAdapter ( ) { if ( Zend_Registry :: isRegistered ( 'multidb' ) ) { return $ this -> _setAdapter ( Zend_Registry :: get ( 'multidb' ) -> getDb ( $ this -> _connection ) ) ; } return parent :: _setupDatabaseAdapter ( ) ; }
1105	protected function applyLockBetween ( $ lft , $ rgt ) { $ this -> node -> newQuery ( ) -> where ( $ this -> node -> getLeftColumnName ( ) , '>=' , $ lft ) -> where ( $ this -> node -> getRightColumnName ( ) , '<=' , $ rgt ) -> select ( $ this -> node -> getKeyName ( ) ) -> lockForUpdate ( ) -> get ( ) ; }
387	public function setAttributeOrders ( $ attributeOrders , $ validate = true ) { if ( $ attributeOrders === null || ! $ validate ) { $ this -> _attributeOrders = $ attributeOrders ; } else { $ this -> _attributeOrders = [ ] ; foreach ( $ attributeOrders as $ attribute => $ order ) { if ( isset ( $ this -> attributes [ $ attribute ] ) ) { $ this -> _attributeOrders [ $ attribute ] = $ order ; if ( ! $ this -> enableMultiSort ) { break ; } } } } }
12756	protected function deleteFieldsForCFGroup ( $ customFieldsGroup ) { $ em = $ this -> getContainer ( ) -> get ( 'doctrine.orm.default_entity_manager' ) ; foreach ( $ customFieldsGroup -> getCustomFields ( ) as $ field ) { $ em -> remove ( $ field ) ; } }
7247	protected function purge ( ShipmentInterface $ shipment ) { foreach ( $ shipment -> getItems ( ) as $ item ) { if ( 0 == $ item -> getAvailable ( ) ) { $ shipment -> removeItem ( $ item ) ; } } }
7421	protected function initializeProductMediaGalleryValueToEntity ( array $ attr ) { $ rowId = $ attr [ MemberNames :: ROW_ID ] ; $ valueId = $ attr [ MemberNames :: VALUE_ID ] ; if ( $ this -> loadProductMediaGalleryValueToEntityByValueIdAndRowId ( $ valueId , $ rowId ) ) { return ; } return $ attr ; }
9479	public function respondWithMessage ( $ message = null ) { $ res [ 'status' ] = $ this -> getStatusText ( ) ; if ( $ this -> getErrorCode ( ) ) { $ res [ 'error' ] = $ this -> getErrorCode ( ) ; if ( is_null ( $ message ) ) $ res [ 'message' ] = $ this -> getErrorMessage ( ) ; else $ res [ 'message' ] = $ message ; } else { $ res [ 'message' ] = $ message ; } return $ this -> respond ( $ res ) ; }
10277	public static function getDefaultRowHeightByFont ( \ PhpOffice \ PhpSpreadsheet \ Style \ Font $ font ) { switch ( $ font -> getName ( ) ) { case 'Arial' : switch ( $ font -> getSize ( ) ) { case 10 : $ rowHeight = 12.75 ; break ; case 9 : $ rowHeight = 12 ; break ; case 8 : $ rowHeight = 11.25 ; break ; case 7 : $ rowHeight = 9 ; break ; case 6 : case 5 : $ rowHeight = 8.25 ; break ; case 4 : $ rowHeight = 6.75 ; break ; case 3 : $ rowHeight = 6 ; break ; case 2 : case 1 : $ rowHeight = 5.25 ; break ; default : $ rowHeight = 12.75 * $ font -> getSize ( ) / 10 ; break ; } break ; case 'Calibri' : switch ( $ font -> getSize ( ) ) { case 11 : $ rowHeight = 15 ; break ; case 10 : $ rowHeight = 12.75 ; break ; case 9 : $ rowHeight = 12 ; break ; case 8 : $ rowHeight = 11.25 ; break ; case 7 : $ rowHeight = 9 ; break ; case 6 : case 5 : $ rowHeight = 8.25 ; break ; case 4 : $ rowHeight = 6.75 ; break ; case 3 : $ rowHeight = 6.00 ; break ; case 2 : case 1 : $ rowHeight = 5.25 ; break ; default : $ rowHeight = 15 * $ font -> getSize ( ) / 11 ; break ; } break ; case 'Verdana' : switch ( $ font -> getSize ( ) ) { case 10 : $ rowHeight = 12.75 ; break ; case 9 : $ rowHeight = 11.25 ; break ; case 8 : $ rowHeight = 10.50 ; break ; case 7 : $ rowHeight = 9.00 ; break ; case 6 : case 5 : $ rowHeight = 8.25 ; break ; case 4 : $ rowHeight = 6.75 ; break ; case 3 : $ rowHeight = 6 ; break ; case 2 : case 1 : $ rowHeight = 5.25 ; break ; default : $ rowHeight = 12.75 * $ font -> getSize ( ) / 10 ; break ; } break ; default : $ rowHeight = 15 * $ font -> getSize ( ) / 11 ; break ; } return $ rowHeight ; }
6573	protected static function examine ( $ part , array & $ array , $ path_relative , $ allow_escape = false ) { if ( $ part === '.' ) { return ; } if ( $ part !== '..' ) { $ array [ ] = $ part ; return ; } $ last = end ( $ array ) ; if ( $ last === '..' ) { $ array [ ] = $ part ; return ; } if ( $ last !== false ) { array_pop ( $ array ) ; return ; } if ( ! $ path_relative ) { return ; } if ( ! $ allow_escape ) throw new \ UnexpectedValueException ( 'Attempt to traverse outside the root directory.' ) ; $ array [ ] = $ part ; }
9759	function contain ( $ value = null ) : self { if ( $ this -> hasFlag ( 'file' ) ) return $ this -> expect ( @ file_get_contents ( $ this -> target ) , stringContains ( $ value ) ) ; return $ this -> expect ( $ this -> target , is_string ( $ this -> target ) ? stringContains ( $ value ) : contains ( $ value ) ) ; }
4767	public static function convertXmlToPhpObj ( $ node ) { $ ret = array ( ) ; if ( is_object ( $ node ) && $ node -> hasChildNodes ( ) ) { foreach ( $ node -> childNodes as $ child ) { $ name = self :: decode ( $ child -> nodeName ) ; if ( $ child -> nodeType == XML_TEXT_NODE ) { $ ret = self :: decode ( $ child -> nodeValue ) ; } else { if ( 'array' === $ name ) { return self :: parseArray ( $ child ) ; } else { $ ret [ $ name ] = self :: convertXmlToPhpObj ( $ child ) ; } } } } return ! empty ( $ ret ) ? $ ret : null ; }
527	public function registerAssetFiles ( $ view ) { $ manager = $ view -> getAssetManager ( ) ; foreach ( $ this -> js as $ js ) { if ( is_array ( $ js ) ) { $ file = array_shift ( $ js ) ; $ options = ArrayHelper :: merge ( $ this -> jsOptions , $ js ) ; $ view -> registerJsFile ( $ manager -> getAssetUrl ( $ this , $ file ) , $ options ) ; } else { if ( $ js !== null ) { $ view -> registerJsFile ( $ manager -> getAssetUrl ( $ this , $ js ) , $ this -> jsOptions ) ; } } } foreach ( $ this -> css as $ css ) { if ( is_array ( $ css ) ) { $ file = array_shift ( $ css ) ; $ options = ArrayHelper :: merge ( $ this -> cssOptions , $ css ) ; $ view -> registerCssFile ( $ manager -> getAssetUrl ( $ this , $ file ) , $ options ) ; } else { if ( $ css !== null ) { $ view -> registerCssFile ( $ manager -> getAssetUrl ( $ this , $ css ) , $ this -> cssOptions ) ; } } } }
11097	public static function secondsBetweenDates ( $ start , $ end , $ absolute = true , $ timezone = 'Europe/Prague' ) { $ timezoneObj = new \ DateTimeZone ( $ timezone ) ; $ date = new DateTime ( $ end , $ timezoneObj ) ; $ diff = $ date -> diff ( new DateTime ( $ start , $ timezoneObj ) , $ absolute ) ; return ( $ diff -> invert ? - 1 : 1 ) * ( ( $ diff -> days * 86400 ) + ( $ diff -> h * 3600 ) + ( $ diff -> i * 60 ) + $ diff -> s ) ; }
3932	private function setLabel ( PropertyInterface $ property , $ propInfo , IAttribute $ attribute ) { if ( $ property -> getLabel ( ) ) { return ; } if ( ! isset ( $ propInfo [ 'label' ] ) ) { $ property -> setLabel ( $ attribute -> getName ( ) ) ; return ; } $ lang = $ propInfo [ 'label' ] ; if ( is_array ( $ lang ) ) { $ property -> setLabel ( reset ( $ lang ) ) ; $ property -> setDescription ( next ( $ lang ) ) ; return ; } $ property -> setLabel ( $ lang ) ; }
806	private function findReturnAnnotations ( Tokens $ tokens , $ index ) { do { $ index = $ tokens -> getPrevNonWhitespace ( $ index ) ; } while ( $ tokens [ $ index ] -> isGivenKind ( [ T_ABSTRACT , T_FINAL , T_PRIVATE , T_PROTECTED , T_PUBLIC , T_STATIC , ] ) ) ; if ( ! $ tokens [ $ index ] -> isGivenKind ( T_DOC_COMMENT ) ) { return [ ] ; } $ doc = new DocBlock ( $ tokens [ $ index ] -> getContent ( ) ) ; return $ doc -> getAnnotationsOfType ( 'return' ) ; }
12320	public static function getBundleLocationName ( string $ sName ) : string { $ oConfig = self :: get ( $ sName , null , true ) ; if ( isset ( $ oConfig -> redirect ) ) { return $ oConfig -> redirect ; } else { return PORTAL ; } }
1863	protected function validate ( ) { foreach ( \ func_get_args ( ) as $ strPath ) { if ( $ strPath == '' ) { throw new \ RuntimeException ( 'No file or folder name given' ) ; } elseif ( Validator :: isInsecurePath ( $ strPath ) ) { throw new \ RuntimeException ( 'Invalid file or folder name ' . $ strPath ) ; } } }
4777	public function getOutput ( ItemInterface $ item , $ userId ) { if ( $ item -> getCacheTime ( ) ) { $ cache = $ this -> cache -> getItem ( $ item -> getId ( ) . $ userId ) ; $ cache -> expiresAfter ( $ item -> getCacheTime ( ) ) ; if ( false === $ cache -> isHit ( ) ) { $ cache -> set ( $ item -> getTemplate ( ) ? $ this -> engine -> render ( $ item -> getTemplate ( ) , [ 'widget' => $ item ] ) : $ item -> getContent ( ) ) ; $ this -> cache -> save ( $ cache ) ; } return $ cache -> get ( ) ; } return $ item -> getTemplate ( ) ? $ this -> engine -> render ( $ item -> getTemplate ( ) , [ 'widget' => $ item ] ) : $ item -> getContent ( ) ; }
1951	public function resendButton ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { return ( ! $ row [ 'confirmedOn' ] && ! $ row [ 'invalidatedThrough' ] && $ row [ 'emailSubject' ] && $ row [ 'emailText' ] && $ row [ 'createdOn' ] > strtotime ( '-24 hours' ) ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : '' ; }
8647	private function configureCurlOptions ( $ action , array $ converted , $ streamHandle = null , $ contentMd5 = null ) { $ curlOptions = $ this -> getDefaultCurlOptions ( ) ; if ( ! is_null ( $ this -> config [ 'ProxyHost' ] ) ) { $ proxy = $ this -> config [ 'ProxyHost' ] ; $ proxy .= ':' . ( $ this -> config [ 'ProxyPort' ] == - 1 ? '80' : $ this -> config [ 'ProxyPort' ] ) ; $ curlOptions [ CURLOPT_PROXY ] = $ proxy ; } if ( array_key_exists ( 'CURLOPT_VERBOSE' , $ this -> config ) && ! is_null ( $ this -> config [ 'CURLOPT_VERBOSE' ] ) ) { $ curlOptions [ CURLOPT_VERBOSE ] = $ this -> config [ 'CURLOPT_VERBOSE' ] ; } $ serviceUrl = $ this -> config [ 'ServiceURL' ] ; if ( ! ( substr ( $ serviceUrl , strlen ( $ serviceUrl ) - 1 ) === '/' ) ) { $ serviceUrl .= '/' ; } $ requestType = MarketplaceWebService_RequestType :: getRequestType ( $ action ) ; if ( $ requestType == MarketplaceWebService_RequestType :: POST_UPLOAD ) { if ( is_null ( $ streamHandle ) || ! is_resource ( $ streamHandle ) ) { throw new MarketplaceWebService_Exception ( array ( 'Message' => 'Missing stream resource.' ) ) ; } $ serviceUrl .= '?' . $ this -> getParametersAsString ( $ converted [ CONVERTED_PARAMETERS_KEY ] ) ; $ curlOptions [ CURLOPT_URL ] = $ serviceUrl ; $ header [ ] = 'Expect: ' ; $ header [ ] = 'Accept: ' ; $ header [ ] = 'Transfer-Encoding: chunked' ; $ header [ ] = 'Content-MD5: ' . $ contentMd5 ; $ curlOptions [ CURLOPT_HTTPHEADER ] = array_merge ( $ header , $ converted [ CONVERTED_HEADERS_KEY ] ) ; rewind ( $ streamHandle ) ; $ curlOptions [ CURLOPT_INFILE ] = $ streamHandle ; $ curlOptions [ CURLOPT_UPLOAD ] = true ; $ curlOptions [ CURLOPT_CUSTOMREQUEST ] = self :: REQUEST_TYPE ; } else if ( ! ( $ requestType === MarketplaceWebService_RequestType :: UNKNOWN ) ) { $ curlOptions [ CURLOPT_URL ] = $ this -> config [ 'ServiceURL' ] ; $ curlOptions [ CURLOPT_POSTFIELDS ] = $ this -> getParametersAsString ( $ converted [ CONVERTED_PARAMETERS_KEY ] ) ; if ( $ requestType == MarketplaceWebService_RequestType :: POST_DOWNLOAD ) { $ this -> responseBodyContents = $ streamHandle ; $ curlOptions [ CURLOPT_WRITEFUNCTION ] = array ( $ this , 'responseCallback' ) ; } } else { throw new InvalidArgumentException ( "$action is not a valid request type." ) ; } return $ curlOptions ; }
11947	public function getPriority ( ) { if ( isset ( $ this -> object -> singleWidget ) ) { if ( isset ( $ this -> object -> singleWidget ) && isset ( $ this -> object -> singleWidget -> content -> priorityAdjust ) ) { return $ this -> _priority + $ this -> object -> singleWidget -> content -> priorityAdjust ; } } return $ this -> _priority ; }
4759	protected function transformTemplate ( Template $ template ) { return array ( 'template' => $ template -> getTemplate ( ) , 'engine' => $ template -> getEngine ( ) , 'vars' => $ this -> transform ( $ template -> getVars ( ) ) , 'streamable' => $ this -> transformBoolean ( $ template -> isStreamable ( ) ) , ) ; }
5853	protected function loadVirtualTca ( ) { $ GLOBALS [ 'TCA' ] [ static :: virtualTable ] = include ( ExtensionManagementUtility :: extPath ( $ this -> extKey ) . 'Configuration/TCA/Module/Options.php' ) ; ExtensionManagementUtility :: addLLrefForTCAdescr ( static :: virtualTable , 'EXT:' . $ this -> extKey . '/Resource/Private/Language/locallang_csh_' . static :: virtualTable . '.xlf' ) ; }
7287	public function getInvoicedAt ( $ latest = false ) { if ( 0 == $ this -> invoices -> count ( ) ) { return null ; } $ criteria = Criteria :: create ( ) ; $ criteria -> andWhere ( Criteria :: expr ( ) -> eq ( 'type' , InvoiceTypes :: TYPE_INVOICE ) ) -> orderBy ( [ 'createdAt' => $ latest ? Criteria :: DESC : Criteria :: ASC ] ) ; $ invoices = $ this -> invoices ; $ invoices = $ invoices -> matching ( $ criteria ) ; if ( false !== $ invoice = $ invoices -> first ( ) ) { return $ invoice -> getCreatedAt ( ) ; } return null ; }
263	public function close ( ) { if ( $ this -> getIsActive ( ) ) { $ this -> fields = $ this -> composeFields ( ) ; YII_DEBUG ? session_write_close ( ) : @ session_write_close ( ) ; } }
8392	public function routes ( Request $ request ) { $ table = new \ cli \ Table ( ) ; $ table -> setHeaders ( [ 'Type' , 'Subdomain' , 'Method' , 'Path' , 'Action' ] ) ; $ rows = [ ] ; $ routes = Http :: getRoutes ( ) ; usort ( $ routes , function ( array $ a , array $ b ) { if ( $ a [ 'subdomain' ] != $ b [ 'subdomain' ] ) { return strcmp ( $ a [ 'subdomain' ] , $ b [ 'subdomain' ] ) ; } if ( $ a [ 'path' ] != $ a [ 'path' ] ) { return strcmp ( $ a [ 'path' ] , $ b [ 'path' ] ) ; } return strcmp ( $ a [ 'method' ] , $ b [ 'method' ] ) ; } ) ; foreach ( $ routes as $ route ) { $ rows [ ] = [ $ route [ 'type' ] , $ route [ 'subdomain' ] , $ route [ 'method' ] , empty ( $ route [ 'uri' ] ) === false ? '/' . ltrim ( rtrim ( $ route [ 'uri' ] , '/' ) , '/' ) . $ route [ 'path' ] : $ route [ 'path' ] , $ route [ 'action' ] [ 0 ] == '\\' ? $ route [ 'action' ] : rtrim ( $ route [ 'namespace' ] , '\\' ) . '\\' . $ route [ 'action' ] , ] ; } $ table -> setRows ( $ rows ) ; $ table -> display ( ) ; }
8285	protected function sessionTimeoutCheck ( $ configKey , $ sessKey , $ clear , $ alwaysUpdate = false ) { if ( $ this -> config [ $ configKey ] !== false ) { $ t = time ( ) ; if ( $ this -> session -> has ( $ sessKey ) ) { if ( $ this -> session -> get ( $ sessKey ) < $ t - $ this -> config [ $ configKey ] ) { if ( $ clear ) { $ this -> session -> invalidate ( ) ; } else { $ this -> session -> migrate ( true ) ; } $ this -> session -> set ( $ sessKey , $ t ) ; } elseif ( $ alwaysUpdate ) { $ this -> session -> set ( $ sessKey , $ t ) ; } } else { $ this -> session -> set ( $ sessKey , $ t ) ; } } }
12094	public function getMd5Url ( $ address , $ scheme = true , $ www = true ) { $ this -> urlAddress -> setAddress ( $ address ) ; return $ this -> urlAddress -> getMd5Address ( $ scheme , $ www ) ; }
11250	public function delete ( string $ migration ) : void { $ stmt = $ this -> pdo -> prepare ( "delete from {$this->table} where migration = ?" ) ; $ stmt -> bindParam ( 1 , $ migration ) ; $ stmt -> execute ( ) ; }
7107	static public function round ( $ amount , $ currency ) { $ precision = static :: getPrecision ( $ currency ) ; $ roundingIncrement = static :: getRoundingIncrement ( $ currency ) ; $ amount = round ( $ amount , $ precision , \ PHP_ROUND_HALF_EVEN ) ; if ( 0 < $ roundingIncrement && 0 < $ precision ) { $ roundingFactor = $ roundingIncrement / pow ( 10 , $ precision ) ; $ amount = round ( $ amount / $ roundingFactor ) * $ roundingFactor ; } return $ amount ; }
9689	static function getDataType ( $ value ) { switch ( $ value ) { case "string" : return self :: $ STRING ; case "double" : return self :: $ DOUBLE ; case "float" : return self :: $ FLOAT ; case "integer" : return self :: $ INTEGER ; case "boolean" : return self :: $ BOOLEAN ; case "timestamp" : return self :: $ TIMESTAMP ; case "json" : return self :: $ JSON ; default : return null ; } }
9010	public function char ( int $ size = 36 , string $ charset = null ) : self { $ this -> type = 'char(' . $ size . ')' . $ this -> stringOptions ( $ charset ) ; return $ this ; }
7979	public function getSessionProperties ( $ sessId ) { return json_decode ( self :: getClient ( ) -> getPcaSessionProperties ( $ this -> pp , $ this -> sn , $ sessId ) ) ; }
3640	public function all ( bool $ trim = true , bool $ clean = true ) { $ values = $ this -> request -> all ( ) ; return $ this -> clean ( $ values , $ trim , $ clean ) ; }
2649	public function setVclAsMain ( $ version , $ name ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/vcl/' . $ name . '/main' ; $ result = $ this -> _fetch ( $ url , 'PUT' ) ; return $ result ; }
4517	public function postUpdate ( LifecycleEventArgs $ args ) { $ entity = $ args -> getEntity ( ) ; if ( ! $ entity instanceof Parameter ) { return ; } $ entity -> setValue ( unserialize ( $ entity -> getValue ( ) ) ) ; }
5379	protected function wrap ( $ text ) { $ text = str_replace ( "\r\r\n" , "\r\n" , str_replace ( "\n" , "\r\n" , $ text ) ) ; $ text = str_replace ( "\r\n\n" , "\r\n" , str_replace ( "\r" , "\r\n" , $ text ) ) ; if ( strncmp ( $ text , "\r\n" , strlen ( "\r\n" ) ) == 0 ) { $ text = substr ( $ text , strlen ( "\r\n" ) ) ; } if ( $ this -> wrapIsEnabled ( ) ) { return wordwrap ( $ text , ( integer ) $ this -> getAttribute ( 'cols' ) , "\r\n" ) ; } return $ text ; }
7891	protected function triggerDeploy ( $ project ) { if ( ! $ project ) { throw new InvalidArgumentException ( 'Incorrect project hook.' ) ; } file_get_contents ( sprintf ( self :: DEPLOY_URL , $ project ) ) ; $ this -> info ( 'Deployment request successful!' ) ; }
10806	protected function getConfig ( ) { $ config = array_replace ( $ this -> config , $ this -> dialect_config ) ; ksort ( $ config ) ; return $ config ; }
12091	public function client ( ) { if ( empty ( $ this -> authToken ) ) { throw new NotFoundTokenException ( 'Token not found' ) ; } $ this -> client = new Client ( [ 'base_uri' => $ this -> microService , 'timeout' => $ this -> timeout , 'headers' => [ 'Auth-Token' => $ this -> authToken ] ] ) ; return $ this -> client ; }
1116	public function newNestedSetQuery ( $ excludeDeleted = true ) { $ builder = $ this -> newQuery ( $ excludeDeleted ) -> orderBy ( $ this -> getQualifiedOrderColumnName ( ) ) ; if ( $ this -> isScoped ( ) ) { foreach ( $ this -> scoped as $ scopeFld ) $ builder -> where ( $ scopeFld , '=' , $ this -> $ scopeFld ) ; } return $ builder ; }
9326	protected function registerEngines ( ) { $ app = $ this -> app ; $ config = $ app [ 'config' ] ; $ resolver = $ app [ 'view.engine.resolver' ] ; if ( $ config [ 'markdown.tags' ] ) { $ this -> registerBladeEngine ( $ resolver ) ; } if ( $ config [ 'markdown.views' ] ) { $ this -> registerMarkdownEngine ( $ resolver ) ; $ this -> registerMarkdownPhpEngine ( $ resolver ) ; $ this -> registerMarkdownBladeEngine ( $ resolver ) ; } }
5823	private function resolveOptions ( array $ options = array ( ) ) { $ this -> options [ 'alertPublisher' ] = $ this -> alertPublisher ; return array_merge ( $ this -> options , $ options ) ; }
981	public function planCharge ( ) { return $ this -> charges ( ) -> whereIn ( 'type' , [ Charge :: CHARGE_RECURRING , Charge :: CHARGE_ONETIME ] ) -> where ( 'plan_id' , $ this -> plan_id ) -> orderBy ( 'created_at' , 'desc' ) -> first ( ) ; }
6347	public static function all ( Iterator $ iterator , callable $ predicate ) : bool { while ( $ iterator -> valid ( ) ) { if ( ! Predicates :: call ( $ predicate , $ iterator -> current ( ) ) ) { return false ; } $ iterator -> next ( ) ; } return true ; }
2366	public static function censor ( $ strString , $ varWords , $ strReplace = '' ) { foreach ( ( array ) $ varWords as $ strWord ) { $ strString = preg_replace ( '/\b(' . str_replace ( '\*' , '\w*?' , preg_quote ( $ strWord , '/' ) ) . ')\b/i' , $ strReplace , $ strString ) ; } return $ strString ; }
8610	public function updateSubscription ( $ request ) { if ( ! ( $ request instanceof MWSSubscriptionsService_Model_UpdateSubscriptionInput ) ) { require_once ( dirname ( __FILE__ ) . '/Model/UpdateSubscriptionInput.php' ) ; $ request = new MWSSubscriptionsService_Model_UpdateSubscriptionInput ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'UpdateSubscription' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/UpdateSubscriptionResponse.php' ) ; $ response = MWSSubscriptionsService_Model_UpdateSubscriptionResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
9920	private function findSimpleRelations ( Model $ model ) { foreach ( $ model -> getColumns ( ) as $ column ) { if ( ends_with ( $ column -> getName ( ) , self :: ID_SUFFIX ) ) { $ this -> defineRelation ( $ model , $ column -> getName ( ) ) ; } } }
8448	public function broadcastMsg ( array $ peers , $ msg ) { $ peerList = $ this -> formatPeers ( $ peers ) ; return $ this -> exec ( 'broadcast ' . $ peerList . ' ' . $ msg ) ; }
31	public function parseHgIgnoreLine ( $ line ) { if ( preg_match ( '#^syntax\s*:\s*(glob|regexp)$#' , $ line , $ matches ) ) { if ( $ matches [ 1 ] === 'glob' ) { $ this -> patternMode = self :: HG_IGNORE_GLOB ; } else { $ this -> patternMode = self :: HG_IGNORE_REGEX ; } return null ; } if ( $ this -> patternMode == self :: HG_IGNORE_GLOB ) { return $ this -> patternFromGlob ( $ line ) ; } return $ this -> patternFromRegex ( $ line ) ; }
7606	public function render ( array $ aDropdownOptions ) { if ( empty ( $ aDropdownOptions [ 'attributes' ] ) ) { $ aDropdownOptions [ 'attributes' ] = array ( 'class' => 'dropdown' ) ; } else { if ( ! is_array ( $ aDropdownOptions [ 'attributes' ] ) ) { throw new LogicException ( '"attributes" option expects an array, "' . gettype ( $ aDropdownOptions [ 'attributes' ] ) . '" given' ) ; } if ( empty ( $ aDropdownOptions [ 'attributes' ] [ 'class' ] ) ) { $ aDropdownOptions [ 'attributes' ] [ 'class' ] = 'dropdown' ; } elseif ( ! preg_match ( '/(\s|^)dropdown(\s|$)/' , $ aDropdownOptions [ 'attributes' ] [ 'class' ] ) ) { $ aDropdownOptions [ 'attributes' ] [ 'class' ] .= ' dropdown' ; } } return sprintf ( static :: $ dropdownContainerFormat , $ this -> createAttributesString ( $ aDropdownOptions [ 'attributes' ] ) , $ this -> renderToggle ( $ aDropdownOptions ) . $ this -> renderListItems ( $ aDropdownOptions ) ) ; }
1206	protected function renderLink ( ItemInterface $ item , array $ options = array ( ) ) { if ( $ item -> getUri ( ) && ( ! $ item -> isCurrent ( ) || $ options [ 'currentAsLink' ] ) ) { $ text = $ this -> renderLinkElement ( $ item , $ options ) ; } else { $ text = $ this -> renderSpanElement ( $ item , $ options ) ; } return $ this -> format ( $ text , 'link' , $ item -> getLevel ( ) , $ options ) ; }
6612	public static function getDropdownMap ( $ keyAttribute , $ valueAttribute , array $ default = [ ] ) { $ map = ArrayHelper :: map ( self :: getActive ( ) , $ keyAttribute , $ valueAttribute ) ; if ( $ default ) { $ map = array_merge ( $ default , $ map ) ; } return $ map ; }
2880	public function disableTranslateAction ( ) { try { $ this -> getService ( ) -> setTranslateInline ( 0 ) ; $ this -> getService ( ) -> flushCache ( ) ; } catch ( Exception $ e ) { $ message = $ this -> __ ( 'Translate inline cannot be disabled: %s' , $ e -> getMessage ( ) ) ; $ this -> getSession ( ) -> addError ( $ message ) ; } $ this -> _redirectReferer ( ) ; }
4901	public static function loadConfig ( $ configuration = [ ] ) { $ configDir = static :: getConfigDir ( ) ; if ( empty ( $ configuration ) ) { $ configFile = $ configDir . '/config.php' ; if ( ! is_file ( $ configFile ) ) { throw new InvalidArgumentException ( sprintf ( 'Can not load config file "%s". Please be sure that this file exists and readable' , $ configFile ) ) ; } $ configuration = include $ configFile ; } $ isCli = php_sapi_name ( ) === 'cli' ; $ modules = $ configuration [ 'modules' ] ; $ modules = static :: generateModuleConfiguration ( $ modules ) ; $ yawikConfig = $ configDir . '/autoload/yawik.config.global.php' ; $ installMode = false ; if ( ! $ isCli && ! file_exists ( $ yawikConfig ) ) { $ modules = static :: generateModuleConfiguration ( [ 'Install' ] ) ; $ installMode = true ; } elseif ( in_array ( 'Install' , $ modules ) ) { $ modules = array_diff ( $ modules , [ 'Install' ] ) ; } static :: $ env = $ env = getenv ( 'APPLICATION_ENV' ) ? : 'production' ; $ defaults = [ 'module_listener_options' => [ 'module_paths' => [ './module' , './vendor' , './modules' ] , 'config_glob_paths' => [ sprintf ( $ configDir . '/autoload/{,*.}{global,%s,local}.php' , $ env ) ] , 'config_cache_enabled' => ( $ env == 'production' ) , 'module_map_cache_enabled' => ( $ env == 'production' ) , 'module_map_cache_key' => 'module_map' , 'check_dependencies' => ( $ env != 'production' ) , 'cache_dir' => getcwd ( ) . "/var/cache" , ] , ] ; $ envConfig = [ ] ; $ envConfigFile = $ configDir . '/config.' . $ env . '.php' ; if ( file_exists ( $ envConfigFile ) ) { if ( is_readable ( $ envConfigFile ) ) { $ envConfig = include $ envConfigFile ; } else { \ trigger_error ( sprintf ( 'Environment config file "%s" is not readable.' , $ envConfigFile ) , E_USER_NOTICE ) ; } } $ configuration = ArrayUtils :: merge ( $ defaults , $ configuration ) ; $ configuration = ArrayUtils :: merge ( $ configuration , $ envConfig ) ; $ configuration [ 'modules' ] = $ modules ; if ( $ installMode ) { $ configuration [ 'module_listener_options' ] [ 'config_cache_enabled' ] = false ; $ configuration [ 'module_listener_options' ] [ 'module_map_cache_enabled' ] = false ; } if ( getenv ( 'DOCKER_ENV' ) == 'yes' ) { $ configuration = ArrayUtils :: merge ( $ configuration , static :: getDockerEnv ( $ configuration ) ) ; } return $ configuration ; }
6149	public function sendJson ( $ data , $ statusCode = null ) { return $ this -> setStatusCode ( $ statusCode ) -> setJsonBody ( $ data ) -> send ( ) ; }
3763	private function getLegendProperty ( LegendInterface $ legend , $ propertyName ) { if ( $ legend -> hasProperty ( $ propertyName ) ) { $ property = $ legend -> getProperty ( $ propertyName ) ; } else { $ property = new Property ( $ propertyName ) ; $ legend -> addProperty ( $ property ) ; } return $ property ; }
2032	public static function findFirstActiveByMemberGroups ( $ arrIds ) { if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } $ time = Date :: floorToMinute ( ) ; $ objDatabase = Database :: getInstance ( ) ; $ arrIds = array_map ( '\intval' , $ arrIds ) ; $ objResult = $ objDatabase -> prepare ( "SELECT p.* FROM tl_member_group g LEFT JOIN tl_page p ON g.jumpTo=p.id WHERE g.id IN(" . implode ( ',' , $ arrIds ) . ") AND g.jumpTo>0 AND g.redirect='1' AND g.disable!='1' AND (g.start='' OR g.start<='$time') AND (g.stop='' OR g.stop>'" . ( $ time + 60 ) . "') AND p.published='1' AND (p.start='' OR p.start<='$time') AND (p.stop='' OR p.stop>'" . ( $ time + 60 ) . "') ORDER BY " . $ objDatabase -> findInSet ( 'g.id' , $ arrIds ) ) -> limit ( 1 ) -> execute ( ) ; if ( $ objResult -> numRows < 1 ) { return null ; } $ objRegistry = Registry :: getInstance ( ) ; if ( $ objPage = $ objRegistry -> fetch ( 'tl_page' , $ objResult -> id ) ) { return $ objPage ; } return new static ( $ objResult ) ; }
11116	public function drop ( ) : void { $ dropped = $ this -> repository -> drop ( ) ; if ( count ( $ dropped ) === 0 ) { return ; } $ this -> notify -> note ( '' ) ; foreach ( $ dropped as [ $ type , $ value ] ) { $ type = ucfirst ( $ type ) ; $ this -> notify -> note ( "<comment>{$type}</comment> \"{$value}\" <comment>dropped</comment>" ) ; } }
6310	private function getCommand ( DatabaseObjectInterface $ databaseObject , $ isCreate = true ) { if ( $ databaseObject instanceof Column ) { $ command = $ this -> container -> get ( $ isCreate ? 'rentgen.add_column' : 'rentgen.drop_column' ) -> setColumn ( $ databaseObject ) ; } elseif ( $ databaseObject instanceof ConstraintInterface ) { $ command = $ this -> container -> get ( $ isCreate ? 'rentgen.add_constraint' : 'rentgen.drop_constraint' ) -> setConstraint ( $ databaseObject ) ; } elseif ( $ databaseObject instanceof Index ) { $ command = $ this -> container -> get ( $ isCreate ? 'rentgen.create_index' : 'rentgen.drop_index' ) -> setIndex ( $ databaseObject ) ; } elseif ( $ databaseObject instanceof Schema ) { $ command = $ this -> container -> get ( $ isCreate ? 'rentgen.create_schema' : 'rentgen.drop_schema' ) -> setSchema ( $ databaseObject ) ; } elseif ( $ databaseObject instanceof Table ) { $ command = $ this -> container -> get ( $ isCreate ? 'rentgen.create_table' : 'rentgen.drop_table' ) -> setTable ( $ databaseObject ) ; } else { throw new \ Exception ( sprintf ( "Class %s is not supported" , get_class ( $ databaseObject ) ) ) ; } return $ command ; }
5308	protected function getPathFromRect ( SimpleXMLElement $ rect ) { if ( empty ( $ rect [ 'width' ] ) || $ rect [ 'width' ] < 0 || empty ( $ rect [ 'height' ] ) || $ rect [ 'height' ] < 0 ) { return '' ; } if ( empty ( $ rect [ 'x' ] ) ) { $ rect [ 'x' ] = 0 ; } if ( empty ( $ rect [ 'y' ] ) ) { $ rect [ 'y' ] = 0 ; } return 'M' . $ rect [ 'x' ] . ' ' . $ rect [ 'y' ] . 'l' . $ rect [ 'width' ] . ' 0l0 ' . $ rect [ 'height' ] . 'l' . ( - $ rect [ 'width' ] ) . ' 0Z' ; }
9859	public function getStream ( $ stream ) { if ( $ stream === null ) { return null ; } $ streamData = '' ; if ( $ this -> props [ $ stream ] [ 'size' ] < self :: SMALL_BLOCK_THRESHOLD ) { $ rootdata = $ this -> _readData ( $ this -> props [ $ this -> rootentry ] [ 'startBlock' ] ) ; $ block = $ this -> props [ $ stream ] [ 'startBlock' ] ; while ( $ block != - 2 ) { $ pos = $ block * self :: SMALL_BLOCK_SIZE ; $ streamData .= substr ( $ rootdata , $ pos , self :: SMALL_BLOCK_SIZE ) ; $ block = self :: getInt4d ( $ this -> smallBlockChain , $ block * 4 ) ; } return $ streamData ; } $ numBlocks = $ this -> props [ $ stream ] [ 'size' ] / self :: BIG_BLOCK_SIZE ; if ( $ this -> props [ $ stream ] [ 'size' ] % self :: BIG_BLOCK_SIZE != 0 ) { ++ $ numBlocks ; } if ( $ numBlocks == 0 ) { return '' ; } $ block = $ this -> props [ $ stream ] [ 'startBlock' ] ; while ( $ block != - 2 ) { $ pos = ( $ block + 1 ) * self :: BIG_BLOCK_SIZE ; $ streamData .= substr ( $ this -> data , $ pos , self :: BIG_BLOCK_SIZE ) ; $ block = self :: getInt4d ( $ this -> bigBlockChain , $ block * 4 ) ; } return $ streamData ; }
12085	public function store ( $ objectURI = null ) { $ this -> setPropertyValue ( "media_owner" , $ this -> user -> getPropertyValue ( "user_name_id" ) ) ; if ( ! $ this -> saveObject ( $ objectURI , $ this -> getObjectType ( ) ) ) { return false ; } return true ; }
40	protected function fetchRootIdentifier ( ) { if ( $ this -> repoData ) { return ; } $ repoDataUrl = $ this -> getApiUrl ( ) . '/repos/' . $ this -> owner . '/' . $ this -> repository ; $ this -> repoData = JsonFile :: parseJson ( $ this -> getContents ( $ repoDataUrl , true ) , $ repoDataUrl ) ; if ( null === $ this -> repoData && null !== $ this -> gitDriver ) { return ; } $ this -> owner = $ this -> repoData [ 'owner' ] [ 'login' ] ; $ this -> repository = $ this -> repoData [ 'name' ] ; $ this -> isPrivate = ! empty ( $ this -> repoData [ 'private' ] ) ; if ( isset ( $ this -> repoData [ 'default_branch' ] ) ) { $ this -> rootIdentifier = $ this -> repoData [ 'default_branch' ] ; } elseif ( isset ( $ this -> repoData [ 'master_branch' ] ) ) { $ this -> rootIdentifier = $ this -> repoData [ 'master_branch' ] ; } else { $ this -> rootIdentifier = 'master' ; } $ this -> hasIssues = ! empty ( $ this -> repoData [ 'has_issues' ] ) ; }
1509	public function getResourceUrl ( string $ type , $ id , array $ params = [ ] ) : string { return $ this -> url ( [ $ type , $ id ] , $ params ) ; }
6319	public function execute ( ) { $ this -> preExecute ( ) ; $ result = $ this -> connection -> execute ( $ this -> getSql ( ) ) ; $ this -> postExecute ( ) ; return $ result ; }
5344	public function make ( $ wsdl , array $ classMap = [ ] ) { return new SoapClient ( $ wsdl , [ 'trace' => true , 'exceptions' => true , 'encoding' => 'utf-8' , 'features' => SOAP_SINGLE_ELEMENT_ARRAYS , 'classmap' => $ classMap , 'cache_wsdl' => WSDL_CACHE_MEMORY , ] ) ; }
1123	public function descendantsAndSelf ( ) { return $ this -> newNestedSetQuery ( ) -> where ( $ this -> getLeftColumnName ( ) , '>=' , $ this -> getLeft ( ) ) -> where ( $ this -> getLeftColumnName ( ) , '<' , $ this -> getRight ( ) ) ; }
262	public function run ( $ id ) { $ model = $ this -> findModel ( $ id ) ; if ( $ this -> checkAccess ) { call_user_func ( $ this -> checkAccess , $ this -> id , $ model ) ; } if ( $ model -> delete ( ) === false ) { throw new ServerErrorHttpException ( 'Failed to delete the object for unknown reason.' ) ; } Yii :: $ app -> getResponse ( ) -> setStatusCode ( 204 ) ; }
12181	public function getPrimaryObject ( $ primaryObject , $ relatedObject , $ role ) { if ( ! $ this -> handlePrimary ) { return false ; } if ( $ role === 'child' ) { $ primaryField = 'primary_child' ; if ( ! $ relatedObject -> objectType -> getPrimaryAsChild ( $ this -> parent ) ) { return false ; } $ primaryParent = $ primaryObject ; } else { $ primaryField = 'primary_parent' ; if ( ! $ relatedObject -> objectType -> getPrimaryAsParent ( $ this -> child ) ) { return false ; } $ primaryParent = $ relatedObject ; } $ key = json_encode ( [ __FUNCTION__ , $ this -> systemId , $ primaryObject -> primaryKey ] ) ; if ( ! isset ( self :: $ _cache [ $ key ] ) ) { self :: $ _cache [ $ key ] = null ; $ relationClass = Yii :: $ app -> classes [ 'Relation' ] ; $ childClass = $ this -> child -> primaryModel ; $ relation = $ relationClass :: find ( ) ; $ alias = $ relationClass :: tableName ( ) ; $ relation -> andWhere ( [ '`' . $ alias . '`.`parent_object_id`' => $ primaryParent -> primaryKey , '`' . $ alias . '`.`' . $ primaryField . '`' => 1 ] ) ; $ relation -> andWhere ( [ 'or' , '`' . $ alias . '`.`child_object_id` LIKE :prefix' ] ) ; $ relation -> params [ ':prefix' ] = $ childClass :: modelPrefix ( ) . '-%' ; $ primaryObject -> addActiveConditions ( $ relation , $ alias ) ; $ relation = $ relation -> one ( ) ; if ( ! empty ( $ relation ) ) { self :: $ _cache [ $ key ] = $ relation ; } } return self :: $ _cache [ $ key ] ; }
10982	public static function getMemInfo ( ) { $ result = [ ] ; if ( $ n = preg_match_all ( '/^([\S]+):\s+(\d+)\skB$/im' , file_get_contents ( '/proc/meminfo' ) , $ matches ) ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ result [ $ matches [ 1 ] [ $ i ] ] = $ matches [ 2 ] [ $ i ] ; } } return $ result ; }
2260	protected static function braceGlob ( $ pattern ) { if ( false === strpos ( $ pattern , '/**/' ) && ( \ defined ( 'GLOB_BRACE' ) || false === strpos ( $ pattern , '{' ) ) ) { return glob ( $ pattern , \ defined ( 'GLOB_BRACE' ) ? GLOB_BRACE : 0 ) ; } $ finder = new Finder ( ) ; $ regex = Glob :: toRegex ( $ pattern ) ; $ filesIterator = $ finder -> files ( ) -> followLinks ( ) -> sortByName ( ) -> in ( \ dirname ( $ pattern ) ) ; $ filesIterator = $ filesIterator -> filter ( function ( \ SplFileInfo $ info ) use ( $ regex ) { $ path = $ info -> getPathname ( ) ; return preg_match ( $ regex , $ path ) && $ info -> isFile ( ) ; } ) ; $ files = iterator_to_array ( $ filesIterator ) ; return array_keys ( $ files ) ; }
12835	private function generateFactoryCreatorMethod ( FactoredService $ service ) : string { $ factoryMethod = $ service -> getFactoryMethod ( ) ; $ taggedAs = implode ( ', ' , $ service -> getTags ( ) ) ; $ classNormalized = $ this -> normalizeFqcn ( $ service -> getClass ( ) ) ; $ optional = $ service -> getFactoryMethod ( ) -> isOptional ( ) ? '?' : '' ; if ( $ service -> isSingleton ( ) ) { return <<<PHP /** * Get the factored service "{$service->getId()}" (Singleton) * * It is tagged as: {$taggedAs} * * @return {$this->normalizeFqcn($service->getClass())} */ public function {$this->mapIdToServiceGetter($service->getId())} () : {$optional}{$classNormalized} { if (isset(\$this->singletons['{$service->getId()}'])) { return \$this->singletons['{$service->getId()}']; } /** @noinspection OneTimeUseVariablesInspection */ \$service = \$this->singletons['{$service->getId()}'] = {$this->generateCreatorByServiceId($factoryMethod->getFactoryId())}->{$factoryMethod->getMethodName()}({$this->buildInjectionParameters($this->container, $factoryMethod->getInjection())} );{$this->generateSetterInjectionsCode($service)} return \$service; }PHP ; } return <<<PHP /** * Get a fresh instance of service "{$service->getId()}" (Prototype) * * It is tagged as: {$taggedAs} * * @return {$this->normalizeFqcn($service->getClass())} */ public function {$this->mapIdToServiceGetter($service->getId())} () : $classNormalized { \$this->prototypes['{$service->getId()}'] = (\$this->prototypes['{$service->getId()}'] ?? 0) + 1; /** @noinspection OneTimeUseVariablesInspection */ \$service = {$this->generateCreatorByServiceId($factoryMethod->getFactoryId())}->{$factoryMethod->getMethodName()}({$this->buildInjectionParameters($this->container, $factoryMethod->getInjection())} );{$this->generateSetterInjectionsCode($service)} return \$service; }PHP ; }
8042	protected function calculateEventLength ( array $ data ) { $ start = $ this -> carbon -> copy ( ) -> setTimestamp ( strtotime ( $ data [ 'start' ] [ 'date' ] . ' ' . $ data [ 'start' ] [ 'time' ] ) ) ; if ( array_key_exists ( 'all_day' , $ data ) ) { $ end = $ this -> carbon -> copy ( ) -> setTimestamp ( strtotime ( $ data [ 'start' ] [ 'date' ] . ' 23:59:59' ) ) ; } else { $ end = $ this -> carbon -> copy ( ) -> setTimestamp ( strtotime ( $ data [ 'start' ] [ 'date' ] . ' ' . $ data [ 'end' ] [ 'time' ] ) ) ; } return $ start -> diffInSeconds ( $ end ) ; }
6830	protected function moveAssignment ( Stock \ StockAssignmentInterface $ assignment , Stock \ StockUnitInterface $ targetUnit , $ quantity ) { $ quantity = min ( $ quantity , $ assignment -> getSoldQuantity ( ) - $ assignment -> getShippedQuantity ( ) ) ; if ( 0 >= $ quantity ) { return 0 ; } $ sourceUnit = $ assignment -> getStockUnit ( ) ; $ saleItem = $ assignment -> getSaleItem ( ) ; $ this -> logger -> unitSold ( $ sourceUnit , - $ quantity ) ; $ sourceUnit -> setSoldQuantity ( $ sourceUnit -> getSoldQuantity ( ) - $ quantity ) ; $ this -> manager -> persist ( $ sourceUnit ) ; $ this -> logger -> unitSold ( $ targetUnit , $ quantity ) ; $ targetUnit -> setSoldQuantity ( $ targetUnit -> getSoldQuantity ( ) + $ quantity ) ; $ this -> manager -> persist ( $ targetUnit ) ; $ merge = null ; foreach ( $ targetUnit -> getStockAssignments ( ) as $ m ) { if ( $ m -> getSaleItem ( ) === $ saleItem ) { $ merge = $ m ; break ; } } if ( $ quantity == $ assignment -> getSoldQuantity ( ) ) { if ( null !== $ merge ) { $ this -> logger -> assignmentSold ( $ merge , $ quantity ) ; $ merge -> setSoldQuantity ( $ merge -> getSoldQuantity ( ) + $ quantity ) ; $ this -> manager -> persist ( $ merge ) ; $ this -> logger -> assignmentSold ( $ assignment , 0 , false ) ; $ assignment -> setSoldQuantity ( 0 ) -> setSaleItem ( null ) -> setStockUnit ( null ) ; $ this -> manager -> remove ( $ assignment ) ; } else { $ this -> logger -> assignmentUnit ( $ assignment , $ targetUnit ) ; $ assignment -> setStockUnit ( $ targetUnit ) ; $ this -> manager -> persist ( $ assignment ) ; } } else { $ this -> logger -> assignmentSold ( $ assignment , - $ quantity ) ; $ assignment -> setSoldQuantity ( $ assignment -> getSoldQuantity ( ) - $ quantity ) ; $ this -> manager -> persist ( $ assignment ) ; if ( null !== $ merge ) { $ this -> logger -> assignmentSold ( $ merge , $ quantity ) ; $ merge -> setSoldQuantity ( $ merge -> getSoldQuantity ( ) + $ quantity ) ; $ this -> manager -> persist ( $ merge ) ; } else { $ create = $ this -> saleFactory -> createStockAssignmentForItem ( $ saleItem ) ; $ this -> logger -> assignmentSold ( $ create , $ quantity , false ) ; $ create -> setSoldQuantity ( $ quantity ) -> setSaleItem ( $ saleItem ) -> setStockUnit ( $ targetUnit ) ; $ this -> manager -> persist ( $ create ) ; } } return $ quantity ; }
12841	static public function recursiveDelete ( $ path ) { if ( is_file ( $ path ) ) { return unlink ( $ path ) ; } $ scans = glob ( rtrim ( $ path , '/' ) . '/*' ) ; foreach ( $ scans as $ scan ) { self :: recursiveDelete ( $ scan ) ; } return rmdir ( $ path ) ; }
471	public function down ( ) { $ transaction = $ this -> db -> beginTransaction ( ) ; try { if ( $ this -> safeDown ( ) === false ) { $ transaction -> rollBack ( ) ; return false ; } $ transaction -> commit ( ) ; } catch ( \ Exception $ e ) { $ this -> printException ( $ e ) ; $ transaction -> rollBack ( ) ; return false ; } catch ( \ Throwable $ e ) { $ this -> printException ( $ e ) ; $ transaction -> rollBack ( ) ; return false ; } return null ; }
6414	public static function limit ( IteratorAggregate $ iterable , int $ limitSize ) : IteratorAggregate { return new CallableIterable ( function ( ) use ( $ iterable , $ limitSize ) { return Iterators :: limit ( Iterators :: from ( $ iterable -> getIterator ( ) ) , $ limitSize ) ; } ) ; }
347	public static function removeCssClass ( & $ options , $ class ) { if ( isset ( $ options [ 'class' ] ) ) { if ( is_array ( $ options [ 'class' ] ) ) { $ classes = array_diff ( $ options [ 'class' ] , ( array ) $ class ) ; if ( empty ( $ classes ) ) { unset ( $ options [ 'class' ] ) ; } else { $ options [ 'class' ] = $ classes ; } } else { $ classes = preg_split ( '/\s+/' , $ options [ 'class' ] , - 1 , PREG_SPLIT_NO_EMPTY ) ; $ classes = array_diff ( $ classes , ( array ) $ class ) ; if ( empty ( $ classes ) ) { unset ( $ options [ 'class' ] ) ; } else { $ options [ 'class' ] = implode ( ' ' , $ classes ) ; } } } }
5640	public function paintGroupEnd ( $ test_name ) { array_pop ( $ this -> test_stack ) ; if ( count ( $ this -> test_stack ) == 0 ) { $ this -> paintFooter ( $ test_name ) ; } }
7834	protected function getPipesByOption ( $ option ) { $ pipes = $ this -> option ( $ option ) ; preg_match_all ( '/\w+/' , $ pipes , $ matches ) ; return array_map ( 'ucfirst' , $ matches [ 0 ] ) ; }
9260	private function isCacheable ( $ data ) { $ cacheable = true ; array_walk_recursive ( $ data , function ( $ value ) use ( & $ cacheable ) { if ( $ value instanceof \ Closure ) { $ cacheable = false ; } } ) ; return $ cacheable ; }
8403	public static function loadClass ( string $ className ) { if ( self :: $ isInit === false ) { throw new BadUse ( 'bootstrap doesn\'t seem to have been initialized' ) ; } $ fileName = null ; if ( ( $ namespacePos = strripos ( $ className , '\\' ) ) !== false ) { $ namespacePos = ( int ) $ namespacePos ; $ namespace = substr ( $ className , 0 , $ namespacePos ) ; $ subNamespaces = array ( ) ; while ( $ fileName === null && $ namespace != null ) { if ( isset ( self :: $ namespaces [ $ namespace ] ) === false ) { $ subNamespacePos = strripos ( $ namespace , '\\' ) ; $ subNamespacePos = ( int ) $ subNamespacePos ; $ subNamespaces [ ] = substr ( $ namespace , $ subNamespacePos ) ; $ namespace = substr ( $ namespace , 0 , $ subNamespacePos ) ; } else { $ fileName = self :: $ namespaces [ $ namespace ] ; } } if ( $ fileName === null ) { throw new UnknownNamespace ( 'can\'t find namespace "' . substr ( $ className , 0 , $ namespacePos ) . '"' ) ; } $ fileName = self :: $ namespaces [ $ namespace ] . str_replace ( '\\' , DIRECTORY_SEPARATOR , implode ( '' , array_reverse ( $ subNamespaces ) ) ) ; $ className = substr ( $ className , $ namespacePos + 1 ) ; } if ( $ fileName != null ) { $ fileName .= DIRECTORY_SEPARATOR . str_replace ( '_' , DIRECTORY_SEPARATOR , $ className ) . '.php' ; require $ fileName ; } }
3859	public function addFilterRule ( $ objFilterRule ) { if ( ! $ this -> objFilter ) { $ this -> objFilter = $ this -> objMetaModel -> getEmptyFilter ( ) ; } $ this -> objFilter -> addFilterRule ( $ objFilterRule ) ; return $ this ; }
1205	protected function renderItem ( ItemInterface $ item , array $ options ) { if ( ! $ item -> isDisplayed ( ) ) { return '' ; } $ class = ( array ) $ item -> getAttribute ( 'class' ) ; if ( $ this -> matcher -> isCurrent ( $ item ) ) { $ class [ ] = $ options [ 'currentClass' ] ; } elseif ( $ this -> matcher -> isAncestor ( $ item , $ options [ 'matchingDepth' ] ) ) { $ class [ ] = $ options [ 'ancestorClass' ] ; } if ( $ item -> actsLikeFirst ( ) ) { $ class [ ] = $ options [ 'firstClass' ] ; } if ( $ item -> actsLikeLast ( ) ) { $ class [ ] = $ options [ 'lastClass' ] ; } if ( $ item -> hasChildren ( ) && $ options [ 'depth' ] !== 0 ) { if ( null !== $ options [ 'branch_class' ] && $ item -> getDisplayChildren ( ) ) { $ class [ ] = $ options [ 'branch_class' ] ; } } elseif ( null !== $ options [ 'leaf_class' ] ) { $ class [ ] = $ options [ 'leaf_class' ] ; } $ attributes = $ item -> getAttributes ( ) ; if ( ! empty ( $ class ) ) { $ attributes [ 'class' ] = implode ( ' ' , $ class ) ; } $ html = $ this -> format ( '<li' . $ this -> renderHtmlAttributes ( $ attributes ) . '>' , 'li' , $ item -> getLevel ( ) , $ options ) ; $ html .= $ this -> renderLink ( $ item , $ options ) ; $ childrenClass = ( array ) $ item -> getChildrenAttribute ( 'class' ) ; $ childrenClass [ ] = 'menu_level_' . $ item -> getLevel ( ) ; $ childrenAttributes = $ item -> getChildrenAttributes ( ) ; $ childrenAttributes [ 'class' ] = implode ( ' ' , $ childrenClass ) ; $ html .= $ this -> renderList ( $ item , $ childrenAttributes , $ options ) ; $ html .= $ this -> format ( '</li>' , 'li' , $ item -> getLevel ( ) , $ options ) ; return $ html ; }
1249	public function createService ( $ namespace , array $ config = [ ] ) { $ configuration = $ this -> config ; if ( isset ( $ this -> config [ $ namespace ] ) ) { $ configuration = arrayMergeDeep ( $ configuration , $ this -> config [ $ namespace ] ) ; } $ configuration = arrayMergeDeep ( $ configuration , $ config ) ; $ service = "DTS\\eBaySDK\\{$namespace}\\Services\\{$namespace}Service" ; return new $ service ( $ configuration ) ; }
9858	private function isValueInList ( Cell $ cell ) { $ cellValue = $ cell -> getValue ( ) ; $ dataValidation = $ cell -> getDataValidation ( ) ; $ formula1 = $ dataValidation -> getFormula1 ( ) ; if ( ! empty ( $ formula1 ) ) { if ( $ formula1 [ 0 ] === '"' ) { return in_array ( strtolower ( $ cellValue ) , explode ( ',' , strtolower ( trim ( $ formula1 , '"' ) ) ) , true ) ; } elseif ( strpos ( $ formula1 , ':' ) > 0 ) { $ matchFormula = '=MATCH(' . $ cell -> getCoordinate ( ) . ', ' . $ formula1 . ', 0)' ; $ calculation = Calculation :: getInstance ( $ cell -> getWorksheet ( ) -> getParent ( ) ) ; try { $ result = $ calculation -> calculateFormula ( $ matchFormula , $ cell -> getCoordinate ( ) , $ cell ) ; return $ result !== Functions :: NA ( ) ; } catch ( Exception $ ex ) { return false ; } } } return true ; }
3656	public function boot ( ) { $ environment = System :: getContainer ( ) -> get ( 'contao.framework' ) -> getAdapter ( Environment :: class ) ; $ script = explode ( '?' , $ environment -> get ( 'relativeRequest' ) , 2 ) [ 0 ] ; if ( ( 'contao/login' === $ script ) || ( 'contao/install' === $ script ) ) { return ; } $ connection = System :: getContainer ( ) -> get ( 'database_connection' ) ; if ( ! $ connection -> getSchemaManager ( ) -> tablesExist ( [ 'tl_metamodel' , 'tl_metamodel_dca' , 'tl_metamodel_dca_sortgroup' , 'tl_metamodel_dcasetting' , 'tl_metamodel_dcasetting_condition' , 'tl_metamodel_attribute' , 'tl_metamodel_filter' , 'tl_metamodel_filtersetting' , 'tl_metamodel_rendersettings' , 'tl_metamodel_rendersetting' , 'tl_metamodel_dca_combine' , ] ) ) { System :: getContainer ( ) -> get ( 'logger' ) -> error ( 'MetaModels startup interrupted. Not all MetaModels tables have been created.' ) ; return ; } $ event = new MetaModelsBootEvent ( ) ; $ this -> tryDispatch ( MetaModelsEvents :: SUBSYSTEM_BOOT , $ event ) ; $ determinator = System :: getContainer ( ) -> get ( 'cca.dc-general.scope-matcher' ) ; switch ( true ) { case $ determinator -> currentScopeIsFrontend ( ) : $ this -> tryDispatch ( MetaModelsEvents :: SUBSYSTEM_BOOT_FRONTEND , $ event ) ; break ; case $ determinator -> currentScopeIsBackend ( ) : $ this -> tryDispatch ( MetaModelsEvents :: SUBSYSTEM_BOOT_BACKEND , $ event ) ; break ; default : } }
6387	public function readDiscussion ( $ id ) { $ model = $ this -> readObject ( $ id , 'forum_discussions' ) ; $ model -> url = $ this -> cfg -> wwwroot . '/mod/forum/discuss.php?d=' . $ id ; return $ model ; }
172	private static function matchPathname ( $ path , $ basePath , $ pattern , $ firstWildcard , $ flags ) { if ( isset ( $ pattern [ 0 ] ) && $ pattern [ 0 ] === '/' ) { $ pattern = StringHelper :: byteSubstr ( $ pattern , 1 , StringHelper :: byteLength ( $ pattern ) ) ; if ( $ firstWildcard !== false && $ firstWildcard !== 0 ) { $ firstWildcard -- ; } } $ namelen = StringHelper :: byteLength ( $ path ) - ( empty ( $ basePath ) ? 0 : StringHelper :: byteLength ( $ basePath ) + 1 ) ; $ name = StringHelper :: byteSubstr ( $ path , - $ namelen , $ namelen ) ; if ( $ firstWildcard !== 0 ) { if ( $ firstWildcard === false ) { $ firstWildcard = StringHelper :: byteLength ( $ pattern ) ; } if ( $ firstWildcard > $ namelen ) { return false ; } if ( strncmp ( $ pattern , $ name , $ firstWildcard ) ) { return false ; } $ pattern = StringHelper :: byteSubstr ( $ pattern , $ firstWildcard , StringHelper :: byteLength ( $ pattern ) ) ; $ name = StringHelper :: byteSubstr ( $ name , $ firstWildcard , $ namelen ) ; if ( empty ( $ pattern ) && empty ( $ name ) ) { return true ; } } $ matchOptions = [ 'filePath' => true ] ; if ( $ flags & self :: PATTERN_CASE_INSENSITIVE ) { $ matchOptions [ 'caseSensitive' ] = false ; } return StringHelper :: matchWildcard ( $ pattern , $ name , $ matchOptions ) ; }
7226	public function info ( $ name = null ) { if ( $ name ) { return $ this -> info ? $ this -> info [ $ name ] : curl_getinfo ( $ this -> curl , "CURLINFO" . strtoupper ( $ name ) ) ; } else { return $ this -> info ? : curl_getinfo ( $ this -> curl ) ; } }
10602	public function addQuery ( $ name , $ value ) { $ part = $ name . '=' . $ value ; $ this -> _urlParts [ 'query' ] .= empty ( $ this -> _urlParts [ 'query' ] ) ? $ part : '&' . $ part ; return $ this ; }
11476	public function authenticate ( Zend_Auth_Adapter_Interface $ adapter ) { $ result = $ adapter -> authenticate ( ) ; if ( $ this -> hasIdentity ( ) ) { $ this -> clearIdentity ( ) ; } if ( $ result -> isValid ( ) ) { $ this -> getStorage ( ) -> write ( $ adapter -> getResultRowObject ( ) ) ; } return $ result ; }
4897	public static function getConfigDir ( ) { if ( is_null ( static :: $ configDir ) ) { $ configDir = '' ; $ dirs = [ __DIR__ . '/../../../../*/sandbox/config' , __DIR__ . '/../../../config' , ] ; foreach ( $ dirs as $ dir ) { foreach ( glob ( $ dir ) as $ testDir ) { $ configDir = realpath ( $ testDir ) ; break ; } if ( is_dir ( $ configDir ) ) { break ; } } if ( ! is_dir ( $ configDir ) ) { throw new InvalidArgumentException ( 'Can not determine which config directory to be used.' ) ; } static :: $ configDir = $ configDir ; } return static :: $ configDir ; }
12811	private static function getForeignKeysNames ( string $ table ) : array { if ( self :: $ foreignKeysCache === null || ! array_key_exists ( $ table , self :: $ foreignKeysCache ) ) self :: getForeignKeys ( $ table ) ; return array_keys ( self :: $ foreignKeysCache [ $ table ] ) ; }
5583	public function clickLinkById ( $ id ) { if ( ! ( $ url = $ this -> getLinkById ( $ id ) ) ) { return false ; } $ this -> load ( $ url , new SimpleGetEncoding ( ) ) ; return $ this -> getContent ( ) ; }
2413	protected function addTableTlStyleSheet ( \ DOMDocument $ xml , \ DOMNode $ tables , Result $ objTheme ) { $ table = $ xml -> createElement ( 'table' ) ; $ table -> setAttribute ( 'name' , 'tl_style_sheet' ) ; $ table = $ tables -> appendChild ( $ table ) ; $ this -> loadDataContainer ( 'tl_style_sheet' ) ; $ objDcaExtractor = DcaExtractor :: getInstance ( 'tl_style_sheet' ) ; $ arrOrder = $ objDcaExtractor -> getOrderFields ( ) ; $ objStyleSheet = $ this -> Database -> prepare ( "SELECT * FROM tl_style_sheet WHERE pid=? ORDER BY name" ) -> execute ( $ objTheme -> id ) ; while ( $ objStyleSheet -> next ( ) ) { $ this -> addDataRow ( $ xml , $ table , $ objStyleSheet -> row ( ) , $ arrOrder ) ; } $ objStyleSheet -> reset ( ) ; $ table = $ xml -> createElement ( 'table' ) ; $ table -> setAttribute ( 'name' , 'tl_style' ) ; $ table = $ tables -> appendChild ( $ table ) ; $ this -> loadDataContainer ( 'tl_style' ) ; $ objDcaExtractor = DcaExtractor :: getInstance ( 'tl_style' ) ; $ arrOrder = $ objDcaExtractor -> getOrderFields ( ) ; while ( $ objStyleSheet -> next ( ) ) { $ objStyle = $ this -> Database -> prepare ( "SELECT * FROM tl_style WHERE pid=? ORDER BY sorting" ) -> execute ( $ objStyleSheet -> id ) ; while ( $ objStyle -> next ( ) ) { $ this -> addDataRow ( $ xml , $ table , $ objStyle -> row ( ) , $ arrOrder ) ; } } }
5615	public function paintGroupEnd ( $ message ) { $ node = $ this -> _stack -> pop ( ) ; $ current = $ this -> _stack -> peek ( ) ; if ( $ current ) { if ( $ node -> isFailed ( ) ) { $ current -> fail ( ) ; } $ current -> putChild ( $ node ) ; } else { $ this -> _graph = $ node ; } parent :: paintGroupEnd ( $ message ) ; }
12483	private function plainBonus ( $ bonus ) { $ result = [ ] ; foreach ( $ bonus as $ item ) { $ bonusData = $ item -> getEntries ( ) ; foreach ( $ bonusData as $ entry ) { $ bonus = $ entry -> getValue ( ) ; if ( $ bonus > Cfg :: DEF_ZERO ) { $ result [ ] = $ entry ; } } } return $ result ; }
6783	public function setHeaderParameters ( $ optionNames ) { foreach ( ( array ) $ optionNames as $ option ) { $ this -> headerParameters [ $ option ] = true ; } return $ this ; }
1081	private function loc ( Token $ startToken ) { if ( empty ( $ this -> lexer -> options [ 'noLocation' ] ) ) { return new Location ( $ startToken , $ this -> lexer -> lastToken , $ this -> lexer -> source ) ; } return null ; }
9154	private function parseParameters ( \ ReflectionMethod $ action ) { $ params = $ action -> getParameters ( ) ; if ( count ( $ params ) < 1 ) { return false ; } $ param = $ params [ 0 ] ; assert ( $ param instanceof \ ReflectionParameter ) ; if ( ! ( $ class = $ param -> getClass ( ) ) || $ class -> getName ( ) != 'Nkey\Caribu\Mvc\Controller\Request' ) { return false ; } return true ; }
3093	public function process ( $ data , $ serviceContext ) { if ( empty ( $ data ) ) { throw new \ common_exception_InconsistentData ( 'No action to check. Processing action requires data.' ) ; } $ actions = [ ] ; $ duration = 0 ; foreach ( $ data as $ entry ) { $ action = $ this -> resolve ( $ entry ) ; $ actions [ ] = $ action ; if ( $ action -> hasRequestParameter ( 'itemDuration' ) ) { $ duration += $ action -> getRequestParameter ( 'itemDuration' ) + self :: TIMEPOINT_INTERVAL ; } } $ now = microtime ( true ) ; $ last = $ serviceContext -> getTestSession ( ) -> getTimer ( ) -> getLastRegisteredTimestamp ( ) ; $ elapsed = $ now - $ last ; if ( $ duration > $ elapsed ) { \ common_Logger :: t ( 'Ignoring the last timestamp to take into account the actual duration to sync. Could introduce TimeLine inconsistency!' ) ; $ last = $ now - $ duration ; } usort ( $ actions , function ( $ a , $ b ) { return $ a -> getTimestamp ( ) - $ b -> getTimestamp ( ) ; } ) ; $ response = [ ] ; foreach ( $ actions as $ action ) { try { $ serviceContext -> setSyncingMode ( $ action -> getRequestParameter ( 'offline' ) ) ; if ( $ action -> hasRequestParameter ( 'itemDuration' ) && $ serviceContext -> isSyncingMode ( ) ) { $ last += $ action -> getRequestParameter ( 'itemDuration' ) + self :: TIMEPOINT_INTERVAL ; $ action -> setTime ( $ last ) ; } else { $ action -> setTime ( $ now ) ; } $ action -> setServiceContext ( $ serviceContext ) ; if ( $ serviceContext instanceof QtiRunnerServiceContext ) { } $ responseAction = $ action -> process ( ) ; } catch ( \ common_Exception $ e ) { $ responseAction = [ 'error' => $ e -> getMessage ( ) ] ; $ responseAction [ 'success' ] = false ; } $ responseAction [ 'name' ] = $ action -> getName ( ) ; $ responseAction [ 'timestamp' ] = $ action -> getTimeStamp ( ) ; $ responseAction [ 'requestParameters' ] = $ action -> getRequestParameters ( ) ; $ response [ ] = $ responseAction ; if ( $ responseAction [ 'success' ] === false ) { break ; } } $ this -> getRunnerService ( ) -> persist ( $ serviceContext ) ; return $ response ; }
3853	public function overrideOutputFormat ( $ strOutputFormat = null ) { $ strOutputFormat = strval ( $ strOutputFormat ) ; if ( strlen ( $ strOutputFormat ) ) { $ this -> strOutputFormat = $ strOutputFormat ; } else { unset ( $ this -> strOutputFormat ) ; } return $ this ; }
12270	protected function dispatchSlotsEvent ( $ baseEventName , Page $ page , array $ slots ) { $ eventNames = $ this -> generateEventNames ( $ baseEventName , $ page ) ; $ event = new SlotsRenderingEvent ( $ slots ) ; foreach ( $ eventNames as $ eventName ) { $ event = Dispatcher :: dispatch ( $ eventName , $ event ) ; } return $ event -> getSlots ( ) ; }
7705	function _GetAttValPos ( $ Att ) { if ( $ this -> pST_Src === false ) $ this -> pST_Src = substr ( $ this -> Txt , $ this -> PosBeg , $ this -> pST_PosEnd - $ this -> PosBeg + 1 ) ; $ a = ' ' . $ Att . '="' ; $ p0 = strpos ( $ this -> pST_Src , $ a ) ; if ( $ p0 !== false ) { $ p1 = $ p0 + strlen ( $ a ) ; $ p2 = strpos ( $ this -> pST_Src , '"' , $ p1 ) ; if ( $ p2 !== false ) return array ( $ p1 , $ p2 - $ p1 , $ p0 , $ p2 - $ p0 + 1 ) ; } return false ; }
4869	public function createService ( ServiceLocatorInterface $ serviceLocator ) { $ helper = new DateFormat ( ) ; $ helper -> setLocale ( Locale :: DEFAULT_LOCALE ) ; return $ helper ; }
4646	public function compute ( ) { $ dimensions = $ this -> dimensions ; if ( empty ( $ dimensions ) ) { return array ( ) ; } $ values = reset ( $ dimensions ) ; $ name = key ( $ dimensions ) ; unset ( $ dimensions [ $ name ] ) ; $ posibilities = array ( ) ; foreach ( $ values as $ v ) { $ posibilities [ ] = array ( $ name => $ v ) ; } if ( empty ( $ dimensions ) ) { return $ posibilities ; } $ matrix = new Matrix ( ) ; foreach ( $ dimensions as $ name => $ values ) { $ matrix -> setDimension ( $ name , $ values ) ; } $ result = $ matrix -> compute ( ) ; $ newResult = array ( ) ; foreach ( $ result as $ value ) { foreach ( $ posibilities as $ possiblity ) { $ newResult [ ] = $ value + $ possiblity ; } } return $ newResult ; }
12658	private function getFileName ( $ language ) { if ( $ language === $ this -> baseLang ) { return $ this -> baseDir . $ this -> pageName . '.js' ; } else { return $ this -> baseDir . $ language . '/' . $ this -> pageName . '.js' ; } }
4334	public function getCfg ( $ path = null ) { if ( $ path == 'outputAs' ) { $ ret = $ this -> cfg [ 'outputAs' ] ; if ( ! $ ret ) { $ ret = $ this -> getDefaultOutputAs ( ) ; } } elseif ( $ path == 'css' ) { $ ret = $ this -> getCss ( ) ; } else { $ ret = $ this -> debug -> utilities -> arrayPathGet ( $ this -> cfg , $ path ) ; } return $ ret ; }
6104	public function wait ( ) { if ( $ this -> getTransport ( ) -> getConfig ( "blocking" ) ) { throw new Ts3Exception ( "only available in non-blocking mode" ) ; } do { $ evt = $ this -> getTransport ( ) -> readLine ( ) ; var_dump ( $ evt ) ; } while ( $ evt instanceof StringHelper && ! $ evt -> section ( TeamSpeak3 :: SEPARATOR_CELL ) -> startsWith ( TeamSpeak3 :: EVENT ) ) ; return new Event ( $ evt , $ this -> getHost ( ) ) ; }
9518	public function getUsage ( $ withEncapsulation = true , $ withAliases = true ) { $ usage = '' ; if ( $ withEncapsulation ) { $ usage = ( $ this -> required ? '' : '[' ) ; } $ aliases = ( $ withAliases ? $ this -> getAliasUsage ( ) : '' ) ; $ usage .= $ this -> prefix . $ this -> parameterName . $ aliases . ' ' ; $ usage .= $ this -> getPropertiesAsString ( ) ; return $ usage . ( $ withEncapsulation ? ( $ this -> required ? '' : ']' ) : '' ) ; }
10913	public function setVariable ( string $ name , $ value , bool $ as_instance = true ) { $ this -> variables [ $ name ] = $ value ; if ( is_object ( $ value ) ) $ this -> instances [ get_class ( $ value ) ] = $ value ; return $ this ; }
12001	static protected function doctrine2Query ( \ Doctrine \ ORM \ EntityManager $ entityManager , $ entityName , $ field , $ generate ) { $ result = $ entityManager -> createQueryBuilder ( ) -> select ( "entity.$field" ) -> from ( $ entityName , 'entity' ) -> where ( "entity.$field = :$field" ) -> setParameter ( "$field" , $ generate ) -> getQuery ( ) -> getResult ( ) ; return ! empty ( $ result ) ; }
4552	public function exists ( UserParameters $ parameters = null ) { $ object = $ this -> execute ( 'GET' , 'http://www.mocky.io/v2/592c6f7311000029066df850' ) ; if ( $ object && property_exists ( $ object , '_id' ) && $ object -> _id ) { return true ; } return false ; }
1786	public function generateAlias ( $ varValue , Contao \ DataContainer $ dc ) { $ aliasExists = function ( string $ alias ) use ( $ dc ) : bool { if ( \ in_array ( $ alias , array ( 'top' , 'wrapper' , 'header' , 'container' , 'main' , 'left' , 'right' , 'footer' ) , true ) ) { return true ; } return $ this -> Database -> prepare ( "SELECT id FROM tl_article WHERE alias=? AND id!=?" ) -> execute ( $ alias , $ dc -> id ) -> numRows > 0 ; } ; if ( $ varValue == '' ) { $ varValue = Contao \ System :: getContainer ( ) -> get ( 'contao.slug' ) -> generate ( $ dc -> activeRecord -> title , $ dc -> activeRecord -> pid , $ aliasExists ) ; } elseif ( $ aliasExists ( $ varValue ) ) { throw new Exception ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'aliasExists' ] , $ varValue ) ) ; } return $ varValue ; }
4903	public function createService ( ServiceLocatorInterface $ serviceLocator ) { $ select = $ this ( $ serviceLocator , self :: class , $ this -> options ) ; $ this -> options = [ ] ; return $ select ; }
9922	private function defineManyToManyRelation ( Model $ model1 , Model $ model2 ) { $ this -> relations [ $ model1 -> getName ( ) ] [ ] = new Relation ( $ model1 , $ model2 , Relation :: HAS_AND_BELONGS_TO ) ; $ this -> relations [ $ model2 -> getName ( ) ] [ ] = new Relation ( $ model2 , $ model1 , Relation :: HAS_AND_BELONGS_TO ) ; }
9038	protected function execute ( QueryBuilder $ builder ) : ? Result { return $ this -> connection -> queryArgs ( $ builder -> getQuerySql ( ) , $ builder -> getQueryParameters ( ) ) ; }
8623	public function setOfferListingCount ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'OfferListingCount' ] [ 'FieldValue' ] = $ value ; return $ this ; }
1693	protected function convertHexColor ( $ color , $ blnWriteToFile = false , $ vars = array ( ) ) { if ( strncmp ( $ color , '$' , 1 ) === 0 ) { if ( ! $ blnWriteToFile ) { return array ( $ color ) ; } else { $ color = str_replace ( array_keys ( $ vars ) , $ vars , $ color ) ; } } $ rgb = array ( ) ; if ( \ strlen ( $ color ) == 6 ) { $ dec = hexdec ( $ color ) ; $ rgb [ 'red' ] = 0xFF & ( $ dec >> 0x10 ) ; $ rgb [ 'green' ] = 0xFF & ( $ dec >> 0x8 ) ; $ rgb [ 'blue' ] = 0xFF & $ dec ; } elseif ( \ strlen ( $ color ) == 3 ) { $ rgb [ 'red' ] = hexdec ( str_repeat ( substr ( $ color , 0 , 1 ) , 2 ) ) ; $ rgb [ 'green' ] = hexdec ( str_repeat ( substr ( $ color , 1 , 1 ) , 2 ) ) ; $ rgb [ 'blue' ] = hexdec ( str_repeat ( substr ( $ color , 2 , 1 ) , 2 ) ) ; } return $ rgb ; }
1928	protected function validator ( $ varInput ) { foreach ( $ varInput as $ k => $ v ) { if ( $ k != 'unit' ) { $ varInput [ $ k ] = parent :: validator ( $ v ) ; } } return $ varInput ; }
4684	public function setValueNormalization ( bool $ enabled = false ) { if ( $ enabled === true ) { $ this -> initColumnConversions ( ) ; } else { $ this -> toIntColumns = [ ] ; $ this -> toFloatColumns = [ ] ; $ this -> toStringColumns = [ ] ; $ this -> toBoolColumns = [ ] ; $ this -> toDateTimeColumns = [ ] ; $ this -> toDriverColumns = [ ] ; } }
9965	public function setSelectedCells ( $ pCoordinate ) { $ pCoordinate = strtoupper ( $ pCoordinate ) ; $ pCoordinate = preg_replace ( '/^([A-Z]+)$/' , '${1}:${1}' , $ pCoordinate ) ; $ pCoordinate = preg_replace ( '/^(\d+)$/' , '${1}:${1}' , $ pCoordinate ) ; $ pCoordinate = preg_replace ( '/^([A-Z]+):([A-Z]+)$/' , '${1}1:${2}1048576' , $ pCoordinate ) ; $ pCoordinate = preg_replace ( '/^(\d+):(\d+)$/' , 'A${1}:XFD${2}' , $ pCoordinate ) ; if ( Coordinate :: coordinateIsRange ( $ pCoordinate ) ) { list ( $ first ) = Coordinate :: splitRange ( $ pCoordinate ) ; $ this -> activeCell = $ first [ 0 ] ; } else { $ this -> activeCell = $ pCoordinate ; } $ this -> selectedCells = $ pCoordinate ; return $ this ; }
3842	private function parsePanelSort ( PanelRowInterface $ row ) { if ( ! $ row -> hasElement ( 'sort' ) ) { $ element = new DefaultSortElementInformation ( ) ; $ row -> addElement ( $ element ) ; } }
36	protected function printLinks ( CompletePackageInterface $ package , $ linkType , $ title = null ) { $ title = $ title ? : $ linkType ; $ io = $ this -> getIO ( ) ; if ( $ links = $ package -> { 'get' . ucfirst ( $ linkType ) } ( ) ) { $ io -> write ( "\n<info>" . $ title . "</info>" ) ; foreach ( $ links as $ link ) { $ io -> write ( $ link -> getTarget ( ) . ' <comment>' . $ link -> getPrettyConstraint ( ) . '</comment>' ) ; } } }
1255	private function getValueToAssignToValue ( \ stdClass $ meta ) { if ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\Base64BinaryType' , false ) ) { return $ meta -> strData ; } elseif ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\BooleanType' , false ) ) { return strtolower ( $ meta -> strData ) === 'true' ; } elseif ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\DecimalType' , false ) ) { return is_int ( 0 + $ meta -> strData ) ? ( integer ) $ meta -> strData : ( double ) $ meta -> strData ; } elseif ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\DoubleType' , false ) ) { return ( double ) $ meta -> strData ; } elseif ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\IntegerType' , false ) ) { return ( integer ) $ meta -> strData ; } elseif ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\StringType' , false ) ) { return $ meta -> strData ; } elseif ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\TokenType' , false ) ) { return $ meta -> strData ; } elseif ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\URIType' , false ) ) { return $ meta -> strData ; } return $ meta -> strData ; }
3170	protected function hasItemHrefIndexFile ( QtiRunnerServiceContext $ context , $ itemIdentifier ) { if ( $ context -> isAdaptive ( ) ) { return true ; } else { $ indexFile = $ this -> getItemHrefIndexFile ( $ context , $ itemIdentifier ) ; return $ indexFile -> exists ( ) ; } }
1833	public function onUnregister ( Registry $ registry ) { foreach ( static :: getUniqueFields ( ) as $ strColumn ) { $ varAliasValue = $ this -> { $ strColumn } ; if ( $ registry -> isRegisteredAlias ( $ this , $ strColumn , $ varAliasValue ) ) { $ registry -> unregisterAlias ( $ this , $ strColumn , $ varAliasValue ) ; } } }
9833	public function setWorkbookPassword ( $ pValue , $ pAlreadyHashed = false ) { if ( ! $ pAlreadyHashed ) { $ pValue = PasswordHasher :: hashPassword ( $ pValue ) ; } $ this -> workbookPassword = $ pValue ; return $ this ; }
9763	function endWith ( string $ value ) : self { return $ this -> expect ( $ this -> target , stringEndsWith ( $ value ) ) ; }
9171	public function getControllerPluginConfig ( ) { return [ 'aliases' => [ 'email' => Controller \ Plugin \ Email :: class , 'mutex' => Controller \ Plugin \ Mutex :: class , 'referer' => Controller \ Plugin \ Referer :: class , 'settings' => Controller \ Plugin \ Settings :: class , 'thumbnail' => Controller \ Plugin \ Thumbnail :: class , 'zettaUrl' => Controller \ Plugin \ Url :: class , ] , 'factories' => [ Controller \ Plugin \ Email :: class => Controller \ Plugin \ Factory \ EmailFactory :: class , Controller \ Plugin \ Mutex :: class => Controller \ Plugin \ Factory \ MutexFactory :: class , Controller \ Plugin \ Referer :: class => InvokableFactory :: class , Controller \ Plugin \ Settings :: class => Factory \ WithSettingsFactory :: class , Controller \ Plugin \ Thumbnail :: class => Factory \ WithThumbnailFactory :: class , Controller \ Plugin \ Url :: class => Factory \ WithUrlConfigFactory :: class , ] , ] ; }
2756	public function configDelete ( ConfigCrudEvent $ event ) { $ config = $ event -> getConfig ( ) ; if ( $ config -> getName ( ) === 'views.view.thunder_media' && ( $ media_view = View :: load ( 'media' ) ) ) { $ media_view -> setStatus ( TRUE ) -> save ( ) ; } }
7502	private function getOrCreateGroup ( string $ namespace ) : Group { $ group = $ this -> em -> find ( Group :: getClass ( ) , $ namespace ) ; if ( null !== $ group ) { return $ group ; } $ group = new Group ( $ namespace ) ; $ t = $ this -> tm -> createTransaction ( ) ; $ this -> em -> persist ( $ group ) ; $ t -> commit ( ) ; return $ group ; }
3269	public function readFromFile ( ) : \ Generator { $ file = $ this -> openFile ( static :: FILE_READ ) ; try { foreach ( $ file as $ line ) { yield new Line ( $ line ) ; } } finally { $ this -> closeFile ( $ file ) ; } }
9811	protected function pureGet ( string $ path , array $ params = [ ] , array $ headers = [ ] ) { if ( $ params ) { $ path .= '?' . http_build_query ( $ params ) ; } return $ this -> client -> get ( $ path , $ headers ) ; }
2795	public function getTempDirectory ( ) { if ( is_null ( $ this -> tempDirectory ) ) { $ root = sys_get_temp_dir ( ) ; if ( ! is_dir ( $ root . '/humbug' ) ) { mkdir ( $ root . '/humbug' , 0777 , true ) ; } $ this -> tempDirectory = $ root . '/humbug' ; } return $ this -> tempDirectory ; }
4180	protected function notifyUser ( ) { $ this -> console -> line ( '' ) ; $ this -> console -> line ( "{$this->isDone($this->getProviders()->isRegistered())} " . "{$this->getProviders()->count()} service provider registered." ) ; $ this -> console -> line ( "{$this->isDone($this->getFacades()->isRegistered())} " . "{$this->getFacades()->count()} facade registered." ) ; $ this -> console -> line ( "{$this->isDone($this->getMigration()->isRegistered())} " . "{$this->getMigration()->count()} migration file ran." ) ; $ this -> console -> line ( "{$this->isDone($this->getResources()->isRegistered())} " . '- ' . $ this -> console -> tokenizePackageInfo ( ) [ 'name' ] . ' file publish.' ) ; return true ; }
11402	public function getAppCode ( $ path , $ width = 430 , $ autoColor = false , $ lineColor = [ 'r' => 0 , 'g' => 0 , 'b' => 0 ] ) { $ params = [ 'path' => $ path , 'width' => $ width , 'auto_color' => $ autoColor , 'line_color' => $ lineColor , ] ; return $ this -> getStream ( self :: API_GET_WXACODE , $ params ) ; }
5140	public function map ( array $ methods , string $ path , $ handler ) : void { if ( is_string ( $ handler ) ) { $ handler = $ this -> getContainer ( ) -> get ( $ handler ) ; } $ this -> router -> map ( $ methods , $ path , $ handler ) ; }
8612	public function setMarketplace ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'Marketplace' ] [ 'FieldValue' ] = $ value ; return $ this ; }
8577	public function setItemFeeList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ItemFeeList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
12665	public function install ( ) : ApplicationInterface { try { $ resolved_modules = ( new ModuleDependencyResolver ( $ this -> required_modules ) ) -> resolve ( ) ; $ this -> installModules ( $ resolved_modules ) ; return $ this ; } catch ( \ Throwable $ e ) { throw new ApplicationInstallationException ( __METHOD__ . ' failed: ' . $ e -> getMessage ( ) , $ e ) ; } }
1557	protected function defaultOrder ( $ query ) { if ( $ this -> doesRequireOrdering ( $ query ) ) { $ query -> orderBy ( $ this -> primaryKey ) ; } return $ this ; }
10391	protected static function getSysTempDir ( ) { if ( function_exists ( 'sys_get_temp_dir' ) ) { return sys_get_temp_dir ( ) ; } else if ( $ tmp = getenv ( 'TMP' ) ) { return $ tmp ; } else if ( $ tmp = getenv ( 'TEMP' ) ) { return $ tmp ; } else if ( $ tmp = getenv ( 'TMPDIR' ) ) { return $ tmp ; } return '/tmp' ; }
2007	public function onKernelException ( GetResponseForExceptionEvent $ event ) : void { $ exception = $ event -> getException ( ) ; if ( $ exception -> getPrevious ( ) instanceof ResourceNotFoundException && ! $ this -> hasRootPages ( ) ) { $ exception = new NoRootPageFoundException ( 'No root page found' , 0 , $ exception ) ; } $ class = $ this -> getTargetClass ( $ exception ) ; if ( null === $ class ) { return ; } if ( null !== ( $ httpException = $ this -> convertToHttpException ( $ exception , $ class ) ) ) { $ event -> setException ( $ httpException ) ; } }
7721	public function actionIndex ( ) { $ searchModel = new MahasiswaSearch ( ) ; $ dataProvider = $ searchModel -> search ( Yii :: $ app -> request -> queryParams ) ; $ field = [ 'fileImport' => 'File Import' , ] ; $ modelImport = DynamicModel :: validateData ( $ field , [ [ [ 'fileImport' ] , 'required' ] , [ [ 'fileImport' ] , 'file' , 'extensions' => 'xls,xlsx' , 'maxSize' => 1024 * 1024 ] , ] ) ; return $ this -> render ( 'index' , [ 'searchModel' => $ searchModel , 'dataProvider' => $ dataProvider , 'modelImport' => $ modelImport , ] ) ; }
8728	public function changeFolder ( HTTPRequest $ request ) { $ token = $ this -> getForm ( ) -> getSecurityToken ( ) ; if ( ! $ token -> checkRequest ( $ request ) ) { return $ this -> httpError ( 400 ) ; } $ folderID = $ request -> postVar ( 'FolderID' ) ; if ( $ folderID ) { $ this -> FolderSelector ( ) -> setLastFolderID ( $ folderID ) ; } }
4280	public function stream_stat ( ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ array = \ fstat ( $ this -> handle ) ; self :: register ( ) ; return $ array ; }
260	public function renderFile ( $ viewFile , $ params = [ ] , $ context = null ) { $ viewFile = $ requestedFile = Yii :: getAlias ( $ viewFile ) ; if ( $ this -> theme !== null ) { $ viewFile = $ this -> theme -> applyTo ( $ viewFile ) ; } if ( is_file ( $ viewFile ) ) { $ viewFile = FileHelper :: localize ( $ viewFile ) ; } else { throw new ViewNotFoundException ( "The view file does not exist: $viewFile" ) ; } $ oldContext = $ this -> context ; if ( $ context !== null ) { $ this -> context = $ context ; } $ output = '' ; $ this -> _viewFiles [ ] = [ 'resolved' => $ viewFile , 'requested' => $ requestedFile ] ; if ( $ this -> beforeRender ( $ viewFile , $ params ) ) { Yii :: debug ( "Rendering view file: $viewFile" , __METHOD__ ) ; $ ext = pathinfo ( $ viewFile , PATHINFO_EXTENSION ) ; if ( isset ( $ this -> renderers [ $ ext ] ) ) { if ( is_array ( $ this -> renderers [ $ ext ] ) || is_string ( $ this -> renderers [ $ ext ] ) ) { $ this -> renderers [ $ ext ] = Yii :: createObject ( $ this -> renderers [ $ ext ] ) ; } $ renderer = $ this -> renderers [ $ ext ] ; $ output = $ renderer -> render ( $ this , $ viewFile , $ params ) ; } else { $ output = $ this -> renderPhpFile ( $ viewFile , $ params ) ; } $ this -> afterRender ( $ viewFile , $ params , $ output ) ; } array_pop ( $ this -> _viewFiles ) ; $ this -> context = $ oldContext ; return $ output ; }
203	protected function createQuery ( $ targetClass , $ condition ) { $ query = $ targetClass :: find ( ) -> andWhere ( $ condition ) ; if ( $ this -> filter instanceof \ Closure ) { call_user_func ( $ this -> filter , $ query ) ; } elseif ( $ this -> filter !== null ) { $ query -> andWhere ( $ this -> filter ) ; } return $ query ; }
2156	protected function validator ( $ varInput ) { if ( $ varInput == '*****' ) { $ this -> blnSubmitInput = false ; return true ; } return parent :: validator ( $ varInput ) ; }
10415	public function updateTable ( $ connection = null ) { $ connection = $ connection ? : $ this -> connection ; $ schemaManager = $ connection -> getSchemaManager ( ) ; if ( ! $ schemaManager -> tablesExist ( [ $ this -> tableName ] ) ) { return false ; } $ table = new Table ( $ this -> tableName ) ; $ this -> buildTable ( $ table ) ; $ oldTable = $ schemaManager -> listTableDetails ( $ this -> tableName ) ; $ comparator = new Comparator ( ) ; $ diff = $ comparator -> diffTable ( $ oldTable , $ table ) ; if ( ! $ diff ) { return null ; } $ schemaManager -> alterTable ( $ diff ) ; return true ; }
6616	public function getEndpointResult ( $ method , $ endpointName , Request $ request ) { $ methodName = $ this -> parseEndpointName ( $ method , $ endpointName ) ; if ( ! $ this -> reflection -> hasMethod ( $ methodName ) ) { throw new \ RuntimeException ( "{$this->reflection->getName()}::{$methodName} does not exist" ) ; } $ reflectionMethod = $ this -> reflection -> getMethod ( $ methodName ) ; return $ reflectionMethod -> invokeArgs ( $ this -> controller , $ this -> mapRequestToArguments ( $ reflectionMethod , $ request ) ) ; }
3423	protected function groupsMustBeSelected ( ) { return in_array ( 'GROUPS' , $ this -> select ) || in_array ( 'GROUP_ID' , $ this -> select ) || in_array ( 'GROUPS_ID' , $ this -> select ) ; }
3891	public function loadCallback ( string $ value = null ) { return null === $ value ? null : trim ( \ base64_encode ( $ value ) , '=' ) ; }
8784	protected function log ( $ level , $ message ) { if ( is_array ( $ message ) || is_object ( $ message ) ) { $ message = print_r ( $ message , true ) ; } $ text = '[' . date ( $ this -> timeFormat , time ( ) ) . '] - [' . strtoupper ( $ level ) . '] - [' . http ( ) -> getClientIP ( ) . '] . $ message ; $ this -> save ( $ text ) ; }
12867	public function init_options ( ) { if ( ! is_array ( $ this -> options ) ) { $ this -> options = array ( ) ; } $ options_id = $ this -> get_id ( '-options' ) ; $ options = get_option ( $ options_id ) ; $ need_update = false ; if ( $ options === false ) { $ need_update = true ; $ options = array ( ) ; } foreach ( $ this -> options as $ key => $ value ) { if ( ! array_key_exists ( $ key , $ options ) ) { $ options [ $ key ] = $ value ; } } if ( ! array_key_exists ( 'latest_used_version' , $ options ) ) { $ options [ 'latest_used_version' ] = $ this -> version ; $ need_update = true ; } if ( $ need_update === true ) { update_option ( $ options_id , $ options ) ; } return $ options ; }
10311	function getRecipients ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ excludeDeletedRecipients = false , $ standardFields = null , $ customFields = null , $ embedFieldBackups = false , $ pageIndex = 1 , $ pageSize = 100 ) { $ params = $ this -> createQueryParameters ( $ pageIndex , $ pageSize , $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , null , $ embedFieldBackups ) ; $ params = $ this -> appendArrayFields ( $ params , "standard_field" , $ standardFields ) ; $ params = $ this -> appendArrayFields ( $ params , "custom_field" , $ customFields ) ; if ( isset ( $ excludeDeletedRecipients ) ) $ params [ 'exclude_deleted_recipients' ] = ( $ excludeDeletedRecipients == true ) ? "true" : "false" ; return $ this -> get ( 'reports/recipients' , $ params ) ; }
9222	public function serialize ( ) { $ this -> requestAllPages ( ) ; return serialize ( array ( 'page' => $ this -> page , 'key' => $ this -> key , 'data' => $ this -> data ) ) ; }
12358	private function registerCalc ( $ period ) { $ ctx = new \ Praxigento \ Core \ Data ( ) ; $ ctx -> set ( PCalcReg :: IN_CALC_TYPE_CODE , Cfg :: CODE_TYPE_CALC_FORECAST_PHASE1 ) ; $ ctx -> set ( PCalcReg :: IN_PERIOD , $ period ) ; $ res = $ this -> zCalcReg -> exec ( $ ctx ) ; $ result = $ res -> get ( PCalcReg :: OUT_CALC_ID ) ; return $ result ; }
10098	public function setOutline ( $ visible = true , $ symbols_below = true , $ symbols_right = true , $ auto_style = false ) { $ this -> outlineOn = $ visible ; $ this -> outlineBelow = $ symbols_below ; $ this -> outlineRight = $ symbols_right ; $ this -> outlineStyle = $ auto_style ; if ( $ this -> outlineOn ) { $ this -> outlineOn = 1 ; } }
1295	public function has ( string $ name , string $ locale = null , bool $ checkLinksAreResolved = true ) : bool { $ field = $ this -> sys -> getContentType ( ) -> getField ( $ name , true ) ; if ( ! $ field ) { return false ; } if ( ! \ array_key_exists ( $ field -> getId ( ) , $ this -> fields ) ) { return false ; } try { $ result = $ this -> getUnresolvedField ( $ field , $ locale ) ; if ( $ checkLinksAreResolved ) { $ this -> resolveFieldLinks ( $ result , $ locale ) ; } } catch ( \ Exception $ exception ) { return false ; } return true ; }
2258	protected function prepareForWidget ( $ arrData , $ strName , $ varValue = null , $ strField = '' , $ strTable = '' ) { @ trigger_error ( 'Using Controller::prepareForWidget() has been deprecated and will no longer work in Contao 5.0. Use Widget::getAttributesFromDca() instead.' , E_USER_DEPRECATED ) ; return Widget :: getAttributesFromDca ( $ arrData , $ strName , $ varValue , $ strField , $ strTable ) ; }
2251	public static function convertRelativeUrls ( $ strContent , $ strBase = '' , $ blnHrefOnly = false ) { if ( $ strBase == '' ) { $ strBase = Environment :: get ( 'base' ) ; } $ search = $ blnHrefOnly ? 'href' : 'href|src' ; $ arrUrls = preg_split ( '/((' . $ search . ')="([^"]+)")/i' , $ strContent , - 1 , PREG_SPLIT_DELIM_CAPTURE ) ; $ strContent = '' ; for ( $ i = 0 , $ c = \ count ( $ arrUrls ) ; $ i < $ c ; $ i += 4 ) { $ strContent .= $ arrUrls [ $ i ] ; if ( ! isset ( $ arrUrls [ $ i + 2 ] ) ) { continue ; } $ strAttribute = $ arrUrls [ $ i + 2 ] ; $ strUrl = $ arrUrls [ $ i + 3 ] ; if ( ! preg_match ( '@^(?:[a-z0-9]+:|#)@i' , $ strUrl ) ) { $ strUrl = $ strBase . ( ( $ strUrl != '/' ) ? $ strUrl : '' ) ; } $ strContent .= $ strAttribute . '="' . $ strUrl . '"' ; } return $ strContent ; }
952	public function save ( ) { if ( ! $ this -> response ) { throw new Exception ( 'No activation response was recieved.' ) ; } $ planCharge = $ this -> shop -> planCharge ( ) ; $ charge = new Charge ( ) ; $ charge -> type = Charge :: CHARGE_USAGE ; $ charge -> reference_charge = $ planCharge -> charge_id ; $ charge -> shop_id = $ this -> shop -> id ; $ charge -> charge_id = $ this -> response -> id ; $ charge -> price = $ this -> response -> price ; $ charge -> description = $ this -> response -> description ; $ charge -> billing_on = $ this -> response -> billing_on ; return $ charge -> save ( ) ; }
9881	private function writeCalcPr ( XMLWriter $ objWriter , $ recalcRequired = true ) { $ objWriter -> startElement ( 'calcPr' ) ; $ objWriter -> writeAttribute ( 'calcId' , '999999' ) ; $ objWriter -> writeAttribute ( 'calcMode' , 'auto' ) ; $ objWriter -> writeAttribute ( 'calcCompleted' , ( $ recalcRequired ) ? 1 : 0 ) ; $ objWriter -> writeAttribute ( 'fullCalcOnLoad' , ( $ recalcRequired ) ? 0 : 1 ) ; $ objWriter -> endElement ( ) ; }
10091	protected function checkOptionsArray ( $ options ) { if ( isset ( $ options [ 's' ] ) ) { $ options [ 'size' ] = $ options [ 's' ] ; unset ( $ options [ 's' ] ) ; } if ( isset ( $ options [ 'd' ] ) ) { $ options [ 'default' ] = $ options [ 'd' ] ; unset ( $ options [ 'd' ] ) ; } $ allowedOptions = array ( 'algorithm' => true , 'default' => true , 'https' => true , 'size' => true , ) ; foreach ( $ options as $ key => $ value ) { if ( ! isset ( $ allowedOptions [ $ key ] ) ) { throw new InvalidArgumentException ( 'Invalid option in array: ' . $ key ) ; } } return $ options ; }
4357	protected function processLog ( ) { $ str = '' ; foreach ( $ this -> data [ 'log' ] as $ entry ) { $ channel = isset ( $ entry [ 2 ] [ 'channel' ] ) ? $ entry [ 2 ] [ 'channel' ] : null ; if ( $ this -> channelTest ( $ channel ) ) { $ str .= $ this -> processLogEntryWEvent ( $ entry [ 0 ] , $ entry [ 1 ] , $ entry [ 2 ] ) ; } } return $ str ; }
878	public function useRuleSet ( RuleSetInterface $ ruleSet ) { $ fixers = [ ] ; $ fixersByName = [ ] ; $ fixerConflicts = [ ] ; $ fixerNames = array_keys ( $ ruleSet -> getRules ( ) ) ; foreach ( $ fixerNames as $ name ) { if ( ! \ array_key_exists ( $ name , $ this -> fixersByName ) ) { throw new \ UnexpectedValueException ( sprintf ( 'Rule "%s" does not exist.' , $ name ) ) ; } $ fixer = $ this -> fixersByName [ $ name ] ; $ config = $ ruleSet -> getRuleConfiguration ( $ name ) ; if ( null !== $ config ) { if ( $ fixer instanceof ConfigurableFixerInterface ) { if ( ! \ is_array ( $ config ) || ! \ count ( $ config ) ) { throw new InvalidFixerConfigurationException ( $ fixer -> getName ( ) , 'Configuration must be an array and may not be empty.' ) ; } $ fixer -> configure ( $ config ) ; } else { throw new InvalidFixerConfigurationException ( $ fixer -> getName ( ) , 'Is not configurable.' ) ; } } $ fixers [ ] = $ fixer ; $ fixersByName [ $ name ] = $ fixer ; $ conflicts = array_intersect ( $ this -> getFixersConflicts ( $ fixer ) , $ fixerNames ) ; if ( \ count ( $ conflicts ) > 0 ) { $ fixerConflicts [ $ name ] = $ conflicts ; } } if ( \ count ( $ fixerConflicts ) > 0 ) { throw new \ UnexpectedValueException ( $ this -> generateConflictMessage ( $ fixerConflicts ) ) ; } $ this -> fixers = $ fixers ; $ this -> fixersByName = $ fixersByName ; return $ this ; }
4333	private static function buildAttribBoolVal ( $ key , $ value = true ) { if ( $ key == 'autocomplete' ) { $ value = $ value ? 'on' : 'off' ; } elseif ( $ key == 'spellcheck' ) { $ value = $ value ? 'true' : 'false' ; } elseif ( $ key == 'translate' ) { $ value = $ value ? 'yes' : 'no' ; } elseif ( $ value ) { $ value = $ key ; } else { $ value = null ; } return $ value ; }
2227	public function editHeader ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { return $ this -> User -> canEditFieldsOf ( 'tl_faq_category' ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; }
10654	public function __isset ( $ propertyName ) { $ methodName = 'get' . $ propertyName ; if ( method_exists ( $ this , $ methodName ) ) { return ( $ this -> $ methodName ( ) !== null ) ; } else { return false ; } }
5659	private function indexWidgetById ( $ widget ) { $ id = $ widget -> getAttribute ( 'id' ) ; if ( ! $ id ) { return ; } if ( ! isset ( $ this -> widgets_by_id [ $ id ] ) ) { $ this -> widgets_by_id [ $ id ] = array ( ) ; } $ this -> widgets_by_id [ $ id ] [ ] = $ widget ; }
871	public static function getDisplayableAllowedValues ( FixerOptionInterface $ option ) { $ allowed = $ option -> getAllowedValues ( ) ; if ( null !== $ allowed ) { $ allowed = array_filter ( $ allowed , static function ( $ value ) { return ! ( $ value instanceof \ Closure ) ; } ) ; usort ( $ allowed , static function ( $ valueA , $ valueB ) { if ( $ valueA instanceof AllowedValueSubset ) { return - 1 ; } if ( $ valueB instanceof AllowedValueSubset ) { return 1 ; } return strcasecmp ( self :: toString ( $ valueA ) , self :: toString ( $ valueB ) ) ; } ) ; if ( 0 === \ count ( $ allowed ) ) { $ allowed = null ; } } return $ allowed ; }
6362	public function convert ( float $ duration , TimeUnit $ timeUnit ) : float { return $ duration * ( $ timeUnit -> inMicros / $ this -> inMicros ) ; }
4415	public static function modify ( $ tpl , $ operatorName , $ operatorParameters , $ rootNamespace , $ currentNamespace , & $ operatorValue , $ namedParameters , $ placement ) { if ( $ operatorName === 'has_tags_bundle' ) { $ operatorValue = class_exists ( 'Netgen\TagsBundle\Version' ) && TagsBundleVersion :: VERSION_ID >= 30000 ; } }
11420	protected function getCache ( $ pk ) { $ app = App :: getInstance ( ) ; return $ app [ 'cache' ] -> getItem ( $ this -> dbtable . '/' . $ pk -> getValue ( ) ) ; }
2287	public static function findActiveByEmailAndUsername ( $ strEmail , $ strUsername = null , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ time = Date :: floorToMinute ( ) ; $ arrColumns = array ( "$t.email=? AND $t.login='1' AND ($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.disable=''" ) ; if ( $ strUsername !== null ) { $ arrColumns [ ] = "$t.username=?" ; } return static :: findOneBy ( $ arrColumns , array ( $ strEmail , $ strUsername ) , $ arrOptions ) ; }
3295	protected function getFingers ( Lead $ lead ) { $ fingers = [ ] ; if ( $ lead -> getEmail ( ) ) { $ fingers [ 'email' ] = strtolower ( $ lead -> getEmail ( ) ) ; } if ( $ lead -> getPhone ( ) ) { $ fingers [ 'phone' ] = preg_replace ( '/\D/' , '' , $ lead -> getPhone ( ) ) ; } if ( $ lead -> getMobile ( ) ) { $ fingers [ 'mobile' ] = preg_replace ( '/\D/' , '' , $ lead -> getMobile ( ) ) ; } return $ fingers ; }
1516	public function readRelatedResource ( StoreInterface $ store , FetchRelated $ request ) { $ record = $ request -> getRecord ( ) ; $ result = $ this -> beforeReadingRelationship ( $ record , $ request ) ; if ( $ this -> isResponse ( $ result ) ) { return $ result ; } $ related = $ store -> queryRelated ( $ record , $ request -> getRelationshipName ( ) , $ request -> getParameters ( ) ) ; $ records = ( $ related instanceof PageInterface ) ? $ related -> getData ( ) : $ related ; $ result = $ this -> afterReadingRelationship ( $ record , $ records , $ request ) ; if ( $ this -> isInvokedResult ( $ result ) ) { return $ result ; } return $ this -> reply ( ) -> content ( $ related ) ; }
8511	public function listInboundShipmentItems ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_ListInboundShipmentItemsRequest ) ) { $ request = new FBAInboundServiceMWS_Model_ListInboundShipmentItemsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListInboundShipmentItems' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_ListInboundShipmentItemsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
8435	public function delete ( ) : bool { $ status = false ; if ( $ this -> new === false ) { $ deleteQuery = new Delete ( $ this -> getDatabaseName ( ) ) ; $ deleteQuery -> from ( $ this -> getTableName ( ) ) ; $ where = array ( ) ; foreach ( $ this -> getPrimary ( ) as $ primary ) { $ field = $ this -> { 'field' . ucfirst ( $ primary ) } ; $ realName = constant ( get_called_class ( ) . '::FIELD_' . strtoupper ( Helper :: codifyName ( $ primary ) ) ) ; $ where [ $ realName ] = ':primary' . ucfirst ( $ primary ) ; $ deleteQuery -> bind ( 'primary' . ucfirst ( $ primary ) , $ field [ 'value' ] ) ; } $ deleteQuery -> where ( $ where ) ; $ status = $ deleteQuery -> execute ( ) ; } return $ status ; }
10734	public function setLower ( $ lower ) : self { if ( ! is_numeric ( $ lower ) ) { throw new InvalidArgumentException ( __METHOD__ . "() expects parameter one, lower, to be a number" ) ; } $ this -> lower = + $ lower ; return $ this ; }
10388	protected function handleTtl ( $ key , $ expireSetTs , $ expireSec ) { $ ttl = $ expireSetTs + $ expireSec - time ( ) ; if ( $ ttl <= 0 ) { $ this -> getClient ( ) -> delete ( $ key ) ; throw new KeyNotFoundException ( ) ; } return $ ttl ; }
8109	protected function getWithDefault ( $ field ) { $ value = $ this -> owner -> getField ( $ field ) ; if ( $ value ) { return $ value ; } $ defaults = $ this -> owner -> config ( ) -> get ( 'defaults' ) ; if ( isset ( $ defaults [ $ field ] ) ) { return $ defaults [ $ field ] ; } }
3528	public function getFriends ( ) { $ data = FortniteClient :: sendUnrealClientGetRequest ( FortniteClient :: EPIC_FRIENDS_ENDPOINT . $ this -> account_id , $ this -> access_token , true ) ; return $ data ; }
7674	function TbsStoreLoad ( $ idx , $ file = false ) { $ this -> TBS -> Source = $ this -> TbsStoreGet ( $ idx , false ) ; $ this -> TbsCurrIdx = $ idx ; if ( $ file === false ) $ file = $ this -> TbsGetFileName ( $ idx ) ; $ this -> TBS -> OtbsCurrFile = $ file ; }
2496	private function getIndexFieldName ( int $ depth ) : string { if ( $ depth === 0 ) { return self :: $ fieldName ; } return sprintf ( self :: $ relatedContentFieldName , $ depth ) ; }
5509	public function expect ( $ method , $ args , $ message = '%s' ) { $ this -> dieOnNoMethod ( $ method , 'set expected arguments' ) ; $ this -> checkArgumentsIsArray ( $ args , 'set expected arguments' ) ; $ this -> expectations -> expectArguments ( $ method , $ args , $ message ) ; $ args = $ this -> replaceWildcards ( $ args ) ; $ message .= Mock :: getExpectationLine ( ) ; $ this -> expected_args [ strtolower ( $ method ) ] = new ParametersExpectation ( $ args , $ message ) ; }
7704	function OpenDoc_MsExcelCompatibility ( & $ Txt ) { $ el_tbl = 'table:table' ; $ el_col = 'table:table-column' ; $ el_row = 'table:table-row' ; $ el_cell = 'table:table-cell' ; $ att_rep_col = 'table:number-columns-repeated' ; $ att_rep_row = 'table:number-rows-repeated' ; $ loop = array ( $ att_rep_col , $ att_rep_row ) ; foreach ( $ loop as $ att_rep ) { $ p = 0 ; while ( $ xml = clsTbsXmlLoc :: FindElementHavingAtt ( $ Txt , $ att_rep , $ p ) ) { $ xml -> FindName ( ) ; $ p = $ xml -> PosEnd ; $ next = clsTbsXmlLoc :: FindStartTagByPrefix ( $ Txt , '' , $ p ) ; $ next_name = $ next -> Name ; if ( $ next_name == '' ) { $ next_name = $ next -> GetSrc ( ) ; $ next_name = substr ( $ next_name , 1 , strlen ( $ next_name ) - 2 ) ; } ; $ z_src = $ next -> GetSrc ( ) ; $ delete = false ; if ( ( $ xml -> Name == $ el_col ) && ( $ xml -> SelfClosing ) ) { if ( ( $ next_name == $ el_row ) || ( $ next_name == '/' . $ el_tbl ) ) { $ delete = true ; } } elseif ( ( $ xml -> Name == $ el_cell ) && ( $ xml -> SelfClosing ) ) { if ( $ next_name == '/' . $ el_row ) { $ delete = true ; } } elseif ( $ xml -> Name == $ el_row ) { if ( $ next_name == '/' . $ el_tbl ) { $ inner_src = '' . $ xml -> GetInnerSrc ( ) ; if ( strpos ( $ inner_src , '<' ) === false ) { $ delete = true ; } } } if ( $ delete ) { $ p = $ xml -> PosBeg ; $ xml -> Delete ( ) ; } } } }
7146	public function save_custom_profile_fields ( $ user_id ) { if ( 'POST' !== $ _SERVER [ 'REQUEST_METHOD' ] || ! isset ( $ _POST [ 'iac_nonce' ] ) ) { return ; } if ( ! wp_verify_nonce ( $ _POST [ 'iac_nonce' ] , 'iac_user_settings' ) ) { return ; } do_action ( 'iac_save_user_settings' , $ user_id , isset ( $ _POST [ 'post_subscription' ] ) ? $ _POST [ 'post_subscription' ] : NULL , isset ( $ _POST [ 'comment_subscription' ] ) ? $ _POST [ 'comment_subscription' ] : NULL ) ; }
6516	public function register ( Container $ container ) { $ container [ 'doctrine.orm.em' ] = $ this -> getOrmEmDefinition ( $ container ) ; $ container [ 'doctrine.orm.em.config' ] = $ this -> getOrmEmConfigDefinition ( $ container ) ; $ container [ 'doctrine.orm.em.default_options' ] = $ this -> getOrmEmDefaultOptions ( ) ; $ container [ 'doctrine.orm.ems' ] = $ this -> getOrmEmsDefinition ( $ container ) ; $ container [ 'doctrine.orm.ems.config' ] = $ this -> getOrmEmsConfigServiceProvider ( $ container ) ; $ container [ 'doctrine.orm.ems.options.initializer' ] = $ this -> getOrmEmsOptionsInitializerDefinition ( $ container ) ; $ container [ 'doctrine.orm.entity.listener_resolver.default' ] = $ this -> getOrmEntityListenerResolverDefinition ( $ container ) ; $ container [ 'doctrine.orm.manager_registry' ] = $ this -> getOrmManagerRegistryDefintion ( $ container ) ; $ container [ 'doctrine.orm.mapping_driver.factory.annotation' ] = $ this -> getOrmMappingDriverFactoryAnnotation ( $ container ) ; $ container [ 'doctrine.orm.mapping_driver.factory.class_map' ] = $ this -> getOrmMappingDriverFactoryClassMap ( $ container ) ; $ container [ 'doctrine.orm.mapping_driver.factory.php' ] = $ this -> getOrmMappingDriverFactoryPhp ( $ container ) ; $ container [ 'doctrine.orm.mapping_driver.factory.simple_xml' ] = $ this -> getOrmMappingDriverFactorySimpleXml ( $ container ) ; $ container [ 'doctrine.orm.mapping_driver.factory.simple_yaml' ] = $ this -> getOrmMappingDriverFactorySimpleYaml ( $ container ) ; $ container [ 'doctrine.orm.mapping_driver.factory.static_php' ] = $ this -> getOrmMappingDriverFactoryStaticPhp ( $ container ) ; $ container [ 'doctrine.orm.mapping_driver.factory.xml' ] = $ this -> getOrmMappingDriverFactoryXml ( $ container ) ; $ container [ 'doctrine.orm.mapping_driver.factory.yaml' ] = $ this -> getOrmMappingDriverFactoryYaml ( $ container ) ; $ container [ 'doctrine.orm.mapping_driver_chain' ] = $ this -> getOrmMappingDriverChainDefinition ( $ container ) ; $ container [ 'doctrine.orm.repository.factory.default' ] = $ this -> getOrmRepositoryFactoryDefinition ( $ container ) ; $ container [ 'doctrine.orm.strategy.naming.default' ] = $ this -> getOrmNamingStrategyDefinition ( $ container ) ; $ container [ 'doctrine.orm.strategy.quote.default' ] = $ this -> getOrmQuoteStrategyDefinition ( $ container ) ; }
5555	public function getUrls ( ) { if ( is_integer ( $ this -> focus ) ) { return $ this -> frames [ $ this -> focus ] -> getUrls ( ) ; } $ urls = array ( ) ; foreach ( $ this -> frames as $ frame ) { $ urls = array_merge ( $ urls , $ frame -> getUrls ( ) ) ; } return array_values ( array_unique ( $ urls ) ) ; }
1450	protected function validatorForResource ( array $ data , array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] ) : ValidatorInterface { return $ this -> factory -> createResourceValidator ( ResourceObject :: create ( $ data ) , $ rules , $ messages , $ customAttributes ) ; }
667	public static function startsWith ( $ string , $ with , $ caseSensitive = true ) { if ( ! $ bytes = static :: byteLength ( $ with ) ) { return true ; } if ( $ caseSensitive ) { return strncmp ( $ string , $ with , $ bytes ) === 0 ; } $ encoding = Yii :: $ app ? Yii :: $ app -> charset : 'UTF-8' ; return mb_strtolower ( mb_substr ( $ string , 0 , $ bytes , '8bit' ) , $ encoding ) === mb_strtolower ( $ with , $ encoding ) ; }
11825	public function add ( $ encoding = 'UTF-8' ) { $ str = file_get_contents ( $ this -> uri ) ; return file_put_contents ( $ this -> uri , $ this -> getBom ( $ encoding ) . $ str ) ; }
12686	public function inferType ( $ value ) { if ( is_string ( $ value ) ) { return new StringType ( ) ; } elseif ( is_array ( $ value ) ) { return new ArrayType ( ) ; } elseif ( is_object ( $ value ) ) { return $ this -> inferObjectType ( $ value ) ; } elseif ( is_integer ( $ value ) ) { return new IntegerType ( ) ; } elseif ( is_bool ( $ value ) ) { return new BooleanType ( ) ; } elseif ( is_null ( $ value ) ) { return new MixedType ( ) ; } $ e = new InferException ( 'Typ konnte nicht geraten werden: ' . Util :: varInfo ( $ value ) ) ; $ e -> value = $ value ; throw $ e ; }
1592	protected function validateResource ( ) : bool { $ identifier = $ this -> validateTypeAndId ( ) ; $ attributes = $ this -> validateAttributes ( ) ; $ relationships = $ this -> validateRelationships ( ) ; if ( $ attributes && $ relationships ) { return $ this -> validateAllFields ( ) && $ identifier ; } return $ identifier && $ attributes && $ relationships ; }
10223	public function menuFor ( $ model , $ modelId = 0 , ModelConfig $ config = null ) { if ( is_null ( $ this -> aujaConfigurator ) ) { throw new \ LogicException ( 'Auja not initialized. Call Auja::init first.' ) ; } $ modelName = $ this -> resolveModelName ( $ model ) ; if ( $ modelId == 0 ) { $ menu = $ this -> noAssociationsMenuFor ( $ modelName , $ config ) ; } else { $ menu = $ this -> buildComplexIndexMenu ( $ modelName , $ modelId , $ config ) ; } return $ menu ; }
1059	public static function findValuesRemovedFromEnums ( Schema $ oldSchema , Schema $ newSchema ) { $ oldTypeMap = $ oldSchema -> getTypeMap ( ) ; $ newTypeMap = $ newSchema -> getTypeMap ( ) ; $ valuesRemovedFromEnums = [ ] ; foreach ( $ oldTypeMap as $ typeName => $ oldType ) { $ newType = $ newTypeMap [ $ typeName ] ?? null ; if ( ! ( $ oldType instanceof EnumType ) || ! ( $ newType instanceof EnumType ) ) { continue ; } $ valuesInNewEnum = [ ] ; foreach ( $ newType -> getValues ( ) as $ value ) { $ valuesInNewEnum [ $ value -> name ] = true ; } foreach ( $ oldType -> getValues ( ) as $ value ) { if ( isset ( $ valuesInNewEnum [ $ value -> name ] ) ) { continue ; } $ valuesRemovedFromEnums [ ] = [ 'type' => self :: BREAKING_CHANGE_VALUE_REMOVED_FROM_ENUM , 'description' => sprintf ( '%s was removed from enum type %s.' , $ value -> name , $ typeName ) , ] ; } } return $ valuesRemovedFromEnums ; }
12167	private function createMenuGroupTable ( ) { $ this -> database -> query ( "DROP TABLE IF EXISTS `?menu_group`;" ) ; $ this -> database -> query ( "CREATE TABLE IF NOT EXISTS `?menu_group` ( `menu_group_id` int(11) NOT NULL AUTO_INCREMENT, `menu_group_title` varchar(45) NOT NULL, `menu_group_order` int(11) NOT NULL DEFAULT '0', `menu_group_uid` varchar(45) NOT NULL, `menu_group_iscore` TINYINT(1) NOT NULL DEFAULT '0', PRIMARY KEY (`menu_group_id`), UNIQUE KEY `menu_group_id_UNIQUE` (`menu_group_id`), UNIQUE KEY `menu_group_uid_UNIQUE` (`menu_group_uid`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 AUTO_INCREMENT=6 ; " ) ; $ this -> database -> query ( "INSERT INTO `?menu_group` (`menu_group_id`, `menu_group_title`, `menu_group_order`, `menu_group_uid`, `menu_group_iscore`) VALUES (1, 'Media Menu', 1, 'mediamenu', 1), (2, 'User Menu', 2, 'usermenu', 1), (3, 'Dashboard Menu', 3, 'dashboardmenu', 1), (4, 'Messages Menu', 4, 'messagesmenu', 1), (5, 'Profile Menu', 5, 'profilemenu', 1), (6, 'People Menu', 6, 'peoplemenu', 1);" ) ; }
9508	public function showByLevel ( Log $ log , $ level ) { $ this -> authorize ( LogViewerPolicy :: PERMISSION_SHOW ) ; if ( $ level == 'all' ) return redirect ( ) -> route ( 'admin::foundation.system.log-viewer.logs.show' , [ $ log -> date ] ) ; $ levels = $ this -> logViewer -> levelsNames ( ) ; $ entries = $ this -> logViewer -> entries ( $ log -> date , $ level ) -> paginate ( $ this -> perPage ) ; $ this -> addBreadcrumbRoute ( trans ( 'foundation::log-viewer.titles.logs-list' ) , 'admin::foundation.system.log-viewer.logs.list' ) ; $ this -> setTitle ( $ log -> date . ' | ' . ucfirst ( $ level ) ) ; $ this -> addBreadcrumbRoute ( $ log -> date , 'admin::foundation.system.log-viewer.logs.show' , [ $ log -> date ] ) ; $ this -> addBreadcrumb ( ucfirst ( $ level ) ) ; return $ this -> view ( 'admin.system.log-viewer.show' , compact ( 'log' , 'levels' , 'entries' , 'level' ) ) ; }
9456	public function getOffSet ( ) { if ( $ this -> getPaginator ( ) ) { return $ this -> getPaginator ( ) -> getOffset ( ) ; } else { $ offset = $ this -> get ( 'offset' ) ; if ( ! $ offset ) { $ offset = 0 ; } return $ offset ; } }
5492	protected function renderArguments ( $ args ) { $ descriptions = array ( ) ; if ( is_array ( $ args ) ) { foreach ( $ args as $ arg ) { $ dumper = new SimpleDumper ( ) ; $ descriptions [ ] = $ dumper -> describeValue ( $ arg ) ; } } return implode ( ', ' , $ descriptions ) ; }
1385	protected function memberRequired ( string $ path , string $ member ) : void { $ this -> errors -> add ( $ this -> translator -> memberRequired ( $ path , $ member ) ) ; }
7023	private function formatZ ( & $ str ) { if ( strstr ( $ str , '%Z' ) ) $ str = str_replace ( '%Z' , $ this -> timezone -> offset * 3600 , $ str ) ; }
12514	public static function create ( $ path = '' , $ mode = 0777 ) { $ path = Path :: clean ( $ path ) ; $ fs = new Filesystem ( ) ; try { $ fs -> mkdir ( $ path ) ; } catch ( IOExceptionInterface $ e ) { throw new Exception ( Helper :: getTranslation ( 'FAILED_CREATING' ) . ' ' . $ e -> getPath ( ) ) ; } return true ; }
831	private function fixConstructor ( Tokens $ tokens , $ className , $ classStart , $ classEnd ) { $ php4 = $ this -> findFunction ( $ tokens , $ className , $ classStart , $ classEnd ) ; if ( null === $ php4 ) { return ; } if ( ! empty ( $ php4 [ 'modifiers' ] [ T_ABSTRACT ] ) || ! empty ( $ php4 [ 'modifiers' ] [ T_STATIC ] ) ) { return ; } $ php5 = $ this -> findFunction ( $ tokens , '__construct' , $ classStart , $ classEnd ) ; if ( null === $ php5 ) { $ tokens [ $ php4 [ 'nameIndex' ] ] = new Token ( [ T_STRING , '__construct' ] ) ; $ this -> fixInfiniteRecursion ( $ tokens , $ php4 [ 'bodyIndex' ] , $ php4 [ 'endIndex' ] ) ; return ; } list ( $ seq , $ case ) = $ this -> getWrapperMethodSequence ( $ tokens , '__construct' , $ php4 [ 'startIndex' ] , $ php4 [ 'bodyIndex' ] ) ; if ( null !== $ tokens -> findSequence ( $ seq , $ php4 [ 'bodyIndex' ] - 1 , $ php4 [ 'endIndex' ] , $ case ) ) { for ( $ i = $ php4 [ 'startIndex' ] ; $ i <= $ php4 [ 'endIndex' ] ; ++ $ i ) { $ tokens -> clearAt ( $ i ) ; } return ; } list ( $ seq , $ case ) = $ this -> getWrapperMethodSequence ( $ tokens , $ className , $ php4 [ 'startIndex' ] , $ php4 [ 'bodyIndex' ] ) ; if ( null !== $ tokens -> findSequence ( $ seq , $ php5 [ 'bodyIndex' ] - 1 , $ php5 [ 'endIndex' ] , $ case ) ) { for ( $ i = $ php5 [ 'startIndex' ] ; $ i <= $ php5 [ 'endIndex' ] ; ++ $ i ) { $ tokens -> clearAt ( $ i ) ; } $ tokens [ $ php4 [ 'nameIndex' ] ] = new Token ( [ T_STRING , '__construct' ] ) ; } }
5384	public function setValue ( $ value ) { if ( $ value === false ) { return parent :: setValue ( $ value ) ; } if ( $ value != $ this -> getAttribute ( 'value' ) ) { return false ; } return parent :: setValue ( $ value ) ; }
9251	public function addCompilerPass ( CompilerPassInterface $ pass , $ type = PassConfig :: TYPE_BEFORE_OPTIMIZATION ) { $ this -> compilerPasses [ ] = array ( $ pass , $ type ) ; }
181	public function getConverter ( ) { if ( $ this -> _converter === null ) { $ this -> _converter = Yii :: createObject ( AssetConverter :: className ( ) ) ; } elseif ( is_array ( $ this -> _converter ) || is_string ( $ this -> _converter ) ) { if ( is_array ( $ this -> _converter ) && ! isset ( $ this -> _converter [ 'class' ] ) ) { $ this -> _converter [ 'class' ] = AssetConverter :: className ( ) ; } $ this -> _converter = Yii :: createObject ( $ this -> _converter ) ; } return $ this -> _converter ; }
12503	public static function beginTransaction ( $ connection ) { $ connection -> query = 'BEGIN_TRANSACTION' ; $ connection -> method = 'POST' ; $ connection -> action = '/_query' ; return self :: sendQuery ( $ connection ) ; }
5021	public function getFieldInputSpecification ( $ field ) { if ( ! $ this -> hasField ( $ field ) ) { return [ ] ; } if ( ! isset ( $ this -> fields [ $ field ] [ '__filter__' ] ) ) { $ this -> fields [ $ field ] [ '__filter__' ] = $ this -> copyArrayValues ( $ this -> fields [ $ field ] , [ 'input_filter' => [ ] , 'required' , ] ) ; } return $ this -> fields [ $ field ] [ '__filter__' ] ; }
10536	public function extractHeaders ( ) { $ headers = [ ] ; $ requestHeaders = array_keys ( $ this -> cors ) ; foreach ( $ requestHeaders as $ headerField ) { $ serverField = $ this -> headerizeToPhp ( $ headerField ) ; $ headerData = isset ( $ _SERVER [ $ serverField ] ) ? $ _SERVER [ $ serverField ] : null ; if ( $ headerData !== null ) { $ headers [ $ headerField ] = $ headerData ; } } return $ headers ; }
7700	function MsWord_InitHeaderFooter ( ) { if ( $ this -> MsWord_HeaderFooter !== false ) return ; $ types_ok = array ( 'default' => true , 'first' => false , 'even' => false ) ; $ idx = $ this -> FileGetIdx ( 'word/settings.xml' ) ; if ( $ idx !== false ) { $ Txt = $ this -> TbsStoreGet ( $ idx , 'GetHeaderFooterFile' ) ; $ types_ok [ 'even' ] = ( strpos ( $ Txt , '<w:evenAndOddHeaders/>' ) !== false ) ; unset ( $ Txt ) ; } $ idx = $ this -> FileGetIdx ( 'word/document.xml' ) ; if ( $ idx === false ) return false ; $ Txt = $ this -> TbsStoreGet ( $ idx , 'GetHeaderFooterFile' ) ; $ types_ok [ 'first' ] = ( strpos ( $ Txt , '<w:titlePg/>' ) !== false ) ; $ places = array ( 'header' , 'footer' ) ; $ files = array ( ) ; $ rels = $ this -> OpenXML_Rels_GetObj ( 'word/document.xml' , '' ) ; foreach ( $ places as $ place ) { $ p = 0 ; $ entity = 'w:' . $ place . 'Reference' ; while ( $ loc = clsTbsXmlLoc :: FindStartTag ( $ Txt , $ entity , $ p ) ) { $ p = $ loc -> PosEnd ; $ type = $ loc -> GetAttLazy ( 'w:type' ) ; if ( isset ( $ types_ok [ $ type ] ) && $ types_ok [ $ type ] ) { $ rid = $ loc -> GetAttLazy ( 'r:id' ) ; if ( isset ( $ rels -> TargetLst [ $ rid ] ) ) { $ target = $ rels -> TargetLst [ $ rid ] ; $ files [ ] = array ( 'file' => ( 'word/' . $ target ) , 'type' => $ type , 'place' => $ place ) ; } } } } $ this -> MsWord_HeaderFooter = $ files ; }
4657	public function run ( Job $ job , $ command ) { if ( is_string ( $ command ) ) { $ command = [ '/bin/bash' , '-c' , $ command ] ; } $ image = $ this -> docker -> getImageManager ( ) -> find ( $ job -> getName ( ) ) ; $ hostConfig = new HostConfig ( ) ; $ config = new ContainerConfig ( ) ; $ config -> setCmd ( $ command ) ; $ config -> setImage ( $ image -> getId ( ) ) ; $ config -> setHostConfig ( $ hostConfig ) ; $ config -> setLabels ( new \ ArrayObject ( [ 'com.jolici.container=true' ] ) ) ; $ config -> setAttachStderr ( true ) ; $ config -> setAttachStdout ( true ) ; $ links = [ ] ; foreach ( $ job -> getServices ( ) as $ service ) { if ( $ service -> getContainer ( ) ) { $ serviceContainer = $ this -> docker -> getContainerManager ( ) -> find ( $ service -> getContainer ( ) ) ; $ links [ ] = sprintf ( '%s:%s' , $ serviceContainer -> getName ( ) , $ service -> getName ( ) ) ; } } $ hostConfig -> setLinks ( $ links ) ; $ containerCreateResult = $ this -> docker -> getContainerManager ( ) -> create ( $ config ) ; $ attachStream = $ this -> docker -> getContainerManager ( ) -> attach ( $ containerCreateResult -> getId ( ) , [ 'stream' => true , 'stdout' => true , 'stderr' => true , ] , ContainerManager :: FETCH_STREAM ) ; $ attachStream -> onStdout ( $ this -> logger -> getRunStdoutCallback ( ) ) ; $ attachStream -> onStderr ( $ this -> logger -> getRunStderrCallback ( ) ) ; $ this -> docker -> getContainerManager ( ) -> start ( $ containerCreateResult -> getId ( ) ) ; $ attachStream -> wait ( ) ; $ containerWait = $ this -> docker -> getContainerManager ( ) -> wait ( $ containerCreateResult -> getId ( ) ) ; return $ containerWait -> getStatusCode ( ) ; }
420	public function run ( ) { $ block = ob_get_clean ( ) ; if ( $ this -> renderInPlace ) { echo $ block ; } $ this -> view -> blocks [ $ this -> getId ( ) ] = $ block ; }
2090	public static function countPublishedBySourceAndParent ( $ strSource , $ intParent , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.source=? AND $t.parent=?" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ arrColumns [ ] = "$t.published='1'" ; } return static :: countBy ( $ arrColumns , array ( $ strSource , ( int ) $ intParent ) ) ; }
3753	public function save ( ModelInterface $ objItem , $ timestamp = null ) { if ( null === $ timestamp ) { @ \ trigger_error ( 'Not passing a timestamp has been deprecated and will cause an error in MetaModels 3' , E_USER_DEPRECATED ) ; } if ( $ objItem instanceof Model ) { $ backupLanguage = $ this -> setLanguage ( $ this -> getCurrentLanguage ( ) ) ; $ objItem -> getItem ( ) -> save ( $ timestamp ) ; $ this -> setLanguage ( $ backupLanguage ) ; return $ objItem ; } throw new \ RuntimeException ( 'ERROR: incompatible object passed to GeneralDataMetaModel::save()' ) ; }
2100	public static function getNumericTimeFormat ( ) { if ( TL_MODE == 'FE' ) { global $ objPage ; if ( $ objPage -> timeFormat != '' && static :: isNumericFormat ( $ objPage -> timeFormat ) ) { return $ objPage -> timeFormat ; } } return Config :: get ( 'timeFormat' ) ; }
7559	function select ( $ query = '*' , $ index = false , $ recursive = true , $ check_self = false ) { $ s = new $ this -> selectClass ( $ this , $ query , $ check_self , $ recursive ) ; $ res = $ s -> result ; unset ( $ s ) ; if ( is_array ( $ res ) && ( $ index === true ) && ( count ( $ res ) === 1 ) ) { return $ res [ 0 ] ; } elseif ( is_int ( $ index ) && is_array ( $ res ) ) { if ( $ index < 0 ) { $ index += count ( $ res ) ; } return ( $ index < count ( $ res ) ) ? $ res [ $ index ] : null ; } else { return $ res ; } }
8033	public function loadView ( $ viewName , $ data = array ( ) , $ mergeData = array ( ) ) { $ this -> htmlContent = View :: make ( $ viewName , $ data , $ mergeData ) ; return $ this ; }
782	public function add ( $ cookie ) { if ( $ this -> readOnly ) { throw new InvalidCallException ( 'The cookie collection is read only.' ) ; } $ this -> _cookies [ $ cookie -> name ] = $ cookie ; }
5870	protected static function getBasicMetadata ( $ fileName ) { $ extension = strtolower ( substr ( $ fileName , strrpos ( $ fileName , '.' ) + 1 ) ) ; $ metadata = [ ] ; if ( GeneralUtility :: inList ( 'jpg,jpeg,tif,tiff' , $ extension ) && function_exists ( 'exif_read_data' ) ) { $ exif = @ exif_read_data ( $ fileName ) ; if ( $ exif ) { $ metadata = $ exif ; $ metadata [ 'ImageDescription' ] = static :: safeUtf8Encode ( $ metadata [ 'ImageDescription' ] ) ; if ( isset ( $ metadata [ 'GPSLatitude' ] ) && is_array ( $ metadata [ 'GPSLatitude' ] ) ) { $ reference = isset ( $ metadata [ 'GPSLatitudeRef' ] ) ? $ metadata [ 'GPSLatitudeRef' ] : 'N' ; $ decimal = static :: rationalToDecimal ( $ metadata [ 'GPSLatitude' ] ) ; $ decimal *= $ reference === 'N' ? 1 : - 1 ; $ metadata [ 'GPSLatitudeDecimal' ] = $ decimal ; } if ( isset ( $ metadata [ 'GPSLongitude' ] ) && is_array ( $ metadata [ 'GPSLongitude' ] ) ) { $ reference = isset ( $ metadata [ 'GPSLongitudeRef' ] ) ? $ metadata [ 'GPSLongitudeRef' ] : 'E' ; $ decimal = static :: rationalToDecimal ( $ metadata [ 'GPSLongitude' ] ) ; $ decimal *= $ reference === 'E' ? 1 : - 1 ; $ metadata [ 'GPSLongitudeDecimal' ] = $ decimal ; } if ( isset ( $ metadata [ 'GPSAltitude' ] ) ) { $ rationalParts = explode ( '/' , $ metadata [ 'GPSAltitude' ] ) ; if ( ! empty ( $ rationalParts [ 1 ] ) ) { $ metadata [ 'GPSAltitudeDecimal' ] = $ rationalParts [ 0 ] / $ rationalParts [ 1 ] ; } else { $ metadata [ 'GPSAltitudeDecimal' ] = 0 ; } } } $ imageinfo = [ ] ; if ( function_exists ( 'iptcparse' ) && getimagesize ( $ fileName , $ imageinfo ) ) { if ( isset ( $ imageinfo [ 'APP13' ] ) ) { $ data = iptcparse ( $ imageinfo [ 'APP13' ] ) ; $ mapping = [ '2#005' => 'Title' , '2#025' => 'Keywords' , '2#040' => 'Instructions' , '2#080' => 'Creator' , '2#085' => 'CreatorFunction' , '2#090' => 'City' , '2#092' => 'Location' , '2#095' => 'Region' , '2#100' => 'CountryCode' , '2#101' => 'Country' , '2#103' => 'IdentifierWork' , '2#105' => 'CreatorTitle' , '2#110' => 'Credit' , '2#115' => 'Source' , '2#116' => 'Copyright' , '2#120' => 'Description' , '2#122' => 'DescriptionAuthor' , ] ; foreach ( $ mapping as $ iptcKey => $ metadataKey ) { if ( isset ( $ data [ $ iptcKey ] ) ) { $ metadata [ 'IPTC' . $ metadataKey ] = static :: safeUtf8Encode ( $ data [ $ iptcKey ] [ 0 ] ) ; } } } } } return $ metadata ; }
11287	protected function _getCustomValue ( $ attributeName , $ query , $ loadMap = false ) { $ def = $ this -> model_attributes [ $ attributeName ] ; $ result = $ this -> _getRelation ( $ attributeName , $ query , $ loadMap ) ; if ( ! $ result ) { $ result = $ query -> fetch ( ) ; } return $ result ; }
10361	public static function writeLogs ( string $ message ) : bool { return ( bool ) file_put_contents ( rtrim ( LOGS_PATH , '/' ) . '/' . gmdate ( 'Y_m_d' ) . '.log' , '[' . gmdate ( 'd-M-Y H:i:s' ) . '] ' . $ message . PHP_EOL , FILE_APPEND ) ; }
9947	public function getRowDimension ( $ pRow , $ create = true ) { $ found = null ; if ( ! isset ( $ this -> rowDimensions [ $ pRow ] ) ) { if ( ! $ create ) { return null ; } $ this -> rowDimensions [ $ pRow ] = new RowDimension ( $ pRow ) ; $ this -> cachedHighestRow = max ( $ this -> cachedHighestRow , $ pRow ) ; } return $ this -> rowDimensions [ $ pRow ] ; }
11622	public function api ( string $ link = null , string $ method = null ) : \ TheCMSThread \ Classes \ API { static $ api ; if ( $ api === null ) { $ api = $ this -> container -> get ( "TheCMSThread\\Core\\API" ) ; } return $ api -> set ( $ link , $ method ) ; }
2797	public function getAdapter ( ) { if ( is_null ( $ this -> adapter ) ) { $ name = ucfirst ( strtolower ( $ this -> get ( 'adapter' ) ) ) ; $ class = '\\Humbug\\Adapter\\' . $ name ; $ this -> adapter = new $ class ; } return $ this -> adapter ; }
9037	protected function update ( $ entity , $ where = null , $ tableName = null , HydratorInterface $ hydrator = null ) { if ( ! $ where ) { $ where = 'id = ' . $ entity -> getId ( ) ; } return parent :: update ( $ entity , $ where , $ tableName , $ hydrator ) ; }
7777	protected function extractFieldAliases ( array $ data ) { foreach ( $ data as $ field => $ fieldRules ) { $ extraction = explode ( '|' , $ field ) ; if ( isset ( $ extraction [ 1 ] ) ) { $ updatedField = $ extraction [ 0 ] ; $ alias = $ extraction [ 1 ] ; $ this -> fieldAliases [ $ updatedField ] = $ alias ; $ data [ $ updatedField ] = $ data [ $ field ] ; unset ( $ data [ $ field ] ) ; } } return $ data ; }
2771	public function cloneRepository ( string $ repository , array $ options = [ ] ) : string { $ argsAndOptions = [ $ repository , $ this -> directory , $ options ] ; return $ this -> run ( 'clone' , $ argsAndOptions , false ) ; }
382	public function argumentsToString ( $ args ) { $ count = 0 ; $ isAssoc = $ args !== array_values ( $ args ) ; foreach ( $ args as $ key => $ value ) { $ count ++ ; if ( $ count >= 5 ) { if ( $ count > 5 ) { unset ( $ args [ $ key ] ) ; } else { $ args [ $ key ] = '...' ; } continue ; } if ( is_object ( $ value ) ) { $ args [ $ key ] = '<span class="title">' . $ this -> htmlEncode ( get_class ( $ value ) ) . '</span>' ; } elseif ( is_bool ( $ value ) ) { $ args [ $ key ] = '<span class="keyword">' . ( $ value ? 'true' : 'false' ) . '</span>' ; } elseif ( is_string ( $ value ) ) { $ fullValue = $ this -> htmlEncode ( $ value ) ; if ( mb_strlen ( $ value , 'UTF-8' ) > 32 ) { $ displayValue = $ this -> htmlEncode ( mb_substr ( $ value , 0 , 32 , 'UTF-8' ) ) . '...' ; $ args [ $ key ] = "<span class=\"string\" title=\"$fullValue\">'$displayValue'</span>" ; } else { $ args [ $ key ] = "<span class=\"string\">'$fullValue'</span>" ; } } elseif ( is_array ( $ value ) ) { $ args [ $ key ] = '[' . $ this -> argumentsToString ( $ value ) . ']' ; } elseif ( $ value === null ) { $ args [ $ key ] = '<span class="keyword">null</span>' ; } elseif ( is_resource ( $ value ) ) { $ args [ $ key ] = '<span class="keyword">resource</span>' ; } else { $ args [ $ key ] = '<span class="number">' . $ value . '</span>' ; } if ( is_string ( $ key ) ) { $ args [ $ key ] = '<span class="string">\'' . $ this -> htmlEncode ( $ key ) . "'</span> => $args[$key]" ; } elseif ( $ isAssoc ) { $ args [ $ key ] = "<span class=\"number\">$key</span> => $args[$key]" ; } } return implode ( ', ' , $ args ) ; }
9561	protected function makeResponse ( $ response , Exception $ exception ) { if ( ! $ response instanceof Response ) { $ response = new Response ( $ response ) ; } if ( ! $ response -> isClientError ( ) && ! $ response -> isServerError ( ) && ! $ response -> isRedirect ( ) ) { if ( $ exception instanceof HttpExceptionInterface ) { $ response -> setStatusCode ( $ exception -> getStatusCode ( ) ) ; $ response -> headers -> add ( $ exception -> getHeaders ( ) ) ; } else { $ response -> setStatusCode ( 500 ) ; } } return $ response ; }
1493	public function index ( $ resourceType , $ meta = null , array $ queryParams = [ ] ) { return $ this -> factory -> createLink ( $ this -> urls -> index ( $ resourceType , $ queryParams ) , $ meta , true ) ; }
12178	public function getIndividual ( ) { if ( ! isset ( $ this -> _individual ) && ! empty ( $ this -> object_individual_id ) ) { $ this -> _individual = false ; $ individualType = Yii :: $ app -> collectors [ 'types' ] -> getOne ( 'Individual' ) ; if ( ! empty ( $ individualType -> object ) ) { $ individualClass = $ individualType -> object -> primaryModel ; $ this -> _individual = $ individualClass :: get ( $ this -> object_individual_id ) ; } } return $ this -> _individual ; }
10144	private function readBof ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = substr ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; $ substreamType = self :: getUInt2d ( $ recordData , 2 ) ; switch ( $ substreamType ) { case self :: XLS_WORKBOOKGLOBALS : $ version = self :: getUInt2d ( $ recordData , 0 ) ; if ( ( $ version != self :: XLS_BIFF8 ) && ( $ version != self :: XLS_BIFF7 ) ) { throw new Exception ( 'Cannot read this Excel file. Version is too old.' ) ; } $ this -> version = $ version ; break ; case self :: XLS_WORKSHEET : break ; default : do { $ code = self :: getUInt2d ( $ this -> data , $ this -> pos ) ; $ this -> readDefault ( ) ; } while ( $ code != self :: XLS_TYPE_EOF && $ this -> pos < $ this -> dataSize ) ; break ; } }
11303	protected static function checkPath ( $ path ) { if ( ! file_exists ( $ path ) ) { throw new NotFoundException ( Message :: get ( Message :: MSG_PATH_NOTFOUND , $ path ) , Message :: MSG_PATH_NOTFOUND ) ; } if ( ! is_readable ( $ path ) ) { throw new RuntimeException ( Message :: get ( Message :: MSG_PATH_NONREADABLE , $ path ) , Message :: MSG_PATH_NONREADABLE ) ; } }
3664	private function getValueFromSource ( $ source , $ valueName , $ arguments ) { switch ( strtolower ( $ source ) ) { case 'get' : return $ this -> container -> get ( Input :: class ) -> get ( $ valueName ) ; case 'post' : return $ this -> container -> get ( Input :: class ) -> post ( $ valueName ) ; case 'cookie' : return $ this -> container -> get ( Input :: class ) -> cookie ( $ valueName ) ; case 'session' : return $ this -> container -> get ( Session :: class ) -> get ( $ valueName ) ; case 'filter' : if ( is_array ( $ this -> filterParameters ) ) { if ( array_key_exists ( $ valueName , $ this -> filterParameters ) ) { return $ this -> filterParameters [ $ valueName ] ; } return null ; } break ; case 'container' : @ trigger_error ( 'Getting filter values from the service container is deprecated, the container will get removed.' , E_USER_DEPRECATED ) ; return $ this -> getValueFromServiceContainer ( $ valueName , $ arguments ) ; default : } return null ; }
10181	public function add ( $ pCoord , Cell $ cell ) { if ( $ pCoord !== $ this -> currentCoordinate ) { $ this -> storeCurrentCell ( ) ; } $ this -> index [ $ pCoord ] = true ; $ this -> currentCoordinate = $ pCoord ; $ this -> currentCell = $ cell ; $ this -> currentCellIsDirty = true ; return $ cell ; }
12045	public function destroy ( UserPolicy $ user , Question $ question ) { return $ question -> user_id == user_id ( ) && $ question -> user_type == user_type ( ) ; }
2710	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ domains = $ this -> api -> getAllDomains ( $ activeVersion ) ; $ storeBaseUrl = $ this -> storeManager -> getStore ( ) -> getBaseUrl ( ) ; if ( ! $ domains ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to check Domain details.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'domains' => $ domains , 'store' => $ storeBaseUrl ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
11026	protected function country ( ) { $ this -> parts [ '{country}' ] = $ this -> form -> field ( $ this -> model , $ this -> model -> getCountryPropertyName ( ) , [ 'options' => [ 'class' => 'form-group' ] ] ) -> dropDownList ( ArrayHelper :: map ( Country :: find ( ) -> orderBy ( [ 'name' => SORT_ASC ] ) -> all ( ) , 'id' , 'name' ) , [ 'id' => $ this -> fieldIds [ 'country' ] , 'prompt' => Yii :: t ( 'jlorente/location' , 'Select country' ) , 'name' => $ this -> getSubmitModelName ( $ this -> model -> getCountryPropertyName ( ) ) ] ) ; }
4092	public function term ( $ term , $ field = false ) { $ this -> term = ( $ field ) ? array ( $ field => $ term ) : $ term ; return $ this ; }
3701	private function convertRenderGroupType ( $ type ) { $ lookup = [ 'char' => GroupAndSortingInformationInterface :: GROUP_CHAR , 'digit' => GroupAndSortingInformationInterface :: GROUP_DIGIT , 'day' => GroupAndSortingInformationInterface :: GROUP_DAY , 'weekday' => GroupAndSortingInformationInterface :: GROUP_WEEKDAY , 'week' => GroupAndSortingInformationInterface :: GROUP_WEEK , 'month' => GroupAndSortingInformationInterface :: GROUP_MONTH , 'year' => GroupAndSortingInformationInterface :: GROUP_YEAR , ] ; if ( array_key_exists ( $ type , $ lookup ) ) { return $ lookup [ $ type ] ; } return GroupAndSortingInformationInterface :: GROUP_NONE ; }
839	public static function fromCode ( $ code ) { $ codeHash = self :: calculateCodeHash ( $ code ) ; if ( self :: hasCache ( $ codeHash ) ) { $ tokens = self :: getCache ( $ codeHash ) ; $ tokens -> generateCode ( ) ; if ( $ codeHash === $ tokens -> codeHash ) { $ tokens -> clearEmptyTokens ( ) ; $ tokens -> clearChanged ( ) ; return $ tokens ; } } $ tokens = new self ( ) ; $ tokens -> setCode ( $ code ) ; $ tokens -> clearChanged ( ) ; return $ tokens ; }
3406	public function loadCommands ( string $ path , string $ namespace = "" , string $ suffix = "Command" ) : Application { $ commands = [ ] ; $ realpath = ( string ) realpath ( $ path ) ; $ finder = ( new Finder ( ) ) -> files ( ) -> in ( $ path ) -> name ( "/[A-Z].*{$suffix}.php/" ) ; foreach ( $ finder as $ file ) { $ filename = ( string ) $ file -> getRealPath ( ) ; require_once $ filename ; $ class = $ filename ; $ class = str_replace ( $ realpath , "" , $ class ) ; $ class = str_replace ( ".php" , "" , $ class ) ; $ class = str_replace ( "/" , "\\" , $ class ) ; $ command = $ class ; if ( substr ( $ command , 0 , 1 ) == "\\" ) { $ command = substr ( $ command , 1 ) ; } $ command = ( string ) preg_replace_callback ( "/^([A-Z])(.*){$suffix}$/" , function ( $ match ) { return strtolower ( $ match [ 1 ] ) . $ match [ 2 ] ; } , $ command ) ; $ command = preg_replace_callback ( "/(\\\\)?([A-Z])/" , function ( $ match ) { $ result = ( $ match [ 1 ] ) ? ":" : "-" ; $ result .= strtolower ( $ match [ 2 ] ) ; return $ result ; } , $ command ) ; $ class = $ namespace . $ class ; $ reflected = new \ ReflectionClass ( $ class ) ; if ( ! $ reflected -> isInstantiable ( ) ) { continue ; } $ commands [ ] = new $ class ( $ command ) ; } if ( count ( $ commands ) < 1 ) { throw new \ InvalidArgumentException ( "No commands were found in the path (" . $ path . ")" ) ; } $ this -> addCommands ( $ commands ) ; return $ this ; }
6695	public static function applyVisible ( & $ Nav ) { if ( $ Nav ) { foreach ( $ Nav as & $ one ) { if ( ! isset ( $ one [ 'visible' ] ) ) { if ( isset ( $ one [ 'permission' ] ) ) { $ authItemModel = Yii :: createObject ( AuthItem :: class ) ; $ one [ 'visible' ] = Yii :: $ app -> user -> can ( $ authItemModel :: SUPER_ADMIN ) || Yii :: $ app -> user -> can ( $ one [ 'permission' ] ) ; } else { if ( is_array ( $ one [ 'url' ] ) ) { $ url = explode ( '/' , trim ( $ one [ 'url' ] [ 0 ] , '/' ) ) ; if ( isset ( $ url [ '0' ] ) && isset ( $ url [ '1' ] ) ) { $ one [ 'visible' ] = Yii :: $ app -> user -> can ( 'Super admin' ) || Yii :: $ app -> user -> can ( $ url [ 0 ] . '/' . $ url [ 1 ] ) ; } } } } if ( isset ( $ one [ 'items' ] ) ) { self :: applyVisible ( $ one [ 'items' ] ) ; } } } }
4396	public function refund ( \ Aimeos \ MShop \ Order \ Item \ Iface $ order ) { $ provider = $ this -> getProvider ( ) ; if ( ! $ provider -> supportsRefund ( ) ) { return ; } $ base = $ this -> getOrderBase ( $ order -> getBaseId ( ) ) ; $ type = \ Aimeos \ MShop \ Order \ Item \ Base \ Service \ Base :: TYPE_PAYMENT ; $ service = $ this -> getBasketService ( $ base , $ type , $ this -> getServiceItem ( ) -> getCode ( ) ) ; $ data = array ( 'transactionReference' => $ this -> getTransactionReference ( $ base ) , 'currency' => $ base -> getPrice ( ) -> getCurrencyId ( ) , 'amount' => $ this -> getAmount ( $ base -> getPrice ( ) ) , 'transactionId' => $ order -> getId ( ) , ) ; $ response = $ provider -> refund ( $ data ) -> send ( ) ; if ( $ response -> isSuccessful ( ) ) { $ attr = array ( 'REFUNDID' => $ response -> getTransactionReference ( ) ) ; $ this -> setAttributes ( $ service , $ attr , 'payment/omnipay' ) ; $ this -> saveOrderBase ( $ base ) ; $ status = \ Aimeos \ MShop \ Order \ Item \ Base :: PAY_REFUND ; $ order -> setPaymentStatus ( $ status ) ; $ this -> saveOrder ( $ order ) ; } }
535	protected function fixDocBlockIndentation ( & $ lines ) { $ docBlock = false ; $ codeBlock = false ; $ listIndent = '' ; $ tag = false ; $ indent = '' ; foreach ( $ lines as $ i => $ line ) { if ( preg_match ( '~^(\s*)/\*\*$~' , $ line , $ matches ) ) { $ docBlock = true ; $ indent = $ matches [ 1 ] ; } elseif ( preg_match ( '~^(\s*)\*+/~' , $ line ) ) { if ( $ docBlock ) { $ lines [ $ i ] = $ indent . ' */' ; } $ docBlock = false ; $ codeBlock = false ; $ listIndent = '' ; $ tag = false ; } elseif ( $ docBlock ) { $ line = ltrim ( $ line ) ; if ( isset ( $ line [ 0 ] ) && $ line [ 0 ] === '*' ) { $ line = substr ( $ line , 1 ) ; } if ( isset ( $ line [ 0 ] ) && $ line [ 0 ] === ' ' ) { $ line = substr ( $ line , 1 ) ; } $ docLine = str_replace ( "\t" , ' ' , rtrim ( $ line ) ) ; if ( empty ( $ docLine ) ) { $ listIndent = '' ; } elseif ( $ docLine [ 0 ] === '@' ) { $ listIndent = '' ; $ codeBlock = false ; $ tag = true ; $ docLine = preg_replace ( '/\s+/' , ' ' , $ docLine ) ; $ docLine = $ this -> fixParamTypes ( $ docLine ) ; } elseif ( preg_match ( '/^(~~~|```)/' , $ docLine ) ) { $ codeBlock = ! $ codeBlock ; $ listIndent = '' ; } elseif ( preg_match ( '/^(\s*)([0-9]+\.|-|\*|\+) /' , $ docLine , $ matches ) ) { $ listIndent = str_repeat ( ' ' , \ strlen ( $ matches [ 0 ] ) ) ; $ tag = false ; $ lines [ $ i ] = $ indent . ' * ' . $ docLine ; continue ; } if ( $ codeBlock ) { $ lines [ $ i ] = rtrim ( $ indent . ' * ' . $ docLine ) ; } else { $ lines [ $ i ] = rtrim ( $ indent . ' * ' . ( empty ( $ listIndent ) && ! $ tag ? $ docLine : ( $ listIndent . ltrim ( $ docLine ) ) ) ) ; } } } }
10443	protected function handleStart ( $ line ) { if ( preg_match ( '/^(INSERT INTO|UPDATE|DELETE FROM)\s+`?(.*?)`?\.`?(.*?)`?$/' , $ line , $ part ) ) { return [ 'type' => $ this -> detectQueryType ( $ part [ 1 ] ) , 'table' => $ part [ 3 ] , ] ; } throw new \ UnexpectedValueException ( "Expected a statement, got {$line}" ) ; }
6394	public function andFinally ( callable $ finallyBlock ) : TryTo { return TryTo :: run ( $ this -> tryBlock , $ this -> exceptions , $ finallyBlock ) ; }
176	public static function removeValue ( & $ array , $ value ) { $ result = [ ] ; if ( is_array ( $ array ) ) { foreach ( $ array as $ key => $ val ) { if ( $ val === $ value ) { $ result [ $ key ] = $ val ; unset ( $ array [ $ key ] ) ; } } } return $ result ; }
10456	protected function setItem ( ItemPipelineEvent $ event ) { $ tempItem = $ event -> getItem ( ) ; if ( ! $ tempItem instanceof $ this -> importItemClass ) { $ this -> log ( "Item provided is not an {$this->importItemClass}" , LogLevel :: ERROR ) ; return false ; } $ this -> importItem = $ tempItem ; return true ; }
5117	public function deleteArticle ( string $ idArticle ) : ? string { $ articleOnRest = $ this -> getArticle ( $ idArticle ) ; if ( ! empty ( $ articleOnRest ) ) { $ articleOnRest = json_decode ( $ articleOnRest , true ) ; if ( isset ( $ articleOnRest [ 'data' ] ) ) { foreach ( Article :: getDeleteableAttachment ( ) as $ field ) { if ( isset ( $ articleOnRest [ 'data' ] [ $ field ] ) ) { foreach ( $ articleOnRest [ 'data' ] [ $ field ] as $ attachment ) { if ( isset ( $ attachment [ $ field . '_order' ] ) ) { $ this -> deleteAttachment ( $ idArticle , $ field , $ attachment [ $ field . '_order' ] ) ; } } } } } return $ this -> delete ( $ this -> getArticleWithIdEndPoint ( $ idArticle ) ) ; } }
12588	protected function createTokenTable ( $ db , $ tableName ) { $ driver = $ db -> getDriverName ( ) ; $ file = dirname ( __DIR__ ) . '/migrations/' . $ this -> tokenTableName . '.' . $ db -> getDriverName ( ) ; $ pdo = $ this -> getDbConnection ( ) -> pdoInstance ; $ sql = file_get_contents ( $ file ) ; $ sql = rtrim ( $ sql ) ; $ sqls = preg_replace_callback ( "/\((.*)\)/" , create_function ( '$matches' , 'return str_replace(";"," $$$ ",$matches[0]);' ) , $ sql ) ; $ sqls = explode ( ";" , $ sqls ) ; foreach ( $ sqls as $ sql ) { if ( ! empty ( $ sql ) ) { $ sql = str_replace ( " $$$ " , ";" , $ sql ) . ";" ; $ pdo -> exec ( $ sql ) ; } } }
12476	public function setCurrentTheme ( $ identifier ) { $ theme = $ this -> getTheme ( $ identifier ) ; $ this -> container -> get ( 'session' ) -> set ( '_admin_theme' , $ theme ) ; }
4196	private function getAbstractionDetails ( Event $ abs ) { $ reflector = $ abs [ 'reflector' ] ; $ abs [ 'phpDoc' ] = $ this -> phpDoc -> getParsed ( $ reflector ) ; $ traversed = false ; if ( $ abs [ 'debugMethod' ] === 'table' && \ count ( $ abs [ 'hist' ] ) < 2 ) { $ obj = $ abs -> getSubject ( ) ; if ( $ obj instanceof \ Traversable && ! $ abs [ 'traverseValues' ] ) { $ traversed = true ; $ abs [ 'hist' ] [ ] = $ obj ; foreach ( $ obj as $ k => $ v ) { $ abs [ 'traverseValues' ] [ $ k ] = $ this -> abstracter -> needsAbstraction ( $ v ) ? $ this -> abstracter -> getAbstraction ( $ v , $ abs [ 'debugMethod' ] , $ abs [ 'hist' ] ) : $ v ; } } } if ( ! $ traversed ) { $ this -> addConstants ( $ abs ) ; while ( $ reflector = $ reflector -> getParentClass ( ) ) { $ abs [ 'extends' ] [ ] = $ reflector -> getName ( ) ; } $ this -> addProperties ( $ abs ) ; $ this -> addMethods ( $ abs ) ; } }
12379	public function handle ( ) : void { $ help = " -----------------------------------------------------------------\n" ; $ help .= " | Command Line Interface\n" ; $ help .= " | See more in https://github.com/senhungwong/command-line-interface\n" ; $ help .= " -------------------------------------------------------------------\n" ; $ commands = CommandEntry :: getCommands ( ) ; if ( $ command = $ this -> getArgument ( 'function-name' ) ) { $ command = new $ commands [ $ command ] ; $ help .= " - " . $ command -> getCommand ( ) . ": " ; $ help .= $ command -> getDescription ( ) . "\n" ; } else { foreach ( $ commands as $ command ) { $ command = new $ command ; $ help .= " - " ; $ help .= $ command -> getCommand ( ) . ": " ; $ help .= $ command -> getDescription ( ) . "\n" ; } } echo $ help ; }
7	private function parseVersion ( $ version ) { if ( preg_match ( '{^v?(\d{1,3})(\.\d+)?(\.\d+)?(\.\d+)?}i' , $ version , $ matches ) ) { $ version = $ matches [ 1 ] . ( ! empty ( $ matches [ 2 ] ) ? $ matches [ 2 ] : '.0' ) . ( ! empty ( $ matches [ 3 ] ) ? $ matches [ 3 ] : '.0' ) . ( ! empty ( $ matches [ 4 ] ) ? $ matches [ 4 ] : '.0' ) ; return $ version ; } return null ; }
7570	public function getApplicationApiService ( ) { $ applicationService = new \ Greenhouse \ GreenhouseToolsPhp \ Services \ ApplicationService ( $ this -> _apiKey , $ this -> _boardToken ) ; $ apiClient = new GuzzleClient ( array ( 'base_uri' => ApiService :: APPLICATION_URL ) ) ; $ applicationService -> setClient ( $ apiClient ) ; return $ applicationService ; }
5010	public function getPermissions ( ) { if ( ! $ this -> permissions ) { $ type = property_exists ( $ this , 'permissionsType' ) ? $ this -> permissionsType : str_replace ( '\\Entity\\' , '/' , static :: class ) ; $ permissions = new Permissions ( $ type ) ; if ( method_exists ( $ this , 'setupPermissions' ) ) { $ this -> setupPermissions ( $ permissions ) ; } $ this -> setPermissions ( $ permissions ) ; } return $ this -> permissions ; }
2672	public function upsertDictionaryItem ( $ dictionaryId , $ itemKey , $ itemValue ) { $ body = [ 'item_value' => $ itemValue ] ; $ url = $ this -> _getApiServiceUri ( ) . 'dictionary/' . $ dictionaryId . '/item/' . urlencode ( $ itemKey ) ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: PUT , $ body ) ; if ( ! $ result ) { throw new LocalizedException ( __ ( 'Failed to create Dictionary item.' ) ) ; } }
8929	public function stack ( $ icons ) { if ( count ( $ icons ) !== 2 ) { throw new \ InvalidArgumentException ( 'Expecting exactly 2 icons in the stack' ) ; } $ contents = [ ] ; $ index = 2 ; foreach ( $ icons as $ key => $ value ) { $ contents [ ] = $ this -> getStackIconElement ( $ key , $ value , $ index ) ; -- $ index ; } return $ this -> html -> span ( $ contents ) -> addClass ( 'fa-stack' ) ; }
10577	private static function get ( $ style , $ setting , $ defaultValue = '' ) { if ( isset ( self :: $ styles [ $ style ] ) ) { $ style = self :: $ styles [ $ style ] ; if ( isset ( $ style [ $ setting ] ) ) { return $ style [ $ setting ] ; } } return $ defaultValue ; }
2300	public static function getSystemMessages ( ) { $ strMessages = '' ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getSystemMessages' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getSystemMessages' ] ) ) { $ arrMessages = array ( ) ; foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getSystemMessages' ] as $ callback ) { $ strBuffer = System :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( ) ; if ( $ strBuffer != '' ) { $ arrMessages [ ] = $ strBuffer ; } } if ( ! empty ( $ arrMessages ) ) { $ strMessages .= implode ( "\n" , $ arrMessages ) ; } } return $ strMessages ; }
7043	public function handleSrcTableNames ( GetPropertyOptionsEvent $ event ) { if ( ( $ event -> getPropertyName ( ) !== 'tag_srctable' ) || ( $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getName ( ) !== 'tl_metamodel_attribute' ) ) { return ; } $ sqlTable = $ this -> translator -> trans ( 'tl_metamodel_attribute.tag_table_type.sql-table' , [ ] , 'contao_tl_metamodel_attribute' ) ; $ translated = $ this -> translator -> trans ( 'tl_metamodel_attribute.tag_table_type.translated' , [ ] , 'contao_tl_metamodel_attribute' ) ; $ untranslated = $ this -> translator -> trans ( 'tl_metamodel_attribute.tag_table_type.untranslated' , [ ] , 'contao_tl_metamodel_attribute' ) ; $ result = $ this -> getMetaModelTableNames ( $ translated , $ untranslated ) ; foreach ( $ this -> connection -> getSchemaManager ( ) -> listTableNames ( ) as $ table ) { if ( 0 !== \ strpos ( $ table , 'mm_' ) ) { $ result [ $ sqlTable ] [ $ table ] = $ table ; } } if ( \ is_array ( $ result [ $ translated ] ) ) { \ asort ( $ result [ $ translated ] ) ; } if ( \ is_array ( $ result [ $ untranslated ] ) ) { \ asort ( $ result [ $ untranslated ] ) ; } if ( \ is_array ( $ result [ $ sqlTable ] ) ) { \ asort ( $ result [ $ sqlTable ] ) ; } $ event -> setOptions ( $ result ) ; }
633	public function delete ( $ table , $ condition = '' , $ params = [ ] ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> delete ( $ table , $ condition , $ params ) ; return $ this -> setSql ( $ sql ) -> bindValues ( $ params ) ; }
9030	public function exception ( Request $ request ) { $ ex = $ request -> getException ( ) ; $ this -> response -> setCode ( 500 ) ; printf ( "<h2>%s</h2>" , HttpStatus :: getStatus ( 500 ) ) ; while ( $ ex != null ) { printf ( "<h3>%s</h3><pre>%s</pre>" , $ ex -> getMessage ( ) , $ ex -> getTraceAsString ( ) ) ; $ ex = $ ex -> getPrevious ( ) ; } }
4006	protected function createInstance ( CreateMetaModelEvent $ event , $ arrData ) { if ( ! $ this -> createInstanceViaLegacyFactory ( $ event , $ arrData ) ) { $ metaModel = new MetaModel ( $ arrData , $ this -> dispatcher , $ this -> database ) ; $ metaModel -> setServiceContainer ( function ( ) { return $ this -> getServiceContainer ( ) ; } , false ) ; $ event -> setMetaModel ( $ metaModel ) ; } if ( $ event -> getMetaModel ( ) ) { $ this -> instancesByTable [ $ event -> getMetaModelName ( ) ] = $ event -> getMetaModel ( ) ; $ this -> instancesById [ $ event -> getMetaModel ( ) -> get ( 'id' ) ] = $ event -> getMetaModel ( ) ; } }
10846	protected function restoreWordCase ( $ token ) { if ( $ token === strtoupper ( $ token ) ) { return function ( $ word ) { return strtoupper ( $ word ) ; } ; } if ( $ token === ucfirst ( $ token ) ) { return function ( $ word ) { return ucfirst ( $ word ) ; } ; } return function ( $ word ) { return $ word ; } ; }
5998	public function setMax ( $ max ) { if ( $ max instanceof DateTime ) { $ this -> max = $ max ; } else { try { $ this -> max = new DateTime ( $ max ) ; } catch ( \ Exception $ e ) { $ this -> max = null ; } } return $ this ; }
1009	public static function defaultFieldResolver ( $ source , $ args , $ context , ResolveInfo $ info ) { $ fieldName = $ info -> fieldName ; $ property = null ; if ( is_array ( $ source ) || $ source instanceof ArrayAccess ) { if ( isset ( $ source [ $ fieldName ] ) ) { $ property = $ source [ $ fieldName ] ; } } elseif ( is_object ( $ source ) ) { if ( isset ( $ source -> { $ fieldName } ) ) { $ property = $ source -> { $ fieldName } ; } } return $ property instanceof Closure ? $ property ( $ source , $ args , $ context , $ info ) : $ property ; }
10778	private function create_image ( ) { $ total = $ this -> total_size ( ) ; $ sprite = imagecreatetruecolor ( $ total [ "width" ] , $ total [ "height" ] ) ; imagesavealpha ( $ sprite , true ) ; $ transparent = imagecolorallocatealpha ( $ sprite , 0 , 0 , 0 , 127 ) ; imagefill ( $ sprite , 0 , 0 , $ transparent ) ; $ top = 0 ; foreach ( $ this -> images as $ image ) { $ func = "imagecreatefrom" . $ image [ 'type' ] ; $ img = $ func ( $ image [ "path" ] ) ; imagecopy ( $ sprite , $ img , ( $ total [ "width" ] - $ image [ "width" ] ) , $ top , 0 , 0 , $ image [ "width" ] , $ image [ "height" ] ) ; $ top += $ image [ "height" ] ; } return $ sprite ; }
4178	public function getFiles ( ) { return $ this -> files ? : $ this -> files = Finder :: create ( ) -> in ( realpath ( $ this -> directory ) ) ; }
848	public function getNonWhitespaceSibling ( $ index , $ direction , $ whitespaces = null ) { while ( true ) { $ index += $ direction ; if ( ! $ this -> offsetExists ( $ index ) ) { return null ; } $ token = $ this [ $ index ] ; if ( ! $ token -> isWhitespace ( $ whitespaces ) ) { return $ index ; } } }
11532	public static function cascade ( array $ folders ) { $ result = null ; foreach ( $ folders as $ folder ) { if ( is_dir ( $ folder ) ) { $ result = $ folder ; break ; } } return $ result ; }
1031	public function completeValueWithLocatedError ( Type $ returnType , $ fieldNodes , ResolveInfo $ info , $ path , $ result ) { try { $ completed = $ this -> completeValue ( $ returnType , $ fieldNodes , $ info , $ path , $ result ) ; $ promise = $ this -> getPromise ( $ completed ) ; if ( $ promise ) { return $ promise -> then ( null , function ( $ error ) use ( $ fieldNodes , $ path ) { return $ this -> exeContext -> promises -> createRejected ( Error :: createLocatedError ( $ error , $ fieldNodes , $ path ) ) ; } ) ; } return $ completed ; } catch ( Exception $ error ) { throw Error :: createLocatedError ( $ error , $ fieldNodes , $ path ) ; } catch ( Throwable $ error ) { throw Error :: createLocatedError ( $ error , $ fieldNodes , $ path ) ; } }
10467	public static function createSimpleAnonymousRecipient ( $ emailAddress , $ countryCode ) { return ( new Recipient ( ) ) -> setHash ( self :: getEmailAddressHash ( $ emailAddress ) ) -> setCountry ( $ countryCode ) -> setProvider ( self :: getDomainFromEmail ( $ emailAddress ) ) ; }
11777	public function appendChoice ( FormEvent $ event ) { $ rootForm = $ this -> getRootForm ( $ event -> getForm ( ) ) ; $ group = $ rootForm -> getData ( ) ; if ( $ group === NULL ) { return ; } $ choices = array ( ) ; foreach ( $ group -> getCustomFields ( ) as $ customFields ) { $ choices [ $ customFields -> getSlug ( ) ] = $ this -> translatableStringHelper -> localize ( $ customFields -> getName ( ) ) ; } $ options = array_merge ( $ this -> options , array ( 'choice_list' => new SimpleChoiceList ( $ choices ) , ) ) ; $ event -> getForm ( ) -> getParent ( ) -> add ( $ this -> choiceName , 'choice' , $ options ) ; }
5562	protected function parse ( $ response , $ depth = 0 ) { $ page = $ this -> buildPage ( $ response ) ; if ( $ this -> ignore_frames || ! $ page -> hasFrames ( ) || ( $ depth > $ this -> maximum_nested_frames ) ) { return $ page ; } $ frameset = new SimpleFrameset ( $ page ) ; foreach ( $ page -> getFrameset ( ) as $ key => $ url ) { $ frame = $ this -> fetch ( $ url , new SimpleGetEncoding ( ) , $ depth + 1 ) ; $ frameset -> addFrame ( $ frame , $ key ) ; } return $ frameset ; }
2946	public function setRolesById ( $ roles ) { $ roles = is_array ( $ roles ) ? $ roles : [ $ roles ] ; return $ this -> roles ( ) -> sync ( $ roles ) ; }
1664	protected function getCountries ( ) { if ( sizeof ( $ this -> countries ) == 0 ) { $ this -> countries = json_decode ( file_get_contents ( __DIR__ . '/Models/countries.json' ) , true ) ; } return $ this -> countries ; }
2844	public function renderTreeNode ( Varien_Data_Tree_Node $ node , $ indentLevel = 0 ) { $ block = $ this -> getLayout ( ) -> createBlock ( 'sheep_debug/view' ) ; $ block -> setRequestInfo ( $ this -> getRequestInfo ( ) ) ; $ block -> setTemplate ( 'sheep_debug/view/panel/_block_node.phtml' ) ; $ block -> setNode ( $ node ) ; $ block -> setIndent ( $ indentLevel ) ; return $ block -> toHtml ( ) ; }
4921	public function region ( $ region , $ reset = false ) { $ this -> currentRegion = $ region ; if ( $ reset ) { $ this -> matrix [ $ this -> currentRegion ] = [ ] ; } return $ this ; }
1026	private function doesFragmentConditionMatch ( $ fragment , ObjectType $ type ) { $ typeConditionNode = $ fragment -> typeCondition ; if ( $ typeConditionNode === null ) { return true ; } $ conditionalType = TypeInfo :: typeFromAST ( $ this -> exeContext -> schema , $ typeConditionNode ) ; if ( $ conditionalType === $ type ) { return true ; } if ( $ conditionalType instanceof AbstractType ) { return $ this -> exeContext -> schema -> isPossibleType ( $ conditionalType , $ type ) ; } return false ; }
9576	protected function resolveKernel ( ) { if ( $ this -> kernel !== null ) { return $ this -> kernel ; } $ class = 'Symfony\Component\EventDispatcher\EventDispatcherInterface' ; $ eventDispatcher = $ this -> container -> isBound ( $ class ) ? $ this -> container -> resolve ( $ class ) : null ; $ kernel = new Kernel ( $ this -> getRouter ( ) , $ this -> requests , $ this -> errorHandler , $ eventDispatcher ) ; return $ this -> kernel = $ this -> resolveStack ( ) -> resolve ( $ kernel ) ; }
1132	public function insideSubtree ( $ node ) { return ( $ this -> getLeft ( ) >= $ node -> getLeft ( ) && $ this -> getLeft ( ) <= $ node -> getRight ( ) && $ this -> getRight ( ) >= $ node -> getLeft ( ) && $ this -> getRight ( ) <= $ node -> getRight ( ) ) ; }
1548	private function registerProcesses ( ) : void { $ this -> routeForProcess ( 'get' , $ this -> baseProcessUrl ( ) , $ this -> actionForRoute ( 'processes' ) ) ; $ this -> routeForProcess ( 'get' , $ this -> processUrl ( ) , $ this -> actionForRoute ( 'process' ) ) ; }
5079	public function postRemap ( ) { $ oUri = Factory :: service ( 'Uri' ) ; $ sMethod = 'post' . ucfirst ( $ oUri -> segment ( 4 ) ) ; if ( method_exists ( $ this , $ sMethod ) ) { return $ this -> $ sMethod ( ) ; } $ oInput = Factory :: service ( 'Input' ) ; $ oHttpCodes = Factory :: service ( 'HttpCodes' ) ; $ oItemModel = Factory :: model ( static :: CONFIG_MODEL_NAME , static :: CONFIG_MODEL_PROVIDER ) ; $ aFields = $ oItemModel -> describeFields ( ) ; $ aValid = [ ] ; $ aInvalid = [ ] ; foreach ( $ aFields as $ oField ) { if ( in_array ( $ oField -> key , static :: CONFIG_POST_IGNORE_FIELDS ) ) { continue ; } $ aValid [ ] = $ oField -> key ; } $ aPost = $ oInput -> post ( ) ; foreach ( $ aPost as $ sKey => $ sValue ) { if ( ! in_array ( $ sKey , $ aValid ) ) { $ aInvalid [ ] = $ sKey ; } } if ( ! empty ( $ aInvalid ) ) { throw new ApiException ( 'The following arguments are invalid: ' . implode ( ', ' , $ aInvalid ) , $ oHttpCodes :: STATUS_BAD_REQUEST ) ; } $ iItemId = ( int ) $ oUri -> segment ( 4 ) ; if ( $ iItemId ) { $ oItem = $ oItemModel -> getById ( $ iItemId ) ; if ( empty ( $ oItem ) ) { throw new ApiException ( 'Item does not exist' , $ oHttpCodes :: STATUS_NOT_FOUND ) ; } elseif ( ! $ oItemModel -> update ( $ iItemId , $ aPost ) ) { throw new ApiException ( 'Failed to update item. ' . $ oItemModel -> lastError ( ) , $ oHttpCodes :: STATUS_INTERNAL_SERVER_ERROR ) ; } elseif ( classUses ( $ oItemModel , 'Nails\Common\Traits\Caching' ) ) { $ oItemModel -> disableCache ( ) ; } $ oItem = $ oItemModel -> getById ( $ iItemId ) ; if ( classUses ( $ oItemModel , 'Nails\Common\Traits\Caching' ) ) { $ oItemModel -> enableCache ( ) ; } } else { $ oItem = $ oItemModel -> create ( $ aPost , true ) ; } $ oResponse = Factory :: factory ( 'ApiResponse' , 'nails/module-api' ) ; $ oResponse -> setData ( $ this -> formatObject ( $ oItem ) ) ; return $ oResponse ; }
3508	private static function doCharDiff ( $ from_text , $ to_text ) { $ result = array ( ) ; $ jobs = array ( array ( 0 , strlen ( $ from_text ) , 0 , strlen ( $ to_text ) ) ) ; while ( $ job = array_pop ( $ jobs ) ) { list ( $ from_segment_start , $ from_segment_end , $ to_segment_start , $ to_segment_end ) = $ job ; $ from_segment_len = $ from_segment_end - $ from_segment_start ; $ to_segment_len = $ to_segment_end - $ to_segment_start ; if ( ! $ from_segment_len || ! $ to_segment_len ) { if ( $ from_segment_len ) { $ result [ $ from_segment_start * 4 + 0 ] = new FineDiffDeleteOp ( $ from_segment_len ) ; } else if ( $ to_segment_len ) { $ result [ $ from_segment_start * 4 + 1 ] = new FineDiffInsertOp ( substr ( $ to_text , $ to_segment_start , $ to_segment_len ) ) ; } continue ; } if ( $ from_segment_len >= $ to_segment_len ) { $ copy_len = $ to_segment_len ; while ( $ copy_len ) { $ to_copy_start = $ to_segment_start ; $ to_copy_start_max = $ to_segment_end - $ copy_len ; while ( $ to_copy_start <= $ to_copy_start_max ) { $ from_copy_start = strpos ( substr ( $ from_text , $ from_segment_start , $ from_segment_len ) , substr ( $ to_text , $ to_copy_start , $ copy_len ) ) ; if ( $ from_copy_start !== false ) { $ from_copy_start += $ from_segment_start ; break 2 ; } $ to_copy_start ++ ; } $ copy_len -- ; } } else { $ copy_len = $ from_segment_len ; while ( $ copy_len ) { $ from_copy_start = $ from_segment_start ; $ from_copy_start_max = $ from_segment_end - $ copy_len ; while ( $ from_copy_start <= $ from_copy_start_max ) { $ to_copy_start = strpos ( substr ( $ to_text , $ to_segment_start , $ to_segment_len ) , substr ( $ from_text , $ from_copy_start , $ copy_len ) ) ; if ( $ to_copy_start !== false ) { $ to_copy_start += $ to_segment_start ; break 2 ; } $ from_copy_start ++ ; } $ copy_len -- ; } } if ( $ copy_len ) { $ jobs [ ] = array ( $ from_segment_start , $ from_copy_start , $ to_segment_start , $ to_copy_start ) ; $ result [ $ from_copy_start * 4 + 2 ] = new FineDiffCopyOp ( $ copy_len ) ; $ jobs [ ] = array ( $ from_copy_start + $ copy_len , $ from_segment_end , $ to_copy_start + $ copy_len , $ to_segment_end ) ; } else { $ result [ $ from_segment_start * 4 ] = new FineDiffReplaceOp ( $ from_segment_len , substr ( $ to_text , $ to_segment_start , $ to_segment_len ) ) ; } } ksort ( $ result , SORT_NUMERIC ) ; return array_values ( $ result ) ; }
8103	private function buildQuery ( $ sql , $ arguments = null ) { if ( is_array ( $ arguments ) ) { $ finalArgs = array ( ) ; foreach ( $ arguments as $ field => $ val ) { $ finalArgs [ ] = " {$field}=:{$field}" ; } $ finalArgs = implode ( ' AND' , $ finalArgs ) ; if ( strpos ( $ sql , ' _arguments_' ) ) { $ sql = str_replace ( ' _arguments_' , $ finalArgs , $ sql ) ; } else { } } $ sql = str_replace ( ' _table_' , " {$this->tableName} " , $ sql ) ; return $ sql ; }
9755	function a ( string $ type = '' ) : self { return mb_strlen ( $ type ) ? $ this -> expect ( $ this -> target , isType ( $ type ) ) : $ this ; }
4971	public static function convert ( ContentItemInterface $ from , ContentItemInterface $ to ) { $ reflectionFrom = new \ ReflectionClass ( $ from ) ; $ reflectionTo = new \ ReflectionClass ( $ to ) ; foreach ( $ reflectionFrom -> getProperties ( ) as $ property ) { $ property -> setAccessible ( true ) ; $ method = 'set' . ucfirst ( $ property -> getName ( ) ) ; if ( $ reflectionTo -> hasMethod ( $ method ) ) { $ to -> $ method ( $ property -> getValue ( $ from ) ) ; } } return $ to ; }
12596	protected function doWeNeedToMinify ( SplFileInfo $ file ) : bool { return ( ! $ this -> debug && ! Str :: s ( $ file -> getFilename ( ) ) -> contains ( '.min.' ) ) ; }
1829	public function delete ( ) { $ intPk = $ this -> { static :: $ strPk } ; if ( isset ( $ this -> arrModified [ static :: $ strPk ] ) ) { $ intPk = $ this -> arrModified [ static :: $ strPk ] ; } $ intAffected = Database :: getInstance ( ) -> prepare ( "DELETE FROM " . static :: $ strTable . " WHERE " . Database :: quoteIdentifier ( static :: $ strPk ) . "=?" ) -> execute ( $ intPk ) -> affectedRows ; if ( $ intAffected ) { Registry :: getInstance ( ) -> unregister ( $ this ) ; $ this -> arrData [ static :: $ strPk ] = null ; } return $ intAffected ; }
928	public function delete ( $ path ) { if ( isset ( $ this -> files [ $ path ] ) ) { unset ( $ this -> files [ $ path ] ) ; } $ this -> unlink ( $ path ) ; }
8242	protected function handleLogin ( Request $ httpRequest ) { $ post = $ httpRequest -> request ; if ( ! $ post -> has ( "username" ) || ! $ post -> has ( "password" ) ) { return ; } if ( ! $ this -> picoAuth -> isValidCSRF ( $ post -> get ( "csrf_token" ) , self :: LOGIN_CSRF_ACTION ) ) { $ this -> picoAuth -> redirectToLogin ( null , $ httpRequest ) ; return ; } $ username = strtolower ( trim ( $ post -> get ( "username" ) ) ) ; $ password = new Password ( $ post -> get ( "password" ) ) ; if ( ! $ this -> limit -> action ( "login" , false , array ( "name" => $ username ) ) ) { $ this -> session -> addFlash ( "error" , $ this -> limit -> getError ( ) ) ; $ this -> picoAuth -> redirectToLogin ( null , $ httpRequest ) ; return ; } if ( ! $ this -> loginAttempt ( $ username , $ password ) ) { $ this -> logInvalidLoginAttempt ( $ username ) ; $ this -> limit -> action ( "login" , true , array ( "name" => $ username ) ) ; $ this -> session -> addFlash ( "error" , "Invalid username or password" ) ; $ this -> picoAuth -> redirectToLogin ( null , $ httpRequest ) ; return ; } else { $ userData = $ this -> storage -> getUserByName ( $ username ) ; if ( $ this -> needsPasswordRehash ( $ userData ) ) { $ this -> passwordRehash ( $ username , $ password ) ; } $ this -> login ( $ username , $ userData ) ; $ this -> picoAuth -> afterLogin ( ) ; } }
11159	protected function getApiRequest ( $ url , Event $ event , Queue $ queue ) { $ self = $ this ; $ request = new HttpRequest ( array ( 'url' => $ url , 'resolveCallback' => function ( $ data ) use ( $ self , $ url , $ event , $ queue ) { $ self -> resolve ( $ url , $ data , $ event , $ queue ) ; } , 'rejectCallback' => function ( $ error ) use ( $ self , $ url ) { $ self -> reject ( $ url , $ error ) ; } ) ) ; return $ request ; }
9778	function writable ( ) : self { if ( ! $ this -> hasFlag ( 'directory' ) && ! $ this -> hasFlag ( 'file' ) ) throw new \ BadMethodCallException ( 'This assertion is not a file or directory one.' ) ; return $ this -> expect ( $ this -> target , isWritable ( ) ) ; }
3997	protected function getItem ( $ metaModelIdOrName , $ mixDataId , $ intIdRenderSetting , $ strOutput = null ) { $ objMetaModel = $ this -> loadMetaModel ( $ metaModelIdOrName ) ; if ( $ objMetaModel == null ) { return false ; } if ( empty ( $ strOutput ) ) { $ strOutput = 'html5' ; } $ objMetaModelList = new ItemList ( ) ; $ objMetaModelList -> setServiceContainer ( $ this -> getServiceContainer ( ) ) -> setMetaModel ( $ objMetaModel -> get ( 'id' ) , $ intIdRenderSetting ) -> overrideOutputFormat ( $ strOutput ) ; $ arrIds = StringUtil :: trimsplit ( ',' , $ mixDataId ) ; foreach ( $ arrIds as $ intKey => $ intId ) { if ( ! $ this -> isPublishedItem ( $ objMetaModel , $ intId ) ) { unset ( $ arrIds [ $ intKey ] ) ; } } if ( count ( $ arrIds ) < 1 ) { return '' ; } $ objMetaModelList -> addFilterRule ( new StaticIdList ( $ arrIds ) ) ; return $ objMetaModelList -> render ( false , $ this ) ; }
7907	protected function getLabel ( $ item ) { $ encodeLabel = isset ( $ item [ 'encode' ] ) ? $ item [ 'encode' ] : $ this -> encodeLabels ; return $ encodeLabel ? Html :: encode ( $ item [ 'label' ] ) : $ item [ 'label' ] ; }
1118	public static function allLeaves ( ) { $ instance = new static ; $ grammar = $ instance -> getConnection ( ) -> getQueryGrammar ( ) ; $ rgtCol = $ grammar -> wrap ( $ instance -> getQualifiedRightColumnName ( ) ) ; $ lftCol = $ grammar -> wrap ( $ instance -> getQualifiedLeftColumnName ( ) ) ; return $ instance -> newQuery ( ) -> whereRaw ( $ rgtCol . ' - ' . $ lftCol . ' = 1' ) -> orderBy ( $ instance -> getQualifiedOrderColumnName ( ) ) ; }
8069	public function bind ( $ username , $ password ) { if ( $ this -> tls ) { if ( ! ldap_start_tls ( $ this -> connection ) ) { throw new ConnectionException ( 'Unable to Connect to LDAP using TLS.' ) ; } } try { $ this -> bound = ldap_bind ( $ this -> connection , $ username , $ password ) ; } catch ( ErrorException $ e ) { $ this -> bound = false ; } return $ this -> bound ; }
1325	public static function fromConsumerAndToken ( Consumer $ consumer , Token $ token = null , $ httpMethod , $ httpUrl , array $ parameters = [ ] , $ json = false ) { $ defaults = [ "oauth_version" => Request :: $ version , "oauth_nonce" => Request :: generateNonce ( ) , "oauth_timestamp" => time ( ) , "oauth_consumer_key" => $ consumer -> key ] ; if ( null !== $ token ) { $ defaults [ 'oauth_token' ] = $ token -> key ; } if ( $ json ) { $ parameters = $ defaults ; } else { $ parameters = array_merge ( $ defaults , $ parameters ) ; } return new Request ( $ httpMethod , $ httpUrl , $ parameters ) ; }
5683	public function getUrls ( ) { $ all = array ( ) ; foreach ( $ this -> links as $ link ) { $ url = $ this -> getUrlFromLink ( $ link ) ; $ all [ ] = $ url -> asString ( ) ; } return $ all ; }
6318	public function query ( $ sql ) { $ rows = array ( ) ; foreach ( $ this -> getConnection ( ) -> query ( $ sql ) as $ row ) { $ rows [ ] = $ row ; } return $ rows ; }
5086	public function startTransaction ( ) : bool { if ( $ this -> isInTransaction ) throw new AlreadyInTransactionException ( ) ; $ this -> isInTransaction = $ this -> executeDirect ( 'START TRANSACTION' ) ; return $ this -> isInTransaction ; }
3934	private function setExcluded ( PropertyInterface $ property , $ propInfo ) { if ( ! isset ( $ propInfo [ 'exclude' ] ) ) { return ; } $ property -> setExcluded ( ( bool ) $ propInfo [ 'exclude' ] ) ; }
7091	protected function match ( Request $ request ) { foreach ( $ this -> routes as $ route ) { if ( $ route -> method ( ) === $ request -> method ( ) && $ route -> match ( $ request -> url ( ) ) ) { if ( $ action = $ route -> action ( ) ) { try { $ response = $ action ( $ request , $ route -> args ( ) ) ; if ( $ response !== false ) return $ response ; } catch ( AbortRouteException $ abort ) { return $ abort -> response ( ) ; } } else return null ; } } return false ; }
6617	protected function mapRequestToArguments ( \ ReflectionMethod $ method , Request $ request ) { $ map = [ ] ; foreach ( $ method -> getParameters ( ) as $ parameter ) { $ value = $ request -> getParameter ( $ parameter -> getName ( ) , $ parameter -> isDefaultValueAvailable ( ) ? $ parameter -> getDefaultValue ( ) : null ) ; if ( $ parameter -> getClass ( ) && $ parameter -> getClass ( ) -> implementsInterface ( Deserializable :: class ) ) { $ value = $ parameter -> getClass ( ) -> newInstanceWithoutConstructor ( ) -> ayeAyeDeserialize ( $ value ) ; $ className = $ parameter -> getClass ( ) -> getName ( ) ; if ( ! is_object ( $ value ) || get_class ( $ value ) !== $ className ) { throw new \ RuntimeException ( "$className::ayeAyeDeserialize did not return an instance of itself" ) ; } } $ map [ $ parameter -> getName ( ) ] = $ value ; } return $ map ; }
8401	public function render ( RenderInterface $ render , $ status = 200 ) { $ this -> renderInst = $ render ; $ this -> status = $ status ; }
9112	public function setVisitTime ( $ visitTime ) { if ( $ visitTime instanceof \ DateTime ) { $ this -> visitTime = $ visitTime ; } else { $ this -> visitTime = new \ DateTime ( $ visitTime ) ; } return $ this ; }
7467	public function addColor ( $ color , $ code = null ) { $ newColors = $ this -> parseColor ( $ color , $ code ) ; $ this -> colors = array_merge ( $ this -> colors , $ newColors ) ; return $ this ; }
8725	public function translationModel ( ) { $ translation = new TranslationModel ( ) ; $ translation -> setConnection ( $ this -> getI18nConnection ( ) ) ; $ translation -> setTable ( $ this -> getI18nTable ( ) ) ; $ translation -> setKeyName ( $ this -> getForeignKey ( ) ) ; $ translation -> setLocaleKey ( $ this -> getLocaleKey ( ) ) ; if ( $ attributes = $ this -> translatableAttributes ( ) ) { $ translation -> fillable ( array_intersect ( $ attributes , $ this -> getFillable ( ) ) ) ; } return $ translation ; }
3118	public function removeCatValue ( $ testSessionId , $ assessmentSectionId , $ key ) { $ extendedState = $ this -> getExtendedState ( $ testSessionId ) ; $ extendedState -> removeCatValue ( $ assessmentSectionId , $ key ) ; $ extendedState -> save ( ) ; }
10979	public function postPersist ( LifecycleEventArgs $ args ) : void { if ( ! $ this -> enableIndexing ) { return ; } $ this -> updateEntity ( $ args -> getObject ( ) , $ args -> getObjectManager ( ) ) ; }
2322	public static function getPixelValue ( $ size ) { @ trigger_error ( 'Using Image::getPixelValue() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ value = preg_replace ( '/[^0-9.-]+/' , '' , $ size ) ; $ unit = preg_replace ( '/[^acehimnprtvwx%]/' , '' , $ size ) ; switch ( $ unit ) { case '' : case 'px' : return ( int ) round ( $ value ) ; break ; case 'em' : return ( int ) round ( $ value * 16 ) ; break ; case 'ex' : return ( int ) round ( $ value * 16 / 2 ) ; break ; case 'pt' : return ( int ) round ( $ value * 16 / 12 ) ; break ; case 'pc' : return ( int ) round ( $ value * 16 ) ; break ; case 'in' : return ( int ) round ( $ value * 16 * 6 ) ; break ; case 'cm' : return ( int ) round ( $ value * 16 / ( 2.54 / 6 ) ) ; break ; case 'mm' : return ( int ) round ( $ value * 16 / ( 25.4 / 6 ) ) ; break ; case '%' : return ( int ) round ( $ value * 16 / 100 ) ; break ; } return 0 ; }
10070	public function make ( $ tag , $ props = null , $ content = null ) { $ tag = parent :: make ( $ tag , $ props , $ content ) ; $ tag = $ this -> decorators -> apply ( $ tag , $ this ) ; return $ tag ; }
207	public static function confirm ( $ message , $ default = false ) { while ( true ) { static :: stdout ( $ message . ' (yes|no) [' . ( $ default ? 'yes' : 'no' ) . ']:' ) ; $ input = trim ( static :: stdin ( ) ) ; if ( empty ( $ input ) ) { return $ default ; } if ( ! strcasecmp ( $ input , 'y' ) || ! strcasecmp ( $ input , 'yes' ) ) { return true ; } if ( ! strcasecmp ( $ input , 'n' ) || ! strcasecmp ( $ input , 'no' ) ) { return false ; } } }
4117	public function isWithinCachedBlock ( Mage_Core_Block_Abstract $ block ) { $ step = $ block ; $ i = 0 ; while ( $ i ++ < 20 && $ step instanceof Mage_Core_Block_Abstract ) { if ( ! is_null ( $ step -> getCacheLifetime ( ) ) ) { return true ; } $ step = $ step -> getParentBlock ( ) ; } return false ; }
10218	private static function cleanComplex ( $ complexNumber ) { if ( $ complexNumber [ 0 ] == '+' ) { $ complexNumber = substr ( $ complexNumber , 1 ) ; } if ( $ complexNumber [ 0 ] == '0' ) { $ complexNumber = substr ( $ complexNumber , 1 ) ; } if ( $ complexNumber [ 0 ] == '.' ) { $ complexNumber = '0' . $ complexNumber ; } if ( $ complexNumber [ 0 ] == '+' ) { $ complexNumber = substr ( $ complexNumber , 1 ) ; } return $ complexNumber ; }
12950	public function beforeDelete ( ) { $ this -> _tagsForDelete = [ ] ; $ relation = $ this -> owner -> getRelation ( 'tagsList' , false ) ; if ( $ relation instanceof ActiveQuery ) { $ this -> _tagsForDelete = ( new Query ( ) ) -> select ( current ( $ relation -> link ) ) -> from ( $ relation -> via -> from [ 0 ] ) -> where ( [ key ( $ relation -> via -> link ) => $ this -> owner -> getPrimaryKey ( ) ] ) -> column ( $ this -> owner -> getDb ( ) ) ; } }
7412	protected function customChmod ( string $ target , $ mode = 0666 ) { if ( false === @ chmod ( $ target , $ mode & ~ umask ( ) ) ) { throw new FileException ( sprintf ( 'Unable to change mode of the "%s"' , $ target ) ) ; } }
11412	public function batchTagUsers ( array $ openIds , $ tagId ) { $ params = [ 'openid_list' => $ openIds , 'tagid' => $ tagId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_MEMBER_BATCH_TAG , $ params ] ) ; }
5731	public function getLeagues ( array $ filter = [ 'areas' => '' ] ) { $ leagues = $ this -> run ( "v2/competitions" . "?" . http_build_query ( $ filter ) ) ; return collect ( $ leagues -> competitions ) ; }
11965	public static function hash ( $ password ) { return \ Yii :: $ app -> security -> generatePasswordHash ( $ password , \ Yii :: $ app -> getModule ( 'user' ) -> cost ) ; }
6670	public function get_movie_rating ( $ votes ) { $ votations = [ ] ; foreach ( $ votes as $ key => $ value ) { for ( $ i = 0 ; $ i < $ value ; $ i ++ ) { $ votations [ ] = $ key ; } } if ( count ( $ votations ) ) { $ rating = array_sum ( $ votations ) / count ( $ votations ) ; return round ( $ rating , 1 ) ; } return 'N/A' ; }
4924	public function type ( $ className ) { if ( ! class_exists ( $ className ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Class %s is non-existent or could not be loaded' , $ className ) ) ; } $ this -> matrix [ $ this -> currentRegion ] [ ] = $ className ; return $ this ; }
11253	public function transaction ( callable $ callback ) : void { $ this -> pdo -> beginTransaction ( ) ; $ callback ( $ this ) ; $ this -> pdo -> commit ( ) ; }
6417	public static function size ( IteratorAggregate $ iterable ) : int { if ( $ iterable instanceof Countable ) { return $ iterable -> count ( ) ; } return Iterators :: size ( Iterators :: from ( $ iterable -> getIterator ( ) ) ) ; }
12802	public function getPage ( $ page = null ) { if ( is_null ( $ page ) ) { $ page = $ this -> page ; } list ( $ offset , $ size ) = $ this -> getLimts ( $ page ) ; $ this -> manager -> limit ( $ offset , $ size ) ; return $ this -> manager -> values ( ) ; }
11265	public function model ( $ pathname ) { $ fullPath = $ this -> config [ 'pathToModels' ] . $ this -> getPath ( $ pathname ) . $ this -> config [ 'modelsPrefix' ] . $ this -> getName ( $ pathname ) . $ this -> config [ 'modelsPostfix' ] . '.php' ; include_once ( $ fullPath ) ; }
229	public function getPdoType ( $ data ) { static $ typeMap = [ 'boolean' => \ PDO :: PARAM_BOOL , 'integer' => \ PDO :: PARAM_INT , 'string' => \ PDO :: PARAM_STR , 'resource' => \ PDO :: PARAM_LOB , 'NULL' => \ PDO :: PARAM_NULL , ] ; $ type = gettype ( $ data ) ; return isset ( $ typeMap [ $ type ] ) ? $ typeMap [ $ type ] : \ PDO :: PARAM_STR ; }
7189	private function copyAdjustment ( Model \ AdjustmentInterface $ source , Model \ AdjustmentInterface $ target ) { $ this -> copy ( $ source , $ target , [ 'designation' , 'type' , 'mode' , 'amount' , 'immutable' , ] ) ; }
896	private function findComparisonStart ( Tokens $ tokens , $ index ) { -- $ index ; $ nonBlockFound = false ; while ( 0 <= $ index ) { $ token = $ tokens [ $ index ] ; if ( $ token -> isGivenKind ( [ T_WHITESPACE , T_COMMENT , T_DOC_COMMENT ] ) ) { -- $ index ; continue ; } if ( $ this -> isOfLowerPrecedence ( $ token ) ) { break ; } $ block = Tokens :: detectBlockType ( $ token ) ; if ( null === $ block ) { -- $ index ; $ nonBlockFound = true ; continue ; } if ( $ block [ 'isStart' ] || ( $ nonBlockFound && Tokens :: BLOCK_TYPE_CURLY_BRACE === $ block [ 'type' ] ) ) { break ; } $ index = $ tokens -> findBlockStart ( $ block [ 'type' ] , $ index ) - 1 ; } return $ tokens -> getNextMeaningfulToken ( $ index ) ; }
6704	public function baseURL ( $ httpverb , $ url , $ params ) { uksort ( $ params , 'strcmp' ) ; return strtoupper ( $ httpverb ) . '&' . rawurlencode ( $ url ) . '&' . rawurlencode ( http_build_query ( $ params ) ) ; }
8051	public function getAllEvents ( ) : array { $ calendarEvents = null ; $ cache = $ this -> cache ; if ( $ cache :: has ( self :: ALL_EVENTS_KEY ) ) { return $ cache :: get ( self :: ALL_EVENTS_KEY ) ; } $ allEvents = $ this -> calendarEvent -> with ( [ 'calendarEventRepeatDates' ] ) -> get ( ) ; $ calendarEvents = $ allEvents -> keyBy ( 'id' ) -> toArray ( ) ; $ cache :: put ( self :: ALL_EVENTS_KEY , $ calendarEvents , $ this -> cacheTimeToLive ) ; return $ calendarEvents ; }
5863	protected function expandConversionMapping ( array $ mapping ) { $ ret = [ ] ; $ matches = [ ] ; foreach ( $ mapping as $ m ) { if ( preg_match ( '/^(.*)\s*=>\s*(.*)/' , $ m , $ matches ) ) { $ ret [ trim ( $ matches [ 1 ] ) ] = trim ( $ matches [ 2 ] ) ; } } return $ ret ; }
2596	public static function decodeProcessingLevel ( $ level ) { $ decoded = null ; $ map = [ 0 => 'system' , 1 => 'application' ] ; if ( array_key_exists ( $ level , $ map ) ) { $ decoded = $ map [ $ level ] ; } return $ decoded ; }
11848	private function checkReadOnly ( ) { if ( true === $ this -> _readOnly ) { $ this -> _pushError ( '' , self :: ERR_READ_ONLY , 'This row has been marked read-only' ) ; return false ; } return true ; }
4626	private function createIndexQueryPath ( Bucket $ bucket ) { $ command = $ this -> command ; if ( $ command -> isMatchQuery ( ) ) { $ path = sprintf ( '/types/%s/buckets/%s/index/%s/%s' , $ bucket -> getType ( ) , $ bucket -> getName ( ) , $ command -> getIndexName ( ) , $ command -> getMatchValue ( ) ) ; } elseif ( $ command -> isRangeQuery ( ) ) { $ path = sprintf ( '/types/%s/buckets/%s/index/%s/%s/%s' , $ bucket -> getType ( ) , $ bucket -> getName ( ) , $ command -> getIndexName ( ) , $ command -> getLowerBound ( ) , $ command -> getUpperBound ( ) ) ; } else { throw new Api \ Exception ( "Invalid Secondary Index Query." ) ; } return $ path ; }
2278	public function setPagesFlags ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ dc -> activeRecord && $ dc -> activeRecord -> type == 'search' ) { $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ dc -> field ] [ 'eval' ] [ 'mandatory' ] = false ; unset ( $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ dc -> field ] [ 'eval' ] [ 'orderField' ] ) ; } return $ varValue ; }
10874	public function getEncodeHash ( int $ id , string $ slug , string $ linkValidate = null ) : string { return base64_encode ( uniqid ( ( $ linkValidate ? strtotime ( $ linkValidate ) : self :: NO_TIME ) . self :: TIME_SEPARATOR , true ) . self :: PART_SEPARATOR . $ this -> getHash ( $ id . $ slug ) . self :: ID_SEPARATOR . $ id ) ; }
4604	protected function parse ( $ path ) : array { $ fixtures = array_key_exists ( 'FIXTURES' , $ _ENV ) ? $ _ENV [ 'FIXTURES' ] : 'dev' ; $ files = glob ( str_replace ( '{fixtures}' , $ fixtures , $ path ) ) ; if ( ! $ files ) { throw new LogicException ( 'Fixtures path "' . $ path . '" yields no files.' ) ; } $ objects = [ ] ; foreach ( $ files as $ file ) { foreach ( Objects :: parseFile ( $ file ) as $ object ) { $ objects [ ] = $ object ; } } return $ objects ; }
11964	private function checkSource ( $ connection ) { if ( gettype ( $ connection ) == "string" ) { $ config = include ( __DIR__ . '/../../../../../clusterpoint.php' ) ; $ connection = $ config [ $ connection ] ; } return $ connection ; }
2277	public function getPasswordDefault ( $ varValue ) { if ( ! trim ( $ varValue ) ) { $ varValue = ( \ is_array ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_module' ] [ 'passwordText' ] ) ? $ GLOBALS [ 'TL_LANG' ] [ 'tl_module' ] [ 'passwordText' ] [ 1 ] : $ GLOBALS [ 'TL_LANG' ] [ 'tl_module' ] [ 'passwordText' ] ) ; } return $ varValue ; }
5100	public function values ( $ values ) { if ( isset ( $ values [ 0 ] ) ) return $ this -> appendByPosition ( $ values ) ; $ this -> fixDefaultValues ( $ values ) ; if ( ! $ this -> fields ) { $ this -> placeholder = false ; $ this -> fields = array_keys ( $ values ) ; return $ this -> appendByPosition ( array_values ( $ values ) ) ; } return $ this -> appendByField ( $ values ) ; }
729	protected function addDefaultPrimaryKey ( & $ fields ) { foreach ( $ fields as $ field ) { if ( false !== strripos ( $ field [ 'decorators' ] , 'primarykey()' ) ) { return ; } } array_unshift ( $ fields , [ 'property' => 'id' , 'decorators' => 'primaryKey()' ] ) ; }
11006	public function setRefererPolicy ( string $ refererPolicy ) : void { if ( ! in_array ( $ refererPolicy , self :: REFERER_POLICY_VALUES ) ) { throw new MiddlewareException ( $ this , sprintf ( "%s is not a valid CSP referer policy, correct values are: %s (see %s)" , $ refererPolicy , implode ( ', ' , self :: REFERER_POLICY_VALUES ) , 'https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Security-Policy/referrer' ) ) ; } $ this -> tags [ 'referer' ] = $ refererPolicy ; }
1936	protected function getForwardUrl ( $ objPage ) { if ( $ objPage -> jumpTo ) { $ objNextPage = PageModel :: findPublishedById ( $ objPage -> jumpTo ) ; } else { $ objNextPage = PageModel :: findFirstPublishedRegularByPid ( $ objPage -> id ) ; } if ( ! $ objNextPage instanceof PageModel ) { $ this -> log ( 'Forward page ID "' . $ objPage -> jumpTo . '" does not exist' , __METHOD__ , TL_ERROR ) ; throw new ForwardPageNotFoundException ( 'Forward page not found' ) ; } $ strGet = '' ; $ strQuery = Environment :: get ( 'queryString' ) ; $ arrQuery = array ( ) ; if ( $ strQuery != '' ) { $ arrChunks = explode ( '&' , $ strQuery ) ; foreach ( $ arrChunks as $ strChunk ) { list ( $ k ) = explode ( '=' , $ strChunk , 2 ) ; $ arrQuery [ ] = $ k ; } } if ( ! empty ( $ _GET ) ) { foreach ( array_keys ( $ _GET ) as $ key ) { if ( Config :: get ( 'addLanguageToUrl' ) && $ key == 'language' ) { continue ; } if ( \ in_array ( $ key , $ arrQuery ) ) { continue ; } if ( $ key == 'auto_item' ) { $ strGet .= '/' . Input :: get ( $ key ) ; } else { $ strGet .= '/' . $ key . '/' . Input :: get ( $ key ) ; } } } if ( $ strQuery != '' ) { $ strQuery = '?' . $ strQuery ; } return $ objNextPage -> getAbsoluteUrl ( $ strGet ) . $ strQuery ; }
2515	public function pnrRetrieve ( RequestOptions \ PnrRetrieveOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'PNR_Retrieve' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; }
4900	public static function loadDotEnv ( ) { $ dotenv = new Dotenv ( ) ; if ( is_file ( getcwd ( ) . '/.env.dist' ) ) { $ dotenv -> load ( getcwd ( ) . '/.env.dist' ) ; } if ( is_file ( $ file = getcwd ( ) . '/.env' ) ) { $ dotenv -> load ( $ file ) ; } if ( false === getenv ( 'TIMEZONE' ) ) { putenv ( 'TIMEZONE=Europe/Berlin' ) ; } date_default_timezone_set ( getenv ( 'TIMEZONE' ) ) ; }
10	private function getCurrentPackages ( $ installedRepo ) { if ( $ this -> locker -> isLocked ( ) ) { try { return $ this -> locker -> getLockedRepository ( true ) -> getPackages ( ) ; } catch ( \ RuntimeException $ e ) { return $ this -> locker -> getLockedRepository ( ) -> getPackages ( ) ; } } return $ installedRepo -> getPackages ( ) ; }
5149	protected function getFullEmail ( $ id ) { try { $ response = $ this -> sendRequest ( 'GET' , "/api/v1/inboxes/{$this->config['inbox_id']}/messages/{$id}" ) ; } catch ( Exception $ e ) { $ this -> fail ( 'Exception: ' . $ e -> getMessage ( ) ) ; } $ fullEmail = json_decode ( $ response -> getBody ( ) ) ; return $ fullEmail ; }
9421	public function getContents ( ) { if ( is_null ( $ this -> stream ) || ! $ this -> isReadable ( ) ) { $ message = 'Could not get contents of stream' ; throw new \ RuntimeException ( $ message ) ; } return stream_get_contents ( $ this -> stream ) ; }
7822	protected function refreshPipelines ( ) { $ yaml = $ this -> parser -> dump ( $ this -> pipelines ) ; $ this -> files -> put ( $ this -> getSource ( ) , $ yaml ) ; }
10627	public static function cpuCoreInfo ( ) { $ cores = array ( ) ; if ( false !== ( $ data = @ file ( '/proc/stat' ) ) ) { foreach ( $ data as $ line ) { if ( preg_match ( '/^cpu[0-9]/' , $ line ) ) { $ info = explode ( ' ' , $ line ) ; $ cores [ ] = array ( 'user' => $ info [ 1 ] , 'nice' => $ info [ 2 ] , 'sys' => $ info [ 3 ] , 'idle' => $ info [ 4 ] , 'iowait' => $ info [ 5 ] , 'irq' => $ info [ 6 ] , 'softirq' => $ info [ 7 ] ) ; } } } return $ cores ; }
9297	public function update ( array $ data = [ ] ) { $ this -> setActionUri ( __FUNCTION__ ) ; $ response = $ this -> client -> post ( $ this -> uri , [ 'multipart' => $ this -> dataToMultipart ( $ data ) , ] ) ; return $ this -> responseToJson ( $ response ) ; }
10324	private function createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , $ source ) { $ queryParameters = array ( ) ; if ( isset ( $ fromDate ) ) $ queryParameters [ 'from_date' ] = $ fromDate ; if ( isset ( $ toDate ) ) $ queryParameters [ 'to_date' ] = $ toDate ; if ( isset ( $ source ) ) $ queryParameters [ 'source' ] = $ source ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , "ids" , $ contactIds ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , "emails" , $ contactEmails ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , "eids" , $ contactExternalIds ) ; if ( isset ( $ mailingIds ) ) { $ queryParameters [ 'mailing_id' ] = array ( ) ; foreach ( $ mailingIds as $ mailingId ) { $ queryParameters [ 'mailing_id' ] [ ] = $ mailingId ; } } return $ queryParameters ; }
134	public function isPackageInstalled ( InstalledRepositoryInterface $ repo , PackageInterface $ package ) { if ( $ package instanceof AliasPackage ) { return $ repo -> hasPackage ( $ package ) && $ this -> isPackageInstalled ( $ repo , $ package -> getAliasOf ( ) ) ; } return $ this -> getInstaller ( $ package -> getType ( ) ) -> isInstalled ( $ repo , $ package ) ; }
12039	public function sendHeaders ( ) { if ( count ( $ this -> _headersRaw ) || count ( $ this -> _headers ) || ( 200 !== $ this -> _httpResponseCode ) ) { $ this -> canSendHeaders ( true ) ; } elseif ( 200 === $ this -> _httpResponseCode ) { return $ this ; } $ httpCodeSent = false ; foreach ( $ this -> _headersRaw as $ header ) { if ( ! $ httpCodeSent && $ this -> _httpResponseCode ) { header ( $ header , true , $ this -> _httpResponseCode ) ; $ httpCodeSent = true ; } else { header ( $ header ) ; } } foreach ( $ this -> _headers as $ header ) { header ( "{$header['name']}: {$header['value']}" , $ header [ 'replace' ] ) ; } if ( ! $ httpCodeSent ) { $ message = array_key_exists ( $ this -> _httpResponseCode , self :: $ _messages ) ? self :: $ _messages [ $ this -> _httpResponseCode ] : 'No Reason Phrase' ; header ( "HTTP/1.1 {$this->_httpResponseCode} {$message}" , true ) ; $ httpCodeSent = true ; } return $ this ; }
7047	protected function buildAddressData ( Common \ AddressInterface $ address , string $ locale ) { $ country = Intl :: getRegionBundle ( ) -> getCountryName ( $ address -> getCountry ( ) -> getCode ( ) , $ locale ) ; $ fullName = trim ( $ address -> getFirstName ( ) . ' ' . $ address -> getLastName ( ) ) ; $ data = [ 'company' => $ address -> getCompany ( ) , 'full_name' => $ fullName , 'street' => $ address -> getStreet ( ) , 'complement' => $ address -> getComplement ( ) , 'supplement' => $ address -> getSupplement ( ) , 'postal_code' => $ address -> getPostalCode ( ) , 'city' => $ address -> getCity ( ) , 'country' => $ country , 'state' => '' , 'phone' => $ this -> formatPhoneNumber ( $ address -> getPhone ( ) ) , 'mobile' => $ this -> formatPhoneNumber ( $ address -> getMobile ( ) ) , ] ; if ( $ address instanceof RelayPointInterface ) { $ data [ 'number' ] = $ address -> getNumber ( ) ; } return $ data ; }
10563	private function _buildActionName ( $ controllerName , $ actionName ) { $ actionName = $ actionName . 'Action' ; if ( ! method_exists ( $ controllerName , $ actionName ) ) { $ actionName = $ this -> defaultAction . 'Action' ; } return $ actionName ; }
5519	protected function emulateCall ( $ method , $ args , $ step ) { return $ this -> actions -> respond ( $ step , $ method , $ args ) ; }
8807	public function set ( $ key , $ value , $ time = 0 ) { if ( is_array ( $ key ) ) { foreach ( $ key as $ k => $ v ) { setcookie ( $ k , $ v , ( $ time == 0 ? 0 : time ( ) + $ time ) , '/' ) ; $ _COOKIE [ $ k ] = $ v ; } } else { setcookie ( $ key , $ value , ( $ time == 0 ? 0 : time ( ) + $ time ) , '/' ) ; $ _COOKIE [ $ key ] = $ value ; } return ; }
9187	public static function embedCampaigns ( $ html , $ campaign = [ ] , $ additionalCampaigns = [ ] ) { $ pattern = '/<a(\s[^>]*)href="([^"]*)"([^>]*)>/si' ; $ html = preg_replace_callback ( $ pattern , function ( $ matches ) use ( $ campaign , $ additionalCampaigns ) { $ href = GoogleCampaignPlugin :: replaceLink ( $ matches [ 2 ] , $ campaign , $ additionalCampaigns ) ; return "<a{$matches[1]}href=\"{$href}\"{$matches[3]}>" ; } , $ html ) ; return $ html ; }
5162	public function attachGallery ( Gallery $ gallery ) : self { return $ this -> attach ( self :: ATTACHMENT_FIELD_GALLERY , $ this -> ensureOrder ( $ gallery , self :: ATTACHMENT_FIELD_GALLERY ) ) ; }
6241	protected function normalizePathComponents ( ) : array { $ components = [ ] ; $ keys = array_keys ( $ this -> components ) ; $ positionStart = reset ( $ keys ) ; $ positionEnd = end ( $ keys ) ; foreach ( $ this -> components as $ position => $ component ) { $ path = self :: normalize ( $ component , $ position === $ positionStart , $ position === $ positionEnd ) ; $ path = str_replace ( [ '/' , '\\' , DIRECTORY_SEPARATOR . DIRECTORY_SEPARATOR ] , DIRECTORY_SEPARATOR , $ path ) ; if ( $ position === $ positionStart && $ path === DIRECTORY_SEPARATOR ) { $ components [ ] = DIRECTORY_SEPARATOR ; } elseif ( $ position === $ positionStart ) { $ components [ ] = rtrim ( $ path , DIRECTORY_SEPARATOR ) ; } else { $ components [ ] = trim ( $ path , DIRECTORY_SEPARATOR ) ; } } return $ components ; }
4981	public function convertToPhpValue ( $ value ) { if ( ! is_array ( $ value ) || ! isset ( $ value [ 'date' ] ) || ! $ value [ 'date' ] instanceof \ MongoDate || ! isset ( $ value [ 'tz' ] ) ) { return null ; } $ timestamp = $ value [ 'date' ] -> sec ; $ date = new \ DateTime ( '@' . $ timestamp ) ; $ date -> setTimezone ( new \ DateTimeZone ( $ value [ 'tz' ] ) ) ; return $ date ; }
10247	public function getString ( $ type = 'letter' , $ desired_length = null ) { if ( empty ( $ desired_length ) ) { $ desired_length = $ this -> getInteger ( 1 , 50 ) ; } $ result = '' ; while ( strlen ( $ result ) < $ desired_length ) { if ( $ type == 'letter' ) { $ result .= $ this -> getLetter ( ) ; } elseif ( $ type == 'number' ) { $ result .= $ this -> getInteger ( 1 , 10 ) ; } else { $ result .= $ this -> getUniqueHash ( ) ; } } return substr ( $ result , 0 , $ desired_length ) ; }
12844	protected function loadAnswerMatching ( ) { if ( $ this -> input -> hasOption ( 'load-choice-matching' ) ) { $ fs = new Filesystem ( ) ; $ filename = $ this -> input -> getOption ( 'load-choice-matching' ) ; if ( ! $ fs -> exists ( $ filename ) ) { $ this -> logger -> warning ( "The file $filename is not found. Choice matching not loaded" ) ; } else { $ this -> logger -> debug ( "Loading $filename as choice matching" ) ; $ this -> cacheAnswersMapping = \ json_decode ( \ file_get_contents ( $ filename ) , true ) ; } } }
8738	protected function filterValues ( array $ values ) { $ attributes = $ this -> model -> translatableAttributes ( ) ; $ translatable = [ ] ; foreach ( $ attributes as $ key ) { if ( array_key_exists ( $ key , $ values ) ) { $ translatable [ $ key ] = $ values [ $ key ] ; unset ( $ values [ $ key ] ) ; } } return [ $ values , $ translatable ] ; }
9790	public function getFormattedValue ( ) { return ( string ) NumberFormat :: toFormattedString ( $ this -> getCalculatedValue ( ) , $ this -> getStyle ( ) -> getNumberFormat ( ) -> getFormatCode ( ) ) ; }
1562	protected function deserializeAttribute ( $ value , $ field , $ record ) { if ( $ this -> isDateAttribute ( $ field , $ record ) ) { return $ this -> deserializeDate ( $ value , $ field , $ record ) ; } $ method = 'deserialize' . Str :: classify ( $ field ) . 'Field' ; if ( method_exists ( $ this , $ method ) ) { return $ this -> { $ method } ( $ value , $ record ) ; } return $ value ; }
11388	public function create ( $ action ) { $ actionName = ucfirst ( $ action ) ; $ class = sprintf ( 'RedKiteCms\Content\BlockManager\BlockManager%s' , $ actionName ) ; if ( ! class_exists ( $ class ) ) { return null ; } $ reflectionClass = new \ ReflectionClass ( $ class ) ; return $ reflectionClass -> newInstance ( $ this -> serializer , $ this -> optionsResolver ) ; }
649	public function dropCommentFromColumn ( $ table , $ column ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> dropCommentFromColumn ( $ table , $ column ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
8263	protected function onStateMismatch ( ) { $ this -> logger -> warning ( "OAuth2 response state mismatch: provider: {provider} from {addr}" , array ( "provider" => get_class ( $ this -> provider ) , "addr" => $ _SERVER [ 'REMOTE_ADDR' ] ) ) ; $ this -> session -> remove ( "oauth2state" ) ; $ this -> session -> addFlash ( "error" , "Invalid OAuth response." ) ; $ this -> picoAuth -> redirectToLogin ( ) ; }
5861	protected function compileRulesets ( array $ rulesets ) { $ out = [ ] ; $ elements = $ rulesets [ 'data' ] [ 'sDEF' ] [ 'lDEF' ] [ 'ruleset' ] [ 'el' ] ; foreach ( $ elements as $ container ) { if ( isset ( $ container [ 'container' ] [ 'el' ] ) ) { $ values = [ ] ; foreach ( $ container [ 'container' ] [ 'el' ] as $ key => $ value ) { if ( $ key === 'title' ) { continue ; } $ values [ $ key ] = $ value [ 'vDEF' ] ; } $ out [ ] = $ this -> expandValuesInRuleset ( $ values ) ; } } return $ out ; }
6262	public function getPrefixMap ( ) { $ prefixMap = ( array ) Configure :: read ( 'SimpleRbac.prefixMap' ) ; if ( empty ( $ prefixMap ) && $ this -> _config [ 'allowEmptyPrefixMap' ] === false ) { throw new \ RuntimeException ( 'SimpleRbac.prefixMap configuration is empty!' ) ; } return $ prefixMap ; }
35	protected function printVersions ( CompletePackageInterface $ package , array $ versions , RepositoryInterface $ installedRepo ) { uasort ( $ versions , 'version_compare' ) ; $ versions = array_keys ( array_reverse ( $ versions ) ) ; if ( $ installedRepo -> hasPackage ( $ package ) ) { $ installedVersion = $ package -> getPrettyVersion ( ) ; $ key = array_search ( $ installedVersion , $ versions ) ; if ( false !== $ key ) { $ versions [ $ key ] = '<info>* ' . $ installedVersion . '</info>' ; } } $ versions = implode ( ', ' , $ versions ) ; $ this -> getIO ( ) -> write ( '<info>versions</info> : ' . $ versions ) ; }
2307	protected function doCreateFileList ( $ strFolder = null , $ level = - 1 , $ strFilter = '' ) { if ( $ strFilter === true ) { @ trigger_error ( 'Passing "true" to Backend::doCreateFileList() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ strFilter = 'gif,jpg,jpeg,png' ; } $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; $ arrPages = scan ( $ rootDir . '/' . $ strFolder ) ; if ( empty ( $ arrPages ) ) { return '' ; } if ( \ in_array ( '.htaccess' , $ arrPages ) ) { return '' ; } ++ $ level ; $ strFolders = '' ; $ strFiles = '' ; foreach ( $ arrPages as $ strFile ) { if ( strncmp ( $ strFile , '.' , 1 ) === 0 ) { continue ; } if ( is_dir ( $ rootDir . '/' . $ strFolder . '/' . $ strFile ) ) { $ strFolders .= $ this -> doCreateFileList ( $ strFolder . '/' . $ strFile , $ level , $ strFilter ) ; } else { if ( $ strFilter != '' && ! preg_match ( '/\.(' . str_replace ( ',' , '|' , $ strFilter ) . ')$/i' , $ strFile ) ) { continue ; } $ strFiles .= sprintf ( '<option value="%s"%s>%s</option>' , $ strFolder . '/' . $ strFile , ( ( $ strFolder . '/' . $ strFile == Input :: get ( 'value' ) ) ? ' selected="selected"' : '' ) , StringUtil :: specialchars ( $ strFile ) ) ; } } if ( \ strlen ( $ strFiles ) ) { return '<optgroup label="' . StringUtil :: specialchars ( $ strFolder ) . '">' . $ strFiles . $ strFolders . '</optgroup>' ; } return $ strFiles . $ strFolders ; }
9769	function match ( string $ pattern ) : self { return $ this -> expect ( $ this -> target , matchesRegularExpression ( $ pattern ) ) ; }
4327	public static function isList ( $ val ) { if ( ! \ is_array ( $ val ) ) { return false ; } $ keys = \ array_keys ( $ val ) ; foreach ( $ keys as $ i => $ key ) { if ( $ i != $ key ) { return false ; } } return true ; }
2087	public static function getDefaultPath ( $ template , $ format ) { $ file = $ template . '.' . $ format ; $ container = System :: getContainer ( ) ; $ rootDir = $ container -> getParameter ( 'kernel.project_dir' ) ; if ( isset ( self :: $ files [ $ template ] ) ) { return $ rootDir . '/' . self :: $ files [ $ template ] . '/' . $ file ; } $ strPath = null ; try { foreach ( $ container -> get ( 'contao.resource_finder' ) -> findIn ( 'templates' ) -> name ( $ file ) as $ file ) { $ strPath = $ file -> getPathname ( ) ; } } catch ( \ InvalidArgumentException $ e ) { } if ( $ strPath !== null ) { return $ strPath ; } throw new \ Exception ( 'Could not find template "' . $ template . '"' ) ; }
7322	public function sidereal ( $ mode = 'a' , Angle $ lon = null ) { $ ut = $ this -> copy ( ) -> toUT1 ( ) ; $ uta = $ ut -> jd ; $ utb = $ ut -> dayFrac ; $ ut = null ; $ tt = $ this -> copy ( ) -> toTT ( ) ; $ tta = $ tt -> jd ; $ ttb = $ tt -> dayFrac ; $ tt = null ; $ st ; if ( $ mode == 'a' ) { $ strad = IAU :: Gst06a ( $ uta , $ utb , $ tta , $ ttb ) ; } else { $ strad = IAU :: Gmst06 ( $ uta , $ utb , $ tta , $ ttb ) ; } if ( $ lon ) { $ st = Angle :: rad ( $ strad ) -> add ( $ lon ) -> norm ( ) -> toTime ( ) ; } else { $ st = Angle :: rad ( $ strad ) -> toTime ( ) ; } return $ st ; }
7604	protected function renderAddOn ( $ aAddOnOptions ) { if ( empty ( $ aAddOnOptions ) ) { throw new InvalidArgumentException ( 'Addon options are empty' ) ; } if ( $ aAddOnOptions instanceof ElementInterface ) { $ aAddOnOptions = array ( 'element' => $ aAddOnOptions ) ; } elseif ( is_scalar ( $ aAddOnOptions ) ) { $ aAddOnOptions = array ( 'text' => $ aAddOnOptions ) ; } elseif ( ! is_array ( $ aAddOnOptions ) ) { throw new InvalidArgumentException ( sprintf ( 'Addon options expects an array or a scalar value, "%s" given' , is_object ( $ aAddOnOptions ) ? get_class ( $ aAddOnOptions ) : gettype ( $ aAddOnOptions ) ) ) ; } $ sMarkup = '' ; $ sAddonTagName = 'span' ; $ sAddonClass = '' ; if ( ! empty ( $ aAddOnOptions [ 'text' ] ) ) { if ( ! is_scalar ( $ aAddOnOptions [ 'text' ] ) ) { throw new InvalidArgumentException ( sprintf ( '"text" option expects a scalar value, "%s" given' , is_object ( $ aAddOnOptions [ 'text' ] ) ? get_class ( $ aAddOnOptions [ 'text' ] ) : gettype ( $ aAddOnOptions [ 'text' ] ) ) ) ; } elseif ( ( $ oTranslator = $ this -> getTranslator ( ) ) ) { $ sMarkup .= $ oTranslator -> translate ( $ aAddOnOptions [ 'text' ] , $ this -> getTranslatorTextDomain ( ) ) ; } else { $ sMarkup .= $ aAddOnOptions [ 'text' ] ; } $ sAddonClass .= ' input-group-addon' ; } elseif ( ! empty ( $ aAddOnOptions [ 'element' ] ) ) { if ( is_array ( $ aAddOnOptions [ 'element' ] ) || ( $ aAddOnOptions [ 'element' ] instanceof Traversable && ! ( $ aAddOnOptions [ 'element' ] instanceof ElementInterface ) ) ) { $ oFactory = new Factory ( ) ; $ aAddOnOptions [ 'element' ] = $ oFactory -> create ( $ aAddOnOptions [ 'element' ] ) ; } elseif ( ! ( $ aAddOnOptions [ 'element' ] instanceof ElementInterface ) ) { throw new LogicException ( sprintf ( '"element" option expects an instanceof Zend\Form\ElementInterface, "%s" given' , is_object ( $ aAddOnOptions [ 'element' ] ) ? get_class ( $ aAddOnOptions [ 'element' ] ) : gettype ( $ aAddOnOptions [ 'element' ] ) ) ) ; } $ aAddOnOptions [ 'element' ] -> setOptions ( array_merge ( $ aAddOnOptions [ 'element' ] -> getOptions ( ) , array ( 'disable-twb' => true ) ) ) ; $ sMarkup .= $ this -> render ( $ aAddOnOptions [ 'element' ] ) ; if ( $ aAddOnOptions [ 'element' ] instanceof Button ) { $ sAddonClass .= ' input-group-btn' ; $ sAddonTagName = 'div' ; } else { $ sAddonClass .= ' input-group-addon' ; } } return sprintf ( static :: $ addonFormat , $ sAddonTagName , trim ( $ sAddonClass ) , $ sMarkup , $ sAddonTagName ) ; }
11623	public function close ( ) { if ( $ this -> id == null ) { throw new InternalException ( 'Session not loaded' ) ; } if ( ! $ this -> cli ) { session_write_close ( ) ; } $ this -> id = null ; }
3525	public function lookup ( $ username ) { try { $ data = FortniteClient :: sendFortniteGetRequest ( FortniteClient :: FORTNITE_PERSONA_API . 'public/account/lookup?q=' . urlencode ( $ username ) , $ this -> access_token ) ; return new self ( $ this -> access_token , $ data -> id ) ; } catch ( GuzzleException $ e ) { if ( $ e -> getResponse ( ) -> getStatusCode ( ) == 404 ) throw new UserNotFoundException ( 'User ' . $ username . ' was not found.' ) ; throw $ e ; } }
603	protected function startsWithAnyLongest ( array & $ with , $ caseSensitive , & $ length = null , & $ content = null ) { if ( empty ( $ with ) ) { return false ; } if ( ! is_array ( reset ( $ with ) ) ) { usort ( $ with , function ( $ string1 , $ string2 ) { return mb_strlen ( $ string2 , 'UTF-8' ) - mb_strlen ( $ string1 , 'UTF-8' ) ; } ) ; $ map = [ ] ; foreach ( $ with as $ string ) { $ map [ mb_strlen ( $ string , 'UTF-8' ) ] [ $ caseSensitive ? $ string : mb_strtoupper ( $ string , 'UTF-8' ) ] = true ; } $ with = $ map ; } foreach ( $ with as $ testLength => $ testValues ) { $ content = $ this -> substring ( $ testLength , $ caseSensitive ) ; if ( isset ( $ testValues [ $ content ] ) ) { $ length = $ testLength ; return true ; } } return false ; }
7445	public function editAction ( $ id ) { $ em = $ this -> getDoctrine ( ) -> getEntityManager ( ) ; $ group = $ em -> getRepository ( 'Orkestra\Bundle\ApplicationBundle\Entity\Group' ) -> find ( $ id ) ; if ( ! $ group ) { throw $ this -> createNotFoundException ( 'Unable to locate Group' ) ; } $ form = $ this -> createForm ( GroupType :: class , $ group ) ; return array ( 'group' => $ group , 'form' => $ form -> createView ( ) , ) ; }
7164	private function buildSaleDiscountsLinesViews ( Model \ SaleInterface $ sale ) { if ( ! $ sale -> hasAdjustments ( Model \ AdjustmentTypes :: TYPE_DISCOUNT ) ) { return ; } foreach ( $ sale -> getAdjustments ( Model \ AdjustmentTypes :: TYPE_DISCOUNT ) as $ adjustment ) { $ this -> view -> addDiscount ( $ this -> buildDiscountLine ( $ adjustment ) ) ; } }
11620	public function auth ( ) : \ TheCMSThread \ Core \ Main \ Auth { static $ auth ; if ( $ auth === null ) { $ auth = $ this -> container -> get ( "TheCMSThread\\Core\\Main\\Auth" ) ; } $ auth -> __construct ( ) ; return $ auth ; }
12457	protected function onSuccessLoad ( ) { if ( $ this -> Web2All -> DebugLevel > Web2All_Manager_Main :: DEBUGLEVEL_MEDIUM ) { $ this -> Web2All -> debugLog ( 'Web2All_Table_Object::loadFromTable(): loaded: ' . $ this -> asDebugString ( ) ) ; } }
8267	public function close ( ) { if ( ! $ this -> isOpened ( ) ) { return ; } $ this -> unlock ( ) ; if ( $ this -> handle && ! fclose ( $ this -> handle ) ) { throw new \ RuntimeException ( "Could not close file " . $ this -> filePath ) ; } }
10819	public static function comment ( $ messages , $ linebreak = true , $ length = 0 ) { $ separator = $ linebreak ? "\n" : '' ; self :: write ( $ messages , 'comment' , $ length , $ separator ) ; }
9500	public function supportsEvent ( $ eventId ) { $ supportedEvents = [ WatcherInterface :: CREATE_EVENT , WatcherInterface :: MODIFY_EVENT , WatcherInterface :: DELETE_EVENT , WatcherInterface :: ALL_EVENT ] ; return array_search ( $ eventId , $ supportedEvents , true ) !== false ; }
4566	public function getForms ( $ id ) { $ forms = [ ] ; $ form = $ this -> getForm ( $ id ) ; $ form -> setMethod ( 'POST' ) -> setPrimary ( true ) ; $ forms [ ] = $ form ; switch ( $ form -> getType ( ) ) { case Form :: TYPE_FORMIO : $ components = $ form -> getSchema ( ) ; $ resolverCollection = $ this -> resolverCollection ; $ extract = function ( & $ container , $ key , & $ component ) use ( & $ extract , & $ forms , $ resolverCollection ) { switch ( true ) { case property_exists ( $ component , 'components' ) : foreach ( $ component -> components as $ key => & $ subComponent ) { $ extract ( $ component -> components , $ key , $ subComponent ) ; } break ; case property_exists ( $ component , 'columns' ) : foreach ( $ component -> columns as & $ column ) { foreach ( $ column -> components as $ key => & $ subComponent ) { $ extract ( $ column -> components , $ key , $ subComponent ) ; } } break ; case property_exists ( $ component , 'properties' ) && is_object ( $ component -> properties ) && property_exists ( $ component -> properties , 'ds_form' ) : $ form = $ this -> getForm ( $ component -> properties -> ds_form ) ; $ data = [ ] ; if ( property_exists ( $ component , 'defaultValue' ) ) { try { $ data = $ resolverCollection -> resolve ( $ component -> defaultValue ) ; } catch ( UnresolvedException $ exception ) { $ data = [ ] ; } catch ( UnmatchedException $ exception ) { } } $ form -> setData ( $ data ) ; $ forms [ ] = $ form ; unset ( $ container [ $ key ] ) ; break ; } } ; foreach ( $ components as $ key => & $ component ) { $ extract ( $ components , $ key , $ component ) ; } $ form -> setSchema ( array_values ( $ components ) ) ; break ; case Form :: TYPE_SYMFONY : break ; default : throw new DomainException ( 'Form type does not exist.' ) ; } return $ forms ; }
7283	public function updateCustomerGroupAndCurrency ( ) { if ( ! $ this -> hasCart ( ) || $ this -> cart -> isLocked ( ) ) { return $ this ; } if ( null !== $ customer = $ this -> cart -> getCustomer ( ) ) { if ( $ this -> cart -> getCustomerGroup ( ) !== $ customer -> getCustomerGroup ( ) ) { $ this -> cart -> setCustomerGroup ( $ customer -> getCustomerGroup ( ) ) ; } } if ( null === $ this -> cart -> getCustomerGroup ( ) ) { $ this -> cart -> setCustomerGroup ( $ this -> customerProvider -> getCustomerGroup ( ) ) ; } if ( null === $ this -> cart -> getCurrency ( ) ) { $ this -> cart -> setCurrency ( $ this -> currencyProvider -> getCurrency ( ) ) ; } return $ this ; }
1422	protected function createModelIdentity ( $ modelClass , $ id , $ keyName = null ) { if ( is_null ( $ id ) ) { return null ; } $ model = new $ modelClass ( ) ; if ( ! $ model instanceof Model ) { throw new RuntimeException ( sprintf ( 'Expecting a model class, got %s.' , $ modelClass ) ) ; } $ model -> setAttribute ( $ keyName ? : $ model -> getRouteKeyName ( ) , $ id ) ; return $ model ; }
9209	protected function findKey ( Table $ Table , Entity $ entity ) { if ( ! empty ( $ entity -> { $ Table -> primaryKey ( ) } ) ) { $ key = $ entity -> { $ Table -> primaryKey ( ) } ; } else { $ key = 'unknown' ; } return $ key ; }
12081	public function deleteChild ( $ idParent , FilterRequest $ filters , $ idChild , $ relation ) { $ idParent = $ this -> getRealId ( $ idParent ) ; $ idChild = $ this -> getRealId ( $ idChild ) ; $ resource = $ this -> repository -> deleteChild ( $ idParent , $ relation , $ idChild ) ; if ( $ resource == null ) { } return $ this -> success ( ) ; }
2022	public static function findFirstPublishedRootByHostAndLanguage ( $ strHost , $ varLanguage , array $ arrOptions = array ( ) ) { @ trigger_error ( 'Using PageModel::findFirstPublishedRootByHostAndLanguage() has been deprecated and will no longer work Contao 5.0.' , E_USER_DEPRECATED ) ; $ t = static :: $ strTable ; $ objDatabase = Database :: getInstance ( ) ; if ( \ is_array ( $ varLanguage ) ) { $ arrColumns = array ( "$t.type='root' AND ($t.dns=? OR $t.dns='')" ) ; if ( ! empty ( $ varLanguage ) ) { $ arrColumns [ ] = "($t.language IN('" . implode ( "','" , $ varLanguage ) . "') OR $t.fallback='1')" ; } else { $ arrColumns [ ] = "$t.fallback='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.dns DESC" . ( ! empty ( $ varLanguage ) ? ", " . $ objDatabase -> findInSet ( "$t.language" , array_reverse ( $ varLanguage ) ) . " DESC" : "" ) . ", $t.sorting" ; } if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: findOneBy ( $ arrColumns , $ strHost , $ arrOptions ) ; } else { $ arrColumns = array ( "$t.type='root' AND ($t.dns=? OR $t.dns='') AND ($t.language=? OR $t.fallback='1')" ) ; $ arrValues = array ( $ strHost , $ varLanguage ) ; if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.dns DESC, $t.fallback" ; } if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: findOneBy ( $ arrColumns , $ arrValues , $ arrOptions ) ; } }
10958	private function processFiles ( ) { foreach ( $ this -> currentCommand -> getFilesToMove ( ) as $ fileToMove ) { if ( $ fileToMove instanceof \ SplFileInfo ) { $ this -> processSplFileInfo ( $ fileToMove ) ; } else { $ this -> processArray ( $ fileToMove ) ; } } }
5411	public function write ( $ message ) { if ( $ this -> isError ( ) || ! $ this -> isOpen ( ) ) { return false ; } $ count = fwrite ( $ this -> handle , $ message ) ; if ( ! $ count ) { if ( $ count === false ) { $ this -> setError ( 'Cannot write to socket' ) ; $ this -> close ( ) ; } return false ; } fflush ( $ this -> handle ) ; $ this -> sent .= $ message ; return true ; }
8197	public function collect ( Traversable $ iterator ) { $ this -> deprecations = array ( ) ; set_error_handler ( array ( $ this , 'errorHandler' ) ) ; foreach ( $ iterator as $ name => $ contents ) { try { $ this -> twig -> parse ( $ this -> twig -> tokenize ( new Twig_Source ( $ contents , $ name ) ) ) ; } catch ( Twig_Error_Syntax $ e ) { } } restore_error_handler ( ) ; $ deprecations = $ this -> deprecations ; $ this -> deprecations = array ( ) ; return $ deprecations ; }
11746	public function device ( ) { if ( is_null ( $ this -> device ) ) { $ this -> device = new Device ( $ this -> accessToken ) ; } return $ this -> device ; }
6630	public function callback ( $ input ) { if ( isset ( $ input [ 'error' ] ) ) { throw new AuthenticationException ( $ input [ 'error' ] . ':' . $ input [ 'error_description' ] ) ; } if ( ! isset ( $ input [ 'code' ] ) || empty ( $ input [ 'code' ] ) ) { throw new AuthenticationException ( 'invalid code' ) ; } if ( ! isset ( $ input [ 'state' ] ) || empty ( $ input [ 'state' ] ) ) { throw new AuthenticationException ( 'invalid state' ) ; } if ( ! $ this -> store -> has ( $ input [ 'state' ] ) ) { throw new AuthenticationException ( 'state expired' ) ; } $ access_token = $ this -> requestAccessToken ( $ input [ 'code' ] ) ; return $ this -> requestProfile ( $ access_token ) ; }
12223	public function get ( $ keys = [ ] ) { $ this -> buildIfNotBuilded ( ) ; $ keys = $ keys == [ ] ? $ this -> keys ( ) : $ keys ; if ( ! $ keys ) { return $ this -> builder -> get ( ) ; } return $ this -> builder -> withColumns ( $ keys ) -> get ( $ keys ) ; }
7088	public function error ( Callable $ action = null ) { if ( $ action ) $ this -> errorAction = $ action ; return $ this -> errorAction ; }
8158	public function register ( $ isSuperAdmin = FALSE , $ status = 1 ) { if ( $ this -> getIsNewRecord ( ) == FALSE ) { throw new RuntimeException ( 'Calling "' . __CLASS__ . '::' . __METHOD__ . '" on existing user' ) ; } $ this -> super_admin = $ isSuperAdmin ? 1 : 0 ; $ this -> status = $ status ; if ( $ this -> save ( ) ) { return TRUE ; } return FALSE ; }
245	public function getColumn ( $ name ) { return isset ( $ this -> columns [ $ name ] ) ? $ this -> columns [ $ name ] : null ; }
12374	public function run ( ) : void { if ( ! $ this -> isRan ) { $ this -> isRan = true ; foreach ( $ this -> items as $ item ) { $ options = $ item [ 2 ] ?? [ ] ; $ ruleName = $ item [ 1 ] ; foreach ( is_array ( $ item [ 0 ] ) ? $ item [ 0 ] : [ $ item [ 0 ] ] as $ fieldName ) { self :: applyRuleToField ( $ fieldName , $ ruleName , $ options ) ; } } } }
9168	public static function parseUrl ( $ url ) : Endpoint { $ url = UrlParser :: parseUrl ( $ url ) ; return new Endpoint ( $ url -> getAddress ( ) , $ url -> getPort ( ) ) ; }
2807	public function purgeProfilesAction ( ) { $ count = $ this -> getService ( ) -> purgeAllProfiles ( ) ; $ this -> getSession ( ) -> addSuccess ( $ this -> __ ( '%d request profiles were deleted' , $ count ) ) ; $ this -> _redirect ( '/' ) ; }
1939	public function clearOptInData ( Contao \ DataContainer $ dc ) { $ this -> Database -> prepare ( "UPDATE tl_newsletter_recipients SET addedOn='' WHERE id=?" ) -> execute ( $ dc -> id ) ; }
2962	public function serialflush ( ) { if ( ! $ this -> _ckOpened ( ) ) { return false ; } if ( fwrite ( $ this -> _dHandle , $ this -> _buffer ) !== false ) { $ this -> _buffer = "" ; return true ; } else { $ this -> _buffer = "" ; trigger_error ( "Error while sending message" , E_USER_WARNING ) ; return false ; } }
6547	public function close ( ) { $ writer = \ PHPExcel_IOFactory :: createWriter ( $ this -> container , $ this -> format ) ; $ writer -> save ( $ this -> resourcepath ) ; }
376	protected function parseDocCommentDetail ( $ reflection ) { $ comment = strtr ( trim ( preg_replace ( '/^\s*\**( |\t)?/m' , '' , trim ( $ reflection -> getDocComment ( ) , '/' ) ) ) , "\r" , '' ) ; if ( preg_match ( '/^\s*@\w+/m' , $ comment , $ matches , PREG_OFFSET_CAPTURE ) ) { $ comment = trim ( substr ( $ comment , 0 , $ matches [ 0 ] [ 1 ] ) ) ; } if ( $ comment !== '' ) { return rtrim ( Console :: renderColoredString ( Console :: markdownToAnsi ( $ comment ) ) ) ; } return '' ; }
1225	private function buildQueryParameters ( array $ paramValues ) { if ( empty ( $ paramValues ) ) { return '' ; } $ query = [ ] ; foreach ( $ paramValues as $ param => $ value ) { if ( is_array ( $ value ) ) { $ value = join ( ',' , $ value ) ; } elseif ( is_bool ( $ value ) ) { $ value = $ value ? 'true' : 'false' ; } elseif ( is_callable ( $ value ) ) { $ value = $ value ( ) ; } $ query [ ] = $ param . '=' . urlencode ( $ value ) ; } return '?' . join ( '&' , $ query ) ; }
10064	public function all ( ) { $ meta = $ this -> metaModel :: get ( [ 'key' , 'value' , 'type' ] ) ; $ data = [ ] ; foreach ( $ meta as $ m ) { $ data [ $ m -> key ] = $ m -> value ; } return $ data ; }
9054	public function createRelationTable ( $ tableName ) : self { $ table = $ this -> getTableData ( $ tableName ) ; $ name = $ this -> name . '_x_' . $ table -> name ; return $ this -> relationTables [ ] = $ this -> tableFactory -> create ( $ name , $ this -> prefix ) ; }
12396	public function where ( $ field , $ operator = null , $ value = null , $ logical = '&&' ) { if ( $ field instanceof Closure ) { $ this -> scope -> where .= $ this -> scope -> where == '' ? ' (' : $ logical . ' (' ; call_user_func ( $ field , $ this ) ; $ this -> scope -> where .= ') ' ; } else { $ logical = ( strlen ( $ this -> scope -> where ) <= 1 || substr ( $ this -> scope -> where , - 1 ) == '(' ) ? '' : $ logical ; $ this -> scope -> where .= Parser :: where ( $ field , $ operator , $ value , $ logical ) ; } return $ this ; }
4476	public function track ( ) : void { if ( $ this -> client -> call ( 'track' , 'track' , $ this -> jid ) ) { $ this -> tracked = true ; } }
7995	public function getVpsList ( ) { $ request = $ this -> get ( 'vps' ) ; $ response = $ request -> send ( ) ; return $ response -> getBody ( true ) ; }
6091	public function removeMoodboard ( $ id ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> delete ( 'v1/moodboards/' . $ id . '' , $ parameters ) ; $ result = new MoodboardResponse ( $ result ) ; return $ result ; }
10989	protected function _setData ( $ key , $ value ) { $ store = $ this -> _getDataStore ( ) ; try { $ this -> _containerSet ( $ store , $ key , $ value ) ; } catch ( InvalidArgumentException $ e ) { throw $ this -> _createOutOfRangeException ( $ this -> __ ( 'Invalid store' ) , null , $ e , $ store ) ; } catch ( OutOfRangeException $ e ) { throw $ this -> _createInvalidArgumentException ( $ this -> __ ( 'Invalid key' ) , null , $ e , $ store ) ; } }
12020	function addSetAPIMethod ( ) { $ methodGenerator = new MethodGenerator ( 'setAPI' ) ; $ methodGenerator -> setBody ( '$this->api = $api;' ) ; $ parameterGenerator = new ParameterGenerator ( 'api' , $ this -> apiClassname ) ; $ methodGenerator -> setParameter ( $ parameterGenerator ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
659	public function noCache ( callable $ callable ) { $ this -> _queryCacheInfo [ ] = false ; try { $ result = call_user_func ( $ callable , $ this ) ; array_pop ( $ this -> _queryCacheInfo ) ; return $ result ; } catch ( \ Exception $ e ) { array_pop ( $ this -> _queryCacheInfo ) ; throw $ e ; } catch ( \ Throwable $ e ) { array_pop ( $ this -> _queryCacheInfo ) ; throw $ e ; } }
8235	protected function ivalidateToken ( $ index , array & $ tokenStorage ) { unset ( $ tokenStorage [ $ index ] ) ; $ this -> session -> set ( self :: SESSION_KEY , $ tokenStorage ) ; }
8651	private function convertGetReport ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetReport' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetReportId ( ) ) { $ parameters [ 'ReportId' ] = $ request -> getReportId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
571	public function generatePasswordHash ( $ password , $ cost = null ) { if ( $ cost === null ) { $ cost = $ this -> passwordHashCost ; } if ( function_exists ( 'password_hash' ) ) { return password_hash ( $ password , PASSWORD_DEFAULT , [ 'cost' => $ cost ] ) ; } $ salt = $ this -> generateSalt ( $ cost ) ; $ hash = crypt ( $ password , $ salt ) ; if ( ! is_string ( $ hash ) || strlen ( $ hash ) !== 60 ) { throw new Exception ( 'Unknown error occurred while generating hash.' ) ; } return $ hash ; }
12927	public function lists ( $ offset = 0 , $ limit = 10 ) { $ params = [ 'begin' => $ offset , 'limit' => $ limit , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_LIST , $ params ] ) ; }
6615	public function hasEndpoint ( $ method , $ endpointName ) { $ methodName = $ this -> parseEndpointName ( $ method , $ endpointName ) ; return $ this -> reflection -> hasMethod ( $ methodName ) ; }
7305	protected function scheduleParentChangeEvents ( CustomerInterface $ customer ) { if ( ! $ customer -> hasChildren ( ) ) { return ; } foreach ( $ customer -> getChildren ( ) as $ child ) { $ this -> persistenceHelper -> scheduleEvent ( CustomerEvents :: PARENT_CHANGE , $ child ) ; } }
9708	private function writeShortNameBiff8 ( $ name , $ sheetIndex , $ rangeBounds , $ isHidden = false ) { $ record = 0x0018 ; $ options = ( $ isHidden ? 0x21 : 0x00 ) ; $ extra = pack ( 'Cvvvvv' , 0x3B , $ sheetIndex - 1 , $ rangeBounds [ 0 ] [ 1 ] - 1 , $ rangeBounds [ 1 ] [ 1 ] - 1 , $ rangeBounds [ 0 ] [ 0 ] - 1 , $ rangeBounds [ 1 ] [ 0 ] - 1 ) ; $ sz = strlen ( $ extra ) ; $ data = pack ( 'vCCvvvCCCCC' , $ options , 0 , 1 , $ sz , 0 , $ sheetIndex , 0 , 0 , 0 , 0 , 0 ) . $ name . $ extra ; $ length = strlen ( $ data ) ; $ header = pack ( 'vv' , $ record , $ length ) ; return $ header . $ data ; }
10027	function getContactByEmail ( $ email , $ standard_fields = array ( ) , $ custom_fields = array ( ) ) { $ queryParameters = array ( 'standard_field' => $ standard_fields ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'custom_field' , $ custom_fields ) ; return $ this -> get ( 'contacts/email/' . utf8_encode ( $ email ) , $ queryParameters ) ; }
12562	public function sendText ( $ message , $ to = null ) { return $ this -> send ( self :: MSG_TYPE_TEXT , $ message , $ to ) ; }
7443	public function newAction ( ) { $ group = new Group ( ) ; $ form = $ this -> createForm ( GroupType :: class , $ group ) ; return array ( 'group' => $ group , 'form' => $ form -> createView ( ) ) ; }
8090	static public function generate ( $ uid = 0 , $ hash = false ) { if ( $ uid ) { $ e_uid = self :: encode ( $ uid ) ; $ e_uid_length = strlen ( $ e_uid ) ; $ e_uid_length = str_pad ( $ e_uid_length , 2 , 0 , STR_PAD_LEFT ) ; $ e_uid_pos = rand ( 10 , 32 - $ e_uid_length - 1 ) ; if ( ! $ hash ) { $ hash = sha1 ( uniqid ( rand ( ) , true ) ) ; } $ code = $ e_uid_pos . $ e_uid_length ; $ code .= substr ( $ hash , 0 , $ e_uid_pos - strlen ( $ code ) ) ; $ code .= $ e_uid ; $ code .= substr ( $ hash , strlen ( $ code ) ) ; return $ code ; } else { return sha1 ( uniqid ( rand ( ) , true ) ) ; } }
4454	private function registerSyncCompleteEvent ( ) : void { $ this -> getEventsManager ( ) -> attach ( QueueEvent \ AfterEnqueue :: getName ( ) , function ( QueueEvent \ AfterEnqueue $ event ) { if ( ! $ this -> client -> config -> get ( 'sync-enabled' ) ) { return ; } $ job = $ this -> popByJid ( $ event -> getJid ( ) ) ; if ( ! empty ( $ job ) ) { $ job -> perform ( ) ; } } ) ; }
7910	public function init ( ) { parent :: init ( ) ; Html :: addCssClass ( $ this -> options , 'ui' ) ; if ( ! isset ( $ this -> options [ 'id' ] ) ) { $ this -> options [ 'id' ] = $ this -> getId ( ) ; } $ this -> registerTranslations ( ) ; }
7460	public function lookup ( $ hash , $ className = 'Orkestra\Bundle\ApplicationBundle\Entity\User' ) { try { return $ this -> hashedEntityHelper -> lookup ( $ hash , $ className ) ; } catch ( \ RuntimeException $ e ) { return null ; } }
12194	public function instantiate ( $ className , array $ data = [ ] ) { $ refl = new \ ReflectionClass ( $ className ) ; $ instanceArgs = [ ] ; if ( $ data ) { $ instanceArgs = $ this -> extractArguments ( $ refl -> getConstructor ( ) -> getParameters ( ) , $ data ) ; } return $ refl -> newInstanceArgs ( $ instanceArgs ) ; }
6967	protected function calculateGoodLines ( Model \ DocumentInterface $ document ) : Amount { $ gross = new Amount ( $ document -> getCurrency ( ) ) ; foreach ( $ document -> getLinesByType ( Model \ DocumentLineTypes :: TYPE_GOOD ) as $ line ) { if ( null !== $ result = $ this -> calculateGoodLine ( $ line ) ) { $ gross -> merge ( $ result ) ; } } $ gross -> copyGrossToUnit ( ) ; return $ gross ; }
7561	protected function parse_sibling ( ) { if ( ( ( $ this -> pos + 1 ) < $ this -> size ) && ( $ this -> doc [ $ this -> pos + 1 ] === '=' ) ) { ++ $ this -> pos ; return ( $ this -> token = self :: TOK_COMPARE_CONTAINS_WORD ) ; } else { return ( $ this -> token = self :: TOK_SIBLING ) ; } }
6315	public function setUpdateAction ( $ updateAction ) { $ updateAction = strtoupper ( $ updateAction ) ; if ( ! in_array ( $ updateAction , $ this -> getAvailableActions ( ) ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Action %s does not exist.' , $ updateAction ) ) ; } $ this -> updateAction = $ updateAction ; }
11966	public function renderSlots ( Page $ page , array $ slots , array $ options = array ( ) ) { $ renderedSlots = array ( ) ; $ slots = $ this -> dispatchSlotsEvent ( RenderEvents :: SLOTS_RENDERING , $ page , $ slots ) ; foreach ( $ slots as $ slotName => $ slot ) { if ( is_string ( $ slot ) ) { $ renderedSlots [ $ slotName ] = $ slot ; continue ; } if ( ! $ slot instanceof Slot ) { continue ; } $ renderedSlots [ $ slotName ] = implode ( "" , $ this -> renderSlot ( $ slot ) ) ; } $ this -> mediaFiles = array_unique ( $ this -> mediaFiles ) ; return $ this -> dispatchSlotsEvent ( RenderEvents :: SLOTS_RENDERED , $ page , $ renderedSlots ) ; }
5470	protected function describePatternMatch ( $ pattern , $ subject ) { preg_match ( $ pattern , $ subject , $ matches ) ; $ position = strpos ( $ subject , $ matches [ 0 ] ) ; $ dumper = $ this -> getDumper ( ) ; return "Pattern [$pattern] detected at character [$position] in [" . $ dumper -> describeValue ( $ subject ) . '] as [' . $ matches [ 0 ] . '] in region [' . $ dumper -> clipString ( $ subject , 100 , $ position ) . ']' ; }
4761	public function flush ( ) { if ( $ this -> doNotTrack ) { return ; } if ( empty ( $ this -> queue ) ) { return ; } if ( $ this -> mergePackets ) { $ this -> send ( implode ( "\n" , $ this -> queue ) ) ; } else { foreach ( $ this -> queue as $ data ) { $ this -> send ( $ data ) ; } } $ this -> queue = array ( ) ; $ this -> queueSize = 0 ; }
2490	protected function processConnectionConfiguration ( ContainerBuilder $ container , array $ config ) { $ alias = $ this -> getAlias ( ) ; if ( isset ( $ config [ 'default_connection' ] ) ) { $ container -> setParameter ( "{$alias}.default_connection" , $ config [ 'default_connection' ] ) ; } elseif ( ! empty ( $ config [ 'connections' ] ) ) { reset ( $ config [ 'connections' ] ) ; $ container -> setParameter ( "{$alias}.default_connection" , key ( $ config [ 'connections' ] ) ) ; } foreach ( $ config [ 'connections' ] as $ name => $ params ) { $ this -> configureSearchServices ( $ container , $ name , $ params ) ; $ this -> configureBoostMap ( $ container , $ name , $ params ) ; $ this -> configureIndexingDepth ( $ container , $ name , $ params ) ; $ container -> setParameter ( "$alias.connection.$name" , $ params ) ; } foreach ( $ config [ 'endpoints' ] as $ name => $ params ) { $ this -> defineEndpoint ( $ container , $ name , $ params ) ; } $ searchEngineDef = $ container -> findDefinition ( self :: ENGINE_ID ) ; $ searchEngineDef -> setFactory ( [ new Reference ( 'ezpublish.solr.engine_factory' ) , 'buildEngine' ] ) ; $ boostFactorProviderDef = $ container -> findDefinition ( self :: BOOST_FACTOR_PROVIDER_ID ) ; $ boostFactorProviderDef -> setFactory ( [ new Reference ( 'ezpublish.solr.boost_factor_provider_factory' ) , 'buildService' ] ) ; }
1806	public function setNewPassword ( $ strPassword , $ user ) { if ( ! $ user ) { return $ strPassword ; } $ objUser = $ this -> Database -> prepare ( "SELECT * FROM tl_member WHERE id=?" ) -> limit ( 1 ) -> execute ( $ user -> id ) ; if ( $ objUser -> numRows ) { if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'setNewPassword' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'setNewPassword' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'setNewPassword' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ objUser , $ strPassword ) ; } } } return $ strPassword ; }
7489	public function insert ( $ offset , $ string ) { $ offset = ( int ) $ offset ; $ string = static :: convertString ( $ string , $ this -> encoding ) ; if ( $ offset < 0 || $ offset >= $ this -> length ( ) ) { throw new \ OutOfBoundsException ( ) ; } $ this -> string = mb_substr ( $ this -> string , 0 , $ offset , $ this -> encoding ) . $ string . mb_substr ( $ this -> string , $ offset , $ this -> length ( ) , $ this -> encoding ) ; return $ this ; }
9009	public function decimal ( int $ total , int $ decimal ) : self { $ this -> type = 'decimal(' . $ total . ',' . $ decimal . ')' ; return $ this ; }
4687	public function where ( ? string $ expression = null , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> where = $ expression ; $ this -> args [ 'where' ] = $ args ; return $ this ; }
10674	private function _cmpFrm ( $ txt ) { $ CmpFrmRV = '' ; $ length = mb_strlen ( $ txt , 'UTF-8' ) ; for ( $ CmpFrmI = 0 ; $ CmpFrmI < $ length ; $ CmpFrmI ++ ) { if ( mb_substr ( $ txt , $ CmpFrmI , 1 , 'UTF-8' ) === '0' ) { $ CmpFrmRV .= $ this -> aCmpReg [ 0 ] ; } elseif ( mb_substr ( $ txt , $ CmpFrmI , 1 , 'UTF-8' ) === '1' ) { $ CmpFrmRV .= $ this -> aCmpReg [ 1 ] ; } elseif ( mb_substr ( $ txt , $ CmpFrmI , 1 , 'UTF-8' ) === '2' ) { $ CmpFrmRV .= $ this -> aCmpReg [ 2 ] ; } else { $ CmpFrmRV .= mb_substr ( $ txt , $ CmpFrmI , 1 , 'UTF-8' ) ; } } return $ CmpFrmRV ; }
8561	public function cancelShipment ( $ request ) { if ( ! ( $ request instanceof MWSMerchantFulfillmentService_Model_CancelShipmentRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/CancelShipmentRequest.php' ) ; $ request = new MWSMerchantFulfillmentService_Model_CancelShipmentRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'CancelShipment' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/CancelShipmentResponse.php' ) ; $ response = MWSMerchantFulfillmentService_Model_CancelShipmentResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
11305	public static function email ( $ email = null , $ errorMsg = null ) { if ( ! $ email ) return null ; $ email = trim ( mb_strtolower ( trim ( $ email ) , "UTF-8" ) ) ; if ( ! filter_var ( $ email , FILTER_VALIDATE_EMAIL ) ) { return null ; } return $ email ; }
4856	public function setParams ( $ namespace , $ params ) { $ session = new Container ( $ namespace ) ; $ session -> params = $ params ; unset ( $ session -> list ) ; return $ this ; }
3954	public function getVariants ( $ objFilter ) { if ( $ this -> isVariantBase ( ) ) { return $ this -> getMetaModel ( ) -> findVariants ( array ( $ this -> get ( 'id' ) ) , $ objFilter ) ; } return null ; }
82	public function extractTo ( $ target , array $ roles = array ( 'php' => '/' , 'script' => '/bin' ) , $ vars = array ( ) ) { $ extractionPath = $ target . '/tarball' ; try { $ archive = new \ PharData ( $ this -> file ) ; $ archive -> extractTo ( $ extractionPath , null , true ) ; if ( ! is_file ( $ this -> combine ( $ extractionPath , '/package.xml' ) ) ) { throw new \ RuntimeException ( 'Invalid PEAR package. It must contain package.xml file.' ) ; } $ fileCopyActions = $ this -> buildCopyActions ( $ extractionPath , $ roles , $ vars ) ; $ this -> copyFiles ( $ fileCopyActions , $ extractionPath , $ target , $ roles , $ vars ) ; $ this -> filesystem -> removeDirectory ( $ extractionPath ) ; } catch ( \ Exception $ exception ) { throw new \ UnexpectedValueException ( sprintf ( 'Failed to extract PEAR package %s to %s. Reason: %s' , $ this -> file , $ target , $ exception -> getMessage ( ) ) , 0 , $ exception ) ; } }
5748	public static function removeLastCharsFromString ( string $ input , int $ numChars = 1 ) : string { if ( $ numChars > strlen ( $ input ) ) { throw new \ InvalidArgumentException ( "Cannot remove $numChars from $input" ) ; } return substr ( $ input , 0 , strlen ( $ input ) - $ numChars ) ; }
10429	private function initSyncStorageForMysql ( ContainerBuilder $ container , array $ config ) { $ doctrineConnection = sprintf ( 'doctrine.dbal.%s_connection' , $ config [ 'connection' ] ) ; $ definition = $ container -> getDefinition ( 'ongr_connections.sync.storage_manager.mysql_storage_manager' ) ; $ definition -> setArguments ( [ new Reference ( $ doctrineConnection , ContainerInterface :: IGNORE_ON_INVALID_REFERENCE ) , $ config [ 'table_name' ] , ] ) ; $ definition -> addMethodCall ( 'setContainer' , [ new Reference ( 'service_container' ) ] ) ; $ container -> getDefinition ( 'ongr_connections.sync.sync_storage' ) -> setArguments ( [ $ definition ] ) ; }
11255	public function call ( string $ class ) : void { $ files = $ this -> all ( $ class ) ; if ( count ( $ files ) < 1 ) { throw InvalidArgumentException :: forNotFoundSeeder ( ) ; } foreach ( $ files as [ $ file , $ content ] ) { $ this -> load ( $ content ) ; $ this -> resolve ( $ file [ 'filename' ] ) -> run ( ) ; } }
6074	public function restoreMedia ( $ id ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/media/' . $ id . '/restore' , $ parameters ) ; $ result = new MediaResponse ( $ result ) ; return $ result ; }
397	public static function getTableSchema ( ) { $ tableSchema = static :: getDb ( ) -> getSchema ( ) -> getTableSchema ( static :: tableName ( ) ) ; if ( $ tableSchema === null ) { throw new InvalidConfigException ( 'The table does not exist: ' . static :: tableName ( ) ) ; } return $ tableSchema ; }
8983	public function isSame ( TableNode $ expected , TableNode $ actual , $ message = NULL ) { $ this -> doAssert ( 'Failed asserting that two tables were identical: ' , [ ] , $ expected , $ actual , $ message ) ; }
11824	public function detect ( ) { $ str = file_get_contents ( $ this -> uri ) ; foreach ( $ this -> getBom ( 'all' ) as $ encoding => $ bom ) { if ( 0 === strncmp ( $ str , $ bom , strlen ( $ bom ) ) ) { return $ encoding ; } } }
12084	public function getObject ( Entity $ subject ) { $ object = NULL ; $ mediaObjectURI = $ subject -> getObjectURI ( ) ; if ( ! empty ( $ mediaObjectURI ) ) : $ mediaSubject = new Object ( ) ; $ mediaObjectType = $ subject -> getObjectType ( ) ; if ( is_object ( $ mediaSubject ) && method_exists ( $ mediaSubject , "getArray" ) ) : $ object = $ mediaSubject :: getArray ( ) ; endif ; else : endif ; return $ object ; }
4650	private function parseEnvironmentLine ( $ environmentLine ) { $ variables = array ( ) ; @ $ variableLines = explode ( ' ' , $ environmentLine ? : '' ) ; foreach ( $ variableLines as $ variableLine ) { if ( ! empty ( $ variableLine ) ) { list ( $ key , $ value ) = $ this -> parseEnvironementVariable ( $ variableLine ) ; $ variables [ $ key ] = $ value ; } } return $ variables ; }
723	public function checkIntegrity ( $ check = true , $ schema = '' , $ table = '' ) { $ enable = $ check ? 'CHECK' : 'NOCHECK' ; $ schema = $ schema ? : $ this -> db -> getSchema ( ) -> defaultSchema ; $ tableNames = $ this -> db -> getTableSchema ( $ table ) ? [ $ table ] : $ this -> db -> getSchema ( ) -> getTableNames ( $ schema ) ; $ viewNames = $ this -> db -> getSchema ( ) -> getViewNames ( $ schema ) ; $ tableNames = array_diff ( $ tableNames , $ viewNames ) ; $ command = '' ; foreach ( $ tableNames as $ tableName ) { $ tableName = $ this -> db -> quoteTableName ( "{$schema}.{$tableName}" ) ; $ command .= "ALTER TABLE $tableName $enable CONSTRAINT ALL; " ; } return $ command ; }
3717	public static function withName ( $ columnName , $ tableName , $ code = 0 , $ previous = null ) { return new static ( sprintf ( 'Column "%s" already exists on table "%s' , $ columnName , $ tableName ) , $ code , $ previous ) ; }
11199	public function processDelete ( $ name , $ container = false ) { if ( ! $ container ) { $ container = $ this ; } if ( isset ( $ container -> singleton -> $ name ) ) { unset ( $ container -> singleton -> $ name ) ; return true ; } if ( isset ( $ container -> signature -> $ name ) ) { unset ( $ container -> signature -> $ name ) ; return true ; } elseif ( $ container -> parent ) { return $ container -> processDelete ( $ name , $ container -> parent ) ; } return false ; }
11659	public static function removeEntriesFromFile ( $ file , $ entries ) { $ properties = self :: readFromFile ( $ file ) ; if ( is_string ( $ entries ) ) { unset ( $ properties [ $ entries ] ) ; } else { foreach ( $ entries as $ i => $ key ) { unset ( $ properties [ $ key ] ) ; } } self :: saveToFile ( $ file , $ properties ) ; }
6785	public function buildFormDataString ( $ options ) { $ options = $ this -> resolve ( $ options ) ; $ formOptions = [ ] ; foreach ( $ this -> formParameters as $ key => $ isFormParameter ) { if ( $ isFormParameter && isset ( $ options [ $ key ] ) ) { $ formOptions [ $ key ] = $ options [ $ key ] ; } } return http_build_query ( $ formOptions ) ; }
8639	public function setDirectPaymentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'DirectPaymentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
2006	protected function removeRecipient ( $ strEmail , $ arrRemove ) { if ( ( $ objRemove = NewsletterRecipientsModel :: findByEmailAndPids ( $ strEmail , $ arrRemove ) ) !== null ) { while ( $ objRemove -> next ( ) ) { $ strHash = md5 ( $ objRemove -> email ) ; if ( ( $ objBlacklist = NewsletterBlacklistModel :: findByHashAndPid ( $ strHash , $ objRemove -> pid ) ) === null ) { $ objBlacklist = new NewsletterBlacklistModel ( ) ; $ objBlacklist -> pid = $ objRemove -> pid ; $ objBlacklist -> hash = $ strHash ; $ objBlacklist -> save ( ) ; } $ objRemove -> delete ( ) ; } } $ objChannels = NewsletterChannelModel :: findByIds ( $ arrRemove ) ; $ arrChannels = $ objChannels -> fetchEach ( 'title' ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'removeRecipient' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'removeRecipient' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'removeRecipient' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ strEmail , $ arrRemove ) ; } } $ arrData = array ( ) ; $ arrData [ 'domain' ] = Idna :: decode ( Environment :: get ( 'host' ) ) ; $ arrData [ 'channel' ] = $ arrData [ 'channels' ] = implode ( "\n" , $ arrChannels ) ; $ objEmail = new Email ( ) ; $ objEmail -> from = $ GLOBALS [ 'TL_ADMIN_EMAIL' ] ; $ objEmail -> fromName = $ GLOBALS [ 'TL_ADMIN_NAME' ] ; $ objEmail -> subject = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'nl_subject' ] , Idna :: decode ( Environment :: get ( 'host' ) ) ) ; $ objEmail -> text = StringUtil :: parseSimpleTokens ( $ this -> nl_unsubscribe , $ arrData ) ; $ objEmail -> sendTo ( $ strEmail ) ; if ( ( $ objTarget = $ this -> objModel -> getRelated ( 'jumpTo' ) ) instanceof PageModel ) { $ this -> redirect ( $ objTarget -> getFrontendUrl ( ) ) ; } System :: getContainer ( ) -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'nl_removed' , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'nl_removed' ] ) ; $ this -> reload ( ) ; }
9491	public function getFileListData ( $ sFieldName ) { if ( empty ( $ sFieldName ) ) { return [ ] ; } $ obFileList = $ this -> $ sFieldName ; if ( $ obFileList -> isEmpty ( ) ) { return [ ] ; } $ arResult = [ ] ; foreach ( $ obFileList as $ obFile ) { if ( empty ( $ obFile ) || ! $ obFile instanceof File ) { continue ; } $ arResult [ ] = $ this -> getFileDataValue ( $ obFile ) ; } return $ arResult ; }
9990	private function writeImageInCell ( Worksheet $ pSheet , $ coordinates ) { $ html = '' ; foreach ( $ pSheet -> getDrawingCollection ( ) as $ drawing ) { if ( $ drawing instanceof Drawing ) { if ( $ drawing -> getCoordinates ( ) == $ coordinates ) { $ filename = $ drawing -> getPath ( ) ; if ( substr ( $ filename , 0 , 1 ) == '.' ) { $ filename = substr ( $ filename , 1 ) ; } $ filename = $ this -> getImagesRoot ( ) . $ filename ; if ( substr ( $ filename , 0 , 1 ) == '.' && substr ( $ filename , 0 , 2 ) != './' ) { $ filename = substr ( $ filename , 1 ) ; } $ filename = htmlspecialchars ( $ filename ) ; $ html .= PHP_EOL ; if ( ( ! $ this -> embedImages ) || ( $ this -> isPdf ) ) { $ imageData = $ filename ; } else { $ imageDetails = getimagesize ( $ filename ) ; if ( $ fp = fopen ( $ filename , 'rb' , 0 ) ) { $ picture = fread ( $ fp , filesize ( $ filename ) ) ; fclose ( $ fp ) ; $ base64 = chunk_split ( base64_encode ( $ picture ) ) ; $ imageData = 'data:' . $ imageDetails [ 'mime' ] . ';base64,' . $ base64 ; } else { $ imageData = $ filename ; } } $ html .= '<div style="position: relative;">' ; $ html .= '<img style="position: absolute; z-index: 1; left: ' . $ drawing -> getOffsetX ( ) . 'px; top: ' . $ drawing -> getOffsetY ( ) . 'px; width: ' . $ drawing -> getWidth ( ) . 'px; height: ' . $ drawing -> getHeight ( ) . 'px;" src="' . $ imageData . '" border="0" />' ; $ html .= '</div>' ; } } elseif ( $ drawing instanceof MemoryDrawing ) { if ( $ drawing -> getCoordinates ( ) != $ coordinates ) { continue ; } ob_start ( ) ; imagepng ( $ drawing -> getImageResource ( ) ) ; $ contents = ob_get_contents ( ) ; ob_end_clean ( ) ; $ dataUri = 'data:image/jpeg;base64,' . base64_encode ( $ contents ) ; $ html .= '<img src="' . $ dataUri . '" style="max-width:100%;width:' . $ drawing -> getWidth ( ) . 'px;" />' ; } } return $ html ; }
6880	public function transform ( $ data ) { $ address = new ShipmentAddress ( ) ; if ( ! is_array ( $ data ) || empty ( $ data ) ) { return $ address ; } foreach ( $ this -> fields as $ field ) { if ( isset ( $ data [ $ field ] ) ) { $ value = $ data [ $ field ] ; if ( $ field === 'country' ) { if ( 0 >= $ value ) { throw new InvalidArgumentException ( "Invalid country id." ) ; } $ value = $ this -> countryRepository -> find ( $ value ) ; if ( null === $ value ) { throw new InvalidArgumentException ( "Country not found." ) ; } } elseif ( $ field === 'phone' || $ field === 'mobile' ) { $ value = unserialize ( $ value ) ; if ( ! $ value instanceof PhoneNumber ) { throw new InvalidArgumentException ( "Invalid phone number." ) ; } } $ this -> accessor -> setValue ( $ address , $ field , $ value ) ; } } return $ address ; }
392	protected static function filterCondition ( array $ condition , array $ aliases = [ ] ) { $ result = [ ] ; $ db = static :: getDb ( ) ; $ columnNames = static :: filterValidColumnNames ( $ db , $ aliases ) ; foreach ( $ condition as $ key => $ value ) { if ( is_string ( $ key ) && ! in_array ( $ db -> quoteSql ( $ key ) , $ columnNames , true ) ) { throw new InvalidArgumentException ( 'Key "' . $ key . '" is not a column name and can not be used as a filter' ) ; } $ result [ $ key ] = is_array ( $ value ) ? array_values ( $ value ) : $ value ; } return $ result ; }
5649	public function assign ( $ key , $ value ) { if ( $ this -> $ key === false ) { $ this -> all [ $ key ] = $ value ; } elseif ( ! is_array ( $ this -> $ key ) ) { $ this -> all [ $ key ] = array ( $ this -> $ key , $ value ) ; } else { $ this -> all [ $ key ] [ ] = $ value ; } }
12737	protected function translate ( ) { $ translatorOptions = $ this -> getTranslatorOptions ( ) ; if ( empty ( $ translatorOptions ) && ! array_key_exists ( "fields" , $ translatorOptions ) ) { return ; } $ params = array ( ) ; if ( array_key_exists ( "params" , $ translatorOptions ) ) { $ params = $ translatorOptions [ "params" ] ; } $ domain = "RedKiteCms" ; if ( array_key_exists ( "domain" , $ translatorOptions ) ) { $ domain = $ translatorOptions [ "domain" ] ; } foreach ( $ translatorOptions [ "fields" ] as $ field ) { $ field = ucfirst ( $ field ) ; $ method = 'get' . $ field ; $ value = Translator :: translate ( $ this -> $ method ( ) , $ params , $ domain ) ; $ method = 'set' . $ field ; $ this -> $ method ( $ value ) ; } }
6770	protected function handleStateChange ( SaleInterface $ sale ) { if ( $ this -> configureAcceptedSale ( $ sale ) ) { $ this -> persistenceHelper -> persistAndRecompute ( $ sale , false ) ; } }
508	protected function composeFields ( $ id = null , $ data = null ) { $ fields = $ this -> writeCallback ? call_user_func ( $ this -> writeCallback , $ this ) : [ ] ; if ( $ id !== null ) { $ fields [ 'id' ] = $ id ; } if ( $ data !== null ) { $ fields [ 'data' ] = $ data ; } return $ fields ; }
3518	public function setShowUnpublished ( $ showUnpublished ) { if ( $ this -> useCookies ) { Cookie :: queue ( $ this -> cookiePrefix . 'show_unpublished' , $ showUnpublished ) ; } $ this -> useDB = $ showUnpublished ? 2 : 1 ; }
2197	public function onAuthenticationSuccess ( Request $ request , TokenInterface $ token ) : RedirectResponse { $ this -> user = $ token -> getUser ( ) ; if ( ! $ this -> user instanceof User ) { return $ this -> getRedirectResponse ( $ request ) ; } $ this -> user -> lastLogin = $ this -> user -> currentLogin ; $ this -> user -> currentLogin = time ( ) ; $ this -> user -> save ( ) ; if ( null !== $ this -> logger ) { $ this -> logger -> info ( sprintf ( 'User "%s" has logged in' , $ this -> user -> username ) , [ 'contao' => new ContaoContext ( __METHOD__ , ContaoContext :: ACCESS , $ this -> user -> username ) ] ) ; } $ this -> triggerPostLoginHook ( ) ; return $ this -> getRedirectResponse ( $ request ) ; }
2203	public static function decodeEntities ( $ varValue ) { if ( $ varValue === null || $ varValue == '' ) { return $ varValue ; } if ( \ is_array ( $ varValue ) ) { foreach ( $ varValue as $ k => $ v ) { $ varValue [ $ k ] = static :: decodeEntities ( $ v ) ; } return $ varValue ; } $ varValue = static :: preserveBasicEntities ( $ varValue ) ; $ varValue = html_entity_decode ( $ varValue , ENT_QUOTES , Config :: get ( 'characterSet' ) ) ; return $ varValue ; }
2722	public function aroundSendPurgeRequest ( PurgeCache $ subject , callable $ proceed , ... $ args ) { if ( $ this -> config -> isFastlyEnabled ( ) !== true ) { $ proceed ( ... $ args ) ; } }
10873	public function cleanUser ( string $ validate = null ) : int { $ result = 0 ; if ( $ validate ) { $ validateTo = new DateTime ; $ validateTo -> modify ( $ validate ) ; $ list = $ this -> getList ( ) -> where ( [ $ this -> tableName [ 0 ] . '.active' => false , $ this -> tableName [ 0 ] . '.added IS NOT NULL' , [ $ this -> tableName [ 0 ] . '.added<=%dt' , $ validateTo ] , ] ) ; foreach ( $ list as $ item ) { if ( $ this -> delete ( $ item [ self :: COLUMN_ID ] ) ) { $ result ++ ; } } } return $ result ; }
2903	public function downloadAsText ( Mage_Core_Model_Config_Element $ configNode ) { $ items = array ( ) ; Mage :: helper ( 'sheep_debug' ) -> xml2array ( $ configNode , $ items ) ; $ content = '' ; foreach ( $ items as $ key => $ value ) { $ content .= "$key = $value\n" ; } $ this -> _prepareDownloadResponse ( 'config.txt' , $ content , 'text/plain' ) ; }
9076	public function addTag ( $ name , array $ attributes = array ( ) ) { foreach ( $ this -> rules as $ rule ) { $ rule -> addTag ( $ name , $ attributes ) ; } }
1321	private function request ( $ url , $ method , $ authorization , array $ postfields , $ json = false ) { $ options = $ this -> curlOptions ( ) ; $ options [ CURLOPT_URL ] = $ url ; $ options [ CURLOPT_HTTPHEADER ] = [ 'Accept: application/json' , $ authorization , 'Expect:' ] ; switch ( $ method ) { case 'GET' : break ; case 'POST' : $ options [ CURLOPT_POST ] = true ; if ( $ json ) { $ options [ CURLOPT_HTTPHEADER ] [ ] = 'Content-type: application/json' ; $ options [ CURLOPT_POSTFIELDS ] = json_encode ( $ postfields ) ; } else { $ options [ CURLOPT_POSTFIELDS ] = Util :: buildHttpQuery ( $ postfields ) ; } break ; case 'DELETE' : $ options [ CURLOPT_CUSTOMREQUEST ] = 'DELETE' ; break ; case 'PUT' : $ options [ CURLOPT_CUSTOMREQUEST ] = 'PUT' ; break ; } if ( in_array ( $ method , [ 'GET' , 'PUT' , 'DELETE' ] ) && ! empty ( $ postfields ) ) { $ options [ CURLOPT_URL ] .= '?' . Util :: buildHttpQuery ( $ postfields ) ; } $ curlHandle = curl_init ( ) ; curl_setopt_array ( $ curlHandle , $ options ) ; $ response = curl_exec ( $ curlHandle ) ; if ( curl_errno ( $ curlHandle ) > 0 ) { throw new TwitterOAuthException ( curl_error ( $ curlHandle ) , curl_errno ( $ curlHandle ) ) ; } $ this -> response -> setHttpCode ( curl_getinfo ( $ curlHandle , CURLINFO_HTTP_CODE ) ) ; $ parts = explode ( "\r\n\r\n" , $ response ) ; $ responseBody = array_pop ( $ parts ) ; $ responseHeader = array_pop ( $ parts ) ; $ this -> response -> setHeaders ( $ this -> parseHeaders ( $ responseHeader ) ) ; curl_close ( $ curlHandle ) ; return $ responseBody ; }
2644	public function getCustomerInfo ( ) { $ uri = $ this -> config -> getApiEndpoint ( ) . 'current_customer' ; $ result = $ this -> _fetch ( $ uri ) ; return $ result ; }
7709	function GetInnerSrc ( ) { return ( $ this -> pET_PosBeg === false ) ? false : substr ( $ this -> Txt , $ this -> pST_PosEnd + 1 , $ this -> pET_PosBeg - $ this -> pST_PosEnd - 1 ) ; }
4186	public function search ( ) { $ url = self :: PACKAGIST_URL . 'search.json?q=' . $ this -> getPackageName ( ) ; $ response = $ this -> client -> get ( $ url ) -> getBody ( ) -> getContents ( ) ; $ this -> rawPackages = collect ( json_decode ( $ response , true ) ) ; return collect ( $ this -> rawPackages -> get ( 'results' ) ) ; }
8733	public function update ( array $ values ) { $ updated = 0 ; $ modelKey = $ this -> getModel ( ) -> getKey ( ) ; $ modelKeyName = $ this -> model -> getKeyName ( ) ; $ values = $ this -> addUpdatedAtColumn ( $ values ) ; list ( $ values , $ i18nValues ) = $ this -> filterValues ( $ values ) ; $ ids = $ modelKey ? [ $ modelKey ] : $ this -> pluck ( $ modelKeyName ) -> all ( ) ; if ( $ values ) { $ updated += $ this -> updateBase ( $ values , $ ids ) ; } if ( $ i18nValues ) { $ updated += $ this -> updateI18n ( $ i18nValues , $ ids ) ; } return $ updated ; }
11581	public function bootstrap ( $ rootDir , $ siteName ) { $ this -> app [ "red_kite_cms.root_dir" ] = $ rootDir ; $ this -> siteName = $ siteName ; $ this -> checkPermissions ( $ rootDir ) ; $ this -> initCmsRequiredServices ( ) ; $ this -> registerProviders ( ) ; $ this -> registerServices ( ) ; $ this -> registerListeners ( ) ; $ this -> register ( $ this -> app ) ; $ this -> boot ( ) ; $ this -> addWebsiteRoutes ( ) ; $ this -> app [ "dispatcher" ] -> dispatch ( CmsEvents :: CMS_BOOTED , new CmsBootedEvent ( $ this -> app [ "red_kite_cms.configuration_handler" ] ) ) ; }
6396	public function run ( ) : void { $ thrownException = null ; try { $ this -> lock -> lock ( ) ; try { $ this -> runnable -> run ( ) ; } catch ( Exception $ e ) { self :: getLogger ( ) -> error ( $ e ) ; $ thrownException = $ e ; } $ this -> lock -> unLock ( ) ; } catch ( LockException $ e ) { throw new RunException ( 'Lock error during running.' , 0 , $ e ) ; } if ( $ thrownException !== null ) { throw new RunException ( 'Error during execution wrapped Runnable object.' , 0 , $ thrownException ) ; } }
365	public function renderColumnGroup ( ) { foreach ( $ this -> columns as $ column ) { if ( ! empty ( $ column -> options ) ) { $ cols = [ ] ; foreach ( $ this -> columns as $ col ) { $ cols [ ] = Html :: tag ( 'col' , '' , $ col -> options ) ; } return Html :: tag ( 'colgroup' , implode ( "\n" , $ cols ) ) ; } } return false ; }
2377	public static function convertEncoding ( $ str , $ to , $ from = null ) { if ( $ str == '' ) { return '' ; } if ( ! $ from ) { $ from = mb_detect_encoding ( $ str , 'ASCII,ISO-2022-JP,UTF-8,EUC-JP,ISO-8859-1' ) ; } if ( $ from == $ to ) { return $ str ; } if ( $ from == 'UTF-8' && $ to == 'ISO-8859-1' ) { return utf8_decode ( $ str ) ; } if ( $ from == 'ISO-8859-1' && $ to == 'UTF-8' ) { return utf8_encode ( $ str ) ; } return mb_convert_encoding ( $ str , $ to , $ from ) ; }
3062	public function canMoveBackward ( ) { $ moveBack = false ; $ session = $ this -> getTestSession ( ) ; if ( $ this -> isAdaptive ( ) ) { $ positionInCatSession = array_search ( $ this -> getCurrentCatItemId ( ) , $ this -> getShadowTest ( ) ) ; if ( $ positionInCatSession === 0 ) { if ( $ session -> getRoute ( ) -> getPosition ( ) !== 0 ) { $ moveBack = $ session -> getPreviousRouteItem ( ) -> getTestPart ( ) -> getNavigationMode ( ) === NavigationMode :: NONLINEAR ; } } else { $ moveBack = $ session -> getRoute ( ) -> current ( ) -> getTestPart ( ) -> getNavigationMode ( ) === NavigationMode :: NONLINEAR ; } } else { $ moveBack = $ session -> canMoveBackward ( ) ; if ( $ moveBack ) { $ moveBack = $ this -> getServiceManager ( ) -> get ( SectionPauseService :: SERVICE_ID ) -> canMoveBackward ( $ session ) ; } } return $ moveBack ; }
4185	public function search ( ) { $ this -> console -> info ( 'Searching directory for service providers.' ) ; $ sps = $ this -> getProviders ( ) ; if ( ! $ sps -> count ( ) ) { $ this -> console -> warn ( 'No service provider file found. Nothing to install.' ) ; return [ ] ; } $ this -> console -> line ( " Found {$sps->count()} Service provider" . ( $ sps -> count ( ) > 1 ? 's' : '' ) . '.' ) ; $ sps -> each ( function ( $ sp , $ index ) { $ currentCount = $ index + 1 ; $ this -> console -> line ( " $currentCount. $sp" ) ; } ) ; if ( ! $ this -> console -> confirm ( 'Register service providers?' , true ) ) { return [ ] ; } $ this -> registered = true ; return $ this -> getProviders ( ) -> toArray ( ) ; }
6742	public function apply ( Request $ request , ParamConverter $ configuration ) { $ param = $ this -> getRequestAttributeName ( $ request , $ configuration ) ; if ( ! $ request -> attributes -> has ( $ param ) ) { return false ; } $ value = $ request -> attributes -> get ( $ param ) ; if ( ! $ value && $ configuration -> isOptional ( ) ) { return false ; } $ convertedValue = $ this -> convertValue ( $ value , $ configuration ) ; if ( null === $ convertedValue && false === $ configuration -> isOptional ( ) ) { throw new NotFoundHttpException ( "Unable to find '{$configuration->getClass()}' with identifier '{$value}' not found" ) ; } $ request -> attributes -> set ( $ configuration -> getName ( ) , $ convertedValue ) ; return true ; }
5360	protected function createBodyStatements ( Operation $ operation , $ queryParamVariable , Context $ context ) { $ bodyParameter = null ; $ bodyVariable = new Expr \ Variable ( 'body' ) ; $ parameterKey = 0 ; if ( $ operation -> getOperation ( ) -> getParameters ( ) ) { foreach ( $ operation -> getOperation ( ) -> getParameters ( ) as $ key => $ parameter ) { if ( $ parameter instanceof BodyParameter ) { $ bodyParameter = $ parameter ; $ parameterKey = $ key ; } } } if ( null === $ bodyParameter ) { return [ [ new Expr \ Assign ( $ bodyVariable , new Expr \ MethodCall ( $ queryParamVariable , 'buildFormDataString' , [ new Arg ( new Expr \ Variable ( 'parameters' ) ) ] ) ) ] , $ bodyVariable ] ; } if ( $ bodyParameter -> getSchema ( ) instanceof Reference || $ context -> getRegistry ( ) -> hasClass ( $ operation -> getReference ( ) . '/parameters/' . $ parameterKey ) ) { return [ [ new Expr \ Assign ( $ bodyVariable , new Expr \ MethodCall ( new Expr \ PropertyFetch ( new Expr \ Variable ( 'this' ) , 'serializer' ) , 'serialize' , [ new Arg ( new Expr \ Variable ( Inflector :: camelize ( $ bodyParameter -> getName ( ) ) ) ) , new Arg ( new Scalar \ String_ ( 'json' ) ) ] ) ) ] , $ bodyVariable ] ; } return [ [ new Expr \ Assign ( $ bodyVariable , new Expr \ Variable ( Inflector :: camelize ( $ bodyParameter -> getName ( ) ) ) ) ] , $ bodyVariable ] ; }
6527	public static function resolveCurie ( $ curie ) : string { $ key = ( string ) $ curie ; if ( isset ( self :: $ curies [ $ key ] ) ) { return self :: $ classes [ self :: $ curies [ $ key ] ] ; } throw new NoMessageForCurie ( SchemaCurie :: fromString ( $ key ) ) ; }
6148	public function setBody ( $ body ) { if ( is_string ( $ body ) ) { $ this -> body = $ body ; } elseif ( is_array ( $ body ) ) { $ this -> setJsonBody ( $ body ) ; } elseif ( is_callable ( $ body ) ) { ob_start ( ) ; $ res1 = call_user_func ( $ body ) ; $ res2 = ob_get_contents ( ) ; $ this -> body = $ res2 . $ res1 ; ob_end_clean ( ) ; } return $ this ; }
9173	public function reverseTransform ( $ jsonMenuNodes ) { if ( $ jsonMenuNodes instanceof Collection && $ jsonMenuNodes -> count ( ) === 0 ) { return new ArrayCollection ( ) ; } $ this -> allNodes = [ ] ; $ firstNode = json_decode ( $ jsonMenuNodes -> first ( ) ) [ 0 ] ; $ menuItemsArray = $ this -> recursiveNodeHandling ( json_decode ( $ jsonMenuNodes -> first ( ) ) ) ; return new ArrayCollection ( $ menuItemsArray ) ; }
2954	protected function findTemplate ( $ text ) { $ matchedTemplate = [ ] ; $ maxMatch = - 1 ; foreach ( $ this -> directoryIterator as $ fileInfo ) { $ templateContent = file_get_contents ( $ fileInfo -> getPathname ( ) ) ; similar_text ( $ text , $ templateContent , $ matchPercentage ) ; if ( $ matchPercentage > $ maxMatch ) { $ this -> logger -> debug ( sprintf ( 'Template "%s" is a best match for now' , $ fileInfo -> getPathname ( ) ) ) ; $ maxMatch = $ matchPercentage ; $ matchedTemplate = [ $ fileInfo -> getPathname ( ) => $ templateContent ] ; } } return $ matchedTemplate ; }
874	public function getAnnotationsOfType ( $ types ) { $ annotations = [ ] ; $ types = ( array ) $ types ; foreach ( $ this -> getAnnotations ( ) as $ annotation ) { $ tag = $ annotation -> getTag ( ) -> getName ( ) ; foreach ( $ types as $ type ) { if ( $ type === $ tag ) { $ annotations [ ] = $ annotation ; } } } return $ annotations ; }
3285	public function getSourceContext ( $ name ) : Source { if ( ! $ this -> exists ( $ name ) ) { throw new LoaderError ( sprintf ( 'Unable to find template "%s" from template map' , $ name ) ) ; } if ( ! file_exists ( $ this -> map [ $ name ] ) ) { throw new LoaderError ( sprintf ( 'Unable to open file "%s" from template map' , $ this -> map [ $ name ] ) ) ; } $ content = file_get_contents ( $ this -> map [ $ name ] ) ; $ source = new Source ( $ content , $ name , $ this -> map [ $ name ] ) ; return $ source ; }
9553	public function allowExtensions ( $ extensions ) { if ( ! is_array ( $ extensions ) ) { $ extensions = [ $ extensions ] ; } $ this -> constraints [ ] = new ExtensionConstraint ( $ extensions ) ; return $ this ; }
8715	public function getAccessToken ( ) : ApiAccessToken { try { $ accessToken = $ this -> tokenStorage -> getAccessToken ( ) ; } catch ( UnableToAcquireAccessToken $ e ) { $ accessToken = null ; } if ( $ accessToken && $ accessToken -> isExpired ( ) ) { $ this -> tokenStorage -> unsetAccessToken ( ) ; $ accessToken = null ; } return $ accessToken ? : $ this -> refreshToken ( ) ; }
5444	protected function reduce ( $ raw ) { if ( $ action = $ this -> regexes [ $ this -> mode -> getCurrent ( ) ] -> match ( $ raw , $ match ) ) { $ unparsed_character_count = strpos ( $ raw , $ match ) ; $ unparsed = substr ( $ raw , 0 , $ unparsed_character_count ) ; $ raw = substr ( $ raw , $ unparsed_character_count + strlen ( $ match ) ) ; return array ( $ raw , $ unparsed , $ match , $ action ) ; } return true ; }
127	public function ensureBinariesPresence ( PackageInterface $ package ) { $ this -> binaryInstaller -> installBinaries ( $ package , $ this -> getInstallPath ( $ package ) , false ) ; }
12629	public function sendToDevice ( $ deviceId , $ openId , $ content ) { $ params = [ 'device_type' => $ this -> deviceType , 'device_id' => $ deviceId , 'open_id' => $ openId , 'content' => base64_encode ( $ content ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_TRANS_MSG , $ params ] ) ; }
3800	public function getMetaModel ( EnvironmentInterface $ interface ) { $ metaModelId = $ this -> connection -> createQueryBuilder ( ) -> select ( 'd.pid' ) -> from ( 'tl_metamodel_dca' , 'd' ) -> leftJoin ( 'd' , 'tl_metamodel_dcasetting' , 's' , '(d.id=s.pid)' ) -> where ( '(s.id=:id)' ) -> setParameter ( 'id' , ModelId :: fromSerialized ( $ interface -> getInputProvider ( ) -> getParameter ( 'pid' ) ) -> getId ( ) ) -> execute ( ) ; if ( $ tableName = $ this -> factory -> translateIdToMetaModelName ( $ metaModelId = $ metaModelId -> fetchColumn ( ) ) ) { return $ this -> factory -> getMetaModel ( $ tableName ) ; } throw new \ RuntimeException ( 'Could not retrieve MetaModel ' . $ metaModelId ) ; }
4941	public function getAllowedTypes ( $ asArray = false ) { $ types = $ this -> getAttribute ( 'data-allowedtypes' ) ; if ( $ asArray ) { return explode ( ',' , $ types ) ; } return $ types ; }
7531	function toString ( $ attributes = true , $ recursive = true , $ content_only = false ) { if ( $ content_only ) { if ( is_int ( $ content_only ) ) { -- $ content_only ; } return $ this -> toString_content ( $ attributes , $ recursive , $ content_only ) ; } $ s = '<' . $ this -> tag ; if ( $ attributes ) { $ s .= $ this -> toString_attributes ( ) ; } if ( $ this -> self_close ) { $ s .= $ this -> self_close_str . '>' ; } else { $ s .= '>' ; if ( $ recursive ) { $ s .= $ this -> toString_content ( $ attributes ) ; } $ s .= '</' . $ this -> tag . '>' ; } return $ s ; }
4721	public function processListItems ( Text $ list , array $ options = array ( ) , $ level = 0 ) { $ list -> replace ( '/\n{2,}\z/' , "\n" ) ; $ list -> replace ( '{ (\n)? # leading line = $1 (^[ \t]*) # leading whitespace = $2 (' . $ this -> getPattern ( ) . ') [ \t]+ # list marker = $3 ((?s:.+?) # list item text = $4 (\n{1,2})) (?= \n* (\z | \2 (' . $ this -> getPattern ( ) . ') [ \t]+)) }mx' , function ( Text $ w , Text $ leadingLine , Text $ ls , Text $ m , Text $ item ) use ( $ options , $ level ) { if ( ( string ) $ leadingLine || $ item -> match ( '/\n{2,}/' ) ) { $ this -> markdown -> emit ( 'outdent' , array ( $ item ) ) ; $ this -> markdown -> emit ( 'block' , array ( $ item ) ) ; } else { $ this -> markdown -> emit ( 'outdent' , array ( $ item ) ) ; $ this -> processList ( $ item , $ options , ++ $ level ) ; $ item -> rtrim ( ) ; $ this -> markdown -> emit ( 'inline' , array ( $ item ) ) ; } return $ this -> getRenderer ( ) -> renderListItem ( $ item ) . "\n" ; } ) ; }
1391	protected function resourceFieldsExistInAttributesAndRelationships ( iterable $ fields ) : void { foreach ( $ fields as $ field ) { $ this -> errors -> add ( $ this -> translator -> resourceFieldExistsInAttributesAndRelationships ( $ field ) ) ; } }
12732	public function handle ( $ signal ) { if ( isset ( $ this -> _bySignal [ $ signal ] ) ) { foreach ( $ this -> _bySignal [ $ signal ] as $ reg ) { $ reg -> interrupt = $ signal ; } } else { return SIG_DFL ; } }
7538	function getRoot ( ) { $ r = $ this -> parent ; $ n = ( $ r === null ) ? null : $ r -> parent ; while ( $ n !== null ) { $ r = $ n ; $ n = $ r -> parent ; } return $ r ; }
4698	public static function compare ( $ hasha = "" , $ hashb = "" ) { $ hashes_are_not_equal = strlen ( $ hasha ) ^ strlen ( $ hashb ) ; $ length = min ( strlen ( $ hasha ) , strlen ( $ hashb ) ) ; $ hasha = substr ( $ hasha , 0 , $ length ) ; $ hashb = substr ( $ hashb , 0 , $ length ) ; for ( $ i = 0 ; $ i < strlen ( $ hasha ) ; $ i ++ ) { $ hashes_are_not_equal += ! ( ord ( $ hasha [ $ i ] ) === ord ( $ hashb [ $ i ] ) ) ; } return ! $ hashes_are_not_equal ; }
5807	public function onAfterWrite ( ) { parent :: onAfterWrite ( ) ; $ write = 'Title' ; $ class = $ this -> owner -> ClassName ; foreach ( Config :: inst ( ) -> get ( 'FusionService' , 'custom_tag_types' ) as $ type => $ field ) { if ( $ type === $ class ) { $ write = $ field ; } } $ changed = $ this -> owner -> getChangedFields ( ) ; $ existing = FusionTag :: get ( ) -> filter ( 'Title' , $ this -> owner -> $ write ) -> first ( ) ; if ( is_null ( $ this -> owner -> FusionTagID ) && ! $ existing ) { $ fusion = FusionTag :: create ( ) ; $ fusion -> Title = $ this -> owner -> $ write ; $ fusion -> TagTypes = serialize ( array ( $ class => $ class ) ) ; $ fusion -> write ( ) ; $ this -> owner -> FusionTagID = $ fusion -> ID ; $ this -> owner -> write ( ) ; } else if ( is_null ( $ this -> owner -> FusionTagID ) && $ existing ) { $ types = unserialize ( $ existing -> TagTypes ) ; $ types [ $ class ] = $ class ; $ existing -> TagTypes = serialize ( $ types ) ; $ existing -> write ( ) ; $ this -> owner -> FusionTagID = $ existing -> ID ; $ this -> owner -> write ( ) ; } else if ( isset ( $ changed [ $ write ] ) && ! isset ( $ changed [ 'FusionTagID' ] ) && $ existing && ( $ existing -> ID != $ this -> owner -> FusionTagID ) ) { $ fusion = FusionTag :: get ( ) -> byID ( $ this -> owner -> FusionTagID ) ; $ types = unserialize ( $ fusion -> TagTypes ) ; unset ( $ types [ $ this -> owner -> ClassName ] ) ; $ fusion -> TagTypes = ! empty ( $ types ) ? serialize ( $ types ) : null ; $ fusion -> write ( ) ; $ types = unserialize ( $ existing -> TagTypes ) ; $ types [ $ class ] = $ class ; $ existing -> TagTypes = serialize ( $ types ) ; $ existing -> write ( ) ; $ this -> owner -> FusionTagID = $ existing -> ID ; $ this -> owner -> write ( ) ; } else if ( isset ( $ changed [ $ write ] ) && ! isset ( $ changed [ 'FusionTagID' ] ) && ( $ existing = FusionTag :: get ( ) -> byID ( $ this -> owner -> FusionTagID ) ) ) { $ existing -> Title = $ changed [ $ write ] [ 'after' ] ; $ existing -> write ( ) ; } }
3315	public function set ( $ key , $ value ) { Arr :: set ( $ this -> configs , $ key , $ value ) ; return $ this ; }
3044	public function encode ( $ data ) { if ( is_array ( $ data ) ) { $ encodedData = [ self :: STORAGE_KEY_FORMAT => $ this -> getFormat ( ) , self :: STORAGE_KEY_VERSION => $ this -> getVersion ( ) , ] ; foreach ( $ data as $ key => & $ value ) { if ( $ value instanceof TimeLine ) { $ encodedData [ $ key ] = $ this -> packTimeLine ( $ value ) ; } else { $ encodedData [ $ key ] = & $ value ; } } return json_encode ( $ encodedData ) ; } return json_encode ( $ data ) ; }
4182	public static function instance ( ) { switch ( func_num_args ( ) ) { case func_num_args ( ) == 0 : return new static ( ) ; case func_num_args ( ) == 1 : return new static ( func_get_arg ( 0 ) ) ; case func_num_args ( ) == 2 : return new static ( func_get_arg ( 0 ) , func_get_arg ( 1 ) ) ; case func_num_args ( ) == 3 : return new static ( func_get_arg ( 0 ) , func_get_arg ( 1 ) , func_get_arg ( 2 ) ) ; case func_num_args ( ) == 4 : return new static ( func_get_arg ( 0 ) , func_get_arg ( 1 ) , func_get_arg ( 2 ) , func_get_arg ( 3 ) ) ; case func_num_args ( ) == 5 : return new static ( func_get_arg ( 0 ) , func_get_arg ( 1 ) , func_get_arg ( 2 ) , func_get_arg ( 3 ) , func_get_arg ( 4 ) ) ; default : throw new Exception ( 'Unable to instantiate class with given arguments' ) ; } }
2885	public function saveProfiling ( ) { if ( ! $ this -> canCollect ( ) || ! Mage :: helper ( 'sheep_debug' ) -> canPersist ( ) ) { return ; } if ( Mage :: helper ( 'sheep_debug' ) -> hasDisablePersistenceCookie ( ) ) { return ; } if ( ! $ this -> getRequestInfo ( ) -> getIsStarted ( ) ) { return ; } $ this -> getRequestInfo ( ) -> save ( ) ; }
3555	protected function castValue ( ) { $ value = $ this -> attributes [ 'meta_value' ] ; $ validTypes = [ 'boolean' , 'integer' , 'float' , 'double' , 'array' , 'object' , 'null' ] ; if ( in_array ( $ this -> attributes [ 'meta_type' ] , $ validTypes ) ) { settype ( $ value , $ this -> attributes [ 'meta_type' ] ) ; } return $ value ; }
3921	private function processFile ( $ fileName ) { $ file = new File ( $ fileName ) ; $ meta = $ this -> metaInformation [ dirname ( $ fileName ) ] [ $ file -> basename ] ; $ title = strlen ( $ meta [ 'title' ] ) ? $ meta [ 'title' ] : StringUtil :: specialchars ( $ file -> basename ) ; if ( strlen ( $ meta [ 'caption' ] ) ) { $ altText = $ meta [ 'caption' ] ; } else { $ altText = ucfirst ( str_replace ( '_' , ' ' , preg_replace ( '/^[0-9]+_/' , '' , $ file -> filename ) ) ) ; } $ information = [ 'file' => $ fileName , 'mtime' => $ file -> mtime , 'alt' => $ altText , 'caption' => ( ! empty ( $ meta [ 'caption' ] ) ? $ meta [ 'caption' ] : '' ) , 'title' => $ title , 'metafile' => $ meta , 'icon' => 'assets/contao/images/' . $ file -> icon , 'extension' => $ file -> extension , 'size' => $ file -> filesize , 'sizetext' => sprintf ( '(%s)' , Controller :: getReadableSize ( $ file -> filesize , 2 ) ) , 'url' => StringUtil :: specialchars ( $ this -> getDownloadLink ( $ fileName ) ) ] ; if ( $ information [ 'isGdImage' ] = $ file -> isGdImage ) { $ information [ 'src' ] = urldecode ( $ this -> resizeImage ( $ fileName ) ) ; if ( file_exists ( TL_ROOT . '/' . $ information [ 'src' ] ) ) { $ size = getimagesize ( TL_ROOT . '/' . $ information [ 'src' ] ) ; $ information [ 'lb' ] = 'lb' . $ this -> getLightboxId ( ) ; $ information [ 'w' ] = $ size [ 0 ] ; $ information [ 'h' ] = $ size [ 1 ] ; $ information [ 'wh' ] = $ size [ 3 ] ; } } if ( $ information [ 'isSvgImage' ] = $ file -> isSvgImage ) { $ information [ 'src' ] = $ fileName ; } if ( $ information [ 'isPicture' ] = ( int ) $ this -> resizeImages [ 2 ] ) { $ picture = Picture :: create ( $ file , $ this -> getResizeImages ( ) ) -> getTemplateData ( ) ; $ picture [ 'alt' ] = $ altText ; $ picture [ 'title' ] = $ title ; $ information [ 'picture' ] = $ picture ; } $ this -> modifiedTime [ ] = $ file -> mtime ; $ this -> outputBuffer [ ] = $ information ; }
7976	public function addSecondaryDnsDomains ( $ domain2add , $ ip ) { self :: getClient ( ) -> addSecondaryDnsDomains ( $ this -> getDomain ( ) , $ domain2add , $ ip ) ; return true ; }
4733	protected function set_cookie ( ) { @ setcookie ( WP_SESSION_COOKIE , $ this -> session_id . '||' . $ this -> expires . '||' . $ this -> exp_variant , $ this -> expires , COOKIEPATH , COOKIE_DOMAIN ) ; }
10906	public function remove ( ) : bool { if ( $ this -> test ( \ sndsgd \ Fs :: EXISTS | \ sndsgd \ Fs :: READABLE | \ sndsgd \ Fs :: WRITABLE ) === false ) { $ this -> error = "failed to remove directory; {$this->error}" ; return false ; } foreach ( $ this -> getList ( ) as $ entity ) { if ( $ entity -> remove ( ) === false ) { $ this -> error = $ entity -> getError ( ) ; return false ; } } if ( @ rmdir ( $ this -> path ) === false ) { $ this -> setError ( "failed to remove directory '{$this->path}'" ) ; return false ; } return true ; }
11515	public function getNamedParam ( string $ category , string $ key ) { $ params = $ this -> getNamedParams ( $ category ) ; return $ params [ $ key ] ?? '' ; }
436	public function afterAction ( $ action , $ result ) { $ event = new ActionEvent ( $ action ) ; $ event -> result = $ result ; $ this -> trigger ( self :: EVENT_AFTER_ACTION , $ event ) ; return $ event -> result ; }
6174	protected function delete ( $ path , $ file ) { return $ this -> driver -> delete ( $ this -> root . $ path , $ file ) ; }
1606	public function findRedirectByPath ( $ path ) { $ redirects = $ this -> findAllRedirects ( true ) ; foreach ( $ redirects as $ redirect ) { $ to = false ; if ( trim ( $ redirect [ 'uri' ] , '/' ) == $ path ) $ to = $ redirect [ 'to' ] ; elseif ( $ uri = $ this -> _isRedirectRegex ( $ redirect [ 'uri' ] ) ) if ( preg_match ( $ uri , $ path ) ) $ to = preg_replace ( $ uri , $ redirect [ 'to' ] , $ path ) ; if ( $ to ) { return [ 'to' => strpos ( $ to , '://' ) !== false ? $ to : UrlHelper :: siteUrl ( $ to ) , 'type' => $ redirect [ 'type' ] , ] ; } } return false ; }
8029	public function registerFreeProcessId ( $ pid ) { $ processDetails = $ this -> getProcessDetails ( $ pid ) ; if ( $ processDetails !== NULL ) { $ this -> registerFreeProcess ( $ processDetails ) ; } return $ this ; }
12399	public function orderBy ( $ field , $ order = null ) { $ this -> scope -> orderBy [ ] = Parser :: orderBy ( $ field , $ order ) ; return $ this ; }
3240	public function setCallbacks ( $ order ) { $ this -> callbackSuccess = route ( config ( 'shop.callback_route' ) , [ 'status' => 'success' , 'id' => $ order -> id , 'token' => $ this -> token , ] ) ; $ this -> callbackFail = route ( config ( 'shop.callback_route' ) , [ 'status' => 'fail' , 'id' => $ order -> id , 'token' => $ this -> token , ] ) ; }
9810	private function readClientAnchor ( ) { $ length = Xls :: getInt4d ( $ this -> data , $ this -> pos + 4 ) ; $ recordData = substr ( $ this -> data , $ this -> pos + 8 , $ length ) ; $ this -> pos += 8 + $ length ; $ c1 = Xls :: getUInt2d ( $ recordData , 2 ) ; $ startOffsetX = Xls :: getUInt2d ( $ recordData , 4 ) ; $ r1 = Xls :: getUInt2d ( $ recordData , 6 ) ; $ startOffsetY = Xls :: getUInt2d ( $ recordData , 8 ) ; $ c2 = Xls :: getUInt2d ( $ recordData , 10 ) ; $ endOffsetX = Xls :: getUInt2d ( $ recordData , 12 ) ; $ r2 = Xls :: getUInt2d ( $ recordData , 14 ) ; $ endOffsetY = Xls :: getUInt2d ( $ recordData , 16 ) ; $ this -> object -> setStartCoordinates ( Coordinate :: stringFromColumnIndex ( $ c1 + 1 ) . ( $ r1 + 1 ) ) ; $ this -> object -> setStartOffsetX ( $ startOffsetX ) ; $ this -> object -> setStartOffsetY ( $ startOffsetY ) ; $ this -> object -> setEndCoordinates ( Coordinate :: stringFromColumnIndex ( $ c2 + 1 ) . ( $ r2 + 1 ) ) ; $ this -> object -> setEndOffsetX ( $ endOffsetX ) ; $ this -> object -> setEndOffsetY ( $ endOffsetY ) ; }
5143	public static function create ( array $ data ) : \ One \ Model \ Photo { $ url = self :: validateUrl ( ( string ) self :: checkData ( $ data , 'url' , '' ) ) ; $ ratio = self :: validateString ( ( string ) self :: checkData ( $ data , 'ratio' , '' ) ) ; $ description = self :: validateString ( ( string ) self :: checkData ( $ data , 'description' , '' ) ) ; $ information = self :: validateString ( ( string ) self :: checkData ( $ data , 'information' , '' ) ) ; return self :: createPhoto ( $ url , $ ratio , $ description , $ information ) ; }
5419	protected function parseHeaderLine ( $ header_line ) { if ( preg_match ( '/HTTP\/(\d+\.\d+)\s+(\d+)/i' , $ header_line , $ matches ) ) { $ this -> http_version = $ matches [ 1 ] ; $ this -> response_code = $ matches [ 2 ] ; } if ( preg_match ( '/Content-type:\s*(.*)/i' , $ header_line , $ matches ) ) { $ this -> mime_type = trim ( $ matches [ 1 ] ) ; } if ( preg_match ( '/Location:\s*(.*)/i' , $ header_line , $ matches ) ) { $ this -> location = trim ( $ matches [ 1 ] ) ; } if ( preg_match ( '/Set-cookie:(.*)/i' , $ header_line , $ matches ) ) { $ this -> cookies [ ] = $ this -> parseCookie ( $ matches [ 1 ] ) ; } if ( preg_match ( '/WWW-Authenticate:\s+(\S+)\s+realm=\"(.*?)\"/i' , $ header_line , $ matches ) ) { $ this -> authentication = $ matches [ 1 ] ; $ this -> realm = trim ( $ matches [ 2 ] ) ; } }
9199	public function getAccessToken ( $ oauthToken , $ oauthVerifier ) { $ oauth = new Oauth1 ( array ( 'consumer_key' => $ this -> credentials -> getConsumerKey ( ) , 'consumer_secret' => $ this -> credentials -> getConsumerSecret ( ) , 'token' => $ oauthToken , 'verifier' => $ oauthVerifier ) ) ; $ this -> guzzleClient -> getEmitter ( ) -> attach ( $ oauth ) ; $ accessTokenResponse = $ this -> guzzleClient -> post ( Config :: get ( 'oauth_access_token' ) , array ( 'auth' => 'oauth' ) ) ; $ response = array ( ) ; parse_str ( $ accessTokenResponse -> getBody ( ) , $ response ) ; $ this -> credentials -> setAccessToken ( $ response [ 'oauth_token' ] ) -> setAccessTokenSecret ( $ response [ 'oauth_token_secret' ] ) ; return $ response ; }
5888	public function getClass ( $ prefix = "ts3_" ) { if ( $ this instanceof Channel && $ this -> isSpacer ( ) ) { return $ prefix . "spacer" ; } elseif ( $ this instanceof Client && $ this [ "client_type" ] ) { return $ prefix . "query" ; } return $ prefix . StringHelper :: factory ( get_class ( $ this ) ) -> toLower ( ) ; }
5397	public function paintMessage ( $ message ) { parent :: paintMessage ( $ message ) ; print $ this -> getIndent ( 1 ) ; print '<' . $ this -> namespace . 'message>' ; print $ this -> toParsedXml ( $ message ) ; print '</' . $ this -> namespace . "message>\n" ; }
8637	public function setOrderFeeList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'OrderFeeList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
5459	protected function acceptTag ( $ tag ) { if ( $ tag -> getTagName ( ) === 'a' ) { $ this -> page -> addLink ( $ tag ) ; } elseif ( $ tag -> getTagName ( ) === 'base' ) { $ this -> page -> setBase ( $ tag -> getAttribute ( 'href' ) ) ; } elseif ( $ tag -> getTagName ( ) === 'title' ) { $ this -> page -> setTitle ( $ tag ) ; } elseif ( $ this -> isFormElement ( $ tag -> getTagName ( ) ) ) { for ( $ i = 0 ; $ i < count ( $ this -> open_forms ) ; $ i ++ ) { $ this -> open_forms [ $ i ] -> addWidget ( $ tag ) ; } $ this -> last_widget = $ tag ; } }
5929	public function updateCategory ( $ id , Category $ category ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'category' => $ category ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/categories/' . $ id . '' , $ parameters ) ; $ result = new CategoryResponse ( $ result ) ; return $ result ; }
8243	public function loginAttempt ( $ username , Password $ password ) { $ userData = $ this -> storage -> getUserByName ( $ username ) ; $ encoder = $ this -> getPasswordEncoder ( $ userData ) ; $ dummy = bin2hex ( \ random_bytes ( 32 ) ) ; $ dummyHash = $ encoder -> encode ( $ dummy ) ; if ( ! $ userData ) { $ encoder -> isValid ( $ dummyHash , $ password ) ; return false ; } return $ encoder -> isValid ( $ userData [ 'pwhash' ] , $ password -> get ( ) ) ; }
3930	private function buildProperty ( PropertiesDefinitionInterface $ definition , IAttribute $ attribute , array $ propInfo ) { if ( ! $ attribute ) { return ; } $ property = $ this -> getOrCreateProperty ( $ definition , $ attribute -> getColName ( ) ) ; $ this -> setLabel ( $ property , $ propInfo , $ attribute ) ; $ this -> setDescription ( $ property , $ propInfo ) ; $ this -> setDefaultValue ( $ property , $ propInfo ) ; $ this -> setExcluded ( $ property , $ propInfo ) ; $ this -> setSearchable ( $ property , $ propInfo ) ; $ this -> setFilterable ( $ property , $ propInfo ) ; $ this -> setWidgetType ( $ property , $ propInfo ) ; $ this -> setOptions ( $ property , $ propInfo ) ; $ this -> setExplanation ( $ property , $ propInfo ) ; $ this -> setEval ( $ property , $ propInfo , ( $ attribute instanceof ITranslated ) ) ; $ this -> setEmptyValue ( $ property , $ propInfo ) ; }
2857	public function viewHandleAction ( ) { $ area = $ this -> getRequest ( ) -> getParam ( 'area' ) ; $ storeId = ( int ) $ this -> getRequest ( ) -> getParam ( 'store' ) ; $ handle = $ this -> getRequest ( ) -> getParam ( 'handle' ) ; $ updatesByFile = $ this -> getService ( ) -> getFileUpdatesWithHandle ( $ handle , $ storeId , $ area ) ; $ databaseUpdates = $ this -> getService ( ) -> getDatabaseUpdatesWithHandle ( $ handle , $ storeId , $ area ) ; $ block = $ this -> getLayout ( ) -> createBlock ( 'sheep_debug/view' , '' , array ( 'template' => 'sheep_debug/view/panel/_layout_updates.phtml' , 'file_updates' => $ updatesByFile , 'db_updates' => $ databaseUpdates ) ) ; $ this -> getResponse ( ) -> setBody ( $ block -> toHtml ( ) ) ; }
8972	protected function paginate ( array $ rates , $ criteria ) { if ( ! array_key_exists ( 'offset' , $ criteria ) && ! array_key_exists ( 'limit' , $ criteria ) ) { return $ rates ; } $ range = array ( ) ; $ offset = array_key_exists ( 'offset' , $ criteria ) ? $ criteria [ 'offset' ] : 0 ; $ limit = min ( ( array_key_exists ( 'limit' , $ criteria ) ? $ criteria [ 'limit' ] : count ( $ rates ) ) + $ offset , count ( $ rates ) ) ; for ( $ i = $ offset ; $ i < $ limit ; $ i ++ ) { $ range [ ] = $ rates [ $ i ] ; } return $ range ; }
7748	private function isAccessible ( \ ReflectionClass $ class , $ methodName , $ parameters ) { if ( $ class -> hasMethod ( $ methodName ) ) { $ method = $ class -> getMethod ( $ methodName ) ; if ( $ method -> isPublic ( ) && $ method -> getNumberOfRequiredParameters ( ) === $ parameters ) { return true ; } } return false ; }
170	public static function filterPath ( $ path , $ options ) { if ( isset ( $ options [ 'filter' ] ) ) { $ result = call_user_func ( $ options [ 'filter' ] , $ path ) ; if ( is_bool ( $ result ) ) { return $ result ; } } if ( empty ( $ options [ 'except' ] ) && empty ( $ options [ 'only' ] ) ) { return true ; } $ path = str_replace ( '\\' , '/' , $ path ) ; if ( ! empty ( $ options [ 'except' ] ) ) { if ( ( $ except = self :: lastExcludeMatchingFromList ( $ options [ 'basePath' ] , $ path , $ options [ 'except' ] ) ) !== null ) { return $ except [ 'flags' ] & self :: PATTERN_NEGATIVE ; } } if ( ! empty ( $ options [ 'only' ] ) && ! is_dir ( $ path ) ) { if ( ( $ except = self :: lastExcludeMatchingFromList ( $ options [ 'basePath' ] , $ path , $ options [ 'only' ] ) ) !== null ) { return true ; } return false ; } return true ; }
2462	public function generateMarkup ( ) { $ intMaxSize = round ( static :: getMaxUploadSize ( ) / 1024 / 1024 ) ; $ strAccepted = implode ( ',' , array_map ( function ( $ a ) { return '.' . $ a ; } , StringUtil :: trimsplit ( ',' , strtolower ( Config :: get ( 'uploadTypes' ) ) ) ) ) ; $ GLOBALS [ 'TL_CSS' ] [ ] = 'assets/dropzone/css/dropzone.min.css' ; $ GLOBALS [ 'TL_JAVASCRIPT' ] [ ] = 'assets/dropzone/js/dropzone.min.js' ; $ return = ' <input type="hidden" name="action" value="fileupload"> <div class="fallback"> <input type="file" name="' . $ this -> strName . '[]" class="tl_upload_field" onfocus="Backend.getScrollOffset()" multiple> </div> <div class="dropzone"> <div class="dz-default dz-message"> <span>' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'dropzone' ] . '</span> </div> <span class="dropzone-previews"></span> </div> <script> Dropzone.autoDiscover = false; window.addEvent("domready", function() { new Dropzone("#tl_files", { paramName: "' . $ this -> strName . '", maxFilesize: ' . $ intMaxSize . ', acceptedFiles: "' . $ strAccepted . '", timeout: 0, previewsContainer: ".dropzone-previews", clickable: ".dropzone", dictFileTooBig: ' . json_encode ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'dropzoneFileTooBig' ] ) . ', dictInvalidFileType: ' . json_encode ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'dropzoneInvalidType' ] ) . ' }).on("addedfile", function() { $$(".dz-message").setStyle("display", "none"); }).on("success", function(file, message) { if (!message) return; var container = $("tl_message"); if (!container) { container = new Element("div", { "id": "tl_message", "class": "tl_message" }).inject($("tl_buttons"), "before"); } container.appendHTML(message); }); $$("div.tl_formbody_submit").setStyle("display", "none"); }); </script>' ; if ( isset ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'fileupload' ] [ 1 ] ) ) { $ return .= ' <p class="tl_help tl_tip">' . sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'fileupload' ] [ 1 ] , System :: getReadableSize ( static :: getMaxUploadSize ( ) ) , Config :: get ( 'gdMaxImgWidth' ) . 'x' . Config :: get ( 'gdMaxImgHeight' ) ) . '</p>' ; } return $ return ; }
5695	public function nestedFormSave ( $ data , $ form , $ request ) { $ formAction = $ this -> getFormActionFromRequest ( $ request ) ; $ actionName = $ formAction -> getButtonName ( ) ; $ this -> record -> $ actionName ( $ data , $ form , $ request ) ; return Controller :: curr ( ) -> redirectBack ( ) ; }
3539	public static function getAdldapProvider ( ) { if ( static :: getExtensionOptions ( 'adldap-providername' ) != '__USE_DEFAULT_PROVIDER__' ) { $ provider = Yii :: $ app -> ad -> getProvider ( static :: getExtensionOptions ( 'adldap-providername' ) ) ; } else { $ provider = Yii :: $ app -> ad -> getDefaultProvider ( ) ; } return $ provider ; }
10328	public function getNestingLevel ( ) { $ nestingLevel = 0 ; $ parent = $ this -> getParent ( ) ; while ( $ parent instanceof SpgrContainer ) { ++ $ nestingLevel ; $ parent = $ parent -> getParent ( ) ; } return $ nestingLevel ; }
7323	protected function checkDate ( $ status ) { switch ( $ status ) { case 3 : case 2 : throw new Exception ( 'time is after end of day' ) ; case - 1 : throw new Exception ( 'bad year' ) ; case - 2 : throw new Exception ( 'bad month' ) ; case - 3 : throw new Exception ( 'bad day' ) ; case - 4 : throw new Exception ( 'bad hour' ) ; case - 5 : throw new Exception ( 'bad minute' ) ; case - 6 : throw new Exception ( 'bad second' ) ; default : return ; } }
3901	public function createColumn ( ) { if ( $ this -> getColName ( ) ) { $ this -> tableManipulator -> createColumn ( $ this -> getMetaModel ( ) -> getTableName ( ) , $ this -> getColName ( ) , $ this -> getSQLDataType ( ) ) ; } }
9948	public function getColumnDimension ( $ pColumn , $ create = true ) { $ pColumn = strtoupper ( $ pColumn ) ; if ( ! isset ( $ this -> columnDimensions [ $ pColumn ] ) ) { if ( ! $ create ) { return null ; } $ this -> columnDimensions [ $ pColumn ] = new ColumnDimension ( $ pColumn ) ; if ( Coordinate :: columnIndexFromString ( $ this -> cachedHighestColumn ) < Coordinate :: columnIndexFromString ( $ pColumn ) ) { $ this -> cachedHighestColumn = $ pColumn ; } } return $ this -> columnDimensions [ $ pColumn ] ; }
11185	public function addMatch ( string $ method , string $ uri , $ next ) { $ method = strtoupper ( $ method ) ; if ( ! in_array ( $ method , $ this -> supported_methods ) ) { throw new Exception ( "Method " . $ method . " is not supported." ) ; } if ( ! is_string ( $ uri ) ) { throw new Exception ( "Uri " . $ uri . " is not valid." ) ; } if ( is_callable ( $ next ) ) { $ new_match = array ( $ this -> ARRAY_METHOD_KEY => $ method , $ this -> ARRAY_URI_KEY => $ uri , $ this -> ARRAY_CALLABLE_BOOL_KEY => true , $ this -> ARRAY_CALLABLE_KEY => $ next ) ; } elseif ( is_string ( $ next ) ) { if ( file_exists ( $ next ) ) { $ new_match = array ( $ this -> ARRAY_METHOD_KEY => $ method , $ this -> ARRAY_URI_KEY => $ uri , $ this -> ARRAY_CALLABLE_BOOL_KEY => false , $ this -> ARRAY_FILE_KEY => $ next ) ; } else { $ dir_next = __DIR__ . "/" . $ next ; if ( file_exists ( $ dir_next ) ) { $ new_match = array ( $ this -> ARRAY_METHOD_KEY => $ method , $ this -> ARRAY_URI_KEY => $ uri , $ this -> ARRAY_CALLABLE_BOOL_KEY => false , $ this -> ARRAY_FILE_KEY => $ dir_next ) ; } else { throw new Exception ( "File " . $ next . " not found." ) ; } } } else { throw new Exception ( "Invalid third parameter. Expecting callable or file." ) ; } array_push ( $ this -> match_list , $ new_match ) ; }
5673	protected function describeArrayDifference ( $ first , $ second , $ identical ) { if ( ! is_array ( $ second ) ) { return $ this -> describeGenericDifference ( $ first , $ second ) ; } if ( ! $ this -> isMatchingKeys ( $ first , $ second , $ identical ) ) { return sprintf ( 'as key list [%s] does not match key list [%s]' , implode ( ', ' , array_keys ( $ first ) ) , implode ( ', ' , array_keys ( $ second ) ) ) ; } foreach ( array_keys ( $ first ) as $ key ) { if ( $ identical && ( $ first [ $ key ] === $ second [ $ key ] ) ) { continue ; } if ( ! $ identical && ( $ first [ $ key ] == $ second [ $ key ] ) ) { continue ; } return sprintf ( 'with member [%s] %s' , $ key , $ this -> describeDifference ( $ first [ $ key ] , $ second [ $ key ] , $ identical ) ) ; } return '' ; }
5055	protected function getEntityClassName ( $ name ) { $ repositoryName = str_replace ( 'Repository/' , '' , $ name ) ; $ nameParts = explode ( '/' , $ repositoryName ) ; $ namespace = $ nameParts [ 0 ] ; $ entity = isset ( $ nameParts [ 1 ] ) ? $ nameParts [ 1 ] : substr ( $ namespace , 0 , - 1 ) ; $ class = "\\$namespace\\Entity\\$entity" ; return $ class ; }
4046	public function encodeValue ( EncodePropertyValueFromWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) || ( $ event -> getProperty ( ) !== 'jumpTo' ) ) { return ; } $ value = StringUtil :: deserialize ( $ event -> getValue ( ) , true ) ; foreach ( $ value as $ k => $ v ) { $ value [ $ k ] [ 'value' ] = str_replace ( [ '{{link_url::' , '}}' ] , [ '' , '' ] , $ v [ 'value' ] ) ; } $ event -> setValue ( serialize ( $ value ) ) ; }
10045	private function createFromType ( Model $ model , Column $ column , $ item ) { $ result = null ; switch ( $ column -> getType ( ) ) { case Type :: TEXT : case Type :: TARRAY : case Type :: SIMPLE_ARRAY : case Type :: JSON_ARRAY : case Type :: OBJECT : case Type :: BLOB : $ result = new TextAreaFormItem ( ) ; break ; case Type :: INTEGER : case Type :: SMALLINT : case Type :: BIGINT : $ result = new IntegerFormItem ( ) ; break ; case Type :: DECIMAL : case Type :: FLOAT : $ result = new NumberFormItem ( ) ; break ; case Type :: BOOLEAN : $ result = new CheckboxFormItem ( ) ; break ; case Type :: DATE : $ result = new DateFormItem ( ) ; break ; case Type :: DATETIME : case Type :: DATETIMETZ : $ result = new DateTimeFormItem ( ) ; break ; case Type :: TIME : $ result = new TimeFormItem ( ) ; break ; case Type :: STRING : case Type :: GUID : default : $ result = new TextFormItem ( ) ; break ; } $ columnName = $ column -> getName ( ) ; $ result -> setName ( $ columnName ) ; $ result -> setLabel ( Lang :: trans ( $ this -> aujaConfigurator -> getColumnDisplayName ( $ model , $ columnName ) ) ) ; if ( $ item != null && isset ( $ item -> $ columnName ) ) { $ result -> setValue ( $ item -> $ columnName ) ; } return $ result ; }
5840	protected function crop ( Builder $ url , $ args ) { $ url -> crop ( $ args [ 'top_left_x' ] , $ args [ 'top_left_y' ] , $ args [ 'bottom_right_x' ] , $ args [ 'bottom_right_y' ] ) ; }
2802	public static function parseBooleanValue ( $ value ) : bool { if ( \ is_bool ( $ value ) ) { return $ value ; } if ( \ is_string ( $ value ) ) { $ value = \ strtolower ( $ value ) ; return 'true' === $ value ; } if ( \ is_object ( $ value ) || \ is_array ( $ value ) || \ is_callable ( $ value ) ) { return false ; } return ( bool ) $ value ; }
5762	public function indexView ( Response $ response , ? array $ displayItems = null ) { if ( $ displayItems === null ) { $ displayItems = $ this -> getDisplayItems ( ) ; } $ filterErrorMessage = FormHelper :: getFieldError ( $ this -> sessionFilterFieldKey ) ; FormHelper :: unsetSessionFormErrors ( ) ; return $ this -> view -> render ( $ response , $ this -> template , [ 'title' => $ this -> mapper -> getListViewTitle ( ) , 'insertLinkInfo' => $ this -> insertLinkInfo , 'filterOpsList' => QueryBuilder :: getWhereOperatorsText ( ) , 'filterValue' => $ this -> getFilterFieldValue ( ) , 'filterErrorMessage' => $ filterErrorMessage , 'filterFormActionRoute' => $ this -> indexRoute , 'filterFieldName' => $ this -> sessionFilterFieldKey , 'isFiltered' => $ this -> getFilterFieldValue ( ) != '' , 'resetFilterRoute' => $ this -> filterResetRoute , 'updatesPermitted' => $ this -> updatesPermitted , 'updateColumn' => $ this -> updateColumn , 'updateRoute' => $ this -> updateRoute , 'deletesPermitted' => $ this -> deletesPermitted , 'deleteRoute' => $ this -> deleteRoute , 'displayItems' => $ displayItems , 'columnCount' => $ this -> mapper -> getCountSelectColumns ( ) , 'sortColumn' => $ this -> mapper -> getListViewSortColumn ( ) , 'sortAscending' => $ this -> mapper -> getListViewSortAscending ( ) , 'navigationItems' => $ this -> navigationItems ] ) ; }
5218	protected static function hostname ( ) { return function ( Binder $ binder ) { if ( DIRECTORY_SEPARATOR === '\\' ) { $ fq = php_uname ( 'n' ) ; if ( isset ( $ _SERVER [ 'USERDNSDOMAIN' ] ) ) { $ fq .= '.' . $ _SERVER [ 'USERDNSDOMAIN' ] ; } } else { $ fq = exec ( 'hostname -f' ) ; } $ binder -> bindConstant ( 'stubbles.hostname.nq' ) -> to ( php_uname ( 'n' ) ) ; $ binder -> bindConstant ( 'stubbles.hostname.fq' ) -> to ( $ fq ) ; } ; }
2157	public function generate ( ) { if ( $ this -> youtube == '' ) { return '' ; } if ( TL_MODE == 'BE' ) { $ return = '<p><a href="https://youtu.be/' . $ this -> youtube . '" target="_blank" rel="noreferrer noopener">youtu.be/' . $ this -> youtube . '</a></p>' ; if ( $ this -> headline != '' ) { $ return = '<' . $ this -> hl . '>' . $ this -> headline . '</' . $ this -> hl . '>' . $ return ; } return $ return ; } return parent :: generate ( ) ; }
121	private function createAuthFromConfig ( ) { if ( ! $ this -> config -> has ( 'http-basic' ) ) { return $ this -> hasAuth = false ; } $ authConfig = $ this -> config -> get ( 'http-basic' ) ; $ host = parse_url ( $ this -> url , PHP_URL_HOST ) ; if ( isset ( $ authConfig [ $ host ] ) ) { $ this -> credentials [ 'username' ] = $ authConfig [ $ host ] [ 'username' ] ; $ this -> credentials [ 'password' ] = $ authConfig [ $ host ] [ 'password' ] ; return $ this -> hasAuth = true ; } return $ this -> hasAuth = false ; }
12212	public function getSnippet ( string $ snptName = '' ) { if ( empty ( $ snptName ) ) { return $ this -> snippets ; } else { return isset ( $ this -> snippets [ $ snptName ] ) ? $ this -> snippets [ $ snptName ] : null ; } }
844	public function clearEmptyTokens ( ) { $ limit = $ this -> count ( ) ; $ index = 0 ; for ( ; $ index < $ limit ; ++ $ index ) { if ( $ this -> isEmptyAt ( $ index ) ) { break ; } } if ( $ limit === $ index ) { return ; } for ( $ count = $ index ; $ index < $ limit ; ++ $ index ) { if ( ! $ this -> isEmptyAt ( $ index ) ) { $ this [ $ count ++ ] = $ this [ $ index ] ; } } $ this -> setSize ( $ count ) ; }
7173	protected function resolveCustomerTargetCountry ( CustomerInterface $ customer ) : ? CountryInterface { if ( null !== $ address = $ customer -> getDefaultDeliveryAddress ( ) ) { return $ address -> getCountry ( ) ; } return null ; }
128	protected function getPackageBasePath ( PackageInterface $ package ) { $ installPath = $ this -> getInstallPath ( $ package ) ; $ targetDir = $ package -> getTargetDir ( ) ; if ( $ targetDir ) { return preg_replace ( '{/*' . str_replace ( '/' , '/+' , preg_quote ( $ targetDir ) ) . '/?$}' , '' , $ installPath ) ; } return $ installPath ; }
804	private function hasReturnTypeHint ( Tokens $ tokens , $ index ) { $ endFuncIndex = $ tokens -> getPrevTokenOfKind ( $ index , [ ')' ] ) ; $ nextIndex = $ tokens -> getNextMeaningfulToken ( $ endFuncIndex ) ; return $ tokens [ $ nextIndex ] -> isGivenKind ( CT :: T_TYPE_COLON ) ; }
11108	public function logRequest ( APIRequest $ request ) : void { $ item = $ this -> cacheItemPool -> getItem ( $ this -> deriveCacheKey ( $ request ) ) ; if ( $ requestCount = $ item -> get ( ) ) { $ item -> set ( $ requestCount + 1 ) ; } else { $ item -> set ( 1 ) -> expiresAfter ( $ this -> perXSeconds ) ; } $ this -> cacheItemPool -> save ( $ item ) ; }
10624	private static function checkAndMoveFile ( $ sourceMigrationFile , $ appMigrationDir , IOInterface $ io ) { $ explodedPath = explode ( '/' , $ sourceMigrationFile ) ; $ filename = array_pop ( $ explodedPath ) ; if ( file_exists ( $ appMigrationDir . '/' . $ filename ) ) { if ( md5_file ( $ appMigrationDir . '/' . $ filename ) === md5_file ( $ sourceMigrationFile ) ) { if ( $ io -> isVeryVerbose ( ) ) { $ io -> write ( "<info>found that $sourceMigrationFile is equal" . " to $appMigrationDir/$filename</info>" ) ; } $ doTheMove = false ; } else { $ doTheMove = $ io -> askConfirmation ( "<question>The file \n" . " \t$sourceMigrationFile\n has the same name than the previous " . "migrated file located at \n\t$appMigrationDir/$filename\n " . "but the content is not equal.\n Overwrite the file ?[y,N]" , false ) ; } } else { $ doTheMove = true ; } if ( $ doTheMove ) { $ fs = new Filesystem ( ) ; $ fs -> copy ( $ sourceMigrationFile , $ appMigrationDir . '/' . $ filename ) ; $ io -> write ( "<info>Importing '$filename' migration file</info>" ) ; return true ; } return false ; }
5535	public function divideMapNodes ( $ map , $ aspect ) { $ aspect = ! $ aspect ; $ divisions = $ map -> getSize ( ) ; $ total = $ map -> getTotalSize ( ) ; foreach ( $ map -> getChildren ( ) as $ node ) { if ( ! $ node -> isLeaf ( ) ) { $ dist = $ node -> getTotalSize ( ) / $ total * 100 ; } else { $ dist = 1 / $ total * 100 ; } if ( $ aspect ) { $ horiz = $ dist ; $ vert = 100 ; } else { $ horiz = 100 ; $ vert = $ dist ; } $ this -> paintRectangleStart ( $ node , $ horiz , $ vert ) ; $ this -> divideMapNodes ( $ node , $ aspect ) ; $ this -> paintRectangleEnd ( ) ; } }
10999	public function matchLocale ( $ locale ) { $ locale = Locale :: create ( $ locale ) ; if ( ! empty ( $ this -> redirect ) ) return false ; if ( $ locale === null ) return true ; foreach ( $ this -> locales as $ l ) if ( $ l -> getLocale ( ) == $ locale -> getLocale ( ) ) return true ; return false ; }
7504	public function getTf ( string $ key , array $ args = null , array $ replacements = null , string ... $ namespaces ) { if ( empty ( $ namespaces ) ) { $ namespaces = $ this -> meta -> getNamespaces ( ) ; } $ translatedText = $ this -> textService -> tf ( $ namespaces , $ key , $ args , ... $ this -> meta -> getN2nLocales ( ) ) ; $ replacedText = HtmlBuilderMeta :: replace ( $ translatedText , $ replacements , $ this -> view ) ; return new Raw ( $ replacedText ) ; }
6200	public function currentPath ( ) { $ request = preg_replace ( '!' . $ this -> uri . '(.*)$!i' , '$1' , $ _SERVER [ 'REQUEST_URI' ] ) ; if ( defined ( 'MOD_REWRITE' ) and MOD_REWRITE === true ) { if ( substr ( $ request , - 1 ) != '/' ) { $ request .= '/' ; } $ parseUrl = $ this -> parseUrl ( $ request ) ; $ gets = $ parseUrl [ 'sVars' ] ; } else { $ gets = $ _SERVER [ 'QUERY_STRING' ] ; } return $ gets ; }
9558	public function getUsage ( $ showRequiredFirst = true , $ customBinary = null , $ customScript = null ) { $ fullUsage = '' ; if ( $ customBinary == null ) { $ fullUsage = 'php ' ; } else { $ fullUsage = $ customBinary . ' ' ; } if ( $ customScript == null ) { $ fullUsage .= basename ( $ _SERVER [ 'SCRIPT_NAME' ] ) . ' ' ; } else { $ fullUsage .= $ customScript . ' ' ; } foreach ( $ this -> prefixes as $ prefix => $ parameters ) { if ( $ showRequiredFirst ) { usort ( $ parameters , function ( $ p1 , $ p2 ) { if ( $ p1 -> required && $ p2 -> required ) { return 0 ; } if ( $ p1 -> required && ! $ p2 -> required ) { return - 1 ; } if ( $ p2 -> required && ! $ p1 -> required ) { return 1 ; } } ) ; } foreach ( $ parameters as $ parameter ) { if ( $ parameter -> parent == null ) { $ fullUsage .= $ parameter -> getUsage ( ) . ' ' ; } } } return $ fullUsage ; }
664	public function useMaster ( callable $ callback ) { if ( $ this -> enableSlaves ) { $ this -> enableSlaves = false ; try { $ result = call_user_func ( $ callback , $ this ) ; } catch ( \ Exception $ e ) { $ this -> enableSlaves = true ; throw $ e ; } catch ( \ Throwable $ e ) { $ this -> enableSlaves = true ; throw $ e ; } $ this -> enableSlaves = true ; } else { $ result = call_user_func ( $ callback , $ this ) ; } return $ result ; }
4230	public static function getParsed ( $ what ) { $ hash = null ; if ( \ is_object ( $ what ) ) { $ hash = self :: getHash ( $ what ) ; if ( isset ( self :: $ cache [ $ hash ] ) ) { return self :: $ cache [ $ hash ] ; } } $ comment = self :: getCommentContent ( $ what ) ; if ( \ is_array ( $ comment ) ) { return $ comment ; } $ return = array ( 'summary' => null , 'description' => null , ) ; if ( \ preg_match ( '/^@/m' , $ comment , $ matches , PREG_OFFSET_CAPTURE ) ) { $ pos = $ matches [ 0 ] [ 1 ] ; $ strTags = \ substr ( $ comment , $ pos ) ; $ return = \ array_merge ( $ return , self :: parseTags ( $ strTags ) ) ; $ comment = $ pos > 0 ? \ substr ( $ comment , 0 , $ pos - 1 ) : '' ; } $ comment = \ preg_replace ( '/^\\\@/m' , '@' , $ comment ) ; $ comment = \ str_replace ( '{@*}' , '*/' , $ comment ) ; $ split = \ preg_split ( '/(\.[\r\n]+|[\r\n]{2})/' , $ comment , 2 , PREG_SPLIT_DELIM_CAPTURE ) ; $ split = \ array_replace ( array ( '' , '' , '' ) , $ split ) ; $ return = \ array_merge ( $ return , \ array_filter ( array ( 'summary' => \ trim ( $ split [ 0 ] . $ split [ 1 ] ) , 'desc' => \ trim ( $ split [ 2 ] ) , ) ) ) ; if ( $ hash ) { self :: $ cache [ $ hash ] = $ return ; } return $ return ; }
3461	public function use ( $ middleware ) : void { if ( ! is_subclass_of ( $ middleware , MiddlewareInterface :: class ) ) { if ( ! is_callable ( $ middleware ) ) { throw new ApplicationException ( sprintf ( 'Middleware must be either class or object that implements `%s`' , MiddlewareInterface :: class ) ) ; } $ middleware = new CallableMiddleware ( $ middleware ) ; } $ this -> middleware [ ] = $ middleware ; }
5571	public function back ( ) { if ( ! $ this -> history -> back ( ) ) { return false ; } $ content = $ this -> retry ( ) ; if ( ! $ content ) { $ this -> history -> forward ( ) ; } return $ content ; }
8226	protected function validateRegistration ( array $ reg ) { $ isValid = true ; try { $ this -> storage -> checkValidName ( $ reg [ "username" ] ) ; } catch ( \ RuntimeException $ e ) { $ isValid = false ; $ this -> session -> addFlash ( "error" , $ e -> getMessage ( ) ) ; } $ min = $ this -> config [ "nameLenMin" ] ; $ max = $ this -> config [ "nameLenMax" ] ; if ( strlen ( $ reg [ "username" ] ) < $ min || strlen ( $ reg [ "username" ] ) > $ max ) { $ isValid = false ; $ this -> session -> addFlash ( "error" , sprintf ( "Length of a username must be between %d-%d characters." , $ min , $ max ) ) ; } if ( ! filter_var ( $ reg [ "email" ] , FILTER_VALIDATE_EMAIL ) ) { $ isValid = false ; $ this -> session -> addFlash ( "error" , "Email address does not have a valid format." ) ; } if ( null !== $ this -> storage -> getUserByEmail ( $ reg [ "email" ] ) ) { $ isValid = false ; $ this -> session -> addFlash ( "error" , "This email is already in use." ) ; } if ( $ reg [ "password" ] -> get ( ) !== $ reg [ "passwordRepeat" ] -> get ( ) ) { $ isValid = false ; $ this -> session -> addFlash ( "error" , "The passwords do not match." ) ; } $ localAuth = $ this -> picoAuth -> getContainer ( ) -> get ( 'LocalAuth' ) ; if ( ! $ localAuth -> checkPasswordPolicy ( $ reg [ "password" ] ) ) { $ isValid = false ; } if ( $ this -> storage -> getUserByName ( $ reg [ "username" ] ) !== null ) { $ isValid = false ; $ this -> session -> addFlash ( "error" , "The username is already taken." ) ; } return $ isValid ; }
238	protected function normalizePdoRowKeyCase ( array $ row , $ multiple ) { if ( $ this -> db -> getSlavePdo ( ) -> getAttribute ( \ PDO :: ATTR_CASE ) !== \ PDO :: CASE_UPPER ) { return $ row ; } if ( $ multiple ) { return array_map ( function ( array $ row ) { return array_change_key_case ( $ row , CASE_LOWER ) ; } , $ row ) ; } return array_change_key_case ( $ row , CASE_LOWER ) ; }
6581	public function translate ( $ shift , $ y = null , $ z = null ) { if ( $ shift instanceof self ) return new static ( $ this -> gps [ 'x' ] + $ shift -> gps [ 'x' ] , $ this -> gps [ 'y' ] + $ shift -> gps [ 'y' ] , $ this -> gps [ 'z' ] + $ shift -> gps [ 'z' ] ) ; else return new static ( $ this -> gps [ 'x' ] + $ shift , $ this -> gps [ 'y' ] + $ y , $ this -> gps [ 'z' ] + $ z ) ; }
1494	public static function fromArray ( iterable $ config , string $ urlPrefix = null ) : self { return new self ( ... collect ( $ config ) -> map ( function ( $ value , $ key ) use ( $ urlPrefix ) { return Encoding :: fromArray ( $ key , $ value , $ urlPrefix ) ; } ) -> values ( ) ) ; }
3390	public function redirectAfterResendConfirmationPath ( ) { if ( method_exists ( $ this , 'redirectAfterResendConfirmationTo' ) ) { return $ this -> redirectAfterResendConfirmationTo ( ) ; } return property_exists ( $ this , 'redirectAfterResendConfirmationTo' ) ? $ this -> redirectAfterResendConfirmationTo : route ( 'login' ) ; }
6179	private function loadAllColumnsSchema ( ) { $ schema = $ this -> tableSchema [ 'fields' ] ; foreach ( $ this -> request [ 'leftJoin' ] as $ value ) { $ schemaTable = $ this -> schema -> getSchemaTable ( $ value [ 'table' ] ) ; $ schema = array_merge ( $ schema , $ schemaTable [ 'fields' ] ) ; } foreach ( $ this -> request [ 'rightJoin' ] as $ value ) { $ schemaTable = $ this -> schema -> getSchemaTable ( $ value [ 'table' ] ) ; $ schema = array_merge ( $ schema , $ schemaTable [ 'fields' ] ) ; } $ this -> request [ 'allColumnsSchema' ] = $ schema ; }
3249	public function hasItem ( $ sku , $ requireAll = false ) { if ( is_array ( $ sku ) ) { foreach ( $ sku as $ skuSingle ) { $ hasItem = $ this -> hasItem ( $ skuSingle ) ; if ( $ hasItem && ! $ requireAll ) { return true ; } elseif ( ! $ hasItem && $ requireAll ) { return false ; } } return $ requireAll ; } else { foreach ( $ this -> items as $ item ) { if ( $ item -> sku == $ sku ) { return true ; } } } return false ; }
7852	protected function dispatchWorkflow ( $ workflow ) { $ job = $ this -> inflector -> getJob ( ) ; $ request = $ this -> resolveRequest ( ) ; $ pipes = $ this -> pipelines -> getPipesByPipeline ( $ workflow ) ; $ parameters = $ this -> container -> make ( 'router' ) -> current ( ) -> parameters ( ) ; return $ this -> dispatcher -> pipeThrough ( $ pipes ) -> dispatchFrom ( $ job , $ request , $ parameters ) ; }
867	private function getPreviousBlock ( Tokens $ tokens , $ index ) { $ close = $ previous = $ tokens -> getPrevMeaningfulToken ( $ index ) ; if ( $ tokens [ $ close ] -> equals ( '}' ) ) { $ previous = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_CURLY_BRACE , $ close ) ; } $ open = $ tokens -> getPrevTokenOfKind ( $ previous , [ [ T_IF ] , [ T_ELSE ] , [ T_ELSEIF ] ] ) ; if ( $ tokens [ $ open ] -> isGivenKind ( T_IF ) ) { $ elseCandidate = $ tokens -> getPrevMeaningfulToken ( $ open ) ; if ( $ tokens [ $ elseCandidate ] -> isGivenKind ( T_ELSE ) ) { $ open = $ elseCandidate ; } } return [ $ open , $ close ] ; }
4254	public function build ( $ stats ) { $ this -> stats = $ stats ; return '' . $ this -> buildFatal ( ) . $ this -> buildInConsole ( ) . $ this -> buildNotInConsole ( ) ; }
5878	protected static function updateIndex ( \ TYPO3 \ CMS \ Core \ Resource \ File $ file = null , $ width , $ height , array $ metadata = [ ] ) { if ( count ( $ metadata ) > 0 ) { $ metadataRepository = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Core \ Resource \ Index \ MetaDataRepository :: class ) ; $ currentMetadata = $ metadataRepository -> findByFile ( $ file ) ; $ newMetadata = [ ] ; foreach ( $ currentMetadata as $ key => $ value ) { if ( ! empty ( $ metadata [ $ key ] ) ) { if ( $ key === 'creator_tool' && MathUtility :: canBeInterpretedAsFloat ( $ metadata [ $ key ] ) ) { continue ; } $ newMetadata [ $ key ] = $ metadata [ $ key ] ; } } unset ( $ newMetadata [ 'width' ] ) ; unset ( $ newMetadata [ 'height' ] ) ; $ newMetadata [ 'unit' ] = 'px' ; $ mapping = [ 'color_space' => 'ColorSpace' , 'content_creation_date' => 'DateTimeOriginal' , 'creator' => 'IPTCCreator|Company' , 'creator_tool' => 'Model|Make|Software' , 'description' => 'ImageDescription' , 'keywords' => 'IPTCKeywords' , 'latitude' => 'GPSLatitudeDecimal' , 'longitude' => 'GPSLongitudeDecimal' , 'location_city' => 'IPTCCity' , 'location_country' => 'IPTCCountry' , 'location_region' => 'IPTCRegion' , 'note' => 'IPTCLocation' , 'publisher' => 'IPTCCredit' , 'source' => 'IPTCSource' , 'title' => 'IPTCTitle' , ] ; foreach ( $ mapping as $ falKey => $ metadataKeyMapping ) { if ( ! empty ( $ newMetadata [ $ falKey ] ) ) { continue ; } $ metatadaKeys = explode ( '|' , $ metadataKeyMapping ) ; foreach ( $ metatadaKeys as $ metadataKey ) { $ value = null ; if ( isset ( $ metadata [ $ metadataKey ] ) ) { $ value = trim ( $ metadata [ $ metadataKey ] ) ; if ( ord ( $ value ) === 1 ) $ value = null ; switch ( $ metadataKey ) { case 'ColorSpace' : if ( $ value == 1 ) { $ value = 'RGB' ; } else { $ value = null ; } break ; case 'DateTimeOriginal' : $ value = strtotime ( $ value ) ; break ; } } if ( ! empty ( $ value ) ) { $ newMetadata [ $ falKey ] = $ value ; break ; } } } $ metadataRepository -> update ( $ file -> getUid ( ) , $ newMetadata ) ; } }
3175	private function getItemLabel ( RunnerServiceContext $ context , $ itemUri , $ useTitle = false ) { $ label = '' ; if ( $ useTitle ) { $ label = $ context -> getItemIndexValue ( $ itemUri , 'title' ) ; } if ( ! $ label ) { $ label = $ context -> getItemIndexValue ( $ itemUri , 'label' ) ; } if ( ! $ label ) { $ item = new \ core_kernel_classes_Resource ( $ itemUri ) ; $ label = $ item -> getLabel ( ) ; } return $ label ; }
9855	protected function storeBof ( $ type ) { $ record = 0x0809 ; $ length = 0x0010 ; $ unknown = pack ( 'VV' , 0x000100D1 , 0x00000406 ) ; $ build = 0x0DBB ; $ year = 0x07CC ; $ version = 0x0600 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vvvv' , $ version , $ type , $ build , $ year ) ; $ this -> append ( $ header . $ data . $ unknown ) ; }
9040	public function getMax ( string $ column ) : int { return $ this -> connection -> query ( 'SELECT IFNULL(MAX(%column), 0) position FROM %table' , $ column , $ this -> getTableName ( ) ) -> fetch ( ) -> position ; }
11567	public function set ( string $ sNameOfDi , callable $ cFunction , bool $ bShared = false ) : Di { if ( $ bShared === true ) { self :: $ _aSharedDependencyInjectorContener [ md5 ( $ sNameOfDi ) ] = $ cFunction ; } else { $ this -> _aDependencyInjectorContener [ md5 ( $ sNameOfDi ) ] = $ cFunction ; } return $ this ; }
2572	protected function loadSessionHandler ( $ params ) { if ( isset ( $ params [ 'sessionHandler' ] ) && $ params [ 'sessionHandler' ] instanceof Session \ Handler \ HandlerInterface ) { $ this -> sessionHandler = $ params [ 'sessionHandler' ] ; } }
460	private function quoteTableNames ( $ tables , & $ params ) { foreach ( $ tables as $ i => $ table ) { if ( $ table instanceof Query ) { list ( $ sql , $ params ) = $ this -> build ( $ table , $ params ) ; $ tables [ $ i ] = "($sql) " . $ this -> db -> quoteTableName ( $ i ) ; } elseif ( is_string ( $ i ) ) { if ( strpos ( $ table , '(' ) === false ) { $ table = $ this -> db -> quoteTableName ( $ table ) ; } $ tables [ $ i ] = "$table " . $ this -> db -> quoteTableName ( $ i ) ; } elseif ( strpos ( $ table , '(' ) === false ) { if ( preg_match ( '/^(.*?)(?i:\s+as|)\s+([^ ]+)$/' , $ table , $ matches ) ) { $ tables [ $ i ] = $ this -> db -> quoteTableName ( $ matches [ 1 ] ) . ' ' . $ this -> db -> quoteTableName ( $ matches [ 2 ] ) ; } else { $ tables [ $ i ] = $ this -> db -> quoteTableName ( $ table ) ; } } } return $ tables ; }
6648	public function create_tables ( ) { global $ wpdb ; $ charset_collate = $ wpdb -> get_charset_collate ( ) ; $ table_name = $ wpdb -> prefix . 'efg_custom_rating' ; if ( $ wpdb -> get_var ( "SHOW TABLES LIKE '$table_name'" ) != $ table_name ) { $ sql = "CREATE TABLE $table_name ( id mediumint(9) NOT NULL AUTO_INCREMENT, post_id mediumint(9) NOT NULL, ip varchar(45) NOT NULL, vote int(2) NOT NULL, PRIMARY KEY (id) ) $charset_collate;" ; require_once ( ABSPATH . 'wp-admin/includes/upgrade.php' ) ; dbDelta ( $ sql ) ; } }
6408	public static function filterBy ( IteratorAggregate $ unfiltered , string $ className ) : IteratorAggregate { return self :: from ( Iterators :: filterBy ( Iterators :: from ( $ unfiltered -> getIterator ( ) ) , $ className ) ) ; }
9047	public function getType ( $ data_type = 'metadata' , $ type = 'text' ) { if ( isset ( $ this -> types [ $ data_type ] [ $ type ] ) ) { return $ this -> types [ $ data_type ] [ $ type ] ; } return false ; }
12391	public function setHydrator ( $ hydrator ) { if ( ! is_string ( $ hydrator ) && ! $ hydrator instanceof HydratorInterface ) { throw new Exception \ InvalidArgumentException ( sprintf ( '%s expects parameter 1 to be an object of instance Zend\Stdlib\Hydrator\HydratorInterface or string, %s provided instead' , __METHOD__ , is_object ( $ hydrator ) ? get_class ( $ hydrator ) : gettype ( $ hydrator ) ) ) ; } $ this -> hydrator = $ hydrator ; return $ this ; }
2822	protected function _afterLoad ( ) { $ info = $ this -> getUnserializedInfo ( ) ; $ this -> logging = $ info [ 'logging' ] ; $ this -> action = $ info [ 'action' ] ; $ this -> design = $ info [ 'design' ] ; $ this -> blocks = $ info [ 'blocks' ] ; $ this -> models = $ info [ 'models' ] ; $ this -> collections = $ info [ 'collections' ] ; $ this -> queries = $ info [ 'queries' ] ; $ this -> timers = $ info [ 'timers' ] ; $ this -> emails = $ info [ 'emails' ] ; return parent :: _afterLoad ( ) ; }
12232	public function cloneChildrenFrom ( SimpleXMLElement $ src , $ deep = true ) { $ src = dom_import_simplexml ( $ src ) ; $ dst = dom_import_simplexml ( $ this ) ; $ doc = $ dst -> ownerDocument ; $ fragment = $ doc -> createDocumentFragment ( ) ; foreach ( $ src -> childNodes as $ child ) { $ fragment -> appendChild ( $ doc -> importNode ( $ child -> cloneNode ( $ deep ) , $ deep ) ) ; } $ dst -> appendChild ( $ fragment ) ; return $ this ; }
814	private function getNewLineIndex ( $ index , Tokens $ tokens ) { $ lineEnding = $ this -> whitespacesConfig -> getLineEnding ( ) ; for ( $ index , $ count = \ count ( $ tokens ) ; $ index < $ count ; ++ $ index ) { if ( false !== strstr ( $ tokens [ $ index ] -> getContent ( ) , $ lineEnding ) ) { return $ index ; } } return $ index ; }
7653	public function dir_opendir ( $ path , $ options ) { $ this -> blobs = $ this -> getStorageClient ( $ path ) -> listBlobs ( $ this -> getContainerName ( $ path ) ) ; return is_array ( $ this -> blobs ) ; }
2955	public function PhpSerial ( ) { setlocale ( LC_ALL , "en_US" ) ; $ sysName = php_uname ( ) ; if ( substr ( $ sysName , 0 , 5 ) === "Linux" ) { $ this -> _os = "linux" ; if ( $ this -> _exec ( "stty" ) === 0 ) { register_shutdown_function ( array ( $ this , "deviceClose" ) ) ; } else { trigger_error ( "No stty availible, unable to run." , E_USER_ERROR ) ; } } elseif ( substr ( $ sysName , 0 , 6 ) === "Darwin" ) { $ this -> _os = "osx" ; register_shutdown_function ( array ( $ this , "deviceClose" ) ) ; } elseif ( substr ( $ sysName , 0 , 7 ) === "Windows" ) { $ this -> _os = "windows" ; register_shutdown_function ( array ( $ this , "deviceClose" ) ) ; } else { trigger_error ( "Host OS is neither osx, linux nor windows, unable " . "to run." , E_USER_ERROR ) ; exit ( ) ; } }
7775	protected function handleError ( $ field , $ value , $ rule , array $ args ) { $ this -> errors [ $ rule ] [ ] = [ 'field' => $ field , 'value' => $ value , 'args' => $ args , ] ; }
12444	public static function run ( $ source , $ destination , $ width , $ height = "" ) { $ mime = exif_imagetype ( $ source ) ; switch ( $ mime ) { case IMAGETYPE_JPEG : $ source = imagecreatefromjpeg ( $ source ) ; break ; case IMAGETYPE_PNG : $ source = imagecreatefrompng ( $ source ) ; break ; case IMAGETYPE_GIF : $ source = imagecreatefromgif ( $ source ) ; break ; default : return ; } $ width_src = imagesx ( $ source ) ; $ height_src = imagesy ( $ source ) ; $ width_dest = 0 ; $ height_dest = 0 ; if ( ! $ height ) { $ ratio = ( $ width * 100 ) / $ width_src ; if ( $ ratio > 100 ) { imagejpeg ( $ source , $ destination , 70 ) ; imagedestroy ( $ source ) ; return ; } $ width_dest = $ width ; $ height_dest = $ height_src * $ ratio / 100 ; } else { if ( $ height_src >= $ width_src ) { $ height_dest = ( $ height_src * $ width ) / $ width_src ; $ width_dest = $ width ; } elseif ( $ height_src < $ width_src ) { $ width_dest = ( $ width_src * $ height ) / $ height_src ; $ height_dest = $ height ; } } $ emptyPicture = imagecreatetruecolor ( $ width , ( $ height ) ? $ height : $ height_dest ) ; imagecopyresampled ( $ emptyPicture , $ source , 0 , 0 , 0 , 0 , $ width_dest , $ height_dest , $ width_src , $ height_src ) ; imagejpeg ( $ emptyPicture , $ destination , 70 ) ; imagedestroy ( $ source ) ; imagedestroy ( $ emptyPicture ) ; return ; }
4483	public function requeue ( string $ queue ) : void { if ( $ this -> client -> call ( 'recur.update' , $ this -> jid , 'queue' , $ queue ) ) { $ this -> setQueue ( $ queue ) ; } }
1359	public static function jsonApi ( int $ options = 0 , string $ urlPrefix = null , int $ depth = 512 ) : self { return self :: create ( MediaTypeInterface :: JSON_API_MEDIA_TYPE , $ options , $ urlPrefix , $ depth ) ; }
10086	public function writeDebugLog ( ... $ args ) { if ( $ this -> writeDebugLog ) { $ message = implode ( $ args ) ; $ cellReference = implode ( ' -> ' , $ this -> cellStack -> showStack ( ) ) ; if ( $ this -> echoDebugLog ) { echo $ cellReference , ( $ this -> cellStack -> count ( ) > 0 ? ' => ' : '' ) , $ message , PHP_EOL ; } $ this -> debugLog [ ] = $ cellReference . ( $ this -> cellStack -> count ( ) > 0 ? ' => ' : '' ) . $ message ; } }
8020	public function set ( string $ content ) { $ parsed = $ this -> parseContent ( $ content ) ; $ this -> id = $ parsed -> id ; $ this -> infoUri = $ parsed -> infoUri ; $ this -> partialCancelUri = $ parsed -> partialCancelUri ?? null ; $ this -> nextUri = $ parsed -> nextUri ?? null ; $ this -> columns = [ ] ; if ( isset ( $ parsed -> columns ) ) { $ this -> columnTransfer ( $ parsed -> columns ) ; } $ this -> data = $ parsed -> data ?? [ ] ; $ this -> stats = isset ( $ parsed -> stats ) ? $ this -> statsTransfer ( $ parsed -> stats ) : null ; $ this -> error = isset ( $ parsed -> error ) ? $ this -> errorTransfer ( $ parsed -> error ) : null ; }
553	public function actionFlushSchema ( $ db = 'db' ) { $ connection = Yii :: $ app -> get ( $ db , false ) ; if ( $ connection === null ) { $ this -> stdout ( "Unknown component \"$db\".\n" , Console :: FG_RED ) ; return ExitCode :: UNSPECIFIED_ERROR ; } if ( ! $ connection instanceof \ yii \ db \ Connection ) { $ this -> stdout ( "\"$db\" component doesn't inherit \\yii\\db\\Connection.\n" , Console :: FG_RED ) ; return ExitCode :: UNSPECIFIED_ERROR ; } elseif ( ! $ this -> confirm ( "Flush cache schema for \"$db\" connection?" ) ) { return ExitCode :: OK ; } try { $ schema = $ connection -> getSchema ( ) ; $ schema -> refresh ( ) ; $ this -> stdout ( "Schema cache for component \"$db\", was flushed.\n\n" , Console :: FG_GREEN ) ; } catch ( \ Exception $ e ) { $ this -> stdout ( $ e -> getMessage ( ) . "\n\n" , Console :: FG_RED ) ; } }
10081	protected function registerManager ( ) { $ this -> app -> singleton ( 'auja' , function ( $ app ) { $ config = $ app [ 'config' ] [ 'auja-laravel' ] ? : $ app [ 'config' ] [ 'auja-laravel::config' ] ; return new Auja ( $ app , $ app [ 'auja.configurator' ] , $ config [ 'models' ] ) ; } ) ; $ this -> app -> bind ( 'Label305\AujaLaravel\Auja' , 'auja' ) ; }
11853	protected function redirect ( string $ uri , bool $ isPermanent = false ) : void { $ nCode = $ isPermanent ? 301 : 302 ; Headers :: getInstance ( ) -> addByHttpCode ( $ nCode ) -> add ( 'Location: ' . $ uri ) -> run ( ) ; exit ; }
7726	public function postback ( $ text , $ title , $ postback ) { $ payload = [ 'template_type' => 'button' , 'text' => $ text , 'buttons' => [ [ 'type' => 'postback' , 'title' => $ title , 'payload' => $ postback ] ] , ] ; $ this -> setAttachment ( 'template' , $ payload ) ; return $ this ; }
7408	public function merge ( $ ta ) : self { $ this -> _massageBlockInput ( $ in ) ; $ ret = clone $ this ; foreach ( $ ta as $ k => $ v ) { if ( is_int ( $ k ) ) { $ ret [ ] = $ v ; } else { $ ret [ $ k ] = $ v ; } } return $ ret ; }
2021	public static function findPublishedByPid ( $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid=?" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: findBy ( $ arrColumns , $ intPid , $ arrOptions ) ; }
500	protected function readString ( $ fileHandle , $ length , $ offset = null ) { if ( $ offset !== null ) { fseek ( $ fileHandle , $ offset ) ; } return $ this -> readBytes ( $ fileHandle , $ length ) ; }
7746	private function findSetter ( ) { $ reflClass = new \ ReflectionClass ( $ this -> class ) ; $ setter = 'set' . $ this -> camelize ( $ this -> name ) ; $ classHasProperty = $ reflClass -> hasProperty ( $ this -> name ) ; if ( $ reflClass -> hasMethod ( $ setter ) && $ reflClass -> getMethod ( $ setter ) -> isPublic ( ) ) { $ this -> setter = $ setter ; $ this -> setterType = self :: GETTER_SETTER_METHOD ; } elseif ( ( 0 === strpos ( $ this -> name , 'set' ) ) && $ reflClass -> hasMethod ( $ this -> name ) && $ reflClass -> getMethod ( $ this -> name ) -> isPublic ( ) ) { $ this -> setter = $ this -> name ; $ this -> setterType = self :: GETTER_SETTER_METHOD ; } elseif ( ( $ reflClass -> hasMethod ( '__set' ) && $ reflClass -> getMethod ( '__set' ) -> isPublic ( ) ) || ( $ classHasProperty && $ reflClass -> getProperty ( $ this -> name ) -> isPublic ( ) ) ) { $ this -> setter = $ this -> name ; $ this -> setterType = self :: GETTER_SETTER_PROPERTY ; } }
8171	public function renderString ( $ tplString = '' , $ tplData = [ ] ) { try { return $ this -> twig -> createTemplate ( $ tplString ) -> render ( $ tplData ) ; } catch ( Twig_Error $ err ) { return $ this -> error ( $ err , false , $ tplString ) ; } }
12683	public function process ( ) { $ orderedTasks = $ this -> _tasks ; usort ( $ orderedTasks , function ( $ a , $ b ) { return $ a -> duration ( ) > $ b -> duration ( ) ? 1 : - 1 ; } ) ; $ this -> _ranking = $ orderedTasks ; $ matrix = [ ] ; foreach ( $ this -> _ranking as $ task1 ) { $ name1 = $ task1 -> name ( ) ; $ matrix [ $ name1 ] = [ ] ; foreach ( $ this -> _ranking as $ task2 ) { $ name2 = $ task2 -> name ( ) ; $ percent = intval ( round ( $ task1 -> duration ( ) / $ task2 -> duration ( ) * 100 ) ) ; $ matrix [ $ name1 ] [ $ name2 ] = $ percent ; } } $ this -> _matrix = $ matrix ; return $ this ; }
11557	protected function detectNamespace ( $ settings ) { foreach ( $ this -> options -> getNamespaces ( ) as $ namespaceOptions ) { $ namespaceEntityClass = $ namespaceOptions -> getEntityClass ( ) ; if ( $ settings instanceof $ namespaceEntityClass ) { return $ namespaceOptions -> getName ( ) ; } } throw new Exception \ InvalidArgumentException ( 'Unknown Settings namespace' ) ; }
1783	protected function countItems ( $ newsArchives , $ blnFeatured ) { if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'newsListCountItems' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'newsListCountItems' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'newsListCountItems' ] as $ callback ) { if ( ( $ intResult = System :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ newsArchives , $ blnFeatured , $ this ) ) === false ) { continue ; } if ( \ is_int ( $ intResult ) ) { return $ intResult ; } } } return NewsModel :: countPublishedByPids ( $ newsArchives , $ blnFeatured ) ; }
7973	public function purchase ( $ domain , $ quantity ) { if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; if ( ! $ quantity ) throw new BadMethodCallException ( 'Parameter $quantity is missing.' ) ; $ quantity = intval ( $ quantity ) ; $ allowedQ = array ( 100 , 200 , 250 , 500 , 1000 , 5000 , 2500 , 10000 , 50000 , 100000 ) ; if ( ! in_array ( $ quantity , $ allowedQ ) ) throw new BadMethodCallException ( 'Parameter $quantity must be in array (' . implode ( ', ' , $ allowedQ ) . '), "' . $ quantity . '" given.' ) ; try { $ r = $ this -> post ( 'sms/' . $ domain . '/purchase' , array ( 'Content-Type' => 'application/json;charset=UTF-8' ) , json_encode ( $ quantity ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new SmsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
1497	public function push ( Encoding ... $ encodings ) : self { $ copy = new self ( ) ; $ copy -> stack = collect ( $ this -> stack ) -> merge ( $ encodings ) -> all ( ) ; return $ copy ; }
6342	final public static function valueOf ( $ name ) : self { $ className = static :: class ; Preconditions :: checkArgument ( array_key_exists ( $ className , self :: $ cache ) && array_key_exists ( $ name , self :: $ cache [ $ className ] ) , "The enum '%s' type has no constant with name '%s'" , $ className , $ name ) ; return self :: $ cache [ $ className ] [ $ name ] ; }
2740	public function execute ( ) { $ result = $ this -> resultJsonFactory -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ snippet = Config :: BLOCKING_SETTING_NAME ; $ req = $ this -> api -> hasSnippet ( $ activeVersion , $ snippet ) ; if ( $ req == false ) { return $ result -> setData ( [ 'status' => false ] ) ; } return $ result -> setData ( [ 'status' => true , 'req_setting' => $ req ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
7464	public function newAction ( Request $ request , $ hash ) { $ passwordHelper = $ this -> get ( 'orkestra.application.helper.password' ) ; $ hashedEntityHelper = $ this -> get ( 'orkestra.application.helper.hashed_entity' ) ; $ hashedEntity = $ passwordHelper -> lookup ( $ hash ) ; if ( ! $ hashedEntity ) { throw new EntityNotFoundException ( ) ; } $ user = $ hashedEntity -> getReferencedObject ( ) ; $ hashedEntityHelper -> invalidate ( $ hashedEntity ) ; $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ hashedEntity ) ; $ em -> flush ( ) ; if ( $ user ) { $ request -> getSession ( ) -> set ( PasswordSetController :: CURRENT_USER_ID_KEY , $ user -> getId ( ) ) ; $ form = $ this -> getSetPasswordForm ( ) ; return array ( 'form' => $ form -> createView ( ) ) ; } else { throw $ this -> createNotFoundException ( 'No user was found.' ) ; } }
7493	public function trimLeft ( $ characters = null ) { $ this -> string = ltrim ( $ this -> string , $ characters ) ; return $ this ; }
160	public function andHaving ( $ condition , $ params = [ ] ) { if ( $ this -> having === null ) { $ this -> having = $ condition ; } else { $ this -> having = [ 'and' , $ this -> having , $ condition ] ; } $ this -> addParams ( $ params ) ; return $ this ; }
4485	public function watchdog ( string $ jid , string $ worker , ? int $ pid = null ) { if ( empty ( $ this -> channels ) || $ pid === null ) { return ; } ini_set ( 'default_socket_timeout' , self :: UNLIMITED ) ; $ pubsub = $ this -> redis -> pubSubLoop ( ) ; $ callable = [ $ pubsub , 'subscribe' ] ; if ( ! is_callable ( $ callable ) ) { return ; } call_user_func_array ( $ callable , $ this -> channels ) ; foreach ( $ pubsub as $ message ) { if ( $ message -> kind !== 'message' || empty ( $ message -> payload ) ) { continue ; } $ payload = json_decode ( $ message -> payload , true ) ; if ( empty ( $ payload ) ) { continue ; } if ( empty ( $ payload [ 'event' ] ) || ! is_array ( $ payload ) ) { continue ; } if ( ! in_array ( $ payload [ 'event' ] , self :: WATCHDOG_EVENTS , true ) || empty ( $ payload [ 'jid' ] ) ) { continue ; } if ( $ payload [ 'jid' ] !== $ jid ) { continue ; } $ who = 'watchdog:' . $ worker ; switch ( $ payload [ 'event' ] ) { case self :: LOCK_LOST : if ( ! empty ( $ payload [ 'worker' ] ) && $ payload [ 'worker' ] === $ worker ) { $ this -> logger -> info ( "{type}: sending SIGKILL to child {$pid}; job {jid} handed out to another worker" , [ 'type' => $ who , 'jid' => $ jid ] ) ; $ this -> system -> posixKill ( $ pid , SIGKILL ) ; $ pubsub -> stop ( ) ; } break ; case self :: CANCELED : if ( ! empty ( $ payload [ 'worker' ] ) && $ payload [ 'worker' ] === $ worker ) { $ this -> logger -> info ( "{type}: sending SIGKILL to child {$pid}; job {jid} canceled" , [ 'type' => $ who , 'jid' => $ jid ] ) ; $ this -> system -> posixKill ( $ pid , SIGKILL ) ; $ pubsub -> stop ( ) ; } break ; case self :: COMPLETED : case self :: FAILED : $ pubsub -> stop ( ) ; break ; } } unset ( $ pubsub ) ; ini_set ( 'default_socket_timeout' , $ this -> defaultSocketTimeout ) ; }
11834	public function doStore ( ModulesEvent $ event ) { $ cache = $ this -> getCache ( ) ; $ config = $ this -> getConfig ( ) ; $ cache -> set ( 'config' , $ config ) ; }
1679	public function checkPermission ( ) { if ( $ this -> User -> isAdmin ) { return ; } switch ( Contao \ Input :: get ( 'act' ) ) { case 'create' : case 'select' : case 'show' : break ; case 'delete' : if ( Contao \ Input :: get ( 'id' ) == $ this -> User -> id ) { throw new Contao \ CoreBundle \ Exception \ AccessDeniedException ( 'Attempt to delete own account ID ' . Contao \ Input :: get ( 'id' ) . '.' ) ; } case 'edit' : case 'copy' : case 'toggle' : default : $ objUser = $ this -> Database -> prepare ( "SELECT `admin` FROM tl_user WHERE id=?" ) -> limit ( 1 ) -> execute ( Contao \ Input :: get ( 'id' ) ) ; if ( $ objUser -> admin && Contao \ Input :: get ( 'act' ) != '' ) { throw new Contao \ CoreBundle \ Exception \ AccessDeniedException ( 'Not enough permissions to ' . Contao \ Input :: get ( 'act' ) . ' administrator account ID ' . Contao \ Input :: get ( 'id' ) . '.' ) ; } break ; case 'editAll' : case 'deleteAll' : case 'overrideAll' : $ objSession = Contao \ System :: getContainer ( ) -> get ( 'session' ) ; $ session = $ objSession -> all ( ) ; $ objUser = $ this -> Database -> execute ( "SELECT id FROM tl_user WHERE `admin`=1" ) ; $ session [ 'CURRENT' ] [ 'IDS' ] = array_diff ( $ session [ 'CURRENT' ] [ 'IDS' ] , $ objUser -> fetchEach ( 'id' ) ) ; $ objSession -> replace ( $ session ) ; break ; } }
8123	public function savereview ( $ data , Form $ form ) { $ page = $ this -> findRecord ( $ data ) ; $ results = $ this -> getReviewContentHandler ( ) -> submitReview ( $ page , $ data ) ; if ( is_null ( $ results ) ) { return null ; } if ( $ this -> getSchemaRequested ( ) ) { $ extraData = [ 'message' => $ results ] ; $ schemaId = $ this -> owner -> join_links ( $ this -> owner -> Link ( 'schema/ReviewContentForm' ) , $ page -> ID ) ; return $ this -> getSchemaResponse ( $ schemaId , $ form , null , $ extraData ) ; } return $ results ; }
1756	public static function setCookie ( $ strName , $ varValue , $ intExpires , $ strPath = null , $ strDomain = null , $ blnSecure = false , $ blnHttpOnly = false ) { if ( $ strPath == '' ) { $ strPath = Environment :: get ( 'path' ) ? : '/' ; } $ objCookie = new \ stdClass ( ) ; $ objCookie -> strName = $ strName ; $ objCookie -> varValue = $ varValue ; $ objCookie -> intExpires = $ intExpires ; $ objCookie -> strPath = $ strPath ; $ objCookie -> strDomain = $ strDomain ; $ objCookie -> blnSecure = $ blnSecure ; $ objCookie -> blnHttpOnly = $ blnHttpOnly ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'setCookie' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'setCookie' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'setCookie' ] as $ callback ) { $ objCookie = static :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ objCookie ) ; } } setcookie ( $ objCookie -> strName , $ objCookie -> varValue , $ objCookie -> intExpires , $ objCookie -> strPath , $ objCookie -> strDomain , $ objCookie -> blnSecure , $ objCookie -> blnHttpOnly ) ; }
12852	protected static function symbol ( $ symbol ) { if ( $ symbol instanceof Symbol ) return [ $ symbol -> symbol , $ symbol -> package ] ; throw new \ UnexpectedValueException ( sprintf ( "Unexpected value of type '%s'." , is_object ( $ symbol ) ? get_class ( $ symbol ) : gettype ( $ symbol ) ) ) ; }
9498	public function saveEntity ( BaseEntity $ entity , $ endPoint = '' , $ extraData = null ) { $ end_point = strtolower ( $ endPoint ) ; if ( strpos ( $ end_point , 'http' ) !== 0 ) { $ end_point = $ this -> api -> getApiUrl ( ) . $ end_point ; } $ type = $ this -> getType ( ) ; $ className = explode ( '\\' , $ type ) ; $ baseName = strtolower ( end ( $ className ) ) ; $ method = $ entity -> getId ( ) ? 'put' : 'post' ; if ( $ method == 'post' ) { $ entity -> checkCreatable ( ) ; } $ changes = $ entity -> toArray ( true , $ extraData ) ; if ( empty ( $ changes ) ) { return null ; } $ request = $ this -> api -> $ method ( $ end_point , null , json_encode ( array ( $ baseName => $ changes ) ) ) ; $ response = $ this -> processRequest ( $ request ) ; $ result = $ response -> json ( ) ; if ( $ result && isset ( $ result [ $ baseName ] ) ) { $ changeResult = new ChangeResult ( ) ; $ t = new $ type ( ) ; $ this -> manage ( $ t ) ; $ t -> fromArray ( $ result [ $ baseName ] ) ; $ changeResult -> setItem ( $ t ) ; if ( isset ( $ result [ 'audit' ] ) ) { $ audit = new TicketAudit ( ) ; $ audit -> fromArray ( $ result [ 'audit' ] ) ; $ changeResult -> setAudit ( $ audit ) ; } return $ changeResult ; } return null ; }
6739	public function set_options ( ) { $ slug = Module :: CustomRatingGrifus ( ) -> getOption ( 'slug' ) ; $ options = $ this -> model -> get_options ( ) ; foreach ( $ options as $ option => $ value ) { Module :: CustomRatingGrifus ( ) -> setOption ( $ option , $ value ) ; } }
5989	public function setProperties ( array $ properties ) { $ this -> properties = [ ] ; foreach ( $ properties as $ item ) { $ this -> addPropertyCriteria ( $ item ) ; } return $ this ; }
10946	public function post ( $ name = null , $ defaultValue = null ) { if ( $ name === null ) { return $ this -> getBodyParams ( ) ; } else { return $ this -> getBodyParam ( $ name , $ defaultValue ) ; } }
10385	protected static function unify_params ( $ type , $ field , $ default = '' ) { $ data = array_column ( self :: $ data [ $ type ] , $ field ) ; switch ( $ field ) { case 'media' : case 'footer' : case 'version' : foreach ( $ data as $ key => $ value ) { if ( $ data [ 0 ] !== $ value ) { return $ default ; } } return ( isset ( $ data [ 0 ] ) && $ data [ 0 ] ) ? $ data [ 0 ] : $ default ; default : $ params = [ ] ; foreach ( $ data as $ key => $ value ) { $ params = array_merge ( $ params , $ value ) ; } return array_unique ( $ params ) ; } }
523	protected function includeMigrationFile ( $ class ) { $ class = trim ( $ class , '\\' ) ; if ( strpos ( $ class , '\\' ) === false ) { if ( is_array ( $ this -> migrationPath ) ) { foreach ( $ this -> migrationPath as $ path ) { $ file = $ path . DIRECTORY_SEPARATOR . $ class . '.php' ; if ( is_file ( $ file ) ) { require_once $ file ; break ; } } } else { $ file = $ this -> migrationPath . DIRECTORY_SEPARATOR . $ class . '.php' ; require_once $ file ; } } }
8717	public static function forceCreate ( array $ attributes , $ translations = [ ] ) { $ model = new static ; return static :: unguarded ( function ( ) use ( $ model , $ attributes , $ translations ) { return $ model -> create ( $ attributes , $ translations ) ; } ) ; }
4680	public function render ( ContainerInterface $ di = null ) { switch ( $ this -> type ) { case "file" : if ( $ di -> has ( "viewRenderFile" ) ) { $ viewRender = $ di -> get ( "viewRenderFile" ) ; } else { $ viewRender = new ViewRenderFile ( $ di ) ; $ viewRender -> setDI ( $ di ) ; } $ viewRender -> render ( $ this -> template , $ this -> templateData ) ; break ; case "callback" : if ( ! is_callable ( $ this -> template ) ) { throw new Exception ( "View is expecting a valid callback, provided callback seems to not be a callable." ) ; } echo call_user_func ( $ this -> template , $ this -> templateData ) ; break ; case "string" : echo $ this -> template ; break ; case "empty" : break ; default : throw new Exception ( "Not a valid template type: '{$this->type}'." ) ; } }
7488	public function append ( $ string ) { $ string = static :: convertString ( $ string , $ this -> encoding ) ; $ this -> string .= $ string ; return $ this ; }
8534	public function setChargeInstrumentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ChargeInstrumentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
1971	public static function findMultipleByUuids ( $ arrUuids , array $ arrOptions = array ( ) ) { if ( empty ( $ arrUuids ) || ! \ is_array ( $ arrUuids ) ) { return null ; } $ t = static :: $ strTable ; foreach ( $ arrUuids as $ k => $ v ) { if ( Validator :: isStringUuid ( $ v ) ) { $ v = StringUtil :: uuidToBin ( $ v ) ; } $ arrUuids [ $ k ] = "UNHEX('" . bin2hex ( $ v ) . "')" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.uuid!=" . implode ( ", $t.uuid!=" , $ arrUuids ) ; } return static :: findBy ( array ( "$t.uuid IN(" . implode ( "," , $ arrUuids ) . ")" ) , null , $ arrOptions ) ; }
2037	public function getSlugOptions ( ) { $ slugOptions = array ( 'locale' => $ this -> language ) ; if ( $ this -> validAliasCharacters ) { $ slugOptions [ 'validChars' ] = $ this -> validAliasCharacters ; } return $ slugOptions ; }
7375	public function clear ( ) { while ( ! $ this -> queue -> isEmpty ( ) ) { $ this -> queue -> pop ( ) ; } $ this -> queue = null ; }
5581	public function getLink ( $ label , $ index = 0 ) { $ urls = $ this -> page -> getUrlsByLabel ( $ label ) ; if ( count ( $ urls ) == 0 ) { return false ; } if ( count ( $ urls ) < $ index + 1 ) { return false ; } return $ urls [ $ index ] ; }
415	public function getAcceptableContentTypes ( ) { if ( $ this -> _contentTypes === null ) { if ( $ this -> headers -> get ( 'Accept' ) !== null ) { $ this -> _contentTypes = $ this -> parseAcceptHeader ( $ this -> headers -> get ( 'Accept' ) ) ; } else { $ this -> _contentTypes = [ ] ; } } return $ this -> _contentTypes ; }
8297	protected function createBkFile ( ) { if ( ! is_writable ( dirname ( $ this -> filePath ) ) ) { return ; } $ this -> bkFilePath = $ this -> filePath . '.' . date ( "y-m-d-H-i-s" ) . '.bak' ; $ bkHandle = @ fopen ( $ this -> bkFilePath , 'x+' ) ; if ( $ bkHandle === false ) { $ this -> close ( ) ; throw new \ RuntimeException ( "Could not create a temporary file " . $ this -> bkFilePath ) ; } $ stat = fstat ( $ this -> handle ) ; if ( stream_copy_to_stream ( $ this -> handle , $ bkHandle ) !== $ stat [ 'size' ] ) { $ this -> close ( ) ; throw new \ RuntimeException ( "Could not create a copy of " . $ this -> filePath ) ; } if ( ! fclose ( $ bkHandle ) ) { throw new \ RuntimeException ( "Could not close a backup file " . $ this -> bkFilePath ) ; } fseek ( $ this -> handle , 0 ) ; }
6737	public function uninstallation ( ) { $ this -> model -> delete_post_meta ( ) ; $ this -> model -> delete_options ( ) ; $ this -> model -> remove_tables ( ) ; }
3380	public function getModel ( $ entity ) { if ( \ Links :: isMain ( $ entity ) ) { $ modelClass = 'Serverfireteam\\Panel\\' . $ entity ; } else { if ( ! empty ( \ Config :: get ( 'panel.modelPath' ) ) ) { $ modelClass = $ this -> getNameSpace ( ) . \ Config :: get ( 'panel.modelPath' ) . '\\' . $ entity ; } else { $ modelClass = $ this -> getNameSpace ( ) . $ entity ; } } return $ modelClass ; }
5944	public function categories ( $ categoryIds , $ deploymentSiteIds = null , $ ignoreGrouping = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'deploymentSiteIds' => $ deploymentSiteIds , 'ignoreGrouping' => $ ignoreGrouping ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/filters/categories/' . $ categoryIds . '' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new FilterItem ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
11008	public function addReportUri ( string $ reportUri ) : bool { if ( ! filter_var ( $ reportUri , FILTER_VALIDATE_URL ) ) { throw new MiddlewareException ( $ this , sprintf ( "'%s' is not a valid URI and can not be set as the CSP report URI" , $ reportUri ) ) ; } if ( ! in_array ( $ reportUri , $ this -> tags [ 'report-uri' ] ) ) { $ this -> tags [ 'report-uri' ] [ ] = $ reportUri ; return true ; } return false ; }
1343	public function isIndex ( ) : bool { return $ this -> isMethod ( 'get' ) && $ this -> getRoute ( ) -> isNotResource ( ) && $ this -> getRoute ( ) -> isNotProcesses ( ) ; }
6791	public function create ( $ type , $ source = null ) { $ notify = new Notify ( ) ; $ notify -> setType ( $ type ) -> setSource ( $ source ) ; return $ notify ; }
5539	protected function getPublicNameFromIndex ( $ subject ) { foreach ( $ this -> names as $ name => $ index ) { if ( $ subject == $ index ) { return $ name ; } } return $ subject + 1 ; }
10714	public function updateById ( $ id , array $ newAttributes ) { $ model = $ this -> getById ( $ id ) ; $ results = $ model -> update ( $ newAttributes ) ; if ( ! $ results ) { throw new UpdateFailedRepositoryException ( ) ; } return $ model ; }
11188	public static function set ( array $ arr , $ k , $ v ) { $ nested = ! is_array ( $ k ) ? explode ( '.' , $ k ) : $ k ; $ count = count ( $ nested ) ; if ( $ count == 1 ) { return $ arr [ $ k ] = $ v ; } elseif ( $ count > 1 ) { $ prev = '' ; $ loop = 1 ; $ unshift = $ nested ; foreach ( $ nested as $ part ) { if ( isset ( $ arr [ $ part ] ) && $ count > $ loop ) { $ prev = $ part ; array_shift ( $ unshift ) ; $ loop ++ ; continue ; } else { if ( $ loop > 1 && $ loop < $ count ) { if ( ! isset ( $ arr [ $ prev ] [ $ part ] ) ) $ arr [ $ prev ] [ $ part ] = [ ] ; $ arr [ $ prev ] = static :: set ( $ arr [ $ prev ] , $ unshift , $ v ) ; $ loop ++ ; break ; } elseif ( $ loop >= 1 && $ loop == $ count ) { if ( ! is_array ( $ arr [ $ prev ] ) ) $ arr [ $ prev ] = [ ] ; if ( $ part == '' ) $ arr [ $ prev ] [ ] = $ v ; else $ arr [ $ prev ] [ $ part ] = $ v ; } else { $ arr [ $ part ] = [ ] ; $ prev = $ part ; array_shift ( $ unshift ) ; $ loop ++ ; } } } } return $ arr ; }
4451	public function recur ( string $ className , array $ data , ? int $ interval = null , ? int $ offset = null , ? string $ jid = null , ? int $ retries = null , ? int $ priority = null , ? int $ backlog = null , ? array $ tags = null ) { try { $ jid = $ jid ? : Uuid :: uuid4 ( ) -> toString ( ) ; } catch ( \ Exception $ e ) { throw new RuntimeException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } $ data = json_encode ( $ data , JSON_UNESCAPED_SLASHES ) ; if ( empty ( $ data ) ) { throw new RuntimeException ( sprintf ( 'Unable to encode payload to make a recurring job "%s" for the "%s" queue.' , $ jid , $ this -> name ) ) ; } return $ this -> client -> recur ( $ this -> name , $ jid , $ className , $ data , 'interval' , is_null ( $ interval ) ? 60 : $ interval , is_null ( $ offset ) ? 0 : $ offset , 'priority' , is_null ( $ priority ) ? 0 : $ priority , 'tags' , json_encode ( $ tags ? : [ ] , JSON_UNESCAPED_SLASHES ) , 'retries' , is_null ( $ retries ) ? 5 : $ retries , 'backlog' , is_null ( $ backlog ) ? 0 : $ backlog ) ; }
5023	public function allowSelectMultipleItems ( ) { $ flagOrCallback = $ this -> allowSelectMultipleItems ; return is_callable ( $ flagOrCallback ) ? ( bool ) $ flagOrCallback ( ) : ( bool ) $ flagOrCallback ; }
9478	protected function getCalendarDayDownloads ( $ limit = 30 ) { $ arrCalendarDayDownloads = array ( ) ; $ CalendarDays = date ( 'Y-m-d' , mktime ( 0 , 0 , 0 , date ( "m" ) , date ( "d" ) - $ limit , date ( "Y" ) ) ) ; $ objCalendarDayDownloads = \ Database :: getInstance ( ) -> prepare ( "SELECT dl.`id` , FROM_UNIXTIME(det.`tstamp`,GET_FORMAT(DATE,'ISO')) as datum , count(dl.`filename`) as downloads , dl.`filename` FROM `tl_dlstats` dl INNER JOIN `tl_dlstatdets` det on dl.id = det.pid WHERE FROM_UNIXTIME(det.`tstamp`,GET_FORMAT(DATE,'ISO')) >=? GROUP BY dl.`id`, datum ORDER BY datum DESC, `filename`" ) -> execute ( $ CalendarDays ) ; while ( $ objCalendarDayDownloads -> next ( ) ) { $ viewDate = $ this -> parseDate ( $ GLOBALS [ 'TL_CONFIG' ] [ 'dateFormat' ] , strtotime ( $ objCalendarDayDownloads -> datum ) ) ; $ c4d = $ this -> check4details ( $ objCalendarDayDownloads -> id ) ; $ arrCalendarDayDownloads [ ] = array ( $ viewDate , $ objCalendarDayDownloads -> filename , $ this -> getFormattedNumber ( $ objCalendarDayDownloads -> downloads , 0 ) , $ objCalendarDayDownloads -> id , $ c4d , $ objCalendarDayDownloads -> downloads , strtotime ( $ objCalendarDayDownloads -> datum ) ) ; } return $ arrCalendarDayDownloads ; }
8959	private function prepareArrayParameter ( $ name ) { if ( isset ( $ this -> parameters [ $ name ] ) ) { $ parameterArray = $ this -> parameters [ $ name ] ; $ count = count ( $ parameterArray ) ; $ str = "['" . $ parameterArray [ 0 ] . "'" ; for ( $ i = 1 ; $ i < $ count ; ++ $ i ) { $ str .= ", '" . $ parameterArray [ $ i ] . "'" ; } $ str .= ']' ; return $ str ; } }
6678	public static function getDateRangeText ( $ startDate , $ endDate , $ toSeparator = 'to' ) { if ( $ startDate == $ endDate ) { return self :: format ( $ startDate , DateFormat :: FORMAT_SHORT ) ; } elseif ( self :: format ( $ startDate , DateFormat :: FORMAT_YEAR ) == self :: format ( $ endDate , DateFormat :: FORMAT_YEAR ) ) { $ start_date = ( self :: format ( $ startDate , DateFormat :: FORMAT_MONTH ) == self :: format ( $ endDate , DateFormat :: FORMAT_MONTH ) ) ? self :: format ( $ startDate , DateFormat :: FORMAT_DAY ) : self :: format ( $ startDate , DateFormat :: FORMAT_SHORT_NO_YEAR ) ; } else { $ start_date = self :: format ( $ startDate , DateFormat :: FORMAT_SHORT ) ; } return $ start_date . ' ' . $ toSeparator . ' ' . self :: format ( $ endDate , DateFormat :: FORMAT_SHORT ) ; }
10342	protected function isValidDate ( $ year , $ month , $ day ) { if ( $ month <= 0 || $ month > 12 || $ day <= 0 || $ day > 31 ) { return false ; } if ( ( $ month == 4 || $ month == 6 || $ month == 9 || $ month == 11 ) && ( $ day == 31 ) ) { return false ; } if ( $ month == 2 ) { if ( $ day > 29 ) { return false ; } $ leap = date ( 'L' , strtotime ( $ year . '-01-01' ) ) ; if ( $ leap === '0' && $ day > 28 ) { return false ; } } return true ; }
6456	public function selectable ( ) { $ this -> restrictElements ( [ 'select' => [ ] ] ) ; $ data = [ $ this -> value , $ this -> element -> find ( 'xpath' , "//option[@value='$this->value']" ) -> getText ( ) ] ; self :: debug ( [ 'Expected: %s' , 'Value: %s' , 'Tag: %s' , ] , [ $ this -> expected , implode ( ' => ' , $ data ) , $ this -> tag , ] ) ; $ this -> assert ( in_array ( $ this -> expected , $ data ) , 'selected' ) ; }
9077	public function addCollection ( RuleCollection $ collection ) { foreach ( $ collection -> all ( ) as $ name => $ rule ) { unset ( $ this -> rules [ $ name ] ) ; $ this -> rules [ $ name ] = $ rule ; } $ this -> resources = array_merge ( $ this -> resources , $ collection -> getResources ( ) ) ; }
1663	public function image ( $ imageUrl , $ accessibilityText = null ) { $ this -> imageUrl = $ imageUrl ; $ this -> accessibilityText = $ accessibilityText ; return $ this ; }
864	private function registerFoundToken ( $ token ) { $ tokenKind = $ token instanceof Token ? ( $ token -> isArray ( ) ? $ token -> getId ( ) : $ token -> getContent ( ) ) : ( \ is_array ( $ token ) ? $ token [ 0 ] : $ token ) ; if ( ! isset ( $ this -> foundTokenKinds [ $ tokenKind ] ) ) { $ this -> foundTokenKinds [ $ tokenKind ] = 0 ; } ++ $ this -> foundTokenKinds [ $ tokenKind ] ; }
4929	public function attach ( EventManagerInterface $ events , $ priority = 1 ) { foreach ( $ this -> listenerSpecs as $ name => $ spec ) { $ this -> listeners [ ] = $ events -> attach ( $ spec [ 'event' ] , array ( $ this , "do$name" ) , $ spec [ 'priority' ] ) ; } }
10760	protected function buildUpdateSet ( ) { $ result = [ ] ; $ data = $ this -> clause_data [ 0 ] ; foreach ( $ data as $ col => $ val ) { $ result [ ] = $ this -> quote ( $ col ) . ' = ' . $ this -> processValue ( $ val ) ; } return $ result ; }
10844	protected function calculateAttributePrice ( VariantInterface $ variant , $ amount ) { $ modifierType = $ variant -> getModifierType ( ) ; $ modifierValue = $ variant -> getModifierValue ( ) ; switch ( $ modifierType ) { case '+' : $ amount = $ amount + $ modifierValue ; break ; case '-' : $ amount = $ amount - $ modifierValue ; break ; case '%' : $ amount = $ amount * ( $ modifierValue / 100 ) ; break ; } return round ( $ amount , 2 ) ; }
11405	public function createService ( ServiceLocatorInterface $ serviceLocator ) { $ cacheManager = new CacheManager ( $ serviceLocator -> get ( 'HtSettingsModule\Options\ModuleOptions' ) -> getCacheOptions ( ) ) ; $ cacheManager -> setServiceLocator ( $ serviceLocator ) ; return $ cacheManager ; }
5860	public function getAllFileTypes ( ) { $ fileTypes = [ ] ; foreach ( $ this -> rulesets as $ ruleset ) { if ( is_array ( $ ruleset [ 'file_types' ] ) ) { $ fileTypes = array_merge ( $ fileTypes , $ ruleset [ 'file_types' ] ) ; } } $ fileTypes = array_unique ( $ fileTypes ) ; return $ fileTypes ; }
7456	private function ensureDirectoryExists ( $ path ) { if ( ! is_dir ( $ path ) ) { if ( ! mkdir ( $ path , 0777 , true ) ) { throw new \ RuntimeException ( sprintf ( 'Could not create directory "%s"' , $ path ) ) ; } } return $ path ; }
4030	protected function getLabelPattern ( EnvironmentInterface $ environment , ModelInterface $ model ) { $ translator = $ environment -> getTranslator ( ) ; $ type = $ model -> getProperty ( 'type' ) ; $ combined = 'typedesc.' . $ type ; if ( ( $ resultPattern = $ translator -> translate ( $ combined , 'tl_metamodel_filtersetting' ) ) == $ combined ) { $ resultPattern = $ translator -> translate ( 'typedesc._default_' , 'tl_metamodel_filtersetting' ) ; } return $ resultPattern ; }
7404	private function convertFileInformation ( $ file ) { if ( $ file instanceof FileUpload ) { return $ file ; } $ file = $ this -> fixPhpFilesArray ( $ file ) ; if ( is_array ( $ file ) ) { $ keys = array_keys ( $ file ) ; sort ( $ keys ) ; if ( $ keys == [ 'error' , 'name' , 'size' , 'tmp_name' , 'type' ] ) { if ( UPLOAD_ERR_NO_FILE == $ file [ 'error' ] ) { $ file = null ; } else { $ file = new FileUpload ( $ file [ 'tmp_name' ] , $ file [ 'name' ] , $ file [ 'size' ] , $ file [ 'type' ] , $ file [ 'error' ] ) ; } } else { $ file = array_map ( [ $ this , 'convertFileInformation' ] , $ file ) ; } } return $ file ; }
5304	public function getPath ( $ scale = 1 , $ roundPrecision = null , $ flip = 'none' , $ onlyFilled = true , $ xOffset = 0 , $ yOffset = 0 ) { $ path = $ this -> getPathPart ( $ this -> xmlDocument , $ onlyFilled ) ; if ( $ scale !== 1 || $ roundPrecision !== null || $ flip !== 'none' || $ xOffset !== 0 || $ yOffset !== 0 ) { $ path = $ this -> transformPath ( $ path , $ scale , $ roundPrecision , $ flip , $ xOffset / $ scale , $ yOffset / $ scale ) ; } return trim ( $ path ) ; }
5028	public function decorateClassMetaData ( ClassMetadata $ c ) { $ parentClassName = $ c -> getName ( ) ; if ( isset ( $ this -> mappings [ $ parentClassName ] ) ) { $ c -> discriminatorMap = array ( ) ; $ c -> discriminatorMap [ strtolower ( Str :: classname ( $ parentClassName ) ) ] = $ parentClassName ; foreach ( $ this -> mappings [ $ parentClassName ] as $ className ) { $ bundlePrefix = Str :: infix ( $ this -> getBundleName ( $ className ) , '-' ) ; $ name = Str :: infix ( Str :: classname ( Str :: rstrip ( $ className , Str :: classname ( $ parentClassName ) ) ) , '-' ) ; $ combinedDiscriminator = sprintf ( '%s-%s' , $ bundlePrefix , $ name ) ; $ c -> discriminatorMap [ $ combinedDiscriminator ] = $ className ; $ c -> subClasses [ ] = $ className ; } $ c -> subClasses = array_unique ( $ c -> subClasses ) ; } }
10092	protected function identifierHash ( $ identifier , $ hash = 'md5' ) { if ( filter_var ( $ identifier , FILTER_VALIDATE_EMAIL ) || $ identifier === null ) { return hash ( $ hash , $ identifier ) ; } return hash ( 'sha256' , $ identifier ) ; }
7198	protected function fixCustomers ( OrderInterface $ order ) { $ changed = false ; $ originCustomer = $ order -> getOriginCustomer ( ) ; $ customer = $ order -> getCustomer ( ) ; if ( is_null ( $ customer ) ) { if ( $ originCustomer && $ originCustomer -> hasParent ( ) ) { $ order -> setCustomer ( $ originCustomer -> getParent ( ) ) ; $ changed = true ; } } elseif ( $ customer -> hasParent ( ) ) { $ order -> setCustomer ( $ customer -> getParent ( ) ) ; if ( null === $ order -> getOriginCustomer ( ) ) { $ order -> setOriginCustomer ( $ customer ) ; } $ changed = true ; } if ( $ changed ) { $ this -> persistenceHelper -> persistAndRecompute ( $ order , false ) ; } return $ changed ; }
4066	public function handle ( BuildWidgetEvent $ event ) { $ environment = $ event -> getEnvironment ( ) ; if ( ( $ environment -> getDataDefinition ( ) -> getName ( ) !== 'tl_metamodel_dcasetting' ) || ( $ event -> getProperty ( ) -> getName ( ) !== 'mandatory' ) || ( null === $ event -> getModel ( ) -> getId ( ) ) ) { return ; } $ model = $ event -> getModel ( ) ; $ metaModel = $ this -> getMetaModelFromModel ( $ model ) ; $ attribute = $ metaModel -> getAttributeById ( $ model -> getProperty ( 'attr_id' ) ) ; if ( null === $ attribute ) { return ; } if ( $ attribute -> get ( 'isunique' ) ) { Message :: addInfo ( $ this -> translator -> trans ( 'tl_metamodel_dcasetting.mandatory_for_unique_attr' , [ ] , 'contao_tl_metamodel_dcasetting' ) ) ; $ extra = $ event -> getProperty ( ) -> getExtra ( ) ; $ extra [ 'disabled' ] = true ; $ event -> getProperty ( ) -> setExtra ( $ extra ) ; $ model -> setProperty ( 'mandatory' , true ) ; } }
3646	public function clean ( $ value , bool $ trim = true , bool $ clean = true ) { if ( is_bool ( $ value ) || is_int ( $ value ) || is_float ( $ value ) ) { return $ value ; } $ final = null ; if ( $ value !== null ) { if ( is_array ( $ value ) ) { $ all = $ value ; $ final = [ ] ; foreach ( $ all as $ key => $ value ) { if ( $ value !== null ) { $ final [ $ key ] = $ this -> clean ( $ value , $ trim , $ clean ) ; } } } else { if ( $ value !== null ) { $ final = $ this -> process ( ( string ) $ value , $ trim , $ clean ) ; } } } return $ final ; }
8928	public function add ( $ name , GeneratorInterface $ class ) { if ( array_key_exists ( $ name , $ this -> generators ) ) { throw new \ InvalidArgumentException ( 'Generator already exists.' ) ; } $ this -> generators [ $ name ] = $ class ; }
6194	protected function loadControllers ( $ path ) { $ this -> app -> config [ 'controller' ] = array_unique ( array_merge ( $ this -> app -> config [ 'controller' ] ?? [ ] , $ path ) ) ; }
10205	public function setIndent ( $ pValue ) { if ( $ pValue > 0 ) { if ( $ this -> getHorizontal ( ) != self :: HORIZONTAL_GENERAL && $ this -> getHorizontal ( ) != self :: HORIZONTAL_LEFT && $ this -> getHorizontal ( ) != self :: HORIZONTAL_RIGHT ) { $ pValue = 0 ; } } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'indent' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> indent = $ pValue ; } return $ this ; }
6884	static public function isValidType ( $ type , $ throw = true ) { if ( in_array ( $ type , static :: getTypes ( ) , true ) ) { return true ; } if ( $ throw ) { throw new InvalidArgumentException ( 'Invalid notification type.' ) ; } return false ; }
5666	private function attachLabels ( $ widgets_by_id , $ labels ) { foreach ( $ labels as $ label ) { $ for = $ label -> getFor ( ) ; if ( $ for and isset ( $ widgets_by_id [ $ for ] ) ) { $ text = $ label -> getText ( ) ; foreach ( $ widgets_by_id [ $ for ] as $ widget ) { $ widget -> setLabel ( $ text ) ; } } } }
585	protected function loadBundles ( $ bundles ) { $ this -> stdout ( "Collecting source bundles information...\n" ) ; $ am = $ this -> getAssetManager ( ) ; $ result = [ ] ; foreach ( $ bundles as $ name ) { $ result [ $ name ] = $ am -> getBundle ( $ name ) ; } foreach ( $ result as $ bundle ) { $ this -> loadDependency ( $ bundle , $ result ) ; } return $ result ; }
2183	public function create ( ) : ItemInterface { $ tree = $ this -> factory -> createItem ( 'root' ) ; $ this -> eventDispatcher -> dispatch ( ContaoCoreEvents :: BACKEND_MENU_BUILD , new MenuEvent ( $ this -> factory , $ tree ) ) ; return $ tree ; }
3801	public function getCache ( ) { @ trigger_error ( '"' . __METHOD__ . '" is deprecated as the service container will get removed.' , E_USER_DEPRECATED ) ; if ( \ is_callable ( $ this -> cache ) ) { $ this -> cache = \ call_user_func ( $ this -> cache ) ; } return $ this -> cache ; }
8924	public function merge ( $ patchDocument1 , $ patchDocument2 ) { if ( $ patchDocument1 === null || $ patchDocument2 === null || ! is_object ( $ patchDocument1 ) || ! is_object ( $ patchDocument2 ) ) { return $ patchDocument2 ; } $ patchDocument = $ patchDocument1 ; $ patchDocument1Vars = get_object_vars ( $ patchDocument1 ) ; $ patchDocument2Vars = get_object_vars ( $ patchDocument2 ) ; foreach ( $ patchDocument2Vars as $ var => $ value ) { if ( isset ( $ patchDocument1Vars [ $ var ] ) ) { $ patchDocument -> $ var = $ this -> merge ( $ patchDocument1 -> $ var , $ patchDocument2 -> $ var ) ; } else { $ patchDocument -> $ var = $ patchDocument2 -> $ var ; } } return $ patchDocument ; }
3469	public function options ( string $ route , callable $ controller ) : void { $ this -> register ( $ controller , Route :: options ( $ route ) ) ; }
12079	public function childDissociate ( $ request , $ idParent , $ idChild , $ relation ) { $ idParent = $ this -> getRealId ( $ idParent ) ; $ idChild = $ this -> getRealId ( $ idChild ) ; if ( ! $ this -> repository -> detach ( $ idParent , $ idChild , $ relation ) ) { } return $ this -> success ( [ ] ) ; }
2864	public function getLastFilePosition ( $ filePath ) { if ( ! file_exists ( $ filePath ) ) { return 0 ; } $ f = fopen ( $ filePath , 'r' ) ; fseek ( $ f , - 1 , SEEK_END ) ; return ftell ( $ f ) ; }
1299	private function formatValue ( string $ type , $ value , string $ itemsType = null ) { if ( \ is_object ( $ value ) && $ value instanceof \ JsonSerializable ) { $ value = guzzle_json_decode ( guzzle_json_encode ( $ value ) , true ) ; } if ( null === $ value ) { return null ; } switch ( $ type ) { case 'Array' : return \ array_map ( function ( $ value ) use ( $ itemsType ) { return $ this -> formatValue ( ( string ) $ itemsType , $ value ) ; } , $ value ) ; case 'Date' : return new DateTimeImmutable ( $ value , new \ DateTimeZone ( 'UTC' ) ) ; case 'Link' : return new Link ( $ value [ 'sys' ] [ 'id' ] , $ value [ 'sys' ] [ 'linkType' ] ) ; case 'Location' : return new Location ( $ value [ 'lat' ] , $ value [ 'lon' ] ) ; case 'RichText' : return $ this -> richTextParser -> parse ( $ value ) ; default : return $ value ; } }
9234	public function actionUpdate ( $ id ) { $ model = $ this -> findModel ( $ id ) ; $ model -> tags = ! empty ( $ model -> tags ) ? explode ( "," , $ model -> tags ) : [ ] ; if ( Yii :: $ app -> request -> post ( ) ) { $ post = Yii :: $ app -> request -> post ( ) ; $ category = [ ] ; if ( isset ( $ post [ 'Post' ] [ 'category' ] ) ) { $ category = $ post [ 'Post' ] [ 'category' ] ; } if ( is_array ( $ post [ 'Post' ] [ 'tags' ] ) ) { $ post [ 'Post' ] [ 'tags' ] = implode ( "," , $ post [ 'Post' ] [ 'tags' ] ) ; } $ model -> load ( $ post ) ; $ transaction = Yii :: $ app -> db -> beginTransaction ( ) ; try { if ( $ model -> save ( ) ) { $ cs = BlogCatPos :: deleteAll ( "post_id = :id" , [ "id" => $ model -> id ] ) ; foreach ( $ category as $ d ) { $ c = new BlogCatPos ( ) ; $ c -> post_id = $ model -> id ; $ c -> category_id = $ d ; $ c -> isdel = 0 ; $ c -> save ( ) ; } $ transaction -> commit ( ) ; return $ this -> redirect ( [ 'view' , 'id' => $ model -> id ] ) ; } else { $ transaction -> rollBack ( ) ; } } catch ( Exception $ e ) { $ transaction -> rollBack ( ) ; } } return $ this -> render ( 'update' , [ 'model' => $ model , ] ) ; }
6713	public function getParameter ( $ key , $ default = null ) { if ( array_key_exists ( $ key , $ this -> parameters ) ) { return $ this -> parameters [ $ key ] ; } $ flatKey = $ this -> flatten ( $ key ) ; foreach ( $ this -> parameters as $ index => $ value ) { if ( $ flatKey == $ this -> flatten ( $ index ) ) { return $ value ; } } return $ default ; }
6587	public function setOpt ( $ name , $ value = null ) { if ( is_array ( $ name ) ) { try { $ i = 0 ; foreach ( $ name as $ opt => $ value ) { $ this -> setOpt ( $ opt , $ value ) ; ++ $ i ; } } catch ( CurlException $ e ) { throw $ e -> getCode ( ) ? $ e : new CurlException ( "Set failed at #$i: " . $ e -> getMessage ( ) ) ; } } else { try { set_error_handler ( function ( $ s , $ m , $ f , $ l , $ c = null ) use ( $ name ) { throw new CurlException ( "$m (" . CurlOptions :: name ( $ name ) . ")." ) ; } , \ E_WARNING ) ; $ this -> perform ( 'curl_setopt' , $ name , $ value ) ; } finally { restore_error_handler ( ) ; } } }
9696	function createTransactions ( $ transactions , $ release = true , $ ignoreInvalidEvents = false ) { $ queryParameters = array ( 'release' => ( $ release == true ) ? 'true' : 'false' , 'ignore_invalid_transactions' => ( $ ignoreInvalidEvents == true ) ? 'true' : 'false' ) ; $ data = JSONSerializer :: json_encode ( $ transactions ) ; $ result = $ this -> post ( "transactions" , $ data , $ queryParameters , "application/json" , 'com_maileon_api_transactions_ProcessingReports' ) ; return $ result ; }
6751	private function createQualifiedTransformerClass ( ) { $ reflection = new ReflectionClass ( __CLASS__ ) ; $ name = $ reflection -> getName ( ) ; $ qualifiedTransformerClass = $ name . "Transformer" ; $ this -> setTransformer ( $ qualifiedTransformerClass ) ; }
6841	public function getCache ( $ key ) { return isset ( $ this -> caches [ $ key ] ) ? $ this -> caches [ $ key ] : null ; }
512	protected function addValues ( $ data , $ duration ) { $ result = $ this -> useApcu ? apcu_add ( $ data , null , $ duration ) : apc_add ( $ data , null , $ duration ) ; return is_array ( $ result ) ? array_keys ( $ result ) : [ ] ; }
11663	public static function saveToFile ( $ file , $ properties ) { $ prop_string = self :: saveToString ( $ properties ) ; $ real_file = File :: asFile ( $ file ) ; if ( ! $ real_file -> exists ( ) ) { $ real_file -> touch ( ) ; } $ real_file -> setContent ( $ prop_string ) ; }
1717	public function canEditFieldsOf ( $ table ) { if ( $ this -> isAdmin ) { return true ; } return \ count ( preg_grep ( '/^' . preg_quote ( $ table , '/' ) . '::/' , $ this -> alexf ) ) > 0 ; }
5613	public function paintFail ( $ message ) { parent :: paintFail ( $ message ) ; $ node = new TreemapNode ( 'Assertion' , $ message , false ) ; $ current = $ this -> _stack -> peek ( ) ; $ current -> putChild ( $ node ) ; $ current -> fail ( ) ; }
6932	private function isShipmentAmountInvoiced ( Invoice \ InvoiceInterface $ invoice ) { $ sale = $ invoice -> getSale ( ) ; foreach ( $ sale -> getInvoices ( ) as $ i ) { if ( $ i === $ invoice ) { continue ; } if ( $ i -> hasLineByType ( Document \ DocumentLineTypes :: TYPE_SHIPMENT ) ) { return true ; } } return false ; }
6458	public function writeJson ( IHttpResponseMessage $ response , array $ content ) : void { $ json = json_encode ( $ content ) ; if ( json_last_error ( ) !== JSON_ERROR_NONE ) { throw new InvalidArgumentException ( 'Failed to JSON encode content: ' . json_last_error_msg ( ) ) ; } $ response -> getHeaders ( ) -> add ( 'Content-Type' , 'application/json' ) ; $ response -> setBody ( new StringBody ( $ json ) ) ; }
3732	protected function copyFilter ( $ objFilter ) { if ( $ objFilter ) { $ objNewFilter = $ objFilter -> createCopy ( ) ; } else { $ objNewFilter = $ this -> getEmptyFilter ( ) ; } return $ objNewFilter ; }
10986	public static function getMaxUploadSize ( $ max_size = 0 ) { $ post_max_size = Tools :: unformatBytes ( ini_get ( 'post_max_size' ) ) ; $ upload_max_filesize = Tools :: unformatBytes ( ini_get ( 'upload_max_filesize' ) ) ; if ( $ max_size > 0 ) { $ result = min ( $ post_max_size , $ upload_max_filesize , $ max_size ) ; } else { $ result = min ( $ post_max_size , $ upload_max_filesize ) ; } return $ result ; }
12114	protected function loadForeignDataItems ( ) { $ this -> _foreignDataItems = [ ] ; if ( $ this -> lazyForeign ) { $ primaryKeys = $ this -> foreignModel -> findPrimaryKeys ( $ this -> settings [ 'foreignPullParams' ] ) ; foreach ( $ primaryKeys as $ primaryKey ) { $ this -> createForeignDataItem ( null , [ 'foreignPrimaryKey' => $ primaryKey ] ) ; } } else { $ foreignModels = $ this -> foreignModel -> findAll ( $ this -> settings [ 'foreignPullParams' ] ) ; foreach ( $ foreignModels as $ key => $ model ) { $ this -> createForeignDataItem ( $ model , [ ] ) ; } } }
9676	public function allFonts ( Spreadsheet $ spreadsheet ) { $ aFonts = [ ] ; $ aStyles = $ this -> allStyles ( $ spreadsheet ) ; foreach ( $ aStyles as $ style ) { if ( ! isset ( $ aFonts [ $ style -> getFont ( ) -> getHashCode ( ) ] ) ) { $ aFonts [ $ style -> getFont ( ) -> getHashCode ( ) ] = $ style -> getFont ( ) ; } } return $ aFonts ; }
3215	function getAccountInfo ( ) { $ response = $ this -> doGet ( $ this -> apiHost , "1/account/info" ) ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; return RequestUtil :: parseResponseJson ( $ response -> body ) ; }
6659	protected function getEndpoints ( ) { if ( ! $ this -> endpointsCache ) { $ isHidden = $ this -> getControllerMethod ( 'isMethodHidden' ) ; $ endpoints = [ ] ; $ parts = [ ] ; $ methods = $ this -> reflectedController -> getMethods ( \ ReflectionMethod :: IS_PUBLIC ) ; foreach ( $ methods as $ method ) { if ( preg_match ( '/([a-z]+)([A-Z]\w+)Endpoint$/' , $ method -> getName ( ) , $ parts ) ) { if ( ! $ isHidden ( $ method -> getName ( ) ) ) { $ httpVerb = strtolower ( $ parts [ 1 ] ) ; $ endpoint = $ this -> camelcaseToHyphenated ( $ parts [ 2 ] ) ; if ( ! array_key_exists ( $ httpVerb , $ endpoints ) ) { $ endpoints [ $ httpVerb ] = array ( ) ; } $ endpoints [ $ httpVerb ] [ $ endpoint ] = $ this -> documentation -> getMethodDocumentation ( $ method ) ; } } } $ this -> endpointsCache = $ endpoints ; } return $ this -> endpointsCache ; }
2934	public function save ( ) { if ( is_file ( $ this -> filePath ) && $ this -> autoBackup ) { $ this -> backup ( ) ; } $ this -> writer -> save ( $ this -> filePath ) ; return $ this ; }
8861	public function canView ( $ member = null ) { if ( ! parent :: canView ( $ member ) ) return false ; if ( $ this -> PublishDate ) { $ publishDate = $ this -> dbObject ( "PublishDate" ) ; if ( $ publishDate -> InFuture ( ) && ! Permission :: checkMember ( $ member , "VIEW_DRAFT_CONTENT" ) ) { return false ; } } return true ; }
5699	public function findActionByName ( $ action ) { $ actions = $ this -> owner -> getBetterButtonsActions ( ) ; $ formAction = false ; foreach ( $ actions as $ f ) { if ( $ formAction ) { break ; } if ( $ f instanceof CompositeField ) { $ formAction = $ f -> fieldByName ( $ action ) ; } elseif ( $ f -> getName ( ) === $ action ) { $ formAction = $ f ; } } if ( ! $ formAction ) { $ utils = $ this -> owner -> getBetterButtonsUtils ( ) ; $ formAction = $ utils -> fieldByName ( $ action ) ; } return $ formAction ; }
7877	protected function setupPackage ( ) { $ source = realpath ( __DIR__ . '/../config/logviewer.php' ) ; $ this -> publishes ( [ $ source => config_path ( 'logviewer.php' ) ] , 'config' ) ; $ this -> publishes ( [ realpath ( __DIR__ . '/../assets/css' ) => public_path ( 'assets/styles' ) , realpath ( __DIR__ . '/../assets/js' ) => public_path ( 'assets/scripts' ) , ] , 'public' ) ; $ this -> mergeConfigFrom ( $ source , 'logviewer' ) ; $ this -> loadViewsFrom ( realpath ( __DIR__ . '/../views' ) , 'logviewer' ) ; }
8892	public function consumeSlimContainer ( Set $ container ) { foreach ( $ container as $ key => $ value ) { if ( $ value instanceof \ Closure ) { $ refFunc = new \ ReflectionFunction ( $ value ) ; $ shared = in_array ( 'object' , $ refFunc -> getStaticVariables ( ) ) ; $ this -> registerFactory ( $ key , $ value , $ shared ) ; } elseif ( is_callable ( $ value ) ) { $ this -> registerFactory ( $ key , $ value , false ) ; } else { $ this -> sm -> setService ( $ key , $ value ) ; } } }
7893	public function add ( $ property_name , $ value ) { $ this -> validateProperty ( $ property_name , $ value ) ; $ this -> data [ $ property_name ] [ ] = & $ value ; return $ this ; }
4427	protected function askForChoiceData ( $ optionIdentifier , $ optionName , array $ choices , $ defaultValue ) { $ optionValue = $ this -> input -> getOption ( $ optionIdentifier ) ; $ optionValue = ! empty ( $ optionValue ) ? $ optionValue : $ defaultValue ; $ question = $ this -> getChoiceQuestion ( $ optionName , $ optionValue , $ choices ) ; $ optionValue = $ this -> questionHelper -> ask ( $ this -> input , $ this -> output , $ question ) ; $ this -> input -> setOption ( $ optionIdentifier , $ optionValue ) ; return $ optionValue ; }
11681	public function read ( $ id ) { $ path = $ this -> getPath ( $ id ) ; if ( ! file_exists ( $ path ) ) { return '' ; } if ( filemtime ( $ path ) < time ( ) - $ this -> lifeTime ) { return '' ; } return file_get_contents ( $ path ) ; }
10048	public function getColourByIndex ( $ index ) { if ( isset ( $ this -> colourMap [ $ index ] ) ) { return $ this -> colourMap [ $ index ] ; } return null ; }
9903	public function updateCellReference ( $ pCellRange = 'A1' , $ pBefore = 'A1' , $ pNumCols = 0 , $ pNumRows = 0 ) { if ( strpos ( $ pCellRange , '!' ) !== false ) { return $ pCellRange ; } elseif ( ! Coordinate :: coordinateIsRange ( $ pCellRange ) ) { return $ this -> updateSingleCellReference ( $ pCellRange , $ pBefore , $ pNumCols , $ pNumRows ) ; } elseif ( Coordinate :: coordinateIsRange ( $ pCellRange ) ) { return $ this -> updateCellRange ( $ pCellRange , $ pBefore , $ pNumCols , $ pNumRows ) ; } return $ pCellRange ; }
7480	public function getMime ( ) { $ this -> absolute ( ) ; if ( function_exists ( 'mime_content_type' ) ) { return mime_content_type ( $ this -> data ) ; } if ( function_exists ( 'finfo_open' ) ) { $ resource = finfo_open ( FILEINFO_MIME_TYPE ) ; $ mime = finfo_file ( $ resource , $ this -> data ) ; finfo_close ( $ finfo ) ; return $ mime ; } $ extension = strtolower ( $ this -> getExtension ( ) ) ; $ types = self :: $ mimeTypes ; if ( isset ( $ types [ $ extension ] ) ) { return $ types [ $ extension ] ; } return $ types [ 'class' ] ; }
1657	public function get ( $ name ) { foreach ( $ this -> arguments as $ argument ) { if ( $ argument [ 'name' ] == $ name ) { if ( isset ( $ this -> mapArgumentName [ $ name ] ) ) { return $ this -> { $ this -> mapArgumentName [ $ name ] } ( $ argument ) ; } else { return $ argument ; } } } }
7944	public function ipGetRange ( $ id , $ ip ) { if ( ! $ id ) throw new BadMethodCallException ( 'Missing parameter $id.' ) ; if ( ! $ ip ) throw new BadMethodCallException ( 'Missing parameter $ip.' ) ; return json_decode ( $ this -> getIpProperties ( $ id , $ ip ) ) -> range ; }
8606	public function listSubscriptions ( $ request ) { if ( ! ( $ request instanceof MWSSubscriptionsService_Model_ListSubscriptionsInput ) ) { require_once ( dirname ( __FILE__ ) . '/Model/ListSubscriptionsInput.php' ) ; $ request = new MWSSubscriptionsService_Model_ListSubscriptionsInput ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListSubscriptions' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/ListSubscriptionsResponse.php' ) ; $ response = MWSSubscriptionsService_Model_ListSubscriptionsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
1944	public function section ( $ key , $ template = null ) { if ( empty ( $ this -> sections [ $ key ] ) ) { return ; } $ this -> id = $ key ; $ this -> content = $ this -> sections [ $ key ] ; if ( $ template === null ) { $ template = 'block_section' ; foreach ( $ this -> positions as $ position ) { if ( isset ( $ position [ $ key ] [ 'template' ] ) ) { $ template = $ position [ $ key ] [ 'template' ] ; } } } include $ this -> getTemplate ( $ template ) ; }
6528	public static function registerMap ( array $ map ) { @ trigger_error ( sprintf ( '"%s" is deprecated. Use "registerManifest" instead.' , __CLASS__ ) , E_USER_DEPRECATED ) ; $ nextId = count ( self :: $ curies ) + 30000 ; foreach ( $ map as $ curie => $ class ) { ++ $ nextId ; self :: $ curies [ $ curie ] = $ nextId ; self :: $ classes [ $ nextId ] = $ class ; } }
1283	public function addUnknownField ( string $ name ) : Field { $ this -> fields [ $ name ] = new Field ( $ name , $ name , 'Unknown' ) ; return $ this -> fields [ $ name ] ; }
4810	private function is_scheduled ( $ name ) { $ crons = _get_cron_array ( ) ; if ( empty ( $ crons ) ) { return false ; } foreach ( $ crons as $ cron ) { if ( isset ( $ cron [ $ name ] ) ) { return true ; } } return false ; }
1734	public function validateCode ( User $ user , string $ code ) : bool { $ totp = TOTP :: create ( $ this -> getUpperUnpaddedSecretForUser ( $ user ) ) ; return $ totp -> verify ( $ code ) ; }
3988	public function getChildrenOf ( $ parentTable ) { $ inputScreens = array_filter ( $ this -> getInputScreens ( ) , function ( $ inputScreen ) use ( $ parentTable ) { return ( $ inputScreen [ 'meta' ] [ 'rendertype' ] === 'ctable' ) && ( $ inputScreen [ 'meta' ] [ 'ptable' ] === $ parentTable ) ; } ) ; return $ inputScreens ; }
3468	public function delete ( string $ route , callable $ controller ) : void { $ this -> register ( $ controller , Route :: delete ( $ route ) ) ; }
8075	private function handle ( Response $ response ) { $ stream = stream_for ( $ response -> getBody ( ) ) ; $ data = json_decode ( $ stream -> getContents ( ) ) ; return $ data ; }
11325	public static function hasSuffix ( $ string , $ suffix ) { $ len = strlen ( $ suffix ) ; if ( $ len && substr ( $ string , - $ len ) === $ suffix ) { return true ; } return false ; }
3694	public function getBreadcrumb ( GetBreadcrumbEvent $ event ) { $ environment = $ event -> getEnvironment ( ) ; if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ elements = $ this -> storeFactory -> createStore ( ) ; $ this -> getBreadcrumbElements ( $ environment , $ elements ) ; $ event -> setElements ( $ elements -> getElements ( ) ) ; $ event -> stopPropagation ( ) ; }
124	protected function getErrorMessage ( $ retval , $ file ) { switch ( $ retval ) { case ZipArchive :: ER_EXISTS : return sprintf ( "File '%s' already exists." , $ file ) ; case ZipArchive :: ER_INCONS : return sprintf ( "Zip archive '%s' is inconsistent." , $ file ) ; case ZipArchive :: ER_INVAL : return sprintf ( "Invalid argument (%s)" , $ file ) ; case ZipArchive :: ER_MEMORY : return sprintf ( "Malloc failure (%s)" , $ file ) ; case ZipArchive :: ER_NOENT : return sprintf ( "No such zip file: '%s'" , $ file ) ; case ZipArchive :: ER_NOZIP : return sprintf ( "'%s' is not a zip archive." , $ file ) ; case ZipArchive :: ER_OPEN : return sprintf ( "Can't open zip file: %s" , $ file ) ; case ZipArchive :: ER_READ : return sprintf ( "Zip read error (%s)" , $ file ) ; case ZipArchive :: ER_SEEK : return sprintf ( "Zip seek error (%s)" , $ file ) ; default : return sprintf ( "'%s' is not a valid zip archive, got error code: %s" , $ file , $ retval ) ; } }
12277	public function update ( $ groupId , $ name ) { $ params = [ 'group' => [ 'id' => $ groupId , 'name' => $ name , ] , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_UPDATE , $ params ] ) ; }
5374	public function createTag ( $ name , $ attributes ) { static $ map = array ( 'a' => 'SimpleAnchorTag' , 'title' => 'SimpleTitleTag' , 'base' => 'SimpleBaseTag' , 'button' => 'SimpleButtonTag' , 'textarea' => 'SimpleTextAreaTag' , 'option' => 'SimpleOptionTag' , 'label' => 'SimpleLabelTag' , 'form' => 'SimpleFormTag' , 'frame' => 'SimpleFrameTag' ) ; $ attributes = $ this -> keysToLowerCase ( $ attributes ) ; if ( array_key_exists ( $ name , $ map ) ) { $ tag_class = $ map [ $ name ] ; return new $ tag_class ( $ attributes ) ; } elseif ( $ name === 'select' ) { return $ this -> createSelectionTag ( $ attributes ) ; } elseif ( $ name === 'input' ) { return $ this -> createInputTag ( $ attributes ) ; } return new SimpleTag ( $ name , $ attributes ) ; }
6625	public function put ( $ key , $ data , $ duration = null ) { return $ this -> cache -> put ( $ key , $ data , ( $ duration ) ? : $ this -> duration ) ; }
12342	protected function printInfo ( $ msg , bool $ withTime = true , ? string $ fontColor = self :: FONT_COLOR_MAP [ 'lightGreen' ] , ? string $ bgColor = null ) : void { $ this -> print ( $ this -> getColoredMsg ( $ msg , $ fontColor , $ bgColor ) , $ withTime ) ; }
11587	public function end ( $ taskName ) { if ( ! isset ( $ this -> _tasks [ $ taskName ] ) ) { throw new Exception ( "Undefined task name: `'{$taskName}`." ) ; } $ task = $ this -> _tasks [ $ taskName ] ; $ task -> end ( ) ; return $ task ; }
4470	public function complete ( ? string $ nextq = null , int $ delay = 0 , array $ depends = [ ] ) : string { if ( $ this -> completed || $ this -> failed ) { throw new JobAlreadyFinishedException ( ) ; } $ params = [ $ this -> jid , $ this -> worker , $ this -> queue , json_encode ( $ this -> data , JSON_UNESCAPED_SLASHES ) ? : '{}' ] ; if ( $ nextq ) { $ next = [ 'next' , $ nextq , 'delay' , $ delay , 'depends' , json_encode ( $ depends , JSON_UNESCAPED_SLASHES ) ] ; $ params = array_merge ( $ params , $ next ) ; } $ this -> completed = true ; return call_user_func_array ( [ $ this -> client , 'complete' ] , $ params ) ; }
5333	public function setSignature ( $ parameters , $ privateKey , $ service , $ endpoint , $ timestamp , $ nonce ) { $ this -> __setCookie ( 'signature' , rawurlencode ( $ this -> sign ( $ privateKey , array_merge ( $ parameters , [ '__service' => $ service , '__hostname' => $ endpoint , '__timestamp' => $ timestamp , '__nonce' => $ nonce , ] ) ) ) ) ; }
9573	protected function registerProviders ( ) { $ dependants = [ ] ; foreach ( $ this -> providers as $ provider ) { if ( is_string ( $ provider ) ) { $ provider = new $ provider ( ) ; } $ this -> registerProvider ( $ provider ) ; if ( $ provider instanceof DependantProviderInterface ) { $ dependants [ ] = $ provider ; } } foreach ( $ dependants as $ dependant ) { $ this -> checkProviderDependencies ( $ dependant ) ; } }
3989	public function getScreen ( $ tableName ) { $ inputScreens = $ this -> getInputScreens ( ) ; if ( isset ( $ inputScreens [ $ tableName ] ) ) { return $ inputScreens [ $ tableName ] ; } return null ; }
2355	public function hasFrontendUser ( ) : bool { $ token = $ this -> getToken ( FrontendUser :: SECURITY_SESSION_KEY ) ; return null !== $ token && $ token -> getUser ( ) instanceof FrontendUser ; }
6570	public function getMessage ( ) { return '[' . $ this -> prefix . ( $ this -> context === null ? '' : ( ' - ' . get_class ( $ this -> context ) ) ) . '] ' . $ this -> msg ; }
4490	public function createTopic ( string $ name ) : string { $ res = $ this -> sns -> createTopic ( [ 'Name' => $ name , ] ) ; return $ res [ 'TopicArn' ] ; }
2837	public function getInfoAsArray ( ) { return array ( 'design_area' => $ this -> getArea ( ) , 'package_name' => $ this -> getPackageName ( ) , 'layout_theme' => $ this -> getThemeLayout ( ) , 'template_theme' => $ this -> getThemeTemplate ( ) , 'locale' => $ this -> getThemeLocale ( ) , 'skin' => $ this -> getThemeSkin ( ) ) ; }
8393	public static function run ( ) { if ( self :: $ isInit === true ) { self :: $ request = new Request ( self :: $ routes ) ; self :: $ controllers = array ( ) ; try { $ before = self :: $ request -> getBefore ( ) ; foreach ( $ before as $ b ) { $ controller = Controllers :: get ( $ b [ 'class' ] ) ; $ action = $ b [ 'action' ] ; $ controller -> $ action ( self :: $ request ) ; } if ( self :: $ request -> hasEnded ( ) === false ) { $ controller = Controllers :: get ( self :: $ request -> getClass ( ) ) ; $ action = self :: $ request -> getAction ( ) ; $ controller -> $ action ( self :: $ request ) ; if ( self :: $ request -> hasEnded ( ) === false ) { $ after = self :: $ request -> getAfter ( ) ; foreach ( $ after as $ a ) { $ controller = Controllers :: get ( $ a [ 'class' ] ) ; $ action = $ a [ 'action' ] ; $ controller -> $ action ( self :: $ request ) ; } } } } catch ( \ Exception $ e ) { echo 'Exception: ' . $ e -> getMessage ( ) . PHP_EOL ; echo $ e -> getTraceAsString ( ) ; } } }
8361	public static function init ( RawRequest $ request = null ) { if ( self :: $ isInit === false ) { self :: $ translations = array ( ) ; $ settings = Config :: getSettings ( ) ; if ( isset ( $ settings [ 'locale' ] ) === false || isset ( $ settings [ 'locale' ] [ 'default' ] ) === false ) { throw new BadUse ( 'locale.default isn\'t defined in settings' ) ; } self :: $ currentLanguage = $ settings [ 'locale' ] [ 'default' ] ; if ( $ request != null ) { if ( Session :: has ( '_stray_language' ) === true ) { self :: $ currentLanguage = Session :: get ( '_stray_language' ) ; } else { $ domain = HttpHelper :: extractDomain ( $ request ) ; if ( isset ( $ settings [ 'locale' ] [ 'hosts' ] ) === true && isset ( $ settings [ 'locale' ] [ 'hosts' ] [ $ domain ] ) === true ) { self :: $ currentLanguage = $ settings [ 'locale' ] [ 'hosts' ] [ $ domain ] ; } Session :: set ( '_stray_language' , self :: $ currentLanguage ) ; } } self :: $ isInit = true ; } }
11251	public function getLastBatchNumber ( ) : int { $ stmt = $ this -> pdo -> query ( "select max(batch) from {$this->table}" ) ; $ stmt -> execute ( ) ; return ( int ) $ stmt -> fetch ( PDO :: FETCH_ASSOC ) [ 'max' ] ; }
11144	protected function processClass ( $ class ) { if ( ! class_exists ( '\\' . $ class ) ) { throw new ExtDirectException ( " '{$class}' does not exist!" ) ; } $ annotationReader = new AnnotationReader ( ) ; AnnotationRegistry :: registerLoader ( 'class_exists' ) ; $ reflectionClass = new ReflectionClass ( $ class ) ; $ classAnnotation = $ annotationReader -> getClassAnnotation ( $ reflectionClass , 'ExtDirect\Annotations\Direct' ) ; if ( $ classAnnotation instanceof \ ExtDirect \ Annotations \ Direct ) { $ classAnnotation -> setClassName ( $ class ) ; $ methodCollection = new RemotableCollection ( ) ; foreach ( $ reflectionClass -> getMethods ( ) as $ reflectionMethod ) { $ methodAnnotation = $ annotationReader -> getMethodAnnotation ( $ reflectionMethod , 'ExtDirect\Annotations\Remotable' ) ; if ( $ methodAnnotation instanceof \ ExtDirect \ Annotations \ Remotable ) { $ methodAnnotation -> setMethodName ( $ reflectionMethod -> getName ( ) ) ; $ methodCollection -> add ( $ methodAnnotation ) ; } } $ classAnnotation -> setMethods ( $ methodCollection ) ; return $ classAnnotation ; } return false ; }
8201	protected function exportJob ( $ job ) { $ stats = $ this -> getJobStats ( $ job ) ; $ contents = $ this -> renderForExport ( $ job , $ stats ) ; $ filename = trim ( $ this -> path , '/' ) . '/' . $ this -> buildJobFileName ( $ job , $ stats ) ; if ( file_exists ( $ filename ) ) { throw new \ RuntimeException ( 'File already exists.' ) ; } if ( ! file_put_contents ( $ filename , $ contents ) ) { throw new \ RuntimeException ( 'Error saving the file.' ) ; } }
7682	function Ext_DeductFormat ( & $ Ext , $ Search ) { if ( strpos ( ',odt,ods,odg,odf,odp,odm,ott,ots,otg,otp,' , ',' . $ Ext . ',' ) !== false ) return 'odf' ; if ( strpos ( ',docx,xlsx,xlsm,pptx,' , ',' . $ Ext . ',' ) !== false ) return 'openxml' ; if ( ! $ Search ) return false ; if ( $ this -> FileExists ( 'content.xml' ) ) { if ( $ this -> FileExists ( 'META-INF/manifest.xml' ) ) { $ Ext = '?' ; return 'odf' ; } } elseif ( $ this -> FileExists ( '[Content_Types].xml' ) ) { if ( $ this -> FileExists ( 'word/document.xml' ) ) { $ Ext = 'docx' ; return 'openxml' ; } elseif ( $ this -> FileExists ( 'xl/workbook.xml' ) ) { $ Ext = 'xlsx' ; return 'openxml' ; } elseif ( $ this -> FileExists ( 'ppt/presentation.xml' ) ) { $ Ext = 'pptx' ; return 'openxml' ; } } return false ; }
12141	public function SignupUser ( $ moniker , $ mailer_id = null ) { $ endpoint = '/user/signup' ; $ postdata = array ( "moniker" => $ moniker , "mailer_id" => $ mailer_id ) ; return $ this -> executePostRequest ( $ endpoint , $ postdata ) ; }
5332	public static function haikunate ( array $ params = [ ] ) { $ defaults = [ "delimiter" => "-" , "tokenLength" => 4 , "tokenHex" => false , "tokenChars" => "0123456789" , ] ; $ params = array_merge ( $ defaults , $ params ) ; if ( $ params [ "tokenHex" ] == true ) { $ params [ "tokenChars" ] = "0123456789abcdef" ; } $ adjective = self :: $ ADJECTIVES [ mt_rand ( 0 , count ( self :: $ ADJECTIVES ) - 1 ) ] ; $ noun = self :: $ NOUNS [ mt_rand ( 0 , count ( self :: $ NOUNS ) - 1 ) ] ; $ token = "" ; for ( $ i = 0 ; $ i < $ params [ "tokenLength" ] ; $ i ++ ) { $ token .= $ params [ "tokenChars" ] [ mt_rand ( 0 , strlen ( $ params [ "tokenChars" ] ) - 1 ) ] ; } $ sections = [ $ adjective , $ noun , $ token ] ; return implode ( $ params [ "delimiter" ] , array_filter ( $ sections ) ) ; }
6329	private function getColumnComments ( ) { $ escapement = new Escapement ( ) ; $ comments = '' ; foreach ( $ this -> table -> getColumns ( ) as $ column ) { $ columnDescription = $ column -> getDescription ( ) ; if ( ! empty ( $ columnDescription ) ) { $ comments .= sprintf ( "COMMENT ON COLUMN %s.%s IS '%s';" , $ escapement -> escape ( $ this -> table -> getQualifiedName ( ) ) , $ escapement -> escape ( $ column -> getName ( ) ) , $ columnDescription ) ; } } return $ comments ; }
7021	private function format_s ( & $ str ) { if ( strstr ( $ str , '%s' ) ) $ str = str_replace ( '%s' , sprintf ( '%02d' , $ this -> sec ) , $ str ) ; }
7849	public function dispatchFrom ( $ command , ArrayAccess $ source , array $ extras = [ ] ) { $ this -> command = $ command ; $ this -> values = array_merge ( ( array ) $ source , $ extras ) ; return $ this -> dispatcher -> dispatch ( $ this -> marshal ( ) ) ; }
10171	function fromXML ( $ xmlElement ) { foreach ( $ xmlElement -> children ( ) as $ field ) { $ this -> custom_fields [ trim ( $ field -> name ) ] = $ field -> type ; } }
3148	public function isItemCompleted ( RunnerServiceContext $ context , $ routeItem , $ itemSession , $ partially = true ) { if ( $ context instanceof QtiRunnerServiceContext && $ context -> isAdaptive ( ) ) { $ itemIdentifier = $ context -> getCurrentAssessmentItemRef ( ) -> getIdentifier ( ) ; $ itemState = $ this -> getItemState ( $ context , $ itemIdentifier ) ; if ( $ itemState !== null ) { $ itemResponse = [ ] ; foreach ( $ itemState as $ key => $ value ) { if ( isset ( $ value [ 'response' ] ) ) { $ itemResponse [ $ key ] = $ value [ 'response' ] ; } } $ responses = $ this -> parsesItemResponse ( $ context , $ itemIdentifier , $ itemResponse ) ; $ excludedResponseVariables = array ( 'numAttempts' , 'duration' ) ; foreach ( $ responses as $ var ) { if ( $ var instanceof ResponseVariable && in_array ( $ var -> getIdentifier ( ) , $ excludedResponseVariables ) === false ) { $ value = $ var -> getValue ( ) ; $ defaultValue = $ var -> getDefaultValue ( ) ; if ( Utils :: isNull ( $ value ) === true ) { if ( Utils :: isNull ( $ defaultValue ) === ( ( $ partially ) ? false : true ) ) { return ( ( $ partially ) ? true : false ) ; } } else { if ( $ value -> equals ( $ defaultValue ) === ( ( $ partially ) ? false : true ) ) { return ( ( $ partially ) ? true : false ) ; } } } } } return ( ( $ partially ) ? false : true ) ; } else { return TestRunnerUtils :: isItemCompleted ( $ routeItem , $ itemSession , $ partially ) ; } }
6679	public static function convertDate ( $ dateString , $ fromFormat , $ toFormat ) { $ date = DateTime :: createFromFormat ( $ fromFormat , $ dateString ) ; if ( ! $ date && $ fromFormat == DateFormat :: FORMAT_ORACLE_WITH_MICROSECONDS ) { $ date = DateTime :: createFromFormat ( DateFormat :: FORMAT_ORACLE_DATE_ONLY , $ dateString ) ; } if ( $ date ) { return $ date -> format ( $ toFormat ) ; } return $ dateString ; }
11550	private function preencherLista ( $ pagamentos ) { $ resultado = array ( ) ; foreach ( $ pagamentos as $ pagamento ) { $ resultado [ ] = $ pagamento -> setAutenticacao ( $ this -> getAutenticacaoManager ( ) -> obterAutenticacaoBasica ( $ pagamento -> getAutenticacaoId ( ) ) ) ; } return $ resultado ; }
11368	public static function deduplicate ( $ array ) { if ( empty ( $ array ) ) { return $ array ; } $ known = array ( ) ; foreach ( $ array as $ _index => $ entry ) { if ( is_array ( $ entry ) ) { foreach ( $ entry as $ i => $ _email ) { if ( ! in_array ( $ _email , $ known ) ) { $ known [ ] = $ _email ; } else { unset ( $ array [ $ _index ] ) ; } } } elseif ( is_string ( $ entry ) ) { if ( ! in_array ( $ entry , $ known ) ) { $ known [ ] = $ entry ; } else { unset ( $ array [ $ _index ] ) ; } } } return $ array ; }
930	public function transform ( Tokens $ tokens ) { foreach ( $ this -> items as $ transformer ) { foreach ( $ tokens as $ index => $ token ) { $ transformer -> process ( $ tokens , $ token , $ index ) ; } } }
11974	private function firstParamValidation ( Event $ event ) { $ params = $ event -> getCustomParams ( ) ; return ( is_numeric ( $ params [ 0 ] ) && $ params [ 0 ] > 0 && $ params [ 0 ] <= $ this -> maxDieRolls ) ; }
1556	protected function queryRulesWithoutSearch ( ) { return collect ( $ this -> queryRules ( ) ) -> reject ( function ( $ value , $ key ) { return Str :: startsWith ( $ key , [ 'filter.' , 'sort.' , 'page.' ] ) ; } ) -> all ( ) ; }
7424	public function render ( $ menu = 'Default' , $ debug = false , $ class = null ) { $ response = $ this -> initiateSubRequest ( ) ; return $ response -> getContent ( ) ; }
9978	public function request ( $ url ) { $ ch = curl_init ( ) ; curl_setopt ( $ ch , CURLOPT_URL , $ url ) ; curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , true ) ; curl_setopt ( $ ch , CURLOPT_CONNECTTIMEOUT , $ this -> timeout ) ; $ response = curl_exec ( $ ch ) ; curl_close ( $ ch ) ; if ( $ response === false ) { throw new \ RuntimeException ( 'Connection timeout.' ) ; } return $ response ; }
5796	private function setSlimMiddleware ( \ Slim \ App $ slim , $ slimContainer ) { $ slim -> add ( new CsrfMiddleware ( $ slimContainer ) ) ; if ( isset ( $ this -> config [ 'trackAll' ] ) && $ this -> config [ 'trackAll' ] ) { $ slim -> add ( new TrackerMiddleware ( $ slimContainer ) ) ; } $ slim -> add ( $ slimContainer -> csrf ) ; }
4836	public function create_bill ( $ params ) { if ( ! isset ( $ params [ 'pre_authorization_id' ] ) ) { throw new GoCardless_ArgumentsException ( 'pre_authorization_id missing' ) ; } $ pre_auth = new GoCardless_PreAuthorization ( $ this , array ( 'id' => $ params [ 'pre_authorization_id' ] ) ) ; return $ pre_auth -> create_bill ( array ( 'amount' => $ params [ 'amount' ] ) ) ; }
11527	public function registerPackageHelpers ( ) { foreach ( $ this -> packageHelpers as $ helper ) { $ dashName = last ( explode ( '/' , $ helper ) ) ; $ underscoreName = str_replace ( '-' , '_' , $ dashName ) ; if ( in_array ( '*' , $ this -> packageInclude ) || in_array ( $ dashName , $ this -> packageInclude ) || in_array ( $ underscoreName , $ this -> packageInclude ) ) { require_once $ this -> replaceVariables ( $ this -> packageHelperPattern , compact ( 'dashName' , 'underscoreName' ) ) ; } } }
4441	public function fromSubscriptions ( string $ topic ) : array { $ response = [ ] ; if ( empty ( $ topic ) ) { return $ response ; } $ subscriptions = $ this -> client -> call ( 'subscription' , 'default' , 'all' , $ topic ) ; $ subscriptions = json_decode ( $ subscriptions , true ) ? : [ ] ; foreach ( $ subscriptions as $ subscription => $ queues ) { $ topicPattern = str_replace ( [ '.' , '*' , '#' ] , [ '\.' , '[a-zA-z0-9^.]{1,}' , '.*' ] , $ subscription ) ; if ( preg_match ( "/^$topicPattern$/" , $ topic ) ) { $ response = array_merge ( $ response , $ queues ) ; } } return array_unique ( $ response ) ; }
10270	function setReplyToAddress ( $ mailingId , $ auto = true , $ customEmail = null ) { $ queryParameters = array ( 'auto' => ( $ auto == TRUE ) ? "true" : "false" , 'customEmail' => $ customEmail ) ; return $ this -> post ( 'mailings/' . $ mailingId . '/settings/replyto' , null , $ queryParameters ) ; }
11473	public function destroy ( ResponseRequest $ request , Response $ response ) { try { $ id = $ response [ 'question_id' ] ; $ question = $ this -> question -> selectquestion ( $ id ) ; $ response -> delete ( ) ; return redirect ( '/discussion/' . $ question [ 'slug' ] ) ; } catch ( Exception $ e ) { return $ this -> response -> message ( $ e -> getMessage ( ) ) -> code ( 400 ) -> status ( 'error' ) -> url ( guard_url ( 'forum/response/' . $ response -> getRouteKey ( ) ) ) -> redirect ( ) ; } }
11081	public static function GUIDv4 ( ) { return sprintf ( '%04x%04x-%04x-%04x-%04x-%04x%04x%04x' , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0x0fff ) | 0x4000 , mt_rand ( 0 , 0x3fff ) | 0x8000 , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0xffff ) ) ; }
7815	public static function uploadImgFile ( $ path ) { try { if ( Request :: hasFile ( 'image' ) ) { $ pic = Request :: file ( 'image' ) ; if ( $ pic -> isValid ( ) ) { $ newName = md5 ( rand ( 1 , 1000 ) . $ pic -> getClientOriginalName ( ) ) . "." . $ pic -> getClientOriginalExtension ( ) ; $ pic -> move ( $ path , $ newName ) ; $ url = asset ( $ path . '/' . $ newName ) ; } else { self :: addError ( 'The file is invalid' ) ; } } else { self :: addError ( 'Not File' ) ; } } catch ( \ Exception $ e ) { self :: addError ( $ e -> getMessage ( ) ) ; } $ data = array ( 'status' => empty ( $ message ) ? 0 : 1 , 'message' => self :: getLastError ( ) , 'url' => ! empty ( $ url ) ? $ url : '' ) ; return $ data ; }
9255	public function getRootDir ( ) { if ( ! $ this -> rootDir ) { $ refl = new \ ReflectionObject ( $ this ) ; $ filename = $ refl -> getFileName ( ) ; if ( false !== ( $ pos = strrpos ( $ filename , '/vendor/' ) ) ) { $ filename = substr ( $ filename , 0 , $ pos ) ; } else { $ filename = dirname ( $ filename ) . '/..' ; } $ this -> rootDir = str_replace ( '\\' , '/' , $ filename ) ; } return $ this -> rootDir ; }
6856	protected static function equinoxMarch ( $ year , $ vsop = true ) { $ month = 3 ; if ( $ vsop ) return static :: accurate ( $ year , static :: meanTerms ( $ month , $ year ) , $ month ) ; else return static :: approx ( $ year , static :: meanTerms ( $ month , $ year ) ) ; }
5570	public function retry ( ) { $ frames = $ this -> page -> getFrameFocus ( ) ; if ( count ( $ frames ) > 0 ) { $ this -> loadFrame ( $ frames , $ this -> page -> getUrl ( ) , $ this -> page -> getRequestData ( ) ) ; return $ this -> page -> getRaw ( ) ; } if ( $ url = $ this -> history -> getUrl ( ) ) { $ this -> page = $ this -> fetch ( $ url , $ this -> history -> getParameters ( ) ) ; return $ this -> page -> getRaw ( ) ; } return false ; }
3713	public function isNestedType ( ) { if ( ! isset ( $ this -> isNestedType ) ) { $ this -> isNestedType = in_array ( 'MetaModels\Filter\Setting\IWithChildren' , class_implements ( $ this -> typeClass , true ) ) ; } return $ this -> isNestedType ; }
11715	protected function getCachedToken ( array $ options ) { $ authOptions = array_intersect_key ( $ options , $ this -> api -> postTokens ( ) [ 'params' ] ) ; $ optionsToHash = array_merge ( $ authOptions , array_intersect_key ( $ options , [ 'authUrl' => true , ] ) ) ; if ( isset ( $ optionsToHash [ 'user' ] ) ) { unset ( $ optionsToHash [ 'user' ] [ 'password' ] ) ; } $ key = 'openstack-token-' . md5 ( json_encode ( $ optionsToHash ) ) ; if ( $ this -> cache -> has ( $ key ) ) { return $ this -> cache -> get ( $ key ) ; } $ token = $ this -> generateToken ( $ authOptions ) ; $ cachedToken = $ token -> export ( ) ; $ expiresAt = new DateTime ( $ cachedToken [ 'expires_at' ] ) ; $ this -> cache -> put ( $ key , $ cachedToken , $ expiresAt -> sub ( new DateInterval ( 'PT1M' ) ) ) ; return $ cachedToken ; }
6448	public function getBestLanguageMatch ( array $ supportedLanguages , array $ languageHeaders ) : ? string { usort ( $ languageHeaders , [ $ this , 'compareAcceptLanguageHeaders' ] ) ; $ rankedLanguageHeaders = array_filter ( $ languageHeaders , [ $ this , 'filterZeroScores' ] ) ; $ rankedLanguageHeaderValues = $ this -> getLanguageValuesFromHeaders ( $ rankedLanguageHeaders ) ; foreach ( $ rankedLanguageHeaderValues as $ language ) { $ languageParts = explode ( '-' , $ language ) ; do { foreach ( $ supportedLanguages as $ supportedLanguage ) { if ( $ language === '*' || implode ( '-' , $ languageParts ) === $ supportedLanguage ) { return $ supportedLanguage ; } } array_pop ( $ languageParts ) ; } while ( count ( $ languageParts ) > 0 ) ; } return null ; }
2611	public function getActiveVersion ( $ service , $ activeVersion ) { $ currActiveVersion = $ this -> determineVersions ( $ service -> versions ) ; if ( $ currActiveVersion [ 'active_version' ] != $ activeVersion ) { throw new LocalizedException ( __ ( 'Active versions mismatch.' ) ) ; } return $ currActiveVersion ; }
2323	public static function get ( ) { $ container = System :: getContainer ( ) ; return $ container -> get ( 'contao.csrf.token_manager' ) -> getToken ( $ container -> getParameter ( 'contao.csrf_token_name' ) ) -> getValue ( ) ; }
6843	public function call ( Closure $ c , $ params = array ( ) ) { $ ref = new ReflectionFunction ( $ c ) ; $ params_need = $ ref -> getParameters ( ) ; $ args = $ this -> apply ( $ params_need , $ params ) ; return call_user_func_array ( $ c , $ args ) ; }
2977	public function unserialize ( $ serialized ) { $ this -> data = unserialize ( $ serialized ) ; $ this -> closure = __reconstruct_closure ( $ this -> data ) ; if ( ! $ this -> closure instanceof Closure ) { throw new ClosureUnserializationException ( 'The closure is corrupted and cannot be unserialized.' ) ; } if ( $ this -> data [ 'binding' ] || $ this -> data [ 'isStatic' ] ) { $ this -> closure = $ this -> closure -> bindTo ( $ this -> data [ 'binding' ] , $ this -> data [ 'scope' ] ) ; } }
10933	protected function resolveParams ( UriInfo $ info , array $ params ) { $ uri = $ info -> getUri ( ) ; if ( false === strpos ( $ uri , '{' ) ) { return $ info ; } $ ctx = NULL ; $ result = '' ; foreach ( preg_split ( "'(\\{[^\\}]+\\})'" , $ uri , - 1 , PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY ) as $ part ) { if ( '{' != substr ( $ part , 0 , 1 ) ) { $ result .= $ part ; continue ; } $ placeholder = substr ( $ part , 1 , - 1 ) ; if ( '*' == substr ( $ placeholder , - 1 ) ) { $ placeholder = substr ( $ placeholder , 0 , - 1 ) ; $ multi = true ; } else { $ multi = false ; } switch ( substr ( $ placeholder , 0 , 1 ) ) { case '.' : $ placeholder = substr ( $ placeholder , 1 ) ; $ prefix = '.' ; $ join = $ multi ? '.' : ',' ; break ; case '/' : $ placeholder = substr ( $ placeholder , 1 ) ; $ prefix = '/' ; $ join = $ multi ? '/' : ',' ; break ; default : $ prefix = '' ; $ join = ',' ; } if ( false === strpos ( $ placeholder , '.' ) ) { $ value = array_key_exists ( $ placeholder , $ params ) ? $ params [ $ placeholder ] : $ this ; } else { if ( $ ctx === NULL ) { $ ctx = $ this -> factory -> createContext ( $ params ) ; } $ value = $ ctx -> resolveValue ( explode ( '.' , $ placeholder ) , $ this ) ; } if ( $ value === $ this ) { $ result .= $ part ; } elseif ( is_array ( $ value ) || $ value instanceof \ Traversable ) { $ i = 0 ; foreach ( $ value as $ val ) { $ result .= ( ( $ i ++ == 0 ) ? $ prefix : $ join ) . Uri :: encode ( $ val , true ) ; } } else { $ result .= $ prefix . Uri :: encode ( $ value , true ) ; } } return new UriInfo ( $ result , $ info -> getRouteName ( ) , $ info -> getMethods ( ) , $ info -> getHandler ( ) ) ; }
11443	public function getMessage ( $ id = null ) { if ( ! is_null ( $ id ) ) { return array_key_exists ( $ id , $ this -> messages ) ? $ this -> messages [ $ id ] : null ; } elseif ( count ( $ this -> messages ) > 0 ) { return current ( $ this -> messages ) ; } else { $ message_class = $ this -> getDefault ( 'messager' ) ; if ( class_exists ( $ message_class ) ) { $ this -> addMessage ( new $ message_class ) ; return current ( $ this -> messages ) ; } else { throw new \ Exception ( sprintf ( 'Default message class "%s" not found!' , $ message_class ) ) ; } } }
7447	function decrypt ( $ data , $ password ) { $ data = base64_decode ( $ data ) ; $ salt = substr ( $ data , 0 , 16 ) ; $ ct = substr ( $ data , 16 ) ; $ rounds = 3 ; $ data00 = $ password . $ salt ; $ hash = array ( ) ; $ hash [ 0 ] = hash ( 'sha256' , $ data00 , true ) ; $ result = $ hash [ 0 ] ; for ( $ i = 1 ; $ i < $ rounds ; $ i ++ ) { $ hash [ $ i ] = hash ( 'sha256' , $ hash [ $ i - 1 ] . $ data00 , true ) ; $ result .= $ hash [ $ i ] ; } $ key = substr ( $ result , 0 , 32 ) ; $ iv = substr ( $ result , 32 , 16 ) ; return openssl_decrypt ( $ ct , 'AES-256-CBC' , $ key , true , $ iv ) ; }
7214	public function debit ( $ account , $ amount , \ DateTime $ date ) { $ data = [ $ this -> date , $ account , $ this -> identity , null , $ amount , $ this -> number , $ date -> format ( 'Y-m-d' ) , ] ; if ( false === fputcsv ( $ this -> handle , $ data , ';' , '"' ) ) { throw new RuntimeException ( "Failed to write line." ) ; } }
4027	protected function getLabelComment ( ModelInterface $ model , TranslatorInterface $ translator ) { if ( $ model -> getProperty ( 'comment' ) ) { return sprintf ( $ translator -> translate ( 'typedesc._comment_' , 'tl_metamodel_filtersetting' ) , StringUtil :: specialchars ( $ model -> getProperty ( 'comment' ) ) ) ; } return '' ; }
2210	public function fetchAssoc ( ) { if ( $ this -> intIndex >= $ this -> count ( ) - 1 ) { return false ; } $ this -> arrCache = $ this -> resultSet [ ++ $ this -> intIndex ] ; return $ this -> arrCache ; }
5479	protected function addRadioButton ( $ tag ) { if ( ! isset ( $ this -> radios [ $ tag -> getName ( ) ] ) ) { $ this -> widgets [ ] = new SimpleRadioGroup ( ) ; $ this -> radios [ $ tag -> getName ( ) ] = count ( $ this -> widgets ) - 1 ; } $ this -> widgets [ $ this -> radios [ $ tag -> getName ( ) ] ] -> addWidget ( $ tag ) ; }
8735	public function decrement ( $ column , $ amount = 1 , array $ extra = [ ] ) { $ extra = $ this -> addUpdatedAtColumn ( $ extra ) ; return $ this -> noTranslationsQuery ( ) -> decrement ( $ column , $ amount , $ extra ) ; }
3265	protected function preserveLines ( $ data , bool $ reverse ) { $ search = [ "\n" , "\r" ] ; $ replace = [ '\\n' , '\\r' ] ; if ( $ reverse ) { $ search = [ '\\n' , '\\r' ] ; $ replace = [ "\n" , "\r" ] ; } if ( is_string ( $ data ) ) { $ data = str_replace ( $ search , $ replace , $ data ) ; } elseif ( is_array ( $ data ) ) { foreach ( $ data as & $ value ) { $ value = $ this -> preserveLines ( $ value , $ reverse ) ; } unset ( $ value ) ; } return $ data ; }
10870	public function verifyHash ( string $ password , string $ hash ) : bool { return Passwords :: verify ( $ password , $ hash ) ; }
1812	public function getForms ( ) { if ( ! $ this -> User -> isAdmin && ! \ is_array ( $ this -> User -> forms ) ) { return array ( ) ; } $ arrForms = array ( ) ; $ objForms = $ this -> Database -> execute ( "SELECT id, title FROM tl_form ORDER BY title" ) ; while ( $ objForms -> next ( ) ) { if ( $ this -> User -> hasAccess ( $ objForms -> id , 'forms' ) ) { $ arrForms [ $ objForms -> id ] = $ objForms -> title . ' (ID ' . $ objForms -> id . ')' ; } } return $ arrForms ; }
6196	public function isActive ( string $ url ) { if ( $ this -> makeUrl ( $ url , true ) === str_replace ( $ this -> uri , '' , $ _SERVER [ 'REQUEST_URI' ] ) ) { return true ; } return false ; }
2154	public function getNewsletters ( $ objModule ) { $ objNewsletter = NewsletterChannelModel :: findAll ( ) ; if ( $ objNewsletter === null ) { return array ( ) ; } $ arrNewsletters = array ( ) ; if ( $ objModule === null || TL_MODE == 'BE' ) { while ( $ objNewsletter -> next ( ) ) { $ arrNewsletters [ $ objNewsletter -> id ] = $ objNewsletter -> title ; } } else { $ newsletters = StringUtil :: deserialize ( $ objModule -> newsletters , true ) ; if ( empty ( $ newsletters ) || ! \ is_array ( $ newsletters ) ) { return array ( ) ; } while ( $ objNewsletter -> next ( ) ) { if ( \ in_array ( $ objNewsletter -> id , $ newsletters ) ) { $ arrNewsletters [ $ objNewsletter -> id ] = $ objNewsletter -> title ; } } } natsort ( $ arrNewsletters ) ; return $ arrNewsletters ; }
5706	public function shouldDisplay ( ) { return $ this -> gridFieldRequest -> record -> stagesDiffer ( 'Stage' , 'Live' ) && $ this -> gridFieldRequest -> recordIsPublished ( ) && $ this -> gridFieldRequest -> record -> canEdit ( ) ; }
6042	public function session ( $ sourceId , $ sessionHash , $ remoteIp , $ userAgent , $ userId = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'sourceId' => $ sourceId , 'sessionHash' => $ sessionHash , 'remoteIp' => $ remoteIp , 'userAgent' => $ userAgent , 'userId' => $ userId ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/events/session' , $ parameters ) ; return $ result ; }
6524	public function getHandlerMethodName ( $ withMajor = true ) { if ( true === $ withMajor ) { return lcfirst ( $ this -> classShortName ) ; } return lcfirst ( str_replace ( 'V' . $ this -> id -> getVersion ( ) -> getMajor ( ) , '' , $ this -> classShortName ) ) ; }
5067	public function setOpt ( int $ option , $ value ) : bool { return curl_setopt ( $ this -> ch , $ option , $ value ) ; }
722	public function json ( ) { if ( version_compare ( PHP_VERSION , '5.6' , '<' ) && $ this -> getDb ( ) -> getDriverName ( ) === 'mysql' ) { throw new \ yii \ base \ Exception ( 'JSON column type is not supported in PHP < 5.6' ) ; } return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_JSON ) ; }
7996	protected function validateHashContext ( $ context ) { if ( ! ( $ context instanceof HashContext ) && ( false === $ context || ! is_resource ( $ context ) || ( is_resource ( $ context ) && static :: HASH_CONTEXT_RESOURCE_TYPE !== get_resource_type ( $ context ) ) ) ) { throw new InvalidArgumentException ( 'Unable to initialize hashing context. Your system might not support the supplied algorithm.' ) ; } return $ context ; }
8252	protected function logInvalidLoginAttempt ( $ name ) { $ max = $ this -> config [ "registration" ] [ "nameLenMax" ] ; if ( strlen ( $ name ) > $ max ) { $ max = substr ( $ name , 0 , $ max ) . " (trimmed)" ; } $ this -> getLogger ( ) -> notice ( "Invalid login attempt for {name} by {addr}" , array ( "name" => $ name , "addr" => $ _SERVER [ 'REMOTE_ADDR' ] , ) ) ; }
3591	public function setMeta ( $ key , $ value , $ group = null ) { $ this -> getMetaAttributes ( ) -> set ( $ key , $ value , $ group ) ; }
6283	protected static function buildHttpClient04 ( LoopInterface $ loop , $ dns = null ) { if ( null === $ dns ) { $ dns = static :: buildDnsResolver ( $ loop ) ; } if ( ! $ dns instanceof DnsResolver ) { throw new \ InvalidArgumentException ( 'For react http client v0.4, $dns must be an instance of DnsResolver' ) ; } $ factory = new HttpClientFactory ( ) ; return $ factory -> create ( $ loop , $ dns ) ; }
7100	private function equalComparison ( UnitCandidate $ a , UnitCandidate $ b , $ property , $ quantity ) { if ( $ a -> { $ property } == $ quantity && $ b -> { $ property } != $ quantity ) { return - 1 ; } if ( $ a -> { $ property } != $ quantity && $ b -> { $ property } == $ quantity ) { return 1 ; } return false ; }
4748	public function getPlan ( string $ planCode ) : array { $ cacheKey = sprintf ( 'plan_%s' , $ planCode ) ; $ hit = $ this -> getFromCache ( $ cacheKey ) ; if ( false === $ hit ) { $ response = $ this -> sendRequest ( 'GET' , sprintf ( 'plans/%s' , $ planCode ) ) ; $ data = $ this -> processResponse ( $ response ) ; $ plan = $ data [ 'plan' ] ; $ this -> saveToCache ( $ cacheKey , $ plan ) ; return $ plan ; } return $ hit ; }
10217	public function add ( IComparable $ pSource ) { $ hash = $ pSource -> getHashCode ( ) ; if ( ! isset ( $ this -> items [ $ hash ] ) ) { $ this -> items [ $ hash ] = $ pSource ; $ this -> keyMap [ count ( $ this -> items ) - 1 ] = $ hash ; } }
12970	private function getReflectionAndClassObject ( ) { if ( $ this -> isCalledAfterOn ) { $ this -> isCalledAfterOn = false ; $ classObj = $ this -> classObjOn ; $ reflection = $ this -> reflectionOn ; unset ( $ this -> classObjOn ) ; unset ( $ this -> reflectionOn ) ; return [ $ reflection , $ classObj ] ; } return [ $ this -> reflection , $ this -> classObj ] ; }
12413	public function addDevice ( $ groupId , array $ deviceIdentifiers ) { $ params = [ 'group_id' => intval ( $ groupId ) , 'device_identifiers' => $ deviceIdentifiers , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_ADD_DEVICE , $ params ] ) ; }
7428	public function renderObject ( ) { if ( ! $ this -> isValid ( $ this -> source ) ) { throw new InvalidSourceExtensionException ( ) ; } return sprintf ( $ this -> objectDecorator , $ this -> width , $ this -> height , $ this -> source ) ; }
10364	public function offsetSet ( $ item , $ node ) { if ( $ item !== null ) { throw new ValueException ( $ item , 'null' ) ; } return $ this -> nodes [ ] = $ node ; }
9580	public function setDeferredChannel ( $ channel , callable $ callback ) { if ( isset ( $ this -> channels [ $ channel ] ) ) { throw new InvalidArgumentException ( "Channel $channel is already defined" ) ; } $ this -> deferredChannels [ $ channel ] = $ callback ; }
3171	public function getMap ( RunnerServiceContext $ context , RunnerConfig $ config ) { return $ this -> getScopedMap ( $ context , $ config , RunnerMap :: SCOPE_TEST ) ; }
8918	public function messages ( $ options ) { $ params = [ 'query' => [ 'apikey' => $ this -> apikey , 'limit' => 100 , 'page' => 1 ] ] ; if ( array_key_exists ( 'limit' , $ options ) ) { $ params [ 'query' ] [ 'limit' ] = $ options [ 'limit' ] ; } if ( array_key_exists ( 'page' , $ options ) ) { $ params [ 'query' ] [ 'page' ] = $ options [ 'page' ] ; } if ( array_key_exists ( 'startDate' , $ options ) ) { $ params [ 'query' ] [ 'startDate' ] = $ options [ 'startDate' ] ; } if ( array_key_exists ( 'endDate' , $ options ) ) { $ params [ 'query' ] [ 'endDate' ] = $ options [ 'endDate' ] ; } if ( array_key_exists ( 'status' , $ options ) ) { $ params [ 'query' ] [ 'status' ] = $ options [ 'status' ] ; } if ( array_key_exists ( 'network' , $ options ) ) { $ params [ 'query' ] [ 'network' ] = $ options [ 'network' ] ; } if ( array_key_exists ( 'sendername' , $ options ) ) { $ params [ 'query' ] [ 'sendername' ] = $ options [ 'sendername' ] ; } $ response = $ this -> client -> get ( 'messages' , $ params ) ; return $ response -> getBody ( ) ; }
8323	public function addPingback ( $ url ) { $ response = $ this -> getHttpClient ( ) -> request ( 'GET' , "/res.php?key={$this->apiKey}&action=add_pingback&addr={$url}" ) ; $ responseText = $ response -> getBody ( ) -> __toString ( ) ; if ( $ responseText === self :: STATUS_OK ) { return true ; } throw new ErrorResponseException ( $ this -> getErrorMessage ( $ responseText ) ? : $ responseText , $ this -> getErrorCode ( $ responseText ) ? : 0 ) ; }
11768	public function updateSentinels ( ) { SENTINEL_QUERY : { $ sentinel = $ this -> getSentinelConnection ( ) ; try { $ payload = $ sentinel -> executeCommand ( RawCommand :: create ( 'SENTINEL' , 'sentinels' , $ this -> service ) ) ; $ this -> sentinels = array ( ) ; $ this -> sentinels [ ] = $ sentinel -> getParameters ( ) -> toArray ( ) ; foreach ( $ payload as $ sentinel ) { $ this -> sentinels [ ] = array ( 'host' => $ sentinel [ 3 ] , 'port' => $ sentinel [ 5 ] , 'role' => 'sentinel' , ) ; } } catch ( ConnectionException $ exception ) { $ this -> sentinelConnection = null ; goto SENTINEL_QUERY ; } } }
1134	public function storeNewParent ( ) { if ( $ this -> isDirty ( $ this -> getParentColumnName ( ) ) && ( $ this -> exists || ! $ this -> isRoot ( ) ) ) static :: $ moveToNewParentId = $ this -> getParentId ( ) ; else static :: $ moveToNewParentId = FALSE ; }
11360	public function setSortBy ( $ sortKeys ) { if ( $ sortKeys == null ) { $ sortKeys = [ ] ; } if ( ! is_array ( $ sortKeys ) ) { $ sortKeys = [ $ sortKeys ] ; } $ this -> sortKeys = $ sortKeys ; }
6354	public static function setFakeTime ( $ fakeTime ) { if ( is_string ( $ fakeTime ) ) { $ fakeTime = ( int ) static :: convert ( TS_UNIX , $ fakeTime ) ; } if ( is_int ( $ fakeTime ) ) { $ fakeTime = function ( ) use ( $ fakeTime ) { return $ fakeTime ; } ; } $ old = static :: $ fakeTimeCallback ; static :: $ fakeTimeCallback = $ fakeTime ? $ fakeTime : null ; return $ old ; }
4229	protected function errorHash ( $ errorValues ) { $ errMsg = $ errorValues [ 'message' ] ; $ errMsg = \ preg_replace ( '/(\(.*?)\d+(.*?\))/' , '\1x\2' , $ errMsg ) ; $ errMsg = \ preg_replace ( '/\b([a-z]+\d+)+\b/' , 'xxx' , $ errMsg ) ; $ errMsg = \ preg_replace ( '/\b[\d.-]{4,}\b/' , 'xxx' , $ errMsg ) ; $ errMsg = \ preg_replace ( '/\s*##.+$/' , '' , $ errMsg ) ; $ hash = \ md5 ( $ errorValues [ 'file' ] . $ errorValues [ 'line' ] . $ errorValues [ 'type' ] . $ errMsg ) ; return $ hash ; }
7851	protected function grabParameter ( ReflectionParameter $ parameter ) { if ( isset ( $ this -> values [ $ parameter -> name ] ) ) { return $ this -> values [ $ parameter -> name ] ; } if ( $ parameter -> isDefaultValueAvailable ( ) ) { return $ parameter -> getDefaultValue ( ) ; } throw new Exception ( "Unable to map parameter [{$parameter->name}] to command [{$this->command}]" ) ; }
6304	protected function process ( array $ nav ) { foreach ( $ nav as $ key => $ value ) { if ( ! isset ( $ value [ 'url' ] ) ) { $ nav [ $ key ] [ 'url' ] = $ this -> url -> to ( $ value [ 'slug' ] ) ; } unset ( $ nav [ $ key ] [ 'slug' ] ) ; } return $ nav ; }
2443	public static function encrypt ( $ varValue , $ strKey = null ) { if ( \ is_array ( $ varValue ) ) { foreach ( $ varValue as $ k => $ v ) { $ varValue [ $ k ] = static :: encrypt ( $ v ) ; } return $ varValue ; } elseif ( $ varValue == '' ) { return '' ; } if ( static :: $ resTd === null ) { static :: initialize ( ) ; } if ( ! $ strKey ) { $ strKey = System :: getContainer ( ) -> getParameter ( 'contao.encryption_key' ) ; } $ iv = mcrypt_create_iv ( mcrypt_enc_get_iv_size ( static :: $ resTd ) ) ; mcrypt_generic_init ( static :: $ resTd , md5 ( $ strKey ) , $ iv ) ; $ strEncrypted = mcrypt_generic ( static :: $ resTd , $ varValue ) ; $ strEncrypted = base64_encode ( $ iv . $ strEncrypted ) ; mcrypt_generic_deinit ( static :: $ resTd ) ; return $ strEncrypted ; }
2594	protected function loadCurrencyOverride ( $ currency ) { if ( is_string ( $ currency ) && strlen ( $ currency ) === 3 ) { $ this -> addPriceType ( PricingTicketing :: PRICETYPE_OVERRIDE_CURRENCY_CONVERSION ) ; $ this -> conversionRate = new ConversionRate ( $ currency ) ; } }
11261	public function add ( MethodInterface $ method ) { if ( $ this -> isUnique ( $ method ) ) { $ this -> collection [ ] = $ method ; } else { throw new ExtDirectException ( "Remotable methodname {$method->getAnnotatedName()} already exists, but have to be unique" ) ; } }
4672	public function setPaths ( array $ paths ) : object { foreach ( $ paths as $ path ) { if ( ! ( is_dir ( $ path ) && is_readable ( $ path ) ) ) { throw new Exception ( "Directory '$path' is not readable." ) ; } } $ this -> paths = $ paths ; return $ this ; }
7110	protected function getTicketFromEvent ( ResourceEventInterface $ event ) { $ ticket = $ event -> getResource ( ) ; if ( ! $ ticket instanceof TicketInterface ) { throw new UnexpectedValueException ( "Expected instance of " . TicketInterface :: class ) ; } return $ ticket ; }
1474	public function createResourceValidator ( ResourceObject $ resource , array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] ) { return $ this -> createValidator ( $ resource -> all ( ) , $ rules , $ messages , $ customAttributes , function ( $ key , $ detail , $ failed ) use ( $ resource ) { return $ this -> invalidResource ( $ resource -> pointer ( $ key , '/data' ) , $ detail , $ failed ) ; } ) ; }
1017	public static function getAllBuiltInTypes ( ) { if ( self :: $ builtInTypes === null ) { self :: $ builtInTypes = array_merge ( Introspection :: getTypes ( ) , self :: getStandardTypes ( ) ) ; } return self :: $ builtInTypes ; }
6778	protected function updateVatDisplayMode ( SaleInterface $ sale ) { if ( $ sale -> hasPayments ( ) ) { return false ; } $ mode = null ; if ( null !== $ group = $ sale -> getCustomerGroup ( ) ) { $ mode = $ group -> getVatDisplayMode ( ) ; } if ( null === $ mode ) { $ mode = $ this -> defaultVatDisplayMode ; } if ( $ mode !== $ sale -> getVatDisplayMode ( ) ) { $ sale -> setVatDisplayMode ( $ mode ) ; return true ; } return false ; }
3372	private function getFormFactory ( ContainerInterface $ services ) { $ elements = null ; if ( $ services -> has ( 'FormElementManager' ) ) { $ elements = $ services -> get ( 'FormElementManager' ) ; } return new Factory ( $ elements ) ; }
8450	public function contactRename ( $ contact , $ firstName , $ lastName ) { $ contact = $ this -> escapePeer ( $ contact ) ; $ firstName = $ this -> escapeStringArgument ( $ firstName ) ; $ lastName = $ this -> escapeStringArgument ( $ lastName ) ; return $ this -> exec ( 'rename_contact ' . $ contact . ' ' . $ firstName . ' ' . $ lastName ) ; }
8960	public function sendRequest ( $ path , $ method = 'GET' , $ headers = array ( ) , $ data = '' ) { switch ( $ method ) { case 'GET' : $ response = $ this -> client -> get ( $ path , $ headers ) ; break ; case 'POST' : $ response = $ this -> client -> post ( $ path , $ data , $ headers ) ; break ; } if ( $ response -> code != 200 ) { $ error = htmlspecialchars ( $ response -> body ) ; throw new \ DomainException ( $ error , $ response -> code ) ; } return simplexml_load_string ( $ response -> body ) ; }
4052	private function fetchPropertiesFor ( $ inputScreenId , IMetaModel $ metaModel ) : array { $ builder = $ this -> connection -> createQueryBuilder ( ) ; return array_map ( function ( $ column ) use ( $ inputScreenId , $ metaModel ) { if ( 'attribute' !== $ column [ 'dcatype' ] ) { return $ column ; } if ( ! ( $ attribute = $ metaModel -> getAttributeById ( $ column [ 'attr_id' ] ) ) ) { @ trigger_error ( 'Unknown attribute "' . $ column [ 'attr_id' ] . '" in input screen "' . $ inputScreenId . '"' , E_USER_WARNING ) ; return $ column ; } $ column = array_merge ( $ column , $ attribute -> getFieldDefinition ( $ column ) , [ 'col_name' => $ attribute -> getColName ( ) ] ) ; return $ column ; } , $ builder -> select ( '*' ) -> from ( 'tl_metamodel_dcasetting' ) -> where ( 'pid=:pid' ) -> andWhere ( 'published=:published' ) -> setParameter ( 'pid' , $ inputScreenId ) -> setParameter ( 'published' , 1 ) -> orderBy ( 'sorting' ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ) ; }
7798	public function parse ( $ text ) { $ statements = array ( ) ; foreach ( $ this -> splitStatements ( $ text ) as $ chunk ) { if ( $ statement = $ this -> statement ( $ chunk ) ) { $ statements [ ] = $ statement ; } } return $ statements ; }
1192	private function addCustomAttributes ( array $ attributes , HTMLPurifier_HTMLDefinition $ definition ) { foreach ( $ attributes as $ attribute ) { $ required = ! empty ( $ attribute [ 3 ] ) ? true : false ; $ onElement = $ attribute [ 0 ] ; $ attrName = $ required ? $ attribute [ 1 ] . '*' : $ attribute [ 1 ] ; $ validValues = $ attribute [ 2 ] ; $ definition -> addAttribute ( $ onElement , $ attrName , $ validValues ) ; } return $ definition ; }
2506	public static function exaluateXpathQueryOnWsdl ( $ wsdlId , $ wsdlFilePath , $ xpath ) { WsdlAnalyser :: loadWsdlXpath ( $ wsdlFilePath , $ wsdlId ) ; return self :: $ wsdlDomXpath [ $ wsdlId ] -> evaluate ( $ xpath ) ; }
1237	private function set ( $ class , $ name , $ value ) { self :: ensurePropertyExists ( $ class , $ name ) ; self :: ensurePropertyType ( $ class , $ name , $ value ) ; $ this -> setValue ( $ class , $ name , $ value ) ; }
4847	public static function unregister ( ) { if ( isset ( self :: $ autoloadFn ) ) { spl_autoload_unregister ( self :: $ autoloadFn ) ; self :: $ autoloadFn = null ; } self :: $ aliases = [ ] ; }
2691	public function getForceLossyUrl ( ) { $ baseFile = $ this -> getBaseFile ( ) ; $ extension = pathinfo ( $ baseFile , PATHINFO_EXTENSION ) ; $ url = $ this -> getBaseFileUrl ( $ baseFile ) ; if ( $ extension == 'png' || $ extension == 'bmp' ) { if ( $ this -> isFastlyImageOptimizationEnabled ( ) == false ) { $ this -> lossyUrl = $ url . '?format=jpeg' ; } else { $ this -> lossyParam = '&format=jpeg' ; } } }
12941	public function storePermissions ( $ params = array ( ) ) { $ authorityAreaTitle = $ this -> input -> getString ( "area-title" ) ; $ authorityAreaURI = $ this -> input -> getString ( "area-uri" ) ; $ authorityAreaAction = $ this -> input -> getString ( "area-action" ) ; $ authorityAreaPermission = $ this -> input -> getString ( "area-permission" ) ; $ authorityId = $ this -> input -> getInt ( "area-authority" ) ; $ table = $ this -> load -> table ( "?authority_permissions" ) ; $ aData = array ( "authority_id" => $ authorityId , "permission_area_uri" => strtolower ( $ authorityAreaURI ) , "permission" => strtolower ( $ authorityAreaPermission ) , "permission_type" => strtolower ( $ authorityAreaAction ) , "permission_title" => $ authorityAreaTitle ) ; foreach ( $ aData as $ k => $ item ) { if ( empty ( $ item ) ) { $ this -> setError ( _t ( "Please complete all permission fields; Provide a title and uri defining the area, a permission type and value" ) ) ; return false ; } } if ( ! $ table -> bindData ( $ aData ) ) { throw new \ Platform \ Exception ( $ table -> getError ( ) ) ; return false ; } if ( $ table -> isNewRow ( ) ) { } if ( ! $ table -> save ( ) ) { return false ; } return true ; }
1551	protected function requiresInverseAdapter ( $ record , EncodingParametersInterface $ parameters ) { return ! empty ( $ parameters -> getFilteringParameters ( ) ) || ! empty ( $ parameters -> getSortParameters ( ) ) || ! empty ( $ parameters -> getPaginationParameters ( ) ) || ! empty ( $ parameters -> getIncludePaths ( ) ) ; }
2456	public function deleteAll ( ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notDeletable' ] ) { throw new InternalServerErrorException ( 'Table "' . $ this -> strTable . '" is not deletable.' ) ; } $ objSession = System :: getContainer ( ) -> get ( 'session' ) ; $ session = $ objSession -> all ( ) ; $ ids = $ session [ 'CURRENT' ] [ 'IDS' ] ; if ( \ is_array ( $ ids ) && \ strlen ( $ ids [ 0 ] ) ) { foreach ( $ ids as $ id ) { $ this -> intId = $ id ; $ this -> delete ( true ) ; } } $ this -> redirect ( $ this -> getReferer ( ) ) ; }
10488	public function run ( \ de \ codenamephp \ platform \ cli \ command \ iCommand $ command ) { if ( $ this -> getDirectory ( ) !== '' && is_dir ( $ this -> getDirectory ( ) ) ) { $ currentDir = getcwd ( ) ; chdir ( $ this -> getDirectory ( ) ) ; } $ returnValue = $ this -> getActualPassthru ( ) -> run ( $ command ) ; if ( isset ( $ currentDir ) ) { chdir ( $ currentDir ) ; } return $ returnValue ; }
7513	function next_no_whitespace ( ) { $ this -> token_start = null ; while ( ++ $ this -> pos < $ this -> size ) { if ( ! isset ( $ this -> whitespace [ $ this -> doc [ $ this -> pos ] ] ) ) { if ( isset ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ) { if ( is_string ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ) { return ( $ this -> token = $ this -> { $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] } ( ) ) ; } else { return ( $ this -> token = $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ; } } else { return ( $ this -> token = self :: TOK_UNKNOWN ) ; } } else { $ this -> parse_linebreak ( ) ; } } return ( $ this -> token = self :: TOK_NULL ) ; }
7466	public function moveUploadedFile ( ) { $ this -> dateCreated = new DateTime ( ) ; if ( null === $ this -> _uploadedFile ) { return ; } $ this -> _uploadedFile -> move ( dirname ( $ this -> path ) , basename ( $ this -> path ) ) ; $ this -> _uploadedFile = null ; }
11243	public function setDirection ( Neuron_GameServer_Map_Vector3 $ start , Neuron_GameServer_Map_Vector3 $ end ) { $ this -> startRotation = $ start ; $ this -> endRotation = $ end ; }
6632	public function requestAccessToken ( $ code ) { if ( ! $ code || empty ( $ code ) ) { throw new InvalidFacebookCodeException ( ) ; } $ request = [ 'url' => $ this -> settings [ 'token_url' ] , 'params' => [ 'client_id' => $ this -> settings [ 'api_key' ] , 'redirect_uri' => $ this -> settings [ 'redirect_uri' ] , 'client_secret' => $ this -> settings [ 'secret' ] , 'code' => $ code , 'format' => 'json' , ] , ] ; return $ this -> access_token -> make ( $ this -> http -> get ( $ request ) ) ; }
293	public function getAttribute ( $ name ) { return isset ( $ this -> _attributes [ $ name ] ) ? $ this -> _attributes [ $ name ] : null ; }
265	public function setLogger ( $ value ) { if ( is_string ( $ value ) || is_array ( $ value ) ) { $ value = Yii :: createObject ( $ value ) ; } $ this -> _logger = $ value ; $ this -> _logger -> dispatcher = $ this ; }
8306	public function assertString ( $ config , $ key ) { if ( array_key_exists ( $ key , $ config ) && ! is_string ( $ config [ $ key ] ) ) { throw new ConfigurationException ( $ key . " must be a string." ) ; } return $ this ; }
1197	private function htmlAttributesCallback ( $ name , $ value ) { if ( false === $ value || null === $ value ) { return '' ; } return ' ' . $ this -> renderHtmlAttribute ( $ name , $ value ) ; }
9230	public function patch ( $ path , $ data = array ( ) , $ headers = array ( ) ) { if ( $ this -> throw_exceptions ) { throw new CanvasPest_Exception ( 'The Canvas API does not support the PATCH method' , CanvasPest_Exception :: UNSUPPORTED_METHOD ) ; } return false ; }
1910	protected function createTemplate ( Model $ model , string $ templateName ) : Template { if ( isset ( $ this -> options [ 'template' ] ) ) { $ templateName = $ this -> options [ 'template' ] ; } if ( $ model -> customTpl ) { $ templateName = $ model -> customTpl ; } $ template = $ this -> get ( 'contao.framework' ) -> createInstance ( FrontendTemplate :: class , [ $ templateName ] ) ; $ template -> setData ( $ model -> row ( ) ) ; return $ template ; }
10663	public function setParamType ( $ type ) { if ( ! is_string ( $ type ) || ! in_array ( $ type , [ self :: PARAM_MULTIPART , self :: PARAM_FORM ] ) ) { throw new InvalidArgumentException ( sprintf ( "Invalid parameter form type, form type only allowed $1s and $2s" , self :: PARAM_FORM , self :: PARAM_MULTIPART ) , E_USER_ERROR ) ; } $ this -> currentParamType = $ type ; $ reverse_params = $ type == self :: PARAM_FORM ? self :: PARAM_MULTIPART : self :: PARAM_FORM ; $ reverse_params_value = isset ( $ this -> configs [ $ reverse_params ] ) ? $ this -> configs [ $ reverse_params ] : null ; $ params_value = isset ( $ this -> configs [ $ type ] ) ? $ this -> configs [ $ type ] : null ; unset ( $ this -> configs [ self :: PARAM_FORM ] , $ this -> configs [ self :: PARAM_MULTIPART ] ) ; $ this -> configs [ $ type ] = is_array ( $ reverse_params_value ) ? $ reverse_params_value : ( is_array ( $ params_value ) ? $ params_value : [ ] ) ; return $ this -> buildConfigClient ( ) ; }
7862	protected function setPipesOfWorkflow ( $ workflow ) { $ pipes = $ this -> pipelines -> getPipesByPipeline ( $ workflow ) ; $ this -> pipes = array_map ( function ( $ pipe ) { $ chunks = explode ( '\\' , $ pipe ) ; return end ( $ chunks ) ; } , $ pipes ) ; $ this -> geometry -> setPipes ( $ this -> pipes ) ; }
8181	public function getDefaultStrategy ( $ name ) { if ( ! is_string ( $ this -> defaultStrategy ) && false !== $ this -> defaultStrategy ) { return call_user_func ( $ this -> defaultStrategy , $ name ) ; } return $ this -> defaultStrategy ; }
254	public static function end ( ) { if ( ! empty ( self :: $ stack ) ) { $ widget = array_pop ( self :: $ stack ) ; if ( get_class ( $ widget ) === get_called_class ( ) ) { if ( $ widget -> beforeRun ( ) ) { $ result = $ widget -> run ( ) ; $ result = $ widget -> afterRun ( $ result ) ; echo $ result ; } return $ widget ; } throw new InvalidCallException ( 'Expecting end() of ' . get_class ( $ widget ) . ', found ' . get_called_class ( ) ) ; } throw new InvalidCallException ( 'Unexpected ' . get_called_class ( ) . '::end() call. A matching begin() is not found.' ) ; }
10165	private function readContinue ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; if ( $ this -> drawingData == '' ) { $ this -> pos += 4 + $ length ; return ; } if ( $ length < 4 ) { $ this -> pos += 4 + $ length ; return ; } $ validSplitPoints = [ 0xF003 , 0xF004 , 0xF00D ] ; $ splitPoint = self :: getUInt2d ( $ recordData , 2 ) ; if ( in_array ( $ splitPoint , $ validSplitPoints ) ) { $ splicedRecordData = $ this -> getSplicedRecordData ( ) ; $ this -> drawingData .= $ splicedRecordData [ 'recordData' ] ; return ; } $ this -> pos += 4 + $ length ; }
9002	public function column_time ( AbstractLog $ item ) { $ time = $ item -> get_time ( ) ; if ( empty ( $ time ) ) { echo '-' ; } else { echo $ time -> format ( get_option ( 'date_format' ) . ' ' . get_option ( 'time_format' ) ) ; } }
5651	public function explainFlag ( $ flags , $ explanation ) { $ flags = is_array ( $ flags ) ? $ flags : array ( $ flags ) ; $ this -> flag_sets [ ] = $ flags ; $ this -> explanations [ ] = $ explanation ; }
4033	public function push ( $ url , $ table , $ icon ) { $ this -> elements [ ] = [ 'url' => $ url , 'text' => $ this -> getLabel ( $ table ) , 'icon' => $ this -> iconBuilder -> getBackendIcon ( $ icon ) ] ; }
11844	private function addAPerson ( array $ person , ObjectManager $ manager ) { $ p = new Person ( ) ; foreach ( $ person as $ key => $ value ) { switch ( $ key ) { case 'CountryOfBirth' : case 'Nationality' : $ value = $ this -> getCountry ( $ value ) ; break ; case 'Birthdate' : $ value = new \ DateTime ( $ value ) ; break ; case 'center' : case 'maritalStatus' : $ value = $ this -> getReference ( $ value ) ; break ; } if ( method_exists ( $ p , 'set' . $ key ) ) { call_user_func ( array ( $ p , 'set' . $ key ) , $ value ) ; } elseif ( method_exists ( $ p , 'add' . $ key ) ) { if ( ! is_array ( $ value ) ) { $ value = array ( $ value ) ; } foreach ( $ value as $ v ) { if ( $ v !== NULL ) { call_user_func ( array ( $ p , 'add' . $ key ) , $ v ) ; } } } } $ manager -> persist ( $ p ) ; echo "add person'" . $ p -> __toString ( ) . "'\n" ; }
4149	protected function buildMultipart ( $ mimeBoundary , $ filename ) { $ binary = $ this -> getBinaryFile ( $ filename ) ; $ details = pathinfo ( $ filename ) ; $ type = $ this -> supportedMimes ( $ details [ 'extension' ] ) ; $ data = '--' . $ mimeBoundary . static :: EOL ; $ data .= 'Content-Disposition: form-data; name="media"; filename="' . $ details [ 'basename' ] . '"' . static :: EOL ; $ data .= 'Content-Type: application/octet-stream' . static :: EOL . static :: EOL ; $ data .= $ binary . static :: EOL ; $ data .= '--' . $ mimeBoundary . '--' . static :: EOL . static :: EOL ; unset ( $ mimeBoundary , $ filename , $ binary , $ details , $ type ) ; return $ data ; }
526	public function init ( ) { if ( $ this -> sourcePath !== null ) { $ this -> sourcePath = rtrim ( Yii :: getAlias ( $ this -> sourcePath ) , '/\\' ) ; } if ( $ this -> basePath !== null ) { $ this -> basePath = rtrim ( Yii :: getAlias ( $ this -> basePath ) , '/\\' ) ; } if ( $ this -> baseUrl !== null ) { $ this -> baseUrl = rtrim ( Yii :: getAlias ( $ this -> baseUrl ) , '/' ) ; } }
3572	public function set ( $ key , $ value = null , $ group = null ) { if ( $ key instanceof Attribute ) { return $ this -> setInstance ( $ key ) ; } if ( $ this -> has ( $ key ) ) { $ this -> update ( $ key , $ value , $ group ) ; } else { $ this -> items [ $ key ] = $ this -> newAttribute ( $ key , $ value , $ group ) ; } return $ this ; }
1862	public function move_uploaded_file ( $ strSource , $ strDestination ) { $ this -> validate ( $ strSource , $ strDestination ) ; return move_uploaded_file ( $ strSource , $ this -> strRootDir . '/' . $ strDestination ) ; }
3135	public function getItemState ( RunnerServiceContext $ context , $ itemRef ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ serviceService = $ this -> getServiceManager ( ) -> get ( StorageManager :: SERVICE_ID ) ; $ userUri = \ common_session_SessionManager :: getSession ( ) -> getUserUri ( ) ; $ stateId = $ this -> getStateId ( $ context , $ itemRef ) ; $ state = is_null ( $ userUri ) ? null : $ serviceService -> get ( $ userUri , $ stateId ) ; if ( $ state ) { $ state = json_decode ( $ state , true ) ; if ( is_null ( $ state ) ) { throw new \ common_exception_InconsistentData ( 'Unable to decode the state for the item ' . $ itemRef ) ; } } return $ state ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'getItemState' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } }
1446	protected function dataForUpdate ( $ record , array $ document ) : array { $ resource = $ document [ 'data' ] ?? [ ] ; if ( $ this -> mustValidateExisting ( $ record , $ document ) ) { $ resource [ 'attributes' ] = $ this -> extractAttributes ( $ record , $ resource [ 'attributes' ] ?? [ ] ) ; $ resource [ 'relationships' ] = $ this -> extractRelationships ( $ record , $ resource [ 'relationships' ] ?? [ ] ) ; } return $ resource ; }
8002	private function resolveInputEncoding ( $ string ) { $ encoding = null ; if ( $ this -> detect ) { $ encoding = mb_detect_encoding ( $ string , null , true ) ; } if ( false === $ encoding || null === $ encoding ) { $ encoding = mb_internal_encoding ( ) ; } if ( false === $ encoding || null === $ encoding ) { throw EncodingDetectionException :: forString ( $ string ) ; } return $ encoding ; }
7181	protected function generateNumber ( PaymentInterface $ payment ) { if ( 0 == strlen ( $ payment -> getNumber ( ) ) ) { $ this -> numberGenerator -> generate ( $ payment ) ; return true ; } return false ; }
10067	protected function registerTags ( ) { $ tags = array ( 'error' , 'hint' , 'label' , 'radioset' , 'checkboxset' ) ; foreach ( $ tags as $ tag ) { $ tagClass = str_replace ( ' ' , '' , ucwords ( str_replace ( '-' , ' ' , $ tag ) ) ) ; $ this -> registerTag ( $ tag , __NAMESPACE__ . '\Tag\\' . $ tagClass ) ; } $ widgets = array ( 'text' , 'file' , 'textarea' , 'radio' , 'checkbox' , 'select' , 'multiselect' , 'checkboxset' , 'radioset' , 'email' , 'password' , 'radioset' , 'checkboxset' , 'button' , 'submit' , 'reset' , 'group' , 'fieldset' , 'collection' , 'form' ) ; foreach ( $ widgets as $ widget ) { $ widgetClass = str_replace ( ' ' , '' , ucwords ( str_replace ( '-' , ' ' , $ widget ) ) ) ; $ this -> registerTag ( 'widget-' . $ widget , __NAMESPACE__ . '\Widget\\' . $ widgetClass ) ; } }
7795	protected function statementBody ( $ text ) { switch ( substr ( $ this -> getLine ( '20' , $ text ) , 0 , 4 ) ) { case '940A' : $ this -> format = self :: FORMAT_CLASSIC ; break ; case '940S' : $ this -> format = self :: FORMAT_STRUCTURED ; break ; default : throw new \ RuntimeException ( 'Unknown file format' ) ; } return parent :: statementBody ( $ text ) ; }
9824	public function writeWorksheetRelationships ( \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Worksheet $ pWorksheet , $ pWorksheetId = 1 , $ includeCharts = false ) { $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ objWriter -> startElement ( 'Relationships' ) ; $ objWriter -> writeAttribute ( 'xmlns' , 'http://schemas.openxmlformats.org/package/2006/relationships' ) ; $ d = 0 ; if ( $ includeCharts ) { $ charts = $ pWorksheet -> getChartCollection ( ) ; } else { $ charts = [ ] ; } if ( ( $ pWorksheet -> getDrawingCollection ( ) -> count ( ) > 0 ) || ( count ( $ charts ) > 0 ) ) { $ this -> writeRelationship ( $ objWriter , ++ $ d , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing' , '../drawings/drawing' . $ pWorksheetId . '.xml' ) ; } $ i = 1 ; foreach ( $ pWorksheet -> getHyperlinkCollection ( ) as $ hyperlink ) { if ( ! $ hyperlink -> isInternal ( ) ) { $ this -> writeRelationship ( $ objWriter , '_hyperlink_' . $ i , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink' , $ hyperlink -> getUrl ( ) , 'External' ) ; ++ $ i ; } } $ i = 1 ; if ( count ( $ pWorksheet -> getComments ( ) ) > 0 ) { $ this -> writeRelationship ( $ objWriter , '_comments_vml' . $ i , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing' , '../drawings/vmlDrawing' . $ pWorksheetId . '.vml' ) ; $ this -> writeRelationship ( $ objWriter , '_comments' . $ i , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments' , '../comments' . $ pWorksheetId . '.xml' ) ; } $ i = 1 ; if ( count ( $ pWorksheet -> getHeaderFooter ( ) -> getImages ( ) ) > 0 ) { $ this -> writeRelationship ( $ objWriter , '_headerfooter_vml' . $ i , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing' , '../drawings/vmlDrawingHF' . $ pWorksheetId . '.vml' ) ; } $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
190	private function loadTableColumnsInfo ( $ tableName ) { $ tableColumns = $ this -> db -> createCommand ( 'PRAGMA TABLE_INFO (' . $ this -> quoteValue ( $ tableName ) . ')' ) -> queryAll ( ) ; $ tableColumns = $ this -> normalizePdoRowKeyCase ( $ tableColumns , true ) ; return ArrayHelper :: index ( $ tableColumns , 'cid' ) ; }
8094	public function set ( $ keyPath , $ value ) { $ stops = explode ( '.' , $ keyPath ) ; $ currentLocation = $ previousLocation = $ this ; foreach ( $ stops as $ key ) { if ( $ currentLocation instanceof Collection ) { if ( ! ( $ currentLocation -> $ key instanceof Collection ) ) { $ currentLocation -> $ key = array ( ) ; } } else { $ currentLocation = array ( ) ; $ currentLocation -> $ key = array ( ) ; } $ previousLocation = $ currentLocation ; $ currentLocation = $ currentLocation -> $ key ; } $ previousLocation -> $ key = $ value ; }
680	protected function validateConjunctionCondition ( $ operator , $ condition ) { if ( ! is_array ( $ condition ) || ! ArrayHelper :: isIndexed ( $ condition ) ) { $ this -> addError ( $ this -> filterAttributeName , $ this -> parseErrorMessage ( 'operatorRequireMultipleOperands' , [ 'operator' => $ operator ] ) ) ; return ; } foreach ( $ condition as $ part ) { $ this -> validateCondition ( $ part ) ; } }
574	public function unmaskToken ( $ maskedToken ) { $ decoded = StringHelper :: base64UrlDecode ( $ maskedToken ) ; $ length = StringHelper :: byteLength ( $ decoded ) / 2 ; if ( ! is_int ( $ length ) ) { return '' ; } return StringHelper :: byteSubstr ( $ decoded , $ length , $ length ) ^ StringHelper :: byteSubstr ( $ decoded , 0 , $ length ) ; }
10100	private function writeRichTextString ( $ row , $ col , $ str , $ xfIndex , $ arrcRun ) { $ record = 0x00FD ; $ length = 0x000A ; $ str = StringHelper :: UTF8toBIFF8UnicodeShort ( $ str , $ arrcRun ) ; if ( ! isset ( $ this -> stringTable [ $ str ] ) ) { $ this -> stringTable [ $ str ] = $ this -> stringUnique ++ ; } ++ $ this -> stringTotal ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vvvV' , $ row , $ col , $ xfIndex , $ this -> stringTable [ $ str ] ) ; $ this -> append ( $ header . $ data ) ; }
6012	public function addCommentResponse ( $ item ) { if ( ! ( $ item instanceof self ) ) { if ( is_array ( $ item ) ) { try { $ item = new self ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate CommentResponse. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "CommentResponse"!' , E_USER_WARNING ) ; } } $ this -> replies [ ] = $ item ; return $ this ; }
7900	public function upload ( $ file , Closure $ callback = null ) { $ uploadedFile = $ this -> runUpload ( $ file ) ; if ( ! $ uploadedFile ) { return false ; } if ( $ callback ) { $ callback ( $ uploadedFile ) ; } return true ; }
9702	public function addFont ( \ PhpOffice \ PhpSpreadsheet \ Style \ Font $ font ) { $ fontHashCode = $ font -> getHashCode ( ) ; if ( isset ( $ this -> addedFonts [ $ fontHashCode ] ) ) { $ fontIndex = $ this -> addedFonts [ $ fontHashCode ] ; } else { $ countFonts = count ( $ this -> fontWriters ) ; $ fontIndex = ( $ countFonts < 4 ) ? $ countFonts : $ countFonts + 1 ; $ fontWriter = new Font ( $ font ) ; $ fontWriter -> setColorIndex ( $ this -> addColor ( $ font -> getColor ( ) -> getRGB ( ) ) ) ; $ this -> fontWriters [ ] = $ fontWriter ; $ this -> addedFonts [ $ fontHashCode ] = $ fontIndex ; } return $ fontIndex ; }
5835	private function clearExpiredCacheEntries ( int $ now ) { $ this -> now = $ now ; foreach ( $ this -> cacheTimeouts as $ path => $ timeout ) { if ( $ now <= $ timeout ) { break ; } $ fileInfo = $ this -> cache [ $ path ] ; unset ( $ this -> cache [ $ path ] , $ this -> cacheTimeouts [ $ path ] ) ; $ this -> bufferedFileCount -= isset ( $ fileInfo -> buffer ) ; $ this -> cacheEntryCount -- ; } }
9267	public function recipe ( string $ string , string $ method , callable $ callback = null ) : string { return preg_replace_callback ( RegEx :: REGEX_SPACE , [ $ this , $ method ] , $ this -> callback ( $ string , $ callback ) ) ; }
11016	public function addDefaultListeners ( ) { $ this -> dispatcher -> addListener ( Events :: EVENT_BEFORE_CONTROLLER_RUN , $ this ) ; $ this -> dispatcher -> addListener ( Events :: EVENT_AFTER_CONTROLLER_RUN , $ this ) ; }
1260	protected function createAccess ( ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ accessRequest = $ xml -> appendChild ( $ xml -> createElement ( 'AccessRequest' ) ) ; $ accessRequest -> setAttribute ( 'xml:lang' , 'en-US' ) ; $ accessRequest -> appendChild ( $ xml -> createElement ( 'AccessLicenseNumber' , $ this -> accessKey ) ) ; $ accessRequest -> appendChild ( $ xml -> createElement ( 'UserId' , $ this -> userId ) ) ; $ p = $ accessRequest -> appendChild ( $ xml -> createElement ( 'Password' ) ) ; $ p -> appendChild ( $ xml -> createTextNode ( $ this -> password ) ) ; return $ xml -> saveXML ( ) ; }
1735	public function getProvisionUri ( User $ user , Request $ request ) : string { $ issuer = rawurlencode ( $ request -> getSchemeAndHttpHost ( ) ) ; return sprintf ( 'otpauth://totp/%s:%s?secret=%s&issuer=%s' , $ issuer , rawurlencode ( $ user -> getUsername ( ) ) . '@' . $ issuer , $ this -> getUpperUnpaddedSecretForUser ( $ user ) , $ issuer ) ; }
9258	protected function dumpContainer ( ConfigCache $ cache , ContainerBuilder $ container , $ class , $ baseClass ) { $ dumper = new PhpDumper ( $ container ) ; $ content = $ dumper -> dump ( array ( 'class' => $ class , 'base_class' => $ baseClass ) ) ; $ cache -> write ( $ content , $ container -> getResources ( ) ) ; }
6649	public function uploadFile ( $ event ) { if ( ! array_key_exists ( $ this -> attribute , $ event -> sender -> attributes ) ) { throw new InvalidConfigException ( Yii :: t ( 'wavecms/main' , 'Attribute {attribute} not found in model {model}' , [ 'attribute' => $ this -> attribute , 'model' => $ event -> sender -> className ( ) ] ) ) ; } $ oldFile = false ; if ( isset ( $ event -> sender -> oldAttributes [ $ this -> attribute ] ) ) { $ oldFile = $ event -> sender -> oldAttributes [ $ this -> attribute ] ; } $ uploadedFile = UploadedFile :: getInstance ( $ event -> sender , $ this -> attribute ) ; if ( null !== $ uploadedFile && $ uploadedFile -> size !== 0 ) { $ folder = $ this -> getWebrootFolder ( ) ; if ( $ oldFile ) { $ this -> unlinkFiles ( $ oldFile ) ; } $ baseName = $ uploadedFile -> baseName ; $ fileName = $ baseName . '.' . $ uploadedFile -> extension ; while ( @ file_exists ( $ folder . '/' . $ fileName ) ) { $ baseName .= '_' ; $ fileName = $ baseName . '.' . $ uploadedFile -> extension ; } FileHelper :: createDirectory ( $ folder , 0777 ) ; $ uploadedFile -> saveAs ( $ folder . '/' . $ fileName ) ; $ event -> sender -> { $ this -> attribute } = $ fileName ; } else { if ( Yii :: $ app -> request -> post ( $ this -> attribute . '_file_delete' ) ) { $ this -> unlinkFiles ( $ oldFile ) ; $ event -> sender -> { $ this -> attribute } = null ; } else { $ event -> sender -> { $ this -> attribute } = $ oldFile ; } } }
5648	public function paintMethodEnd ( $ test_name ) { $ numberOfReporters = count ( $ this -> reporters ) ; for ( $ i = 0 ; $ i < $ numberOfReporters ; $ i ++ ) { $ this -> reporters [ $ i ] -> paintMethodEnd ( $ test_name ) ; } }
1774	public function addAttributes ( $ arrAttributes ) { if ( ! \ is_array ( $ arrAttributes ) ) { return ; } foreach ( $ arrAttributes as $ k => $ v ) { $ this -> $ k = $ v ; } }
6859	protected static function solsticeDecember ( $ year , $ vsop = true ) { $ month = 12 ; if ( $ vsop ) return static :: accurate ( $ year , static :: meanTerms ( $ month , $ year ) , $ month ) ; else return static :: approx ( $ year , static :: meanTerms ( $ month , $ year ) ) ; }
6019	public function removeSite ( $ id ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> delete ( 'v1/deployment/' . $ id . '' , $ parameters ) ; $ result = new DeploymentSiteResponse ( $ result ) ; return $ result ; }
9795	public function setDataValidation ( DataValidation $ pDataValidation = null ) { if ( ! isset ( $ this -> parent ) ) { throw new Exception ( 'Cannot set data validation for cell that is not bound to a worksheet' ) ; } $ this -> getWorksheet ( ) -> setDataValidation ( $ this -> getCoordinate ( ) , $ pDataValidation ) ; return $ this -> updateInCollection ( ) ; }
12420	public function dt ( $ domain , $ singular ) { $ singular = ( string ) $ singular ; try { $ locale = $ this -> getLocale ( ) ; foreach ( $ this -> getTranslations ( $ domain ) as $ object ) { if ( ( $ string = $ object -> translate ( $ singular , $ domain , $ locale ) ) != $ singular ) { return $ string ; } } } catch ( \ Exception $ e ) { ; } return ( string ) $ singular ; }
10504	private function registerLogLevels ( ) { $ this -> app -> singleton ( Contracts \ Utilities \ LogLevels :: class , function ( $ app ) { $ translator = $ app [ 'translator' ] ; return new Utilities \ LogLevels ( $ translator , 'en' ) ; } ) ; $ this -> app -> singleton ( 'arcanedev.log-viewer.levels' , Contracts \ Utilities \ LogLevels :: class ) ; }
5906	public function listSettings ( CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/settings' , $ parameters , $ cachePolicy ) ; return $ result ; }
297	public function getDirtyAttributes ( $ names = null ) { if ( $ names === null ) { $ names = $ this -> attributes ( ) ; } $ names = array_flip ( $ names ) ; $ attributes = [ ] ; if ( $ this -> _oldAttributes === null ) { foreach ( $ this -> _attributes as $ name => $ value ) { if ( isset ( $ names [ $ name ] ) ) { $ attributes [ $ name ] = $ value ; } } } else { foreach ( $ this -> _attributes as $ name => $ value ) { if ( isset ( $ names [ $ name ] ) && ( ! array_key_exists ( $ name , $ this -> _oldAttributes ) || $ value !== $ this -> _oldAttributes [ $ name ] ) ) { $ attributes [ $ name ] = $ value ; } } } return $ attributes ; }
440	public function canGetProperty ( $ name , $ checkVars = true , $ checkBehaviors = true ) { if ( method_exists ( $ this , 'get' . $ name ) || $ checkVars && property_exists ( $ this , $ name ) ) { return true ; } elseif ( $ checkBehaviors ) { $ this -> ensureBehaviors ( ) ; foreach ( $ this -> _behaviors as $ behavior ) { if ( $ behavior -> canGetProperty ( $ name , $ checkVars ) ) { return true ; } } } return false ; }
1684	public function checkAdminStatus ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ varValue == '' && $ this -> User -> id == $ dc -> id ) { $ varValue = 1 ; } return $ varValue ; }
6420	public function stop ( ) : Stopwatch { $ tick = $ this -> ticker -> read ( ) ; Preconditions :: checkState ( $ this -> isRunning , 'This stopwatch is already stopped.' ) ; $ this -> isRunning = false ; $ this -> elapsedMicros += ( $ tick - $ this -> startTick ) ; return $ this ; }
8289	protected function authRoutes ( ) { switch ( $ this -> requestUrl ) { case 'login' : if ( $ this -> user -> getAuthenticated ( ) ) { $ this -> redirectToPage ( $ this -> config [ "afterLogin" ] ) ; } break ; case 'logout' : if ( ! $ this -> user -> getAuthenticated ( ) ) { $ this -> redirectToLogin ( ) ; } $ this -> checkLogoutSubmission ( ) ; break ; } }
4629	protected function prepareRequestParameters ( ) { if ( $ this -> command -> hasParameters ( ) ) { $ this -> query = http_build_query ( $ this -> command -> getParameters ( ) , '' , '&' , PHP_QUERY_RFC3986 ) ; } return $ this ; }
1250	public function parse ( $ xml ) { $ parser = xml_parser_create_ns ( 'UTF-8' , '@' ) ; xml_parser_set_option ( $ parser , XML_OPTION_CASE_FOLDING , 0 ) ; xml_parser_set_option ( $ parser , XML_OPTION_SKIP_WHITE , 1 ) ; xml_set_object ( $ parser , $ this ) ; xml_set_element_handler ( $ parser , 'startElement' , 'endElement' ) ; xml_set_character_data_handler ( $ parser , 'cdata' ) ; xml_parse ( $ parser , $ xml , true ) ; xml_parser_free ( $ parser ) ; return $ this -> rootObject ; }
7945	public function ipDeleteMonitoringNotification ( $ id , $ ip , $ notificationId ) { if ( ! $ id ) throw new BadMethodCallException ( 'Missing parameter $id.' ) ; if ( ! $ ip ) throw new BadMethodCallException ( 'Missing parameter $ip.' ) ; if ( ! $ notificationId ) throw new BadMethodCallException ( 'Missing parameter $notificationId.' ) ; try { $ r = $ this -> delete ( 'xdsl/' . $ id . '/ips/' . $ ip . '/monitoringNotifications/' . $ notificationId ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new XdslException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return ; }
8938	public function updateChangeset ( $ id , $ tags = array ( ) ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'changeset/' . $ id ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ tagList = '' ; if ( ! empty ( $ tags ) ) { foreach ( $ tags as $ key => $ value ) { $ tagList .= '<tag k="' . $ key . '" v="' . $ value . '"/>' ; } } $ xml = '<?xml version="1.0" encoding="UTF-8"?> <osm version="0.6" generator="JoomlaOpenStreetMap"> <changeset>' . $ tagList . '</changeset> </osm>' ; $ header [ 'Content-Type' ] = 'text/xml' ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters , $ xml , $ header ) ; $ xmlString = simplexml_load_string ( $ response -> body ) ; return $ xmlString -> changeset ; }
475	public function delete ( $ table , $ condition = '' , $ params = [ ] ) { $ time = $ this -> beginCommand ( "delete from $table" ) ; $ this -> db -> createCommand ( ) -> delete ( $ table , $ condition , $ params ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
2319	public static function resize ( $ image , $ width , $ height , $ mode = '' ) { @ trigger_error ( 'Using Image::resize() has been deprecated and will no longer work in Contao 5.0. Use the contao.image.image_factory service instead.' , E_USER_DEPRECATED ) ; return static :: get ( $ image , $ width , $ height , $ mode , $ image , true ) ? true : false ; }
6930	private function purgeShipmentInvoice ( Invoice \ InvoiceInterface $ invoice ) { $ changed = false ; $ shipment = $ invoice -> getShipment ( ) ; foreach ( $ invoice -> getLinesByType ( Document \ DocumentLineTypes :: TYPE_GOOD ) as $ line ) { foreach ( $ shipment -> getItems ( ) as $ shipmentItem ) { if ( $ line -> getSaleItem ( ) === $ shipmentItem -> getSaleItem ( ) ) { continue 2 ; } } $ invoice -> removeLine ( $ line ) ; $ this -> persistenceHelper -> remove ( $ line , false ) ; $ changed = true ; } $ sale = $ invoice -> getSale ( ) ; foreach ( $ invoice -> getLinesByType ( Document \ DocumentLineTypes :: TYPE_DISCOUNT ) as $ line ) { foreach ( $ sale -> getAdjustments ( Common \ AdjustmentTypes :: TYPE_DISCOUNT ) as $ saleAdjustment ) { if ( $ line -> getSaleAdjustment ( ) === $ saleAdjustment ) { continue 2 ; } } $ invoice -> removeLine ( $ line ) ; $ this -> persistenceHelper -> remove ( $ line , false ) ; $ changed = true ; } if ( null === $ sale -> getShipmentMethod ( ) ) { foreach ( $ invoice -> getLinesByType ( Document \ DocumentLineTypes :: TYPE_SHIPMENT ) as $ line ) { $ invoice -> removeLine ( $ line ) ; $ this -> persistenceHelper -> remove ( $ line , false ) ; $ changed = true ; } } return $ changed ; }
2339	public function renderDropdown ( ) { $ objVersion = $ this -> Database -> prepare ( "SELECT tstamp, version, username, active FROM tl_version WHERE fromTable=? AND pid=? ORDER BY version DESC" ) -> execute ( $ this -> strTable , $ this -> intPid ) ; if ( $ objVersion -> numRows < 2 ) { return '' ; } $ versions = '' ; while ( $ objVersion -> next ( ) ) { $ versions .= ' <option value="' . $ objVersion -> version . '"' . ( $ objVersion -> active ? ' selected="selected"' : '' ) . '>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'version' ] . ' ' . $ objVersion -> version . ' (' . Date :: parse ( Config :: get ( 'datimFormat' ) , $ objVersion -> tstamp ) . ') ' . $ objVersion -> username . '</option>' ; } return '<div class="tl_version_panel"><form action="' . ampersand ( Environment :: get ( 'request' ) , true ) . '" id="tl_version" class="tl_form" method="post" aria-label="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'versioning' ] ) . '"><div class="tl_formbody"><input type="hidden" name="FORM_SUBMIT" value="tl_version"><input type="hidden" name="REQUEST_TOKEN" value="' . REQUEST_TOKEN . '"><select name="version" class="tl_select">' . $ versions . '</select><button type="submit" name="showVersion" id="showVersion" class="tl_submit">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'restore' ] . '</button><a href="' . Backend :: addToUrl ( 'versions=1&amp;popup=1' ) . '" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'showDifferences' ] ) . '" onclick="Backend.openModalIframe({\'title\':\'' . StringUtil :: specialchars ( str_replace ( "'" , "\\'" , sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'recordOfTable' ] , $ this -> intPid , $ this -> strTable ) ) ) . '\',\'url\':this.href});return false">' . Image :: getHtml ( 'diff.svg' ) . '</a></div></form></div>' ; }
10693	protected function fixTable ( $ table , $ tableAlias = '' ) { if ( empty ( $ table ) ) { $ table = [ ] ; } else { if ( ! is_array ( $ table ) ) { $ table = empty ( $ tableAlias ) ? [ $ table ] : [ $ table => $ tableAlias ] ; } } return $ table ; }
1184	protected function wrapValidator ( ) { $ resolver = new Resolver ( $ this -> factory ) ; $ this -> factory -> resolver ( $ resolver -> resolver ( $ this -> field ) ) ; $ this -> factory -> extend ( RemoteValidator :: EXTENSION_NAME , $ resolver -> validatorClosure ( ) ) ; }
573	public function compareString ( $ expected , $ actual ) { if ( ! is_string ( $ expected ) ) { throw new InvalidArgumentException ( 'Expected expected value to be a string, ' . gettype ( $ expected ) . ' given.' ) ; } if ( ! is_string ( $ actual ) ) { throw new InvalidArgumentException ( 'Expected actual value to be a string, ' . gettype ( $ actual ) . ' given.' ) ; } if ( function_exists ( 'hash_equals' ) ) { return hash_equals ( $ expected , $ actual ) ; } $ expected .= "\0" ; $ actual .= "\0" ; $ expectedLength = StringHelper :: byteLength ( $ expected ) ; $ actualLength = StringHelper :: byteLength ( $ actual ) ; $ diff = $ expectedLength - $ actualLength ; for ( $ i = 0 ; $ i < $ actualLength ; $ i ++ ) { $ diff |= ( ord ( $ actual [ $ i ] ) ^ ord ( $ expected [ $ i % $ expectedLength ] ) ) ; } return $ diff === 0 ; }
162	public function addParams ( $ params ) { if ( ! empty ( $ params ) ) { if ( empty ( $ this -> params ) ) { $ this -> params = $ params ; } else { foreach ( $ params as $ name => $ value ) { if ( is_int ( $ name ) ) { $ this -> params [ ] = $ value ; } else { $ this -> params [ $ name ] = $ value ; } } } } return $ this ; }
12777	public function render ( ) { $ sort = 0 ; $ query = $ this -> request -> getQuery ( ) ; if ( isset ( $ query [ 'sort' ] ) && isset ( $ this -> columns [ $ query [ 'sort' ] ] ) ) { $ sort = $ query [ 'sort' ] ; } return $ this -> formatter -> render ( $ this -> columns , $ this -> getRecords ( ) , $ this -> dataManager -> getTotalCount ( ) , $ this -> limit , $ this -> page , $ sort ) ; }
8763	public function delete ( $ server_filename ) { $ upload_path = config ( 'dropzoner.upload-path' ) ; $ full_path = $ upload_path . $ server_filename ; if ( \ File :: exists ( $ full_path ) ) { \ File :: delete ( $ full_path ) ; } event ( new ImageWasDeleted ( $ server_filename ) ) ; return response ( ) -> json ( [ 'error' => false , 'code' => 200 ] , 200 ) ; }
7029	public function getMessagesForQuantity ( float $ quantity ) { $ messages = [ ] ; if ( $ quantity < $ this -> minimumQuantity ) { $ messages [ ] = $ this -> minimumMessage ; } elseif ( 0 < $ this -> maximumQuantity && $ quantity > $ this -> maximumQuantity ) { $ messages [ ] = $ this -> maximumMessage ; } else { if ( null !== $ this -> availableMessage ) { $ messages [ ] = $ this -> availableMessage ; } if ( $ quantity > $ this -> availableQuantity ) { if ( null !== $ this -> resupplyMessage ) { $ messages [ ] = $ this -> resupplyMessage ; if ( $ quantity > $ this -> availableQuantity + $ this -> resupplyQuantity ) { $ messages [ ] = $ this -> overflowMessage ; } } else { $ messages [ ] = $ this -> overflowMessage ; } } } if ( empty ( $ messages ) ) { $ messages [ ] = $ this -> overflowMessage ; } return $ messages ; }
5074	public function outputSetFormat ( $ sFormat ) { if ( static :: isValidFormat ( $ sFormat ) ) { $ this -> sOutputFormat = strtoupper ( $ sFormat ) ; return true ; } return false ; }
3563	protected function getMutator ( $ value , $ dir = 'setter' , $ type = null ) { $ type = $ type ? : $ this -> getValueType ( $ value ) ; foreach ( $ this -> { "{$dir}Mutators" } as $ mutated => $ mutator ) { if ( $ type == $ mutated || $ value instanceof $ mutated ) { return $ mutator ; } } }
8810	public function destroy ( ) { foreach ( $ _COOKIE as $ key => $ value ) { setcookie ( $ key , null , - 1 , '/' ) ; unset ( $ _COOKIE [ $ key ] ) ; } return ; }
7628	public function getContainerAcl ( $ containerName = '' , $ signedIdentifiers = false ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; $ response = $ this -> performRequest ( $ containerName , array ( 'restype' => 'container' , 'comp' => 'acl' ) , 'GET' , array ( ) , false , null , self :: RESOURCE_CONTAINER , self :: PERMISSION_READ ) ; if ( ! $ response -> isSuccessful ( ) ) { throw new BlobException ( $ this -> getErrorMessage ( $ response , 'Resource could not be accessed.' ) ) ; } if ( $ signedIdentifiers == false ) { $ accessType = $ response -> getHeader ( Storage :: PREFIX_STORAGE_HEADER . 'blob-public-access' ) ; if ( strtolower ( $ accessType ) == 'true' ) { $ accessType = self :: ACL_PUBLIC_CONTAINER ; } return $ accessType ; } $ result = $ this -> parseResponse ( $ response ) ; if ( ! $ result ) { return array ( ) ; } $ entries = null ; if ( $ result -> SignedIdentifier ) { if ( count ( $ result -> SignedIdentifier ) > 1 ) { $ entries = $ result -> SignedIdentifier ; } else { $ entries = array ( $ result -> SignedIdentifier ) ; } } $ returnValue = array ( ) ; foreach ( $ entries as $ entry ) { $ returnValue [ ] = new SignedIdentifier ( $ entry -> Id , $ entry -> AccessPolicy ? $ entry -> AccessPolicy -> Start ? $ entry -> AccessPolicy -> Start : '' : '' , $ entry -> AccessPolicy ? $ entry -> AccessPolicy -> Expiry ? $ entry -> AccessPolicy -> Expiry : '' : '' , $ entry -> AccessPolicy ? $ entry -> AccessPolicy -> Permission ? $ entry -> AccessPolicy -> Permission : '' : '' ) ; } return $ returnValue ; }
9200	public function uploadMedia ( $ filepaths , $ client = null ) { $ maxMediaIds = Config :: get ( 'max_media_ids' ) ; if ( count ( $ filepaths ) > $ maxMediaIds ) { throw new MediaUploadLimitException ( "You cannot upload more than ${maxMediaIds} media files in a tweet!" ) ; } $ mediaIds = array ( ) ; if ( is_null ( $ client ) ) { $ client = $ this -> createGuzzleClient ( Config :: get ( 'base_upload_url' ) ) ; } $ endpoint = $ this -> prependVersionToEndpoint ( "media/upload.json" , Config :: get ( 'api_version' ) ) ; foreach ( $ filepaths as $ filepath ) { $ options = $ this -> constructRequestOptions ( array ( ) , $ client ) ; $ options [ 'body' ] = array ( 'media' => new PostFile ( 'media' , fopen ( $ filepath , 'r' ) ) ) ; $ response = $ client -> post ( $ endpoint , $ options ) ; array_push ( $ mediaIds , $ response -> json ( ) [ 'media_id_string' ] ) ; } return ( implode ( "," , $ mediaIds ) ) ; }
11234	protected function checkValue ( $ value , $ subject , $ reference ) { if ( is_null ( $ value ) ) { return $ subject ; } elseif ( $ subject != $ reference ) { throw new RuntimeException ( Message :: get ( Message :: MSG_REF_MALFORMED , $ reference ) , Message :: MSG_REF_MALFORMED ) ; } else { return $ value ; } }
3743	protected function setLanguage ( $ language = '' ) { $ previousLanguage = $ GLOBALS [ 'TL_LANGUAGE' ] ; if ( ! empty ( $ language ) && ( $ GLOBALS [ 'TL_LANGUAGE' ] !== $ language ) ) { $ GLOBALS [ 'TL_LANGUAGE' ] = $ language ; } return $ previousLanguage ; }
11982	public function acquire ( AcquirerInterface $ acquirer , ResourceInterface $ resource ) { if ( ! $ this -> isAccessible ( $ acquirer , $ resource ) ) { throw new ResourceLockedException ( sprintf ( 'The resource is not accessible. It is locked by "%s".' , $ resource -> getLock ( ) -> getAcquirer ( ) -> getIdentifier ( ) ) ) ; } return $ this -> repository -> acquire ( $ acquirer , $ resource ) ; }
7736	private function documentProperties ( ClassMetadata $ metadata , ReflectionClass $ class ) { $ properties = array ( ) ; $ elements = array_merge ( $ class -> getProperties ( ) , $ class -> getMethods ( ) ) ; foreach ( $ elements as $ element ) { $ annotation = $ this -> getAnnotation ( $ element , 'ML\HydraBundle\Mapping\Expose' ) ; if ( null === $ annotation ) { continue ; } $ property = new PropertyDefinition ( $ class -> name , $ element -> name ) ; $ property -> setExposeAs ( $ annotation -> as ) ; $ property -> setIri ( $ annotation -> getIri ( ) ) ; if ( null !== $ annotation -> required ) { $ property -> setRequired ( $ annotation -> required ) ; } if ( null !== $ annotation -> readonly ) { $ property -> setReadOnly ( $ annotation -> readonly ) ; } if ( null !== $ annotation -> writeonly ) { $ property -> setWriteOnly ( $ annotation -> writeonly ) ; } $ tmp = $ this -> getDocBlockText ( $ element ) ; $ property -> setTitle ( $ tmp [ 'title' ] ) ; $ property -> setDescription ( $ tmp [ 'description' ] ) ; $ tmp = $ this -> getType ( $ element ) ; $ property -> setType ( $ tmp [ 'type' ] ) ; $ this -> documentRouteAndOperations ( $ property , $ element ) ; if ( null !== ( $ annotation = $ this -> getAnnotation ( $ element , 'ML\HydraBundle\Mapping\Collection' ) ) ) { $ property -> setRoute ( $ this -> getRouteMetadata ( $ annotation -> route ) ) ; if ( false === $ property -> supportsOperation ( $ annotation -> route ) ) { $ property -> addOperation ( $ this -> getRouteMetadata ( $ annotation -> route ) ) ; } $ property -> setType ( 'ML\HydraBundle\Entity\Collection' ) ; $ property -> setReadOnly ( true ) ; } $ properties [ ] = $ property ; } $ metadata -> setProperties ( $ properties ) ; }
11172	public static function encrypt ( $ data , $ key , $ cipher = MCRYPT_RIJNDAEL_128 , $ mode = MCRYPT_MODE_CBC ) { $ data = serialize ( $ data ) ; $ key = hash ( 'sha256' , $ key , true ) ; $ iv_size = mcrypt_get_iv_size ( $ cipher , $ mode ) ; $ iv = mcrypt_create_iv ( $ iv_size , MCRYPT_RAND ) ; return base64_encode ( serialize ( array ( $ iv , mcrypt_encrypt ( $ cipher , $ key , $ data , $ mode , $ iv ) ) ) ) ; }
3918	private function checkDownloads ( ) { if ( $ this -> getShowImages ( ) ) { return ; } if ( ( $ file = Input :: get ( 'file' ) ) && ( $ key = Input :: get ( 'fileKey' ) ) ) { if ( ! ( array_key_exists ( $ file , $ _SESSION [ 'metaModels_downloads' ] ) && $ _SESSION [ 'metaModels_downloads' ] [ $ file ] === $ key ) ) { $ objHandler = new $ GLOBALS [ 'TL_PTY' ] [ 'error_403' ] ( ) ; $ objHandler -> generate ( $ file ) ; } Controller :: sendFileToBrowser ( $ file ) ; } }
9730	public function setMaxParcelDimensions ( $ value = null ) { if ( is_array ( $ value ) ) { $ value = new ParcelDimensions ( $ value ) ; } elseif ( ! ( $ value instanceof ParcelDimensions ) ) { $ value = null ; } return $ this -> setParameter ( 'max_parcel_dimensions' , $ value ) ; }
8576	public function setItemChargeAdjustmentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ItemChargeAdjustmentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
3401	public function getValue ( ApistMethod $ method , Crawler $ rootNode = null ) { if ( is_null ( $ rootNode ) ) { $ rootNode = $ method -> getCrawler ( ) ; } $ result = $ rootNode -> filter ( $ this -> selector ) ; return $ this -> applyResultCallbackChain ( $ result , $ method ) ; }
803	private function hasVoidReturnAnnotation ( Tokens $ tokens , $ index ) { foreach ( $ this -> findReturnAnnotations ( $ tokens , $ index ) as $ return ) { if ( [ 'void' ] === $ return -> getTypes ( ) ) { return true ; } } return false ; }
3620	public function setFanEveryDaySchedule ( $ start_hour , $ end_hour , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ data = json_encode ( array ( 'fan_duty_start_time' => $ start_hour * 3600 , 'fan_duty_end_time' => $ end_hour * 3600 ) ) ; return $ this -> doPOST ( "/v2/put/device." . $ serial_number , $ data ) ; }
12604	public static function upload ( $ src , $ dest ) { $ dest = Path :: clean ( $ dest ) ; $ baseDir = dirname ( $ dest ) ; try { if ( ! Folder :: exists ( $ baseDir ) ) { Folder :: create ( $ baseDir ) ; } } catch ( Exception $ e ) { throw $ e ; } if ( is_writeable ( $ baseDir ) && move_uploaded_file ( $ src , $ dest ) ) { if ( Path :: setPermissions ( $ dest ) ) { return true ; } throw new Exception ( Helper :: getTranslation ( 'FAILED_CHMOD' ) ) ; } throw new Exception ( Helper :: getTranslation ( 'FAILED_MOVE_UPLOAD' ) ) ; }
12011	private function addBlockSection ( ArrayNodeDefinition $ rootNode ) { $ rootNode -> fixXmlConfig ( 'block_theme' ) -> children ( ) -> arrayNode ( 'block_themes' ) -> prototype ( 'scalar' ) -> end ( ) -> example ( [ '@App/block.html.twig' ] ) -> end ( ) -> end ( ) ; }
4244	private function buildErrorList ( ) { $ errorStr = '' ; $ errors = $ this -> debug -> errorHandler -> get ( 'errors' ) ; \ uasort ( $ errors , function ( $ a1 , $ a2 ) { return \ strcmp ( $ a1 [ 'file' ] . $ a1 [ 'line' ] , $ a2 [ 'file' ] . $ a2 [ 'line' ] ) ; } ) ; $ lastFile = '' ; foreach ( $ errors as $ error ) { if ( $ error [ 'isSuppressed' ] ) { continue ; } if ( $ error [ 'file' ] !== $ lastFile ) { $ errorStr .= $ error [ 'file' ] . ':' . "\n" ; $ lastFile = $ error [ 'file' ] ; } $ typeStr = $ error [ 'type' ] === E_STRICT ? 'Strict' : $ error [ 'typeStr' ] ; $ errorStr .= ' Line ' . $ error [ 'line' ] . ': (' . $ typeStr . ') ' . $ error [ 'message' ] . "\n" ; } return $ errorStr ; }
2501	private function getFacetParams ( array $ facetBuilders ) { $ facetSets = array_map ( function ( $ facetBuilder ) { return $ this -> facetBuilderVisitor -> visitBuilder ( $ facetBuilder , spl_object_hash ( $ facetBuilder ) ) ; } , $ facetBuilders ) ; $ facetParams = array ( ) ; foreach ( $ facetSets as $ facetSet ) { foreach ( $ facetSet as $ key => $ value ) { if ( isset ( $ facetParams [ $ key ] ) ) { if ( ! is_array ( $ facetParams [ $ key ] ) ) { $ facetParams [ $ key ] = array ( $ facetParams [ $ key ] ) ; } $ facetParams [ $ key ] [ ] = $ value ; } else { $ facetParams [ $ key ] = $ value ; } } } return $ facetParams ; }
5551	public function getMimeType ( ) { if ( is_integer ( $ this -> focus ) ) { return $ this -> frames [ $ this -> focus ] -> getMimeType ( ) ; } return $ this -> frameset -> getMimeType ( ) ; }
499	protected function writeInteger ( $ fileHandle , $ integer ) { return $ this -> writeBytes ( $ fileHandle , pack ( $ this -> useBigEndian ? 'N' : 'V' , ( int ) $ integer ) ) ; }
1571	public function getProcessId ( ) : ? string { if ( is_null ( $ this -> processId ) ) { return $ this -> parameter ( ResourceRegistrar :: PARAM_PROCESS_ID ) ; } return $ this -> processId ? : null ; }
1074	public function toArray ( $ debug = false ) { $ result = [ ] ; if ( ! empty ( $ this -> errors ) ) { $ errorsHandler = $ this -> errorsHandler ? : static function ( array $ errors , callable $ formatter ) { return array_map ( $ formatter , $ errors ) ; } ; $ result [ 'errors' ] = $ errorsHandler ( $ this -> errors , FormattedError :: prepareFormatter ( $ this -> errorFormatter , $ debug ) ) ; } if ( $ this -> data !== null ) { $ result [ 'data' ] = $ this -> data ; } if ( ! empty ( $ this -> extensions ) ) { $ result [ 'extensions' ] = $ this -> extensions ; } return $ result ; }
55	public function download ( PackageInterface $ package , $ targetDir , $ preferSource = null ) { $ preferSource = null !== $ preferSource ? $ preferSource : $ this -> preferSource ; $ sourceType = $ package -> getSourceType ( ) ; $ distType = $ package -> getDistType ( ) ; $ sources = array ( ) ; if ( $ sourceType ) { $ sources [ ] = 'source' ; } if ( $ distType ) { $ sources [ ] = 'dist' ; } if ( empty ( $ sources ) ) { throw new \ InvalidArgumentException ( 'Package ' . $ package . ' must have a source or dist specified' ) ; } if ( ! $ preferSource && ( $ this -> preferDist || 'dist' === $ this -> resolvePackageInstallPreference ( $ package ) ) ) { $ sources = array_reverse ( $ sources ) ; } $ this -> filesystem -> ensureDirectoryExists ( $ targetDir ) ; foreach ( $ sources as $ i => $ source ) { if ( isset ( $ e ) ) { $ this -> io -> writeError ( ' <warning>Now trying to download from ' . $ source . '</warning>' ) ; } $ package -> setInstallationSource ( $ source ) ; try { $ downloader = $ this -> getDownloaderForInstalledPackage ( $ package ) ; if ( $ downloader ) { $ downloader -> download ( $ package , $ targetDir ) ; } break ; } catch ( \ RuntimeException $ e ) { if ( $ i === count ( $ sources ) - 1 ) { throw $ e ; } $ this -> io -> writeError ( ' <warning>Failed to download ' . $ package -> getPrettyName ( ) . ' from ' . $ source . ': ' . $ e -> getMessage ( ) . '</warning>' ) ; } } }
8836	public function setMaxRetries ( $ retries ) { switch ( gettype ( $ retries ) ) { case 'integer' : $ this -> maxRetries = new Retries ( $ retries ) ; break ; case 'object' : $ this -> maxRetries = $ retries ; break ; default : throw new InvalidArgumentException ( 'Invalid type for max retries given.' ) ; break ; } }
5461	protected function acceptPageEnd ( ) { while ( count ( $ this -> open_forms ) ) { $ this -> complete_forms [ ] = array_pop ( $ this -> open_forms ) ; } foreach ( $ this -> left_over_labels as $ label ) { for ( $ i = 0 , $ count = count ( $ this -> complete_forms ) ; $ i < $ count ; $ i ++ ) { $ this -> complete_forms [ $ i ] -> attachLabelBySelector ( new SelectById ( $ label -> getFor ( ) ) , $ label -> getText ( ) ) ; } } $ this -> page -> setForms ( $ this -> complete_forms ) ; $ this -> page -> setFrames ( $ this -> loading_frames ) ; }
9174	private function hierarchyToFlatArray ( $ items ) { $ flatArray = [ ] ; foreach ( $ items as $ item ) { $ flatArray [ ] = $ item -> getId ( ) ; if ( $ items -> getChildren ( ) -> count ( ) > 0 ) { $ flatArray = array_merge ( $ flatArray , $ this -> hierarchyToFlatArray ( $ items -> getChildren ( ) ) ) ; } } return $ flatArray ; }
2276	public function getActivationDefault ( $ varValue ) { if ( ! trim ( $ varValue ) ) { $ varValue = ( \ is_array ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_module' ] [ 'emailText' ] ) ? $ GLOBALS [ 'TL_LANG' ] [ 'tl_module' ] [ 'emailText' ] [ 1 ] : $ GLOBALS [ 'TL_LANG' ] [ 'tl_module' ] [ 'emailText' ] ) ; } return $ varValue ; }
1647	public function calculateBearing ( Coordinate $ point1 , Coordinate $ point2 ) : float { $ lat1 = deg2rad ( $ point1 -> getLat ( ) ) ; $ lat2 = deg2rad ( $ point2 -> getLat ( ) ) ; $ lng1 = deg2rad ( $ point1 -> getLng ( ) ) ; $ lng2 = deg2rad ( $ point2 -> getLng ( ) ) ; $ y = sin ( $ lng2 - $ lng1 ) * cos ( $ lat2 ) ; $ x = cos ( $ lat1 ) * sin ( $ lat2 ) - sin ( $ lat1 ) * cos ( $ lat2 ) * cos ( $ lng2 - $ lng1 ) ; $ bearing = rad2deg ( atan2 ( $ y , $ x ) ) ; if ( $ bearing < 0 ) { $ bearing = fmod ( $ bearing + 360 , 360 ) ; } return $ bearing ; }
12112	public function getForeignDataModel ( $ key ) { $ config = $ this -> settings [ 'foreignPullParams' ] ; if ( ! isset ( $ config [ 'where' ] ) ) { $ config [ 'where' ] = [ ] ; } if ( ! empty ( $ config [ 'where' ] ) ) { $ config [ 'where' ] = [ 'and' , $ config [ 'where' ] , [ $ this -> foreignModel -> primaryKey ( ) => $ key ] ] ; } else { $ config [ 'where' ] [ $ this -> foreignModel -> primaryKey ( ) ] = $ key ; } return $ this -> foreignModel -> findOne ( $ config ) ; }
12491	public static function where ( $ field , $ operator , $ value , $ logical ) { if ( gettype ( $ field ) == "array" ) { throw new ClusterpointException ( "\"->where()\" function: passed field selector is not in valid format." , 9002 ) ; } if ( $ operator === null ) { return "{$logical} {$field} " ; } elseif ( $ value === null ) { $ value = $ operator ; $ operator = '==' ; } if ( $ field instanceof Key ) { $ field = self :: field ( "{$field}" ) ; } if ( ! ( $ value instanceof Raw ) ) { if ( is_string ( $ value ) ) { $ value = '"' . Client :: escape ( $ value ) . '"' ; } else { $ value = json_encode ( $ value ) ; } } return "{$logical} {$field}{$operator}{$value} " ; }
4596	public function getList ( ) : array { $ objects = $ this -> execute ( 'GET' , static :: RESOURCE_LIST ) ; $ list = [ ] ; foreach ( $ objects as $ name => $ object ) { $ model = static :: toModel ( $ object ) ; $ list [ ] = $ model ; } return $ list ; }
728	public static function off ( $ class , $ name , $ handler = null ) { $ class = ltrim ( $ class , '\\' ) ; if ( empty ( self :: $ _events [ $ name ] [ $ class ] ) && empty ( self :: $ _eventWildcards [ $ name ] [ $ class ] ) ) { return false ; } if ( $ handler === null ) { unset ( self :: $ _events [ $ name ] [ $ class ] ) ; unset ( self :: $ _eventWildcards [ $ name ] [ $ class ] ) ; return true ; } if ( isset ( self :: $ _events [ $ name ] [ $ class ] ) ) { $ removed = false ; foreach ( self :: $ _events [ $ name ] [ $ class ] as $ i => $ event ) { if ( $ event [ 0 ] === $ handler ) { unset ( self :: $ _events [ $ name ] [ $ class ] [ $ i ] ) ; $ removed = true ; } } if ( $ removed ) { self :: $ _events [ $ name ] [ $ class ] = array_values ( self :: $ _events [ $ name ] [ $ class ] ) ; return $ removed ; } } $ removed = false ; if ( isset ( self :: $ _eventWildcards [ $ name ] [ $ class ] ) ) { foreach ( self :: $ _eventWildcards [ $ name ] [ $ class ] as $ i => $ event ) { if ( $ event [ 0 ] === $ handler ) { unset ( self :: $ _eventWildcards [ $ name ] [ $ class ] [ $ i ] ) ; $ removed = true ; } } if ( $ removed ) { self :: $ _eventWildcards [ $ name ] [ $ class ] = array_values ( self :: $ _eventWildcards [ $ name ] [ $ class ] ) ; if ( empty ( self :: $ _eventWildcards [ $ name ] [ $ class ] ) ) { unset ( self :: $ _eventWildcards [ $ name ] [ $ class ] ) ; if ( empty ( self :: $ _eventWildcards [ $ name ] ) ) { unset ( self :: $ _eventWildcards [ $ name ] ) ; } } } } return $ removed ; }
10823	public static function ask ( $ question , $ defaultValue = null , $ secret = false ) { $ value = '' ; while ( trim ( $ value ) == '' ) { self :: writeln ( '' ) ; self :: write ( ' ' . $ question , 'info' ) ; if ( $ defaultValue !== null ) { self :: write ( ' [' ) ; self :: write ( $ defaultValue , 'comment' ) ; self :: write ( ']' ) ; } self :: writeln ( ':' ) ; if ( $ secret ) { self :: write ( ' > ' ) ; if ( self :: $ testValue === null ) { system ( 'stty -echo' ) ; $ value = trim ( fgets ( STDIN ) ) ; system ( 'stty echo' ) ; } else { $ value = self :: $ testValue ; } } else { if ( self :: $ testValue === null ) { $ value = readline ( ' > ' ) ; } else { $ value = self :: $ testValue ; } } if ( trim ( $ value ) == '' ) { $ value = $ defaultValue ; } if ( trim ( $ value ) == '' ) { self :: writeln ( '' ) ; self :: block ( '[ERROR] A value is required' , 'error' ) ; } self :: writeln ( '' ) ; } return trim ( $ value ) ; }
3123	protected function computeRange ( $ range ) { if ( count ( $ range ) % 2 ) { throw new IncompleteRangeException ( ) ; } $ duration = 0 ; $ start = null ; $ end = null ; foreach ( $ range as $ point ) { if ( $ this -> isStartPoint ( $ point ) ) { if ( $ start ) { throw new MalformedRangeException ( 'A time range must be defined by a START and a END TimePoint! Twice START found.' ) ; } $ start = $ point ; } if ( $ this -> isEndPoint ( $ point ) ) { if ( $ end ) { throw new MalformedRangeException ( 'A time range must be defined by a START and a END TimePoint! Twice END found.' ) ; } $ end = $ point ; } if ( $ start && $ end ) { $ duration += $ this -> getRangeDuration ( $ start , $ end ) ; $ start = null ; $ end = null ; } } return $ duration ; }
92	protected static function validateSyntax ( $ json , $ file = null ) { $ parser = new JsonParser ( ) ; $ result = $ parser -> lint ( $ json ) ; if ( null === $ result ) { if ( defined ( 'JSON_ERROR_UTF8' ) && JSON_ERROR_UTF8 === json_last_error ( ) ) { throw new \ UnexpectedValueException ( '"' . $ file . '" is not UTF-8, could not parse as JSON' ) ; } return true ; } throw new ParsingException ( '"' . $ file . '" does not contain valid JSON' . "\n" . $ result -> getMessage ( ) , $ result -> getDetails ( ) ) ; }
2522	protected function callMessage ( $ messageName , $ options , $ messageOptions , $ endSession = false ) { $ messageOptions = $ this -> makeMessageOptions ( $ messageOptions , $ endSession ) ; $ this -> lastMessage = $ messageName ; $ sendResult = $ this -> sessionHandler -> sendMessage ( $ messageName , $ this -> requestCreator -> createRequest ( $ messageName , $ options ) , $ messageOptions ) ; $ response = $ this -> responseHandler -> analyzeResponse ( $ sendResult , $ messageName ) ; if ( $ messageOptions [ 'returnXml' ] === false ) { $ response -> responseXml = null ; } return $ response ; }
1981	public static function reset ( ) { $ session = System :: getContainer ( ) -> get ( 'session' ) ; if ( ! $ session -> isStarted ( ) ) { return ; } $ session -> getFlashBag ( ) -> clear ( ) ; }
6637	protected function initParams ( ) { Yii :: $ app -> view -> params [ 'h1' ] = Yii :: t ( 'wavecms/main' , '<i>Not set</i>' ) ; Yii :: $ app -> view -> params [ 'buttons_top' ] = [ ] ; Yii :: $ app -> view -> params [ 'buttons_btm' ] = [ ] ; Yii :: $ app -> view -> params [ 'buttons_sublist' ] = [ ] ; }
3001	public function setHTML ( $ message ) { $ f3 = \ Base :: instance ( ) ; $ tmpl = new \ Template ( ) ; if ( $ f3 -> exists ( 'mailer.jumplinks' , $ jumplink ) && $ jumplink ) $ tmpl -> extend ( 'a' , function ( $ node ) use ( $ f3 , $ tmpl ) { if ( isset ( $ node [ '@attrib' ] ) ) { $ attr = $ node [ '@attrib' ] ; unset ( $ node [ '@attrib' ] ) ; } else $ attr = array ( ) ; if ( isset ( $ attr [ 'href' ] ) ) { if ( ! $ f3 -> exists ( 'mailer.jump_route' , $ ping_route ) ) $ ping_route = '/mailer-jump' ; $ attr [ 'href' ] = $ f3 -> get ( 'SCHEME' ) . '://' . $ f3 -> get ( 'HOST' ) . $ f3 -> get ( 'BASE' ) . $ ping_route . '?target=' . urlencode ( $ attr [ 'href' ] ) ; } $ params = '' ; foreach ( $ attr as $ key => $ value ) $ params .= ' ' . $ key . '="' . $ value . '"' ; return '<a' . $ params . '>' . $ tmpl -> build ( $ node ) . '</a>' ; } ) ; $ message = $ tmpl -> build ( $ tmpl -> parse ( $ message ) ) ; $ this -> setContent ( $ message , 'text/html' ) ; }
6839	public function get ( $ key ) { if ( isset ( $ this -> objects [ $ key ] ) ) { return $ this -> objects [ $ key ] ; } throw new InjectorException ( "obj $key not found" ) ; }
12175	public function addOptionalScalarArgument ( $ name , $ type , $ default ) { return $ this -> addArgument ( new ScalarArgument ( $ this -> argumentPosition ++ , $ name , $ type , false , $ default ) ) ; }
12671	public static function getEmulatorInstance ( $ scheme , $ path , $ context ) { if ( ! isset ( static :: $ emulators [ $ scheme ] ) ) { throw new \ InvalidArgumentException ( 'No emulator found for scheme \'' . $ scheme . '\'' ) ; } $ emulator = static :: $ emulators [ $ scheme ] ; return new $ emulator ( $ path , $ context ) ; }
11166	protected function buildHeader ( ) { if ( $ this -> getExtNamespace ( ) === null ) { throw new ExtDirectException ( "Ext js Namespace not set" ) ; } $ var = 'Ext.ns("' . $ this -> getNameSpace ( ) . '"); ' . $ this -> getNameSpace ( ) . "." . Keys :: EXT_HEADER . ' = ' ; return $ var ; }
4696	public static function getToken ( $ token_name = self :: TOKEN_NAME ) { if ( empty ( $ _SESSION [ $ token_name ] ) ) { static :: generateToken ( $ token_name ) ; } return $ _SESSION [ $ token_name ] ; }
5084	protected function validateUserInput ( $ aData , $ oItem = null ) { $ aOut = [ ] ; $ aFields = $ this -> oModel -> describeFields ( ) ; $ aKeys = array_unique ( array_merge ( array_keys ( $ aFields ) , arrayExtractProperty ( $ this -> oModel -> getExpandableFields ( ) , 'trigger' ) ) ) ; $ aValidKeys = array_diff ( $ aKeys , static :: IGNORE_FIELDS_WRITE ) ; foreach ( $ aValidKeys as $ sValidKey ) { $ oField = getFromArray ( $ sValidKey , $ aFields ) ; if ( array_key_exists ( $ sValidKey , $ aData ) ) { $ aOut [ $ sValidKey ] = getFromArray ( $ sValidKey , $ aData ) ; } } return $ aOut ; }
4595	public function getPermissions ( User $ user ) { $ permissions = new ArrayCollection ; $ accesses = $ this -> repository -> findBy ( [ 'assignee' => $ user -> getIdentity ( ) -> getType ( ) , 'assigneeUuid' => null ] ) ; foreach ( $ accesses as $ access ) { foreach ( $ access -> getPermissions ( ) as $ permission ) { $ permissions -> add ( $ permission ) ; } } $ accesses = $ this -> repository -> findBy ( [ 'assignee' => $ user -> getIdentity ( ) -> getType ( ) , 'assigneeUuid' => $ user -> getIdentity ( ) -> getUuid ( ) ] ) ; foreach ( $ accesses as $ access ) { foreach ( $ access -> getPermissions ( ) as $ permission ) { $ permissions -> add ( $ permission ) ; } } $ accesses = $ this -> repository -> findBy ( [ 'assignee' => 'Role' , 'assigneeUuid' => $ user -> getIdentity ( ) -> getRoles ( ) ] ) ; foreach ( $ accesses as $ access ) { foreach ( $ access -> getPermissions ( ) as $ permission ) { $ permissions -> add ( $ permission ) ; } } return $ permissions ; }
3777	protected function getParamName ( ) { if ( $ this -> get ( 'urlparam' ) ) { return $ this -> get ( 'urlparam' ) ; } $ objAttribute = $ this -> getFilteredAttribute ( ) ; if ( $ objAttribute ) { return $ objAttribute -> getColName ( ) ; } return null ; }
957	public function remainingTrialDays ( ) { if ( ! $ this -> isTrial ( ) ) { return ; } return $ this -> isActiveTrial ( ) ? Carbon :: today ( ) -> diffInDays ( $ this -> trial_ends_on ) : 0 ; }
9545	public function create ( $ table , array $ fields , $ tokenize = 'porter' ) { $ fields = implode ( ', ' , $ fields ) ; $ query = "CREATE VIRTUAL TABLE {$table} USING fts4({$fields}, tokenize={$tokenize})" ; $ executed = $ this -> db -> info ( 'tables' , $ table ) ; if ( $ query == $ executed ) { return false ; } if ( ! is_null ( $ executed ) ) { $ this -> db -> exec ( 'DROP TABLE ' . $ table ) ; } $ this -> db -> exec ( $ query ) ; $ this -> db -> info ( 'tables' , $ table , $ query ) ; return true ; }
10089	function addAttachmentFromBase64Data ( $ filename , $ mimetype , $ contents ) { $ attachment = new Attachment ( $ filename , $ mimetype , $ contents ) ; $ this -> attachments [ ] = $ attachment ; }
11459	public function attachFile ( string $ sFileName , string $ sContent , string $ sType ) : bool { $ this -> _aAttachments [ ] = array ( "name" => $ sFileName , "content" => $ sContent , "type" => $ sType ) ; return true ; }
10355	public function incrementAttempts ( ) { $ this -> cache -> add ( $ this -> key , 0 , $ this -> getExpiry ( ) ) ; $ this -> cache -> increment ( $ this -> key ) ; }
1463	private function guessColumn ( ) { if ( $ this -> query instanceof EloquentBuilder || $ this -> query instanceof Relation ) { return $ this -> query -> getModel ( ) -> getCreatedAtColumn ( ) ; } return Model :: CREATED_AT ; }
2098	public static function formatToJs ( $ strFormat ) { $ chunks = str_split ( $ strFormat ) ; foreach ( $ chunks as $ k => $ v ) { switch ( $ v ) { case 'D' : $ chunks [ $ k ] = 'a' ; break ; case 'j' : $ chunks [ $ k ] = 'e' ; break ; case 'l' : $ chunks [ $ k ] = 'A' ; break ; case 'S' : $ chunks [ $ k ] = 'o' ; break ; case 'F' : $ chunks [ $ k ] = 'B' ; break ; case 'M' : $ chunks [ $ k ] = 'b' ; break ; case 'a' : $ chunks [ $ k ] = 'p' ; break ; case 'A' : $ chunks [ $ k ] = 'p' ; break ; case 'g' : $ chunks [ $ k ] = 'l' ; break ; case 'G' : $ chunks [ $ k ] = 'k' ; break ; case 'h' : $ chunks [ $ k ] = 'I' ; break ; case 'i' : $ chunks [ $ k ] = 'M' ; break ; case 's' : $ chunks [ $ k ] = 'S' ; break ; case 'U' : $ chunks [ $ k ] = 's' ; break ; } } return preg_replace ( '/([a-zA-Z])/' , '%$1' , implode ( '' , $ chunks ) ) ; }
2147	protected function sendNewsletter ( Email $ objEmail , Result $ objNewsletter , $ arrRecipient , $ text , $ html , $ css = null ) { $ objEmail -> text = StringUtil :: parseSimpleTokens ( $ text , $ arrRecipient ) ; if ( ! $ objNewsletter -> sendText ) { if ( $ objNewsletter -> template == '' ) { $ objNewsletter -> template = 'mail_default' ; } $ objTemplate = new BackendTemplate ( $ objNewsletter -> template ) ; $ objTemplate -> setData ( $ objNewsletter -> row ( ) ) ; $ objTemplate -> title = $ objNewsletter -> subject ; $ objTemplate -> body = StringUtil :: parseSimpleTokens ( $ html , $ arrRecipient ) ; $ objTemplate -> charset = Config :: get ( 'characterSet' ) ; $ objTemplate -> recipient = $ arrRecipient [ 'email' ] ; $ objTemplate -> css = $ css ; $ objEmail -> html = $ objTemplate -> parse ( ) ; $ objEmail -> imageDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) . '/' ; } try { $ objEmail -> sendTo ( $ arrRecipient [ 'email' ] ) ; } catch ( \ Swift_RfcComplianceException $ e ) { $ _SESSION [ 'REJECTED_RECIPIENTS' ] [ ] = $ arrRecipient [ 'email' ] ; } if ( $ objEmail -> hasFailures ( ) ) { $ _SESSION [ 'REJECTED_RECIPIENTS' ] [ ] = $ arrRecipient [ 'email' ] ; } if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sendNewsletter' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sendNewsletter' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sendNewsletter' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ objEmail , $ objNewsletter , $ arrRecipient , $ text , $ html ) ; } } }
5429	public function getParent ( ) { $ reflection = new ReflectionClass ( $ this -> interface ) ; $ parent = $ reflection -> getParentClass ( ) ; if ( $ parent ) { return $ parent -> getName ( ) ; } return false ; }
8116	public function canBeReviewedBy ( Member $ member = null ) { if ( ! $ this -> owner -> obj ( "NextReviewDate" ) -> exists ( ) ) { return false ; } if ( $ this -> owner -> obj ( "NextReviewDate" ) -> InFuture ( ) ) { return false ; } $ options = $ this -> getOptions ( ) ; if ( ! $ options ) { return false ; } if ( ! $ options || ( ! $ options -> hasExtension ( __CLASS__ ) && ! $ options -> hasExtension ( ContentReviewDefaultSettings :: class ) ) ) { return false ; } if ( $ options -> OwnerGroups ( ) -> count ( ) == 0 && $ options -> OwnerUsers ( ) -> count ( ) == 0 ) { return false ; } if ( ! $ member ) { return true ; } if ( $ member -> inGroups ( $ options -> OwnerGroups ( ) ) ) { return true ; } if ( $ options -> OwnerUsers ( ) -> find ( "ID" , $ member -> ID ) ) { return true ; } return false ; }
7597	public function render ( $ sFontAwesome , array $ aFontAwesomeAttributes = null ) { if ( ! is_scalar ( $ sFontAwesome ) ) { throw new \ InvalidArgumentException ( sprintf ( 'FontAwesome expects a scalar value, "%s" given' , gettype ( $ sFontAwesome ) ) ) ; } if ( empty ( $ aFontAwesomeAttributes ) ) { $ aFontAwesomeAttributes = array ( 'class' => 'fa' ) ; } else { if ( empty ( $ aFontAwesomeAttributes [ 'class' ] ) ) { $ aFontAwesomeAttributes [ 'class' ] = 'fa' ; } elseif ( ! preg_match ( '/(\s|^)fa(\s|$)/' , $ aFontAwesomeAttributes [ 'class' ] ) ) { $ aFontAwesomeAttributes [ 'class' ] .= ' fa' ; } } if ( strpos ( 'fa-' , $ sFontAwesome ) !== 0 ) { $ sFontAwesome = 'fa-' . $ sFontAwesome ; } if ( ! preg_match ( '/(\s|^)' . preg_quote ( $ sFontAwesome , '/' ) . '(\s|$)/' , $ aFontAwesomeAttributes [ 'class' ] ) ) { $ aFontAwesomeAttributes [ 'class' ] .= ' ' . $ sFontAwesome ; } return sprintf ( static :: $ faFormat , $ this -> createAttributesString ( $ aFontAwesomeAttributes ) ) ; }
8236	protected function checkServerConfiguration ( ) { $ pico = $ this -> picoAuth -> getPico ( ) ; $ configDir = $ pico -> getBaseUrl ( ) . basename ( $ pico -> getConfigDir ( ) ) ; $ configFile = $ configDir . "/config.yml" ; $ contentDir = $ pico -> getBaseUrl ( ) . basename ( $ pico -> getConfig ( 'content_dir' ) ) ; $ indexFile = $ contentDir . "/index" . $ pico -> getConfig ( 'content_ext' ) ; $ urls = array ( 'dir_listing' => $ configDir , 'config_file' => $ configFile , 'content_file' => $ indexFile ) ; $ this -> httpsTest ( ) ; $ this -> webRootDirsTest ( ) ; $ this -> picoAuth -> addOutput ( "installer_urltest" , $ urls ) ; }
7651	public function rename ( $ path_from , $ path_to ) { if ( $ this -> getContainerName ( $ path_from ) != $ this -> getContainerName ( $ path_to ) ) { throw new BlobException ( 'Container name can not be changed.' ) ; } if ( $ this -> getFileName ( $ path_from ) == $ this -> getContainerName ( $ path_to ) ) { return true ; } $ this -> getStorageClient ( $ path_from ) -> copyBlob ( $ this -> getContainerName ( $ path_from ) , $ this -> getFileName ( $ path_from ) , $ this -> getContainerName ( $ path_to ) , $ this -> getFileName ( $ path_to ) ) ; $ this -> getStorageClient ( $ path_from ) -> deleteBlob ( $ this -> getContainerName ( $ path_from ) , $ this -> getFileName ( $ path_from ) ) ; clearstatcache ( true , $ path_from ) ; clearstatcache ( true , $ path_to ) ; return true ; }
6165	public function setOptions ( $ options ) { if ( is_array ( $ options ) ) { $ this -> options = $ options ; return $ this ; } $ this -> options = json_decode ( $ options , true ) ; if ( null === $ this -> options ) { $ this -> options = $ options ; } return $ this ; }
11887	public function getUser ( $ owner = true ) { if ( $ owner && $ this -> owner -> getBehavior ( 'Ownable' ) !== null && isset ( $ this -> owner -> objectOwner ) ) { return $ this -> owner -> objectOwner ; } elseif ( isset ( Yii :: $ app -> user ) && isset ( Yii :: $ app -> user -> identity -> primaryKey ) ) { return Yii :: $ app -> user -> identity ; } return false ; }
11736	public function setAddress ( $ address ) { $ address = trim ( $ address , self :: SEPARATOR ) ; if ( ! filter_var ( $ address , FILTER_VALIDATE_URL ) ) { throw new \ InvalidArgumentException ( "$address is not valid format of url address." ) ; } $ this -> address = $ address ; $ this -> parse = parse_url ( $ address ) ; return $ this ; }
9321	protected function compileMarkdownEchos ( $ value ) { $ pattern = sprintf ( '/(@)?%s\s*(.+?)\s*%s(\r?\n)?/s' , $ this -> markdownTags [ 0 ] , $ this -> markdownTags [ 1 ] ) ; $ callback = function ( $ matches ) { $ wrapper = sprintf ( $ this -> markdownFormat , $ this -> compileEchoDefaults ( $ matches [ 2 ] ) ) ; return $ matches [ 1 ] ? strlen ( stripcslashes ( $ this -> markdownTags [ 0 ] ) ) > 2 ? $ matches [ 0 ] : substr ( $ matches [ 0 ] , 1 ) : '<?php echo ' . $ wrapper . '; ?>' ; } ; return preg_replace_callback ( $ pattern , $ callback , $ value ) ; }
11585	public function setSpoolDirectory ( $ dir ) { if ( ! DirectoryHelper :: ensureExists ( $ dir ) ) { throw new \ Exception ( sprintf ( 'Can not create emails spooling directory "%s"!' , $ dir ) ) ; } $ this -> spool_dir = $ dir ; return $ this ; }
6504	public function serializeParameters ( $ type , array $ parameters ) { $ jobType = $ this -> registry -> get ( $ type ) ; $ indices = $ jobType -> getIndicesOfSerializableParameters ( ) ; if ( count ( $ indices ) < count ( $ parameters ) ) { throw new \ InvalidArgumentException ( sprintf ( 'More parameters provided for serialization than defined for job "%s"' , $ type ) ) ; } $ i = 0 ; $ serializedParameters = array ( ) ; foreach ( $ parameters as $ parameter ) { if ( null == $ parameter ) { $ serializedParameters [ ] = null ; } else { $ serializedParameters [ ] = $ this -> serializer -> serialize ( $ parameter , 'json' , $ this -> getParamSerializationContext ( $ jobType , $ indices [ $ i ] ) ) ; } $ i ++ ; } $ data = json_encode ( $ serializedParameters ) ; if ( false === $ data ) { throw new \ RuntimeException ( sprintf ( 'Serialization failed with error "%s"' , json_last_error_msg ( ) ) ) ; } return $ data ; }
11687	public function getAccompanyingPeriodsOrdered ( ) { $ periods = $ this -> getAccompanyingPeriods ( ) -> toArray ( ) ; usort ( $ periods , function ( $ a , $ b ) { $ dateA = $ a -> getOpeningDate ( ) ; $ dateB = $ b -> getOpeningDate ( ) ; if ( $ dateA == $ dateB ) { $ dateEA = $ a -> getClosingDate ( ) ; $ dateEB = $ b -> getClosingDate ( ) ; if ( $ dateEA == $ dateEB ) { return 0 ; } if ( $ dateEA < $ dateEB ) { return - 1 ; } else { return + 1 ; } } if ( $ dateA < $ dateB ) { return - 1 ; } else { return 1 ; } } ) ; return $ periods ; }
6425	public function getLoginStartUrl ( $ redirecturl ) { $ client = $ this -> getClient ( $ redirecturl ) ; $ authUrl = $ client -> createAuthUrl ( ) ; return $ authUrl ; }
1830	public function refresh ( ) { $ intPk = $ this -> { static :: $ strPk } ; if ( isset ( $ this -> arrModified [ static :: $ strPk ] ) ) { $ intPk = $ this -> arrModified [ static :: $ strPk ] ; } $ res = Database :: getInstance ( ) -> prepare ( "SELECT * FROM " . static :: $ strTable . " WHERE " . Database :: quoteIdentifier ( static :: $ strPk ) . "=?" ) -> execute ( $ intPk ) ; $ this -> setRow ( $ res -> row ( ) ) ; }
9869	private function writePageMargins ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { $ objWriter -> startElement ( 'pageMargins' ) ; $ objWriter -> writeAttribute ( 'left' , StringHelper :: formatNumber ( $ pSheet -> getPageMargins ( ) -> getLeft ( ) ) ) ; $ objWriter -> writeAttribute ( 'right' , StringHelper :: formatNumber ( $ pSheet -> getPageMargins ( ) -> getRight ( ) ) ) ; $ objWriter -> writeAttribute ( 'top' , StringHelper :: formatNumber ( $ pSheet -> getPageMargins ( ) -> getTop ( ) ) ) ; $ objWriter -> writeAttribute ( 'bottom' , StringHelper :: formatNumber ( $ pSheet -> getPageMargins ( ) -> getBottom ( ) ) ) ; $ objWriter -> writeAttribute ( 'header' , StringHelper :: formatNumber ( $ pSheet -> getPageMargins ( ) -> getHeader ( ) ) ) ; $ objWriter -> writeAttribute ( 'footer' , StringHelper :: formatNumber ( $ pSheet -> getPageMargins ( ) -> getFooter ( ) ) ) ; $ objWriter -> endElement ( ) ; }
8071	public function retrieveByCredentials ( array $ credentials ) { $ username = $ credentials [ 'username' ] ; $ result = $ this -> ldap -> find ( $ username ) ; if ( ! is_null ( $ result ) ) { $ user = new $ this -> model ; $ user -> build ( $ result ) ; return $ user ; } return null ; }
11000	public function selectLocaleFromAcceptHeader ( Accept $ header ) { $ my_locales = [ ] ; foreach ( $ this -> locales as $ supported_locale ) { $ list = $ supported_locale -> getFallbackList ( ) ; foreach ( $ list as $ locale ) $ my_locales [ $ locale -> getLocale ( ) ] = $ supported_locale -> getLocale ( ) ; } $ best = $ header -> getBestResponseType ( array_keys ( $ my_locales ) ) ; return empty ( $ best ) ? null : ( $ my_locales [ $ best ] ?? null ) ; }
4109	public function toOptionArray ( ) { $ options = array ( ) ; $ options [ ] = array ( 'value' => 'aoe_templatehints/renderer_comment' , 'label' => Mage :: helper ( 'aoe_templatehints' ) -> __ ( 'Comments' ) ) ; $ options [ ] = array ( 'value' => 'aoe_templatehints/renderer_opentip' , 'label' => Mage :: helper ( 'aoe_templatehints' ) -> __ ( 'Popups' ) ) ; $ options [ ] = array ( 'value' => 'aoe_templatehints/renderer_tipOnly' , 'label' => Mage :: helper ( 'aoe_templatehints' ) -> __ ( 'Popups (border initially invisible)' ) ) ; Mage :: dispatchEvent ( 'aoetemplatehints_hintrenderer_options' , array ( 'options' => & $ options ) ) ; return $ options ; }
7298	public function append_signature ( $ message , $ signature = '' ) { if ( empty ( $ signature ) ) { return $ message ; } $ separator = apply_filters ( 'iac_signature_separator' , str_repeat ( PHP_EOL , 2 ) . '--' . PHP_EOL ) ; return $ message . $ separator . $ signature ; }
7732	public function denormalize ( $ data , $ class , $ format = null , array $ context = array ( ) ) { $ value = $ data ; if ( is_array ( $ data ) ) { if ( ! isset ( $ data [ '@value' ] ) || ! isset ( $ data [ '@type' ] ) ) { throw new RuntimeException ( "Cannot denormalize the data as it isn't a valid JSON-LD typed value: " . var_export ( $ data , true ) ) ; } if ( self :: XSD_DATETIME_IRI !== $ data [ '@type' ] ) { throw new RuntimeException ( "Cannot denormalize the data as it isn't a XSD dateTime value: " . var_export ( $ data , true ) ) ; } $ value = $ data [ '@value' ] ; } elseif ( ! is_string ( $ data ) ) { throw new RuntimeException ( "Cannot denormalize the data into a DateTime object: " . var_export ( $ data , true ) ) ; } try { $ date = new \ DateTime ( $ value ) ; return $ date ; } catch ( Exception $ e ) { throw new RuntimeException ( "Cannot denormalize the data as the value is invalid: " . var_export ( $ data , true ) , 0 , $ e ) ; } }
904	public function isUnarySuccessorOperator ( $ index ) { static $ allowedPrevToken = [ ']' , [ T_STRING ] , [ T_VARIABLE ] , [ CT :: T_DYNAMIC_PROP_BRACE_CLOSE ] , [ CT :: T_DYNAMIC_VAR_BRACE_CLOSE ] , ] ; $ tokens = $ this -> tokens ; $ token = $ tokens [ $ index ] ; if ( ! $ token -> isGivenKind ( [ T_INC , T_DEC ] ) ) { return false ; } $ prevToken = $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] ; return $ prevToken -> equalsAny ( $ allowedPrevToken ) ; }
8082	public function report ( $ message ) { $ channel = $ this -> currentChannel ; if ( $ message ) { $ reports = & $ this -> getReports ( $ channel ) ; $ reports [ ] = $ message ; } return $ this ; }
4670	protected function afterGeneration ( ) { $ this -> mapTemplate -> writeToFile ( ) ; $ this -> autoloadMap -> writeToFile ( ) ; $ responseParserTemplate = new ResponseParserTemplate ( $ this -> config ) ; $ this -> autoloadMap -> addEntry ( $ responseParserTemplate -> getClassName ( ) , $ responseParserTemplate -> getClassPath ( ) ) ; $ responseParserTemplate -> writeToFile ( ) ; }
677	public function getLinks ( $ absolute = false ) { $ currentPage = $ this -> getPage ( ) ; $ pageCount = $ this -> getPageCount ( ) ; $ links = [ Link :: REL_SELF => $ this -> createUrl ( $ currentPage , null , $ absolute ) , ] ; if ( $ currentPage > 0 ) { $ links [ self :: LINK_FIRST ] = $ this -> createUrl ( 0 , null , $ absolute ) ; $ links [ self :: LINK_PREV ] = $ this -> createUrl ( $ currentPage - 1 , null , $ absolute ) ; } if ( $ currentPage < $ pageCount - 1 ) { $ links [ self :: LINK_NEXT ] = $ this -> createUrl ( $ currentPage + 1 , null , $ absolute ) ; $ links [ self :: LINK_LAST ] = $ this -> createUrl ( $ pageCount - 1 , null , $ absolute ) ; } return $ links ; }
4522	public function postLoad ( LifecycleEventArgs $ args ) { $ entity = $ args -> getEntity ( ) ; if ( ! $ entity instanceof Config ) { return ; } $ key = $ entity -> getKey ( ) ; $ encrypt = $ this -> configCollection -> get ( $ key ) [ 'encrypt' ] ; $ entity -> setEncrypt ( $ encrypt ) ; }
10645	public function bindInstance ( object $ object ) : Binding { return $ this -> bind ( \ get_class ( $ object ) ) -> instance ( $ object ) ; }
5101	public function valuesExp ( $ expression , $ bind = false ) { return $ this -> appendPart ( CmdInsert :: PART_VALUES , $ expression , $ bind ) ; }
12661	public function createAuthorizerApplication ( $ appId , $ refreshToken ) { $ this -> fetch ( 'authorizer' , function ( $ authorizer ) use ( $ appId , $ refreshToken ) { $ authorizer -> setAppId ( $ appId ) ; $ authorizer -> setRefreshToken ( $ refreshToken ) ; } ) ; return $ this -> fetch ( 'app' , function ( $ app ) { $ app [ 'access_token' ] = $ this -> fetch ( 'authorizer_access_token' ) ; $ app [ 'oauth' ] = $ this -> fetch ( 'oauth' ) ; $ app [ 'server' ] = $ this -> fetch ( 'server' ) ; } ) ; }
9079	private static function parseUri ( Request & $ request , $ uri , $ defaultController , $ defaultAction ) { $ contextUri = $ uri ; if ( null != $ request -> getContextPrefix ( ) && '/' != $ request -> getContextPrefix ( ) ) { $ contextUri = str_replace ( $ request -> getContextPrefix ( ) , '' , $ uri ) ; } $ parts = array ( ) ; if ( $ contextUri != '' ) { while ( isset ( $ contextUri [ 0 ] ) && $ contextUri [ 0 ] == '/' ) { $ contextUri = substr ( $ contextUri , 1 ) ; } $ parts = explode ( '/' , $ contextUri ) ; } if ( count ( $ parts ) > 0 ) { $ request -> setController ( ucfirst ( trim ( $ parts [ 0 ] ) ) ) ; array_shift ( $ parts ) ; if ( ! $ request -> getController ( ) ) { $ request -> setController ( $ defaultController ) ; } } if ( count ( $ parts ) > 0 ) { $ request -> setAction ( trim ( $ parts [ 0 ] ) ) ; array_shift ( $ parts ) ; if ( ! $ request -> getAction ( ) ) { $ request -> setAction ( $ defaultAction ) ; } } return $ parts ; }
3385	private function getRole ( $ identity = null ) { if ( is_object ( $ identity ) ) { return $ identity -> getRole ( ) ; } if ( is_array ( $ identity ) && isset ( $ identity [ 'role' ] ) ) { return $ identity [ 'role' ] ; } return 'guest' ; }
6961	public static function J ( $ year ) { $ jd = static :: J2000 ( ) -> jd + ( $ year - 2000 ) * static :: DaysJulianYear ; $ epoch = new static ( $ jd ) ; $ epoch -> type = YearType :: Julian ( ) ; return $ epoch ; }
6278	protected function find ( $ key ) { $ keyLen = strlen ( $ key ) ; $ u = Util :: hash ( $ key ) ; $ upos = ( $ u << 3 ) & 2047 ; $ hashSlots = $ this -> readInt31 ( $ upos + 4 ) ; if ( ! $ hashSlots ) { return false ; } $ hashPos = $ this -> readInt31 ( $ upos ) ; $ keyHash = $ u ; $ u = Util :: unsignedShiftRight ( $ u , 8 ) ; $ u = Util :: unsignedMod ( $ u , $ hashSlots ) ; $ u <<= 3 ; $ keyPos = $ hashPos + $ u ; for ( $ i = 0 ; $ i < $ hashSlots ; $ i ++ ) { $ hash = $ this -> readInt32 ( $ keyPos ) ; $ pos = $ this -> readInt31 ( $ keyPos + 4 ) ; if ( ! $ pos ) { return false ; } $ keyPos += 8 ; if ( $ keyPos == $ hashPos + ( $ hashSlots << 3 ) ) { $ keyPos = $ hashPos ; } if ( $ hash === $ keyHash ) { if ( $ keyLen === $ this -> readInt31 ( $ pos ) ) { $ dataLen = $ this -> readInt31 ( $ pos + 4 ) ; $ dataPos = $ pos + 8 + $ keyLen ; $ foundKey = $ this -> read ( $ pos + 8 , $ keyLen ) ; if ( $ foundKey === $ key ) { $ this -> dataLen = $ dataLen ; $ this -> dataPos = $ dataPos ; return true ; } } } } return false ; }
7350	protected function initializePaymentSubject ( ) { $ this -> depositTotal = 0 ; $ this -> grandTotal = 0 ; $ this -> paidTotal = 0 ; $ this -> pendingTotal = 0 ; $ this -> outstandingAccepted = 0 ; $ this -> outstandingExpired = 0 ; $ this -> outstandingLimit = 0 ; $ this -> paymentState = PaymentStates :: STATE_NEW ; $ this -> payments = new ArrayCollection ( ) ; }
3851	public function setLimit ( $ blnUse , $ intOffset , $ intLimit ) { $ this -> paginationLimitCalculator -> setApplyLimitAndOffset ( $ blnUse ) -> setOffset ( $ intOffset ) -> setLimit ( $ intLimit ) ; return $ this ; }
10721	public function getLabel ( ) { $ label = $ this -> label ; $ title = $ this -> title ; if ( $ label ) { return $ label ; } else { return $ title ; } }
11625	public function processContent ( Operation $ operation , $ data ) { if ( is_array ( $ data ) ) { $ status = $ this -> contentService -> getSocialMediaScheduleByOperation ( $ operation ) ; if ( ! $ data [ 'locations' ] instanceof ArrayCollection ) { $ locations = $ this -> em -> getRepository ( 'CampaignChainCoreBundle:Location' ) -> findById ( array_values ( $ data [ 'locations' ] ) ) ; $ locations = new ArrayCollection ( $ locations ) ; } else { $ locations = $ data [ 'locations' ] ; } $ status -> setLocations ( $ locations ) ; $ status -> setMessage ( $ data [ 'message' ] ) ; } else { $ status = $ data ; } return $ status ; }
2206	public function generate ( ) { if ( TL_MODE == 'BE' ) { $ objTemplate = new BackendTemplate ( 'be_wildcard' ) ; $ objTemplate -> wildcard = '### ' . Utf8 :: strtoupper ( $ GLOBALS [ 'TL_LANG' ] [ 'FMD' ] [ 'logout' ] [ 0 ] ) . ' ###' ; $ objTemplate -> title = $ this -> headline ; $ objTemplate -> id = $ this -> id ; $ objTemplate -> link = $ this -> name ; $ objTemplate -> href = 'contao/main.php?do=themes&amp;table=tl_module&amp;act=edit&amp;id=' . $ this -> id ; return $ objTemplate -> parse ( ) ; } if ( $ this -> redirectBack ) { $ _SESSION [ 'LAST_PAGE_VISITED' ] = $ this -> getReferer ( ) ; } $ strLogoutUrl = System :: getContainer ( ) -> get ( 'security.logout_url_generator' ) -> getLogoutUrl ( ) ; $ strRedirect = Environment :: get ( 'base' ) ; if ( $ this -> redirectBack && ! empty ( $ _SESSION [ 'LAST_PAGE_VISITED' ] ) ) { $ strRedirect = $ _SESSION [ 'LAST_PAGE_VISITED' ] ; } elseif ( ( $ objTarget = $ this -> objModel -> getRelated ( 'jumpTo' ) ) instanceof PageModel ) { $ strRedirect = $ objTarget -> getAbsoluteUrl ( ) ; } $ uri = Http :: createFromString ( $ strLogoutUrl ) ; $ query = new Query ( $ uri -> getQuery ( ) ) ; $ query = $ query -> merge ( 'redirect=' . $ strRedirect ) ; $ this -> redirect ( ( string ) $ uri -> withQuery ( ( string ) $ query ) ) ; return '' ; }
8293	protected function errorHandler ( \ Exception $ e , $ url = "" ) { $ this -> errorOccurred = true ; $ this -> requestFile = $ this -> pluginDir . '/content/error.md' ; if ( $ this -> config [ "debug" ] === true ) { $ this -> addOutput ( "_exception" , ( string ) $ e ) ; } $ this -> logger -> critical ( "Exception on url '{url}': {e}" , array ( "url" => $ url , "e" => $ e ) ) ; header ( $ _SERVER [ 'SERVER_PROTOCOL' ] . ' 500 Internal Server Error' , true , 500 ) ; $ this -> requestUrl = "500" ; }
4961	public function setForm ( $ form ) { if ( ! $ form instanceof FormInterface && ! $ form instanceof Container ) { throw new \ InvalidArgumentException ( 'Form must either implement \Zend\Form\FormInterface or extend from \Core\Form\Container' ) ; } $ this -> form = $ form ; return $ this ; }
1869	private function parseFile ( string $ file ) : array { $ code = '' ; $ namespace = '' ; $ buffer = false ; $ stream = new \ PHP_Token_Stream ( $ file ) ; foreach ( $ stream as $ token ) { switch ( true ) { case $ token instanceof \ PHP_Token_OPEN_TAG : case $ token instanceof \ PHP_Token_CLOSE_TAG : break ; case false !== $ buffer : $ buffer .= $ token ; if ( ';' === ( string ) $ token ) { $ code .= $ this -> handleDeclare ( $ buffer ) ; $ buffer = false ; } break ; case $ token instanceof \ PHP_Token_NAMESPACE : if ( '{' === $ token -> getName ( ) ) { $ namespace = false ; $ code .= $ token ; } else { $ namespace = $ token -> getName ( ) ; $ stream -> seek ( $ token -> getEndTokenId ( ) ) ; } break ; case $ token instanceof \ PHP_Token_DECLARE : $ buffer = ( string ) $ token ; break ; default : $ code .= $ token ; } } return [ $ code , $ namespace ] ; }
3399	public function get ( $ arguments = [ ] ) { try { $ this -> makeRequest ( $ arguments ) ; } catch ( ConnectException $ e ) { $ url = $ e -> getRequest ( ) -> getUrl ( ) ; return $ this -> errorResponse ( $ e -> getCode ( ) , $ e -> getMessage ( ) , $ url ) ; } catch ( RequestException $ e ) { $ url = $ e -> getRequest ( ) -> getUrl ( ) ; $ status = $ e -> getCode ( ) ; $ response = $ e -> getResponse ( ) ; $ reason = $ e -> getMessage ( ) ; if ( ! is_null ( $ response ) ) { $ reason = $ response -> getReasonPhrase ( ) ; } return $ this -> errorResponse ( $ status , $ reason , $ url ) ; } return $ this -> parseBlueprint ( $ this -> schemaBlueprint ) ; }
10864	protected function generateHashes ( ) : array { $ dirLength = strlen ( $ this -> dir ) ; foreach ( $ this -> createIterator ( ) as $ file ) { if ( ! $ file -> isFile ( ) ) { continue ; } $ realpath = $ file -> getRealPath ( ) ; $ path = $ file -> getPath ( ) . DIRECTORY_SEPARATOR . $ file -> getFilename ( ) ; if ( $ realpath !== $ path ) { continue ; } $ path = substr ( $ realpath , $ dirLength ) ; $ lowerPath = strtolower ( $ path ) ; if ( isset ( $ this -> hashes [ $ lowerPath ] ) ) { $ message = "duplicate file encountered: $path ($lowerPath)" ; throw new \ RuntimeException ( $ message ) ; } $ this -> hashes [ $ lowerPath ] = sha1_file ( $ realpath ) ; } ksort ( $ this -> hashes ) ; return $ this -> hashes ; }
9684	public function getStorage ( ) { if ( null === $ this -> storage ) { $ this -> setStorage ( new Storage \ File ( array ( 'dir' => DATA_PATH ) ) ) ; } return $ this -> storage ; }
12516	public static function delete ( $ path ) { if ( ! Folder :: exists ( $ path ) ) { return true ; } $ path = Path :: clean ( $ path ) ; if ( trim ( $ path ) === '' ) { throw new Exception ( Helper :: getTranslation ( 'FAILED_DELETING' ) . ' : Cannot delete root path' ) ; } $ fs = new Filesystem ( ) ; try { $ fs -> remove ( $ path ) ; } catch ( IOExceptionInterface $ e ) { throw new Exception ( Helper :: getTranslation ( 'FAILED_DELETING' ) . ' - (' . $ e -> getMessage ( ) . ')' ) ; } return true ; }
2451	public function onKernelRequest ( GetResponseEvent $ event ) : void { if ( ! $ this -> scopeMatcher -> isContaoRequest ( $ event -> getRequest ( ) ) ) { return ; } $ request = $ event -> getRequest ( ) ; $ request -> attributes -> set ( '_locale' , $ this -> getLocale ( $ request ) ) ; }
10848	protected function getTableName ( $ returnAlias = false ) { $ result = '' ; foreach ( $ this -> clause_table as $ k => $ v ) { if ( ! is_int ( $ k ) && $ returnAlias ) { return $ k ; } else { return $ v ; } } return $ result ; }
6631	public function authURL ( $ state ) { $ url = $ this -> settings [ 'authentication_url' ] ; $ params = [ 'client_id' => $ this -> settings ( 'api_key' ) , 'redirect_uri' => $ this -> settings ( 'redirect_uri' ) , 'scope' => $ this -> settings ( 'permissions' ) , 'state' => $ state , ] ; return $ url . '?' . http_build_query ( $ params ) ; }
10733	public static function checkLeapYear ( $ year ) { $ year = Cast :: _Int ( $ year ) ; if ( $ year % 4 !== 0 ) { return false ; } elseif ( $ year % 100 !== 0 ) { return true ; } elseif ( $ year % 400 !== 0 ) { return false ; } elseif ( $ year === 0 ) { return false ; } return true ; }
601	public function orOnCondition ( $ condition , $ params = [ ] ) { if ( $ this -> on === null ) { $ this -> on = $ condition ; } else { $ this -> on = [ 'or' , $ this -> on , $ condition ] ; } $ this -> addParams ( $ params ) ; return $ this ; }
8872	private function buildAttachmentPart ( ) { if ( count ( $ this -> attachments ) > 0 ) { $ attachment_part = '' ; foreach ( $ this -> attachments as $ attachment ) { $ file_str = chunk_split ( base64_encode ( file_get_contents ( $ attachment ) ) ) ; $ attachment_part .= "--MIME_BOUNDRY\nContent-Type: " . $ this -> getMimeType ( $ attachment ) . "; name=" . basename ( $ attachment ) . "\nContent-disposition: attachment\nContent-Transfer-Encoding: base64\n\n{$file_str}\n\n" ; } return $ attachment_part ; } }
5598	public function add ( $ severity , $ content , $ filename , $ line ) { $ content = str_replace ( '%' , '%%' , $ content ) ; $ this -> testLatestError ( $ severity , $ content , $ filename , $ line ) ; }
519	private function findMigrationPath ( $ namespace ) { if ( empty ( $ namespace ) ) { return is_array ( $ this -> migrationPath ) ? reset ( $ this -> migrationPath ) : $ this -> migrationPath ; } if ( ! in_array ( $ namespace , $ this -> migrationNamespaces , true ) ) { throw new Exception ( "Namespace '{$namespace}' not found in `migrationNamespaces`" ) ; } return $ this -> getNamespacePath ( $ namespace ) ; }
7965	public function getVoiceConsumptions ( $ service , $ billingAccount , $ params = null ) { $ paramsString = "" ; if ( ! $ service ) throw new BadMethodCallException ( 'Parameter $service is missing.' ) ; if ( ! $ billingAccount ) throw new BadMethodCallException ( 'Parameter $billingAccount is missing.' ) ; if ( $ params != null && is_array ( $ params ) && count ( $ params ) > 0 ) { $ paramsString = "?" ; if ( array_key_exists ( 'creationDatetime.from' , $ params ) ) { $ string = $ params [ 'creationDatetime.from' ] ; if ( $ params [ 'creationDatetime.from' ] instanceof \ Datetime ) $ string = $ params [ 'creationDatetime.from' ] -> format ( "Y-m-d\TH:i:sP" ) ; $ paramsString .= "creationDatetime.from=" . urlencode ( $ string ) ; } if ( array_key_exists ( 'creationDatetime.to' , $ params ) ) { $ paramsString .= "&" ; $ string = $ params [ 'creationDatetime.to' ] ; if ( $ params [ 'creationDatetime.to' ] instanceof \ Datetime ) $ string = $ params [ 'creationDatetime.to' ] -> format ( "Y-m-d\TH:i:sP" ) ; $ paramsString .= "creationDatetime.to=" . urlencode ( $ string ) ; } if ( array_key_exists ( 'destinationType' , $ params ) && in_array ( $ params [ 'destinationType' ] , array ( 'landline' , 'mobile' , 'special' ) ) ) { $ paramsString .= "&" ; $ paramsString .= "destinationType=" . $ params [ 'destinationType' ] ; } if ( array_key_exists ( 'planType' , $ params ) && in_array ( $ params [ 'planType' ] , array ( 'outplan' , 'priceplan' ) ) ) { $ paramsString .= "&" ; $ paramsString .= "planType=" . $ params [ 'planType' ] ; } if ( array_key_exists ( 'wayType' , $ params ) && in_array ( $ params [ 'wayType' ] , array ( 'incoming' , 'outgoing' , 'transfer' ) ) ) { $ paramsString .= "&" ; $ paramsString .= "wayType=" . $ params [ 'wayType' ] ; } } try { $ r = $ this -> get ( 'telephony/' . $ billingAccount -> getBillingAccount ( ) . '/service/' . $ service . '/voiceConsumption' . $ paramsString ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new TelephonyAccountServiceException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
7716	static function FindElement ( & $ TxtOrObj , $ Tag , $ PosBeg , $ Forward = true ) { $ XmlLoc = clsTbsXmlLoc :: FindStartTag ( $ TxtOrObj , $ Tag , $ PosBeg , $ Forward ) ; if ( $ XmlLoc === false ) return false ; $ XmlLoc -> FindEndTag ( ) ; return $ XmlLoc ; }
3580	protected function orderByMeta ( Builder $ query , $ args , $ alias ) { $ query -> with ( 'metaAttributes' ) -> getQuery ( ) -> orderBy ( "{$alias}.meta_value" , $ args -> get ( 'direction' ) ) ; return $ query ; }
7765	private function documentClassProperties ( \ ML \ HydraBundle \ Mapping \ ClassMetadata $ class ) { $ result = array ( ) ; $ propertyDomain = $ this -> getTypeReferenceIri ( $ class -> getName ( ) ) ; foreach ( $ class -> getProperties ( ) as $ property ) { if ( 0 === strncmp ( '@' , $ property -> getExposeAs ( ) , 1 ) ) { continue ; } $ result [ ] = array ( 'property' => ( $ property -> isExternalReference ( ) ) ? $ property -> getIri ( ) : array ( '@id' => 'vocab:' . $ property -> getIri ( ) , '@type' => ( $ property -> getRoute ( ) ) ? 'hydra:Link' : 'rdf:Property' , 'label' => $ property -> getTitle ( ) , 'description' => $ property -> getDescription ( ) , 'domain' => $ propertyDomain , 'range' => $ this -> getTypeReferenceIri ( $ property -> getType ( ) ) , 'supportedOperation' => $ this -> documentOperations ( $ property -> getOperations ( ) ) ) , 'hydra:title' => $ property -> getTitle ( ) , 'hydra:description' => $ property -> getDescription ( ) , 'required' => $ property -> getRequired ( ) , 'readonly' => $ property -> isReadOnly ( ) , 'writeonly' => $ property -> isWriteOnly ( ) ) ; } return $ result ; }
9115	public function setDefaults ( $ defaultController = 'Index' , $ defaultAction = 'index' ) { $ this -> defaultController = $ defaultController ; $ this -> defaultAction = $ defaultAction ; return $ this ; }
5568	public function put ( $ url , $ parameters = false , $ content_type = false ) { if ( ! is_object ( $ url ) ) { $ url = new SimpleUrl ( $ url ) ; } return $ this -> load ( $ url , new SimplePutEncoding ( $ parameters , $ content_type ) ) ; }
7462	public function getContent ( string $ name , array $ data = [ ] ) : string { $ cacheName = $ name ; if ( '' == $ name ) { $ this -> isRouteView = true ; $ stack = debug_backtrace ( ) ; foreach ( $ stack as $ item ) { if ( false !== stripos ( $ item [ 'file' ] , DIRECTORY_SEPARATOR . 'Route' . DIRECTORY_SEPARATOR ) ) { $ cacheName = pathinfo ( $ item [ 'file' ] , PATHINFO_DIRNAME ) . '/' . $ name ; $ cacheName = explode ( 'Route' . DIRECTORY_SEPARATOR , $ cacheName ) [ 1 ] ; $ cacheName = 'route_' . str_replace ( [ '/' , '\\' ] , '_' , $ cacheName ) ; break ; } } } $ cacheName .= '_' . $ this -> language . '.html.php' ; $ path = $ this -> packageRoot . '/view/_cache/' . str_replace ( '/' , '_' , $ cacheName ) ; $ exist = file_exists ( $ path ) ; if ( ! $ this -> cache || ! $ exist ) { $ code = $ this -> compile ( $ name . '/view.html.php' , true , true , true ) ; $ code = preg_replace ( [ '/\>[^\S ]+/s' , '/[^\S ]+\</s' , '/(\s)+/s' ] , [ '>' , '<' , '\\1' ] , $ code ) ; if ( $ exist ) { $ fh = fopen ( $ path , 'r+b' ) ; } else { $ fh = fopen ( $ path , 'wb' ) ; } if ( flock ( $ fh , LOCK_EX ) ) { ftruncate ( $ fh , 0 ) ; fwrite ( $ fh , $ code ) ; flock ( $ fh , LOCK_UN ) ; } fclose ( $ fh ) ; } $ fh = fopen ( $ path , 'rb' ) ; if ( flock ( $ fh , LOCK_SH ) ) { $ html = self :: renderTemplate ( $ path , $ data ) ; flock ( $ fh , LOCK_UN ) ; fclose ( $ fh ) ; return $ html ; } throw new \ RuntimeException ( 'Can\'t render template' ) ; }
11551	public function saveConsignment ( ConsignmentInterface $ consignment ) { $ adapter = $ this -> getAdapter ( $ consignment ) ; $ event = new EventConsignment ( $ consignment ) ; $ this -> eventDispatcher -> dispatch ( Events :: PRE_CONSIGNMENT_SAVE , $ event ) ; if ( ! $ consignment -> getStatus ( ) ) { $ consignment -> setStatus ( ConsignmentStatusList :: STATUS_NEW ) ; } try { $ adapter -> saveConsignment ( $ consignment ) ; $ this -> consignmentRepository -> saveConsignment ( $ consignment ) ; } catch ( \ Exception $ e ) { throw new VendorAdapterException ( 'Error during consignment saving.' , null , $ e ) ; } $ event = new EventConsignment ( $ consignment ) ; $ this -> eventDispatcher -> dispatch ( Events :: POST_CONSIGNMENT_SAVE , $ event ) ; }
1549	protected function authorizeRelationship ( AuthorizerInterface $ authorizer , $ request , $ record , string $ field ) : void { if ( $ this -> isModifyRelationship ( $ request ) ) { $ authorizer -> modifyRelationship ( $ record , $ field , $ request ) ; return ; } $ authorizer -> readRelationship ( $ record , $ field , $ request ) ; }
10382	protected static function save_external_file ( $ url , $ path ) { $ data = file_get_contents ( $ url ) ; return ( $ data && self :: save_file ( $ path , $ data ) ) ? $ data : '' ; }
868	private function isInConditionWithoutBraces ( Tokens $ tokens , $ index , $ lowerLimitIndex ) { do { if ( $ tokens [ $ index ] -> isComment ( ) || $ tokens [ $ index ] -> isWhitespace ( ) ) { $ index = $ tokens -> getPrevMeaningfulToken ( $ index ) ; } $ token = $ tokens [ $ index ] ; if ( $ token -> isGivenKind ( [ T_IF , T_ELSEIF , T_ELSE ] ) ) { return true ; } if ( $ token -> equals ( ';' , '}' ) ) { return false ; } if ( $ token -> equals ( '{' ) ) { $ index = $ tokens -> getPrevMeaningfulToken ( $ index ) ; if ( $ tokens [ $ index ] -> isGivenKind ( T_DO ) ) { -- $ index ; continue ; } if ( ! $ tokens [ $ index ] -> equals ( ')' ) ) { return false ; } $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ index ) ; $ index = $ tokens -> getPrevMeaningfulToken ( $ index ) ; if ( $ tokens [ $ index ] -> isGivenKind ( [ T_IF , T_ELSEIF ] ) ) { return false ; } } elseif ( $ token -> equals ( ')' ) ) { $ type = Tokens :: detectBlockType ( $ token ) ; $ index = $ tokens -> findBlockStart ( $ type [ 'type' ] , $ index ) ; $ index = $ tokens -> getPrevMeaningfulToken ( $ index ) ; } else { -- $ index ; } } while ( $ index > $ lowerLimitIndex ) ; return false ; }
1987	private function filterOptions ( array $ allowedSizes ) : array { if ( empty ( $ allowedSizes ) ) { return [ ] ; } $ filteredSizes = [ ] ; foreach ( $ this -> options as $ group => $ sizes ) { if ( 'image_sizes' === $ group ) { $ this -> filterImageSizes ( $ sizes , $ allowedSizes , $ filteredSizes , $ group ) ; } else { $ this -> filterResizeModes ( $ sizes , $ allowedSizes , $ filteredSizes , $ group ) ; } } return $ filteredSizes ; }
10570	protected function parseSort ( string $ sort , array & $ sorts ) { if ( strlen ( trim ( $ sort ) ) === 0 ) { return ; } if ( substr ( $ sort , 0 , 1 ) == "[" ) { $ json = json_decode ( $ sort ) ; if ( is_array ( $ json ) ) { foreach ( $ json as $ s ) { if ( is_object ( $ s ) ) { $ sorts [ $ s -> property ] = strcasecmp ( self :: DESC , $ s -> direction ) !== 0 ; } } return ; } } if ( substr ( $ sort , - 4 ) == ",asc" ) { $ sorts [ substr ( $ sort , 0 , strlen ( $ sort ) - 4 ) ] = true ; } elseif ( substr ( $ sort , - 5 ) == ",desc" ) { $ sorts [ substr ( $ sort , 0 , strlen ( $ sort ) - 5 ) ] = false ; } elseif ( substr ( $ sort , - 10 ) == ":ascending" ) { $ sorts [ substr ( $ sort , 0 , strlen ( $ sort ) - 10 ) ] = true ; } elseif ( substr ( $ sort , - 11 ) == ":descending" ) { $ sorts [ substr ( $ sort , 0 , strlen ( $ sort ) - 11 ) ] = false ; } else { foreach ( explode ( ',' , $ sort ) as $ s ) { if ( substr ( $ s , 0 , 1 ) === '-' ) { $ sorts [ substr ( $ s , 1 ) ] = false ; } elseif ( substr ( $ s , 0 , 1 ) === '+' ) { $ sorts [ substr ( $ s , 1 ) ] = true ; } else { $ sorts [ $ s ] = true ; } } } }
2218	public function getFields ( ) { $ arrFields = $ GLOBALS [ 'TL_FFL' ] ; foreach ( array_keys ( $ arrFields ) as $ key ) { $ arrFields [ $ key ] = $ GLOBALS [ 'TL_LANG' ] [ 'FFL' ] [ $ key ] [ 0 ] ; } return $ arrFields ; }
3430	protected function rememberInCache ( $ key , $ minutes , Closure $ callback ) { $ minutes = ( double ) $ minutes ; if ( $ minutes <= 0 ) { return $ callback ( ) ; } $ cache = Cache :: createInstance ( ) ; if ( $ cache -> initCache ( $ minutes * 60 , $ key , '/bitrix-models' ) ) { $ vars = $ cache -> getVars ( ) ; return ! empty ( $ vars [ 'isCollection' ] ) ? new Collection ( $ vars [ 'cache' ] ) : $ vars [ 'cache' ] ; } $ cache -> startDataCache ( ) ; $ result = $ callback ( ) ; $ isCollection = $ result instanceof Collection ; if ( $ isCollection ) { $ result = $ result -> all ( ) ; } $ cache -> endDataCache ( [ 'cache' => $ result , 'isCollection' => $ isCollection ] ) ; return $ isCollection ? new Collection ( $ result ) : $ result ; }
12189	public function getPrimaryRelation ( $ baseObject , $ baseRole , $ relationOptions = [ ] ) { $ companionRole = $ this -> companionRole ( $ baseRole ) ; $ companionType = $ this -> companionRoleType ( $ baseRole ) ; $ companionModel = $ companionType -> primaryModel ; if ( ! isset ( $ relationOptions [ 'order' ] ) ) { $ relationOptions [ 'order' ] = [ ] ; } if ( $ companionRole === 'child' ) { array_unshift ( $ relationOptions [ 'order' ] , [ 'primary_child' , SORT_DESC ] ) ; $ relation = $ baseObject -> queryParentRelations ( $ companionModel , $ relationOptions ) -> one ( ) ; } else { array_unshift ( $ relationOptions [ 'order' ] , [ 'primary_parent' , SORT_DESC ] ) ; $ relation = $ baseObject -> queryParentRelations ( $ companionModel , $ relationOptions ) -> one ( ) ; } if ( empty ( $ relation ) ) { return false ; } else { return $ relation ; } }
8130	public function addSuggestions ( $ name , array $ items ) { if ( ! $ alternatives = self :: computeAlternatives ( $ name , $ items ) ) { return ; } $ this -> appendMessage ( sprintf ( ' Did you mean "%s"?' , implode ( '", "' , $ alternatives ) ) ) ; }
5936	public function addGroup ( $ item ) { if ( ! ( $ item instanceof Group ) ) { if ( is_array ( $ item ) ) { try { $ item = new Group ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate Group. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "Group"!' , E_USER_WARNING ) ; } } $ this -> groups [ ] = $ item ; return $ this ; }
6965	public function isIdentityEmpty ( ) { return empty ( $ this -> gender ) && empty ( $ this -> firstName ) && empty ( $ this -> lastName ) ; }
9039	public function getByHash ( $ columns , string $ hash ) : ? IEntity { if ( $ this -> manager -> hasher === null ) { throw new MissingServiceException ( 'Hasher is missing' ) ; } return $ this -> toEntity ( $ this -> manager -> hasher -> hashSQL ( $ this -> builder ( ) , $ columns , $ hash ) ) ; }
6392	public static function reverseOrder ( Comparator $ comparator = null ) : Comparator { if ( $ comparator === null ) { $ comparator = ComparableComparator :: instance ( ) ; } return new ReverseComparator ( $ comparator ) ; }
10059	public function commit ( ) { foreach ( $ this -> deferred as $ item ) { $ this -> save ( $ item ) ; } $ this -> deferred = [ ] ; return true ; }
6098	protected function post ( $ endpoint , array $ parameters = [ ] , $ fireAndForget = false ) { return $ this -> call ( $ endpoint , $ parameters , self :: METHOD_POST , null , $ fireAndForget ) ; }
11926	public function setAutoloadDir ( $ dir ) { if ( ! is_string ( $ dir ) || empty ( $ dir ) ) { throw new InvalidArgumentException ( sprintf ( 'Invalid directory for autoload of configuration provided; ' . 'must be a non-empty string, "%s" received.' , is_object ( $ dir ) ? get_class ( $ dir ) : gettype ( $ dir ) ) ) ; } $ dir = Normalizer :: path ( $ dir ) ; if ( ! file_exists ( $ dir ) || ! is_dir ( $ dir ) ) { throw new InvalidArgumentException ( sprintf ( 'The directory "%s", specified for autoload of configurations, ' . 'does not exists.' , $ dir ) ) ; } $ this -> autoloadDir = $ dir ; }
7330	private function configureSubjectRelativeMapping ( LoadClassMetadataEventArgs $ eventArgs ) { $ metadata = $ eventArgs -> getClassMetadata ( ) ; $ class = $ metadata -> getName ( ) ; if ( ! is_subclass_of ( $ class , SubjectRelativeInterface :: class ) ) { return ; } if ( in_array ( $ class , $ this -> relativeClassCache ) ) { return ; } $ this -> getSubjectIdentityMapper ( $ eventArgs -> getEntityManager ( ) ) -> processClassMetadata ( $ metadata , 'subjectIdentity' , 'subject_' ) ; $ this -> relativeClassCache [ ] = $ class ; }
3874	protected function removeEmptyDetailPages ( $ jumpTos ) { foreach ( $ jumpTos as $ jumpTo ) { $ event = new GetPageDetailsEvent ( $ jumpTo [ 'value' ] ) ; $ this -> getEventDispatcher ( ) -> dispatch ( ContaoEvents :: CONTROLLER_GET_PAGE_DETAILS , $ event ) ; $ pageDetails = $ event -> getPageDetails ( ) ; if ( $ pageDetails === null ) { continue ; } $ baseUrl = $ this -> getBaseUrl ( $ pageDetails ) ; if ( ( $ strKey = array_search ( $ baseUrl -> getUrl ( ) , $ this -> foundPages ) ) !== false ) { unset ( $ this -> foundPages [ $ strKey ] ) ; } $ baseUrl = $ this -> getBaseUrl ( $ pageDetails , null , true ) ; if ( ( $ strKey = array_search ( $ baseUrl -> getUrl ( ) , $ this -> foundPages ) ) !== false ) { unset ( $ this -> foundPages [ $ strKey ] ) ; } } }
10076	public static function controlCharacterPHP2OOXML ( $ value ) { self :: buildCharacterSets ( ) ; return str_replace ( array_values ( self :: $ controlCharacters ) , array_keys ( self :: $ controlCharacters ) , $ value ) ; }
10477	protected function displayExceptions ( Exception $ e ) { $ this -> display [ ] = 'Cerbero\Auth\Exceptions\DisplayException' ; foreach ( $ this -> display as $ exception ) { if ( $ e instanceof $ exception ) { return back ( ) -> withInput ( ) -> withError ( $ e -> getMessage ( ) ) ; } } }
987	public function chargeParams ( ) { $ chargeDetails = [ 'name' => $ this -> plan -> name , 'price' => $ this -> plan -> price , 'test' => $ this -> plan -> isTest ( ) , 'trial_days' => $ this -> plan -> hasTrial ( ) ? $ this -> plan -> trial_days : 0 , 'return_url' => URL :: secure ( Config :: get ( 'shopify-app.billing_redirect' ) , [ 'plan_id' => $ this -> plan -> id ] ) , ] ; if ( isset ( $ this -> plan -> capped_amount ) && $ this -> plan -> capped_amount > 0 ) { $ chargeDetails [ 'capped_amount' ] = $ this -> plan -> capped_amount ; $ chargeDetails [ 'terms' ] = $ this -> plan -> terms ; } return $ chargeDetails ; }
9722	public function write ( Spreadsheet $ spreadsheet , $ filename , array $ writers = [ 'Xlsx' , 'Xls' ] ) { $ spreadsheet -> setActiveSheetIndex ( 0 ) ; foreach ( $ writers as $ writerType ) { $ path = $ this -> getFilename ( $ filename , mb_strtolower ( $ writerType ) ) ; $ writer = IOFactory :: createWriter ( $ spreadsheet , $ writerType ) ; if ( $ writer instanceof Pdf ) { $ tempDir = $ this -> getTemporaryFolder ( ) ; $ writer -> setTempDir ( $ tempDir ) ; } $ callStartTime = microtime ( true ) ; $ writer -> save ( $ path ) ; $ this -> logWrite ( $ writer , $ path , $ callStartTime ) ; } $ this -> logEndingNotes ( ) ; }
4319	protected function interpolate ( $ message , array & $ context = array ( ) ) { \ preg_match_all ( '/\{([a-z0-9_.]+)\}/' , $ message , $ matches ) ; $ placeholders = \ array_unique ( $ matches [ 1 ] ) ; $ replace = array ( ) ; foreach ( $ placeholders as $ key ) { if ( ! isset ( $ context [ $ key ] ) ) { continue ; } $ val = $ context [ $ key ] ; if ( ! \ is_array ( $ val ) && ( ! \ is_object ( $ val ) || \ method_exists ( $ val , '__toString' ) ) ) { $ replace [ '{' . $ key . '}' ] = $ val ; } } $ context = \ array_diff_key ( $ context , \ array_flip ( $ placeholders ) ) ; if ( ! $ context ) { $ context = $ this -> debug -> meta ( ) ; } return \ strtr ( $ message , $ replace ) ; }
11419	protected function getValues ( $ fields , $ preCalculatedResult = false ) { if ( $ preCalculatedResult ) { return $ preCalculatedResult ; } $ app = App :: getInstance ( ) ; $ sql = $ this -> constructSelectSQL ( $ fields ) ; $ item = $ this -> getCache ( $ fields [ $ this -> pk ] ) ; $ results = $ item -> get ( \ Stash \ Invalidation :: PRECOMPUTE , 300 ) ; if ( $ item -> isMiss ( ) ) { $ results = $ this -> runGetRow ( $ sql ) ; if ( $ app [ 'db' ] -> last_error ) { throw new SQLException ( $ app [ 'db' ] -> last_error , $ app [ 'db' ] -> captured_errors ) ; } if ( is_null ( $ results ) ) { throw new ModelNotFoundException ( 'No model in database' , $ this -> dbtable , $ this -> constructorId ) ; } $ app [ 'cache' ] -> save ( $ item -> set ( $ results ) ) ; } return $ results ; }
12236	public function insertPI ( $ target , $ data = null , $ mode = 'before' ) { $ tmp = dom_import_simplexml ( $ this ) ; $ doc = $ tmp -> ownerDocument ; if ( isset ( $ data ) ) { if ( is_array ( $ data ) ) { $ str = '' ; foreach ( $ data as $ k => $ v ) { $ str .= $ k . '="' . htmlspecialchars ( $ v ) . '" ' ; } $ data = substr ( $ str , 0 , - 1 ) ; } else { $ data = ( string ) $ data ; } $ pi = $ doc -> createProcessingInstruction ( $ target , $ data ) ; } else { $ pi = $ doc -> createProcessingInstruction ( $ target ) ; } if ( $ pi !== false ) { $ this -> insertNode ( $ tmp , $ pi , $ mode ) ; } return $ this ; }
6750	public function getTransformer ( ) { if ( ! property_exists ( $ this , 'transformer' ) || ! $ this -> transformer ) { if ( ! $ this -> _defaultTransformer ) { $ this -> createQualifiedTransformerClass ( ) ; } return $ this -> _defaultTransformer ; } return $ this -> transformer ; }
12577	public function previewNewsByName ( $ message , $ to ) { return $ this -> preview ( self :: MSG_TYPE_NEWS , $ message , $ to , self :: PREVIEW_BY_NAME ) ; }
11719	public function saveAction ( Request $ request , Application $ app ) { $ options = array ( "request" => $ request , "configuration_handler" => $ app [ "red_kite_cms.configuration_handler" ] , 'security' => $ app [ "security" ] , "queue_manager" => $ app [ "red_kite_cms.queue_manager" ] , ) ; $ response = parent :: save ( $ options ) ; if ( $ app [ "red_kite_cms.queue_manager" ] -> hasQueue ( ) && $ response -> getContent ( ) == "Queue saved" ) { $ lastRoute = $ request -> getSession ( ) -> get ( 'last_uri' ) ; return $ app -> redirect ( $ lastRoute ) ; } return $ response ; }
4217	private function clearErrorsHelper ( & $ log , $ clear = true ) { $ errorsNotCleared = array ( ) ; foreach ( $ log as $ k => $ entry ) { if ( ! \ in_array ( $ entry [ 0 ] , array ( 'error' , 'warn' ) ) ) { continue ; } $ clear2 = $ clear ; if ( $ this -> channelName ) { $ channel = isset ( $ entry [ 2 ] [ 'channel' ] ) ? $ entry [ 2 ] [ 'channel' ] : null ; $ clear2 = $ clear && $ channel === $ this -> channelName ; } if ( $ clear2 ) { unset ( $ log [ $ k ] ) ; } elseif ( isset ( $ entry [ 2 ] [ 'errorHash' ] ) ) { $ errorsNotCleared [ ] = $ entry [ 2 ] [ 'errorHash' ] ; } } $ log = \ array_values ( $ log ) ; return $ errorsNotCleared ; }
6054	public function createFolder ( Folder $ folder , $ parentId = 0 , $ inheritAccess = null ) { $ parameters = [ 'query' => [ 'parentId' => $ parentId ] , 'body' => json_encode ( [ 'folder' => $ folder , 'inheritAccess' => $ inheritAccess ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/folders' , $ parameters ) ; $ result = new FolderResponse ( $ result ) ; return $ result ; }
7537	function clear ( ) { foreach ( $ this -> children as $ c ) { $ c -> parent = null ; $ c -> delete ( ) ; } $ this -> children = array ( ) ; }
1822	public function adjustPermissions ( $ insertId ) { if ( \ func_num_args ( ) == 4 ) { $ insertId = func_get_arg ( 1 ) ; } if ( $ this -> User -> isAdmin ) { return ; } if ( empty ( $ this -> User -> imageSizes ) || ! \ is_array ( $ this -> User -> imageSizes ) ) { $ imageSizes = array ( ) ; } else { $ imageSizes = $ this -> User -> imageSizes ; } if ( \ in_array ( $ insertId , $ imageSizes ) ) { return ; } $ objSessionBag = Contao \ System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; $ arrNew = $ objSessionBag -> get ( 'new_records' ) ; if ( \ is_array ( $ arrNew [ 'tl_image_size' ] ) && \ in_array ( $ insertId , $ arrNew [ 'tl_image_size' ] ) ) { if ( $ this -> User -> inherit != 'custom' ) { $ objGroup = $ this -> Database -> execute ( "SELECT id, themes, imageSizes FROM tl_user_group WHERE id IN(" . implode ( ',' , array_map ( '\intval' , $ this -> User -> groups ) ) . ")" ) ; while ( $ objGroup -> next ( ) ) { $ arrThemes = Contao \ StringUtil :: deserialize ( $ objGroup -> themes ) ; if ( \ is_array ( $ arrThemes ) && \ in_array ( 'image_sizes' , $ arrThemes ) ) { $ arrImageSizes = Contao \ StringUtil :: deserialize ( $ objGroup -> imageSizes , true ) ; $ arrImageSizes [ ] = $ insertId ; $ this -> Database -> prepare ( "UPDATE tl_user_group SET imageSizes=? WHERE id=?" ) -> execute ( serialize ( $ arrImageSizes ) , $ objGroup -> id ) ; } } } if ( $ this -> User -> inherit != 'group' ) { $ objUser = $ this -> Database -> prepare ( "SELECT themes, imageSizes FROM tl_user WHERE id=?" ) -> limit ( 1 ) -> execute ( $ this -> User -> id ) ; $ arrThemes = Contao \ StringUtil :: deserialize ( $ objUser -> themes ) ; if ( \ is_array ( $ arrThemes ) && \ in_array ( 'image_sizes' , $ arrThemes ) ) { $ arrImageSizes = Contao \ StringUtil :: deserialize ( $ objUser -> imageSizes , true ) ; $ arrImageSizes [ ] = $ insertId ; $ this -> Database -> prepare ( "UPDATE tl_user SET imageSizes=? WHERE id=?" ) -> execute ( serialize ( $ arrImageSizes ) , $ this -> User -> id ) ; } } $ imageSizes [ ] = $ insertId ; $ this -> User -> imageSizes = $ imageSizes ; } }
4014	protected function getHelpWizard ( $ key , $ field ) { if ( empty ( $ field [ 'eval' ] [ 'helpwizard' ] ) ) { return '' ; } $ event = new GenerateHtmlEvent ( 'about.svg' , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'helpWizard' ] , 'style="vertical-align:text-bottom;"' ) ; $ this -> getEventDispatcher ( ) -> dispatch ( ContaoEvents :: IMAGE_GET_HTML , $ event ) ; return sprintf ( ' <a href="%shelp.php?table=%s&amp;field=%s_%s" title="%s" rel="lightbox[help 610 80%]">%s</a>' , TL_PATH . 'contao/' , $ this -> strTable , $ this -> strName , $ key , StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'helpWizard' ] ) , $ event -> getHtml ( ) ) ; }
10655	public function groupBy ( $ func ) { $ ret = array ( ) ; $ it = $ this -> getIterator ( ) ; while ( $ it -> valid ( ) ) { if ( is_object ( $ it -> current ( ) ) ) { $ key = call_user_func ( $ func , $ it -> current ( ) ) ; } else { $ value = $ it -> current ( ) ; $ key = call_user_func_array ( $ func , array ( & $ value ) ) ; $ it -> offsetSet ( $ it -> key ( ) , $ value ) ; unset ( $ value ) ; } if ( is_array ( $ key ) ) { $ ref = & $ ret ; foreach ( $ key as $ subkey ) { if ( ! array_key_exists ( $ subkey , $ ref ) ) { $ ref [ $ subkey ] = array ( ) ; } $ ref = & $ ref [ $ subkey ] ; } $ ref [ ] = $ it -> current ( ) ; } else { $ ret [ $ key ] [ ] = $ it -> current ( ) ; } $ it -> next ( ) ; } unset ( $ ref ) ; $ ret = new self ( $ ret ) ; $ this -> exchangeArray ( $ ret -> getArrayCopy ( ) ) ; return $ this ; }
6081	public function removeMedia ( $ id , $ hardDelete = false ) { $ parameters = [ 'query' => [ 'hardDelete' => $ hardDelete ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> delete ( 'v1/media/' . $ id . '' , $ parameters ) ; $ result = new MediaResponse ( $ result ) ; return $ result ; }
10011	public function removeSheetByIndex ( $ pIndex ) { $ numSheets = count ( $ this -> workSheetCollection ) ; if ( $ pIndex > $ numSheets - 1 ) { throw new Exception ( "You tried to remove a sheet by the out of bounds index: {$pIndex}. The actual number of sheets is {$numSheets}." ) ; } array_splice ( $ this -> workSheetCollection , $ pIndex , 1 ) ; if ( ( $ this -> activeSheetIndex >= $ pIndex ) && ( $ pIndex > count ( $ this -> workSheetCollection ) - 1 ) ) { -- $ this -> activeSheetIndex ; } }
10397	protected function processDiscriminatorMap ( ClassMetadataInfo $ metadata ) { $ newMap = [ ] ; foreach ( $ metadata -> discriminatorMap as $ mapId => $ mappedEntityName ) { $ newKey = $ this -> doReplacement ( $ mapId ) ; $ newMap [ $ newKey ] = $ mappedEntityName ; } $ metadata -> discriminatorMap = $ newMap ; }
9337	public function isComplementary ( Angle $ angle ) { $ out = new self ( $ this -> float_rad + $ angle -> rad ) ; return $ out -> isRight ( ) ; }
8084	public function clearErrors ( $ channelName = '' ) { $ channel = $ this -> namespaceChannel ( $ channelName ) ; $ this -> console [ 'errors' ] [ $ channel ] = array ( ) ; $ this -> console [ 'form' ] [ $ channel ] = array ( ) ; }
2436	public function getData ( ) { $ data = $ this -> sessionBag -> all ( ) ; foreach ( $ this -> mappedKeys as $ strKey ) { unset ( $ data [ $ strKey ] ) ; if ( $ this -> session -> has ( $ strKey ) ) { $ data [ $ strKey ] = $ this -> session -> get ( $ strKey ) ; } } return $ data ; }
5193	public function dispatch ( ServerRequestInterface $ request ) : ServerRequestInterface { $ dispatcher = simpleDispatcher ( [ $ this , 'addRoutes' ] ) ; $ routeInfo = $ dispatcher -> dispatch ( $ request -> getMethod ( ) , $ request -> getUri ( ) -> getPath ( ) ) ; if ( $ routeInfo [ 0 ] === Dispatcher :: METHOD_NOT_ALLOWED ) { throw new MethodNotAllowedException ( $ request -> getMethod ( ) , $ routeInfo [ 1 ] ) ; } if ( $ routeInfo [ 0 ] === Dispatcher :: NOT_FOUND ) { throw new NotFoundHttpException ( sprintf ( "Route '%s' not found." , $ request -> getUri ( ) -> getPath ( ) ) ) ; } foreach ( $ routeInfo [ 2 ] as $ key => $ value ) { $ request = $ request -> withAttribute ( $ key , $ value ) ; } return $ request -> withAttribute ( 'route' , $ this -> routes [ $ routeInfo [ 1 ] ] ) ; }
7955	public function setUnblockSpam ( $ ipblock , $ ipv4 ) { if ( ! $ ipblock ) throw new BadMethodCallException ( 'Parameter $ipblock is missing.' ) ; if ( ! $ ipv4 ) throw new BadMethodCallException ( 'Parameter $ipv4 is missing.' ) ; try { $ r = $ this -> post ( 'ip/' . urlencode ( $ ipblock ) . '/spam/' . $ ipv4 . '/unblock' ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new IpException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
10463	private function bindParams ( $ statement , $ params ) { foreach ( $ params as $ param ) { $ statement -> bindValue ( $ param [ 0 ] , $ param [ 1 ] , $ param [ 2 ] ) ; } }
6108	public function clientPermRemove ( $ cldbid , $ permid ) { return $ this -> getParent ( ) -> channelClientPermRemove ( $ this -> getId ( ) , $ cldbid , $ permid ) ; }
4458	public function fire ( AbstractUserEvent $ event ) { $ status = null ; $ type = $ event :: getEntityName ( ) ; if ( isset ( $ this -> events [ $ type ] ) ) { $ queue = $ this -> events [ $ type ] ; $ status = $ this -> fireQueue ( $ queue , $ event ) ; } $ eventName = $ event -> getName ( ) ; if ( isset ( $ this -> events [ $ eventName ] ) ) { $ queue = $ this -> events [ $ eventName ] ; $ status = $ this -> fireQueue ( $ queue , $ event ) ; } return $ status ; }
12092	public function generate ( $ name , array $ parameters = array ( ) , $ updateTrackerName = 'global' , $ referenceType = RouterInterface :: ABSOLUTE_PATH , $ timestampParameterName = null ) { if ( ! $ timestampParameterName ) { $ timestampParameterName = $ this -> timestampParameterName ; } $ parameters [ $ timestampParameterName ] = $ this -> updateManager -> getLastUpdate ( $ updateTrackerName ) -> format ( 'U' ) ; return $ this -> router -> generate ( $ name , $ parameters , $ referenceType ) ; }
8456	public function drush ( $ command , $ assumeYes = true ) { if ( is_array ( $ command ) ) { $ command = implode ( ' ' , array_filter ( $ command ) ) ; } return $ this -> exec ( $ this -> injectArguments ( $ command , $ assumeYes ) ) ; }
9288	public function truncate ( ) { $ adapter = $ this -> dbAdapter ; $ mapper = new \ CronHelper \ Model \ JobMapper ( $ adapter ) ; $ where = new \ Zend \ Db \ Sql \ Where ( ) ; $ mapper -> deleteByWhere ( $ where ) ; }
3659	public static function getSubscribedServices ( ) { return [ Connection :: class => Connection :: class , Input :: class => Input :: class , InsertTags :: class => InsertTags :: class , Session :: class => Session :: class , IMetaModelsServiceContainer :: class => IMetaModelsServiceContainer :: class ] ; }
12749	private function validateSKU ( string $ sku ) { if ( strlen ( $ sku ) == 0 ) { throw new SKUException ( "A SKU cannot be empty" ) ; } $ containsWhitespace = preg_match ( $ this -> whiteSpacePattern , $ sku ) == 1 ; if ( $ containsWhitespace ) { throw new SKUException ( sprintf ( "A SKU cannot contain white space characters: \"%s\"" , $ sku ) ) ; } $ containsUppercaseCharacters = preg_match ( $ this -> uppercaseCharactersPattern , $ sku ) == 1 ; if ( $ containsUppercaseCharacters ) { throw new SKUException ( sprintf ( "A SKU cannot contain uppercase characters: \"%s\"" , $ sku ) ) ; } $ containsInvalidCharacters = preg_match ( $ this -> invalidCharactersPattern , $ sku ) == 1 ; if ( $ containsInvalidCharacters ) { throw new SKUException ( sprintf ( "The SKU \"%s\" contains invalid characters. A SKU can only contain the following characters: a-z, 0-9 and -" , $ sku ) ) ; } $ prefixMatches = [ ] ; $ prefixContainsInvalidCharacters = preg_match ( $ this -> invalidPrefixCharacters , $ sku , $ prefixMatches ) == 1 ; if ( $ prefixContainsInvalidCharacters ) { throw new SKUException ( sprintf ( "A SKU cannot start with the given characters: \"%s\"" , implode ( "" , $ prefixMatches ) ) ) ; } $ suffixMatches = [ ] ; $ suffixContainsInvalidCharacters = preg_match ( $ this -> invalidSuffixCharacters , $ sku , $ suffixMatches ) == 1 ; if ( $ suffixContainsInvalidCharacters ) { throw new SKUException ( sprintf ( "A SKU cannot end with the given characters: \"%s\"" , implode ( "" , $ suffixMatches ) ) ) ; } if ( strlen ( $ sku ) < $ this -> minLength ) { throw new SKUException ( sprintf ( "The given SKU \"%s\" is too short. The minimum length for a SKU is: %s" , $ sku , $ this -> minLength ) ) ; } if ( strlen ( $ sku ) > $ this -> maxLength ) { throw new SKUException ( sprintf ( "The given SKU \"%s\" is too long (%s character). The maximum length for a SKU is: %s" , strlen ( $ sku ) , $ sku , $ this -> maxLength ) ) ; } }
1719	public function getNewsArchives ( ) { if ( ! $ this -> User -> isAdmin && ! \ is_array ( $ this -> User -> news ) ) { return array ( ) ; } $ arrArchives = array ( ) ; $ objArchives = $ this -> Database -> execute ( "SELECT id, title FROM tl_news_archive ORDER BY title" ) ; while ( $ objArchives -> next ( ) ) { if ( $ this -> User -> hasAccess ( $ objArchives -> id , 'news' ) ) { $ arrArchives [ $ objArchives -> id ] = $ objArchives -> title ; } } return $ arrArchives ; }
6597	protected function getDescription ( array $ lines ) { $ description = '' ; $ summaryFound = false ; $ summaryPassed = false ; foreach ( $ lines as $ line ) { if ( $ line && ! $ summaryPassed ) { $ summaryFound = true ; if ( substr ( trim ( $ line ) , - 1 ) == '.' ) { $ summaryPassed = true ; } continue ; } if ( ! $ line && $ summaryFound && ! $ summaryPassed ) { $ summaryPassed = true ; continue ; } if ( $ line && $ line [ 0 ] == '@' ) { break ; } if ( $ line && $ summaryPassed ) { $ description .= $ line . "\n" ; } } return trim ( $ description ) ; }
11910	public function getDefaultParams ( ) { $ defaultParams = [ ] ; foreach ( $ this -> parameters as $ parameter ) { if ( $ parameter -> hasDefault ( ) ) { if ( $ parameter -> getIsAPIParameter ( ) == false ) { $ defaultParams [ ] = $ parameter ; } } } return $ defaultParams ; }
12068	public function fetchProject ( Project $ project ) { $ response = $ this -> getResponse ( 'get' , sprintf ( 'v2/projects/%s' , $ project -> getProjectKey ( ) ) ) ; return $ this -> hydrator -> hydrate ( $ project , $ response ) ; }
10034	function unsubscribeContactById ( $ id , $ mailingId = "" , $ reasons = null ) { $ queryParameters = array ( 'id' => $ id ) ; if ( ! empty ( $ mailingId ) ) { $ queryParameters [ 'mailingId' ] = $ mailingId ; } if ( ! empty ( $ reasons ) ) { if ( is_array ( $ reasons ) ) { $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'reason' , $ reasons ) ; } else { $ queryParameters [ 'reason' ] = urlencode ( $ reasons ) ; } } return $ this -> delete ( "contacts/contact/unsubscribe" , $ queryParameters ) ; }
5341	protected function call ( $ service , $ method , array $ parameters = [ ] ) { return $ this -> getSoapClient ( $ service , $ method , $ parameters ) -> __call ( $ method , $ parameters ) ; }
6384	public function readFeedbackQuestions ( $ id ) { $ questions = $ this -> readStoreRecords ( 'feedback_item' , [ 'feedback' => $ id ] ) ; $ expandedQuestions = [ ] ; foreach ( $ questions as $ index => $ question ) { $ expandedQuestion = $ question ; $ expandedQuestion -> template = $ this -> readStoreRecord ( 'feedback_template' , [ 'id' => $ question -> template ] ) ; $ expandedQuestion -> url = $ this -> cfg -> wwwroot . '/mod/feedback/edit_item.php?id=' . $ question -> id ; $ expandedQuestions [ $ index ] = $ expandedQuestion ; } return $ expandedQuestions ; }
712	public function integer ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_INTEGER , $ length ) ; }
11673	public function offsetExists ( $ offset ) { if ( is_null ( $ this -> result ) ) { $ this -> fetchData ( ) ; } if ( array_key_exists ( $ offset , $ this -> result ) ) { return true ; } else { return false ; } }
1618	public function scalar ( $ attribute , $ db = null ) { if ( $ this -> emulateExecution ) { return null ; } $ record = $ this -> one ( $ db ) ; if ( $ record !== null ) { return $ record -> hasAttribute ( $ attribute ) ? $ record -> $ attribute : null ; } else { return null ; } }
11222	private static function checkRoutes ( ) { $ method = $ _SERVER [ 'REQUEST_METHOD' ] ; $ route_pos = array_keys ( self :: $ routes , self :: $ uri , true ) ; foreach ( $ route_pos as $ route ) { $ methodRoute = self :: $ methods [ $ route ] ; if ( $ methodRoute == $ method || $ methodRoute == 'ANY' ) { if ( ! is_object ( $ callback = self :: $ callbacks [ $ route ] ) ) { self :: $ response = self :: invokeObject ( $ callback ) ; } else { self :: $ response = call_user_func ( $ callback ) ; } if ( ! self :: $ halts ) { return self :: $ response ; } self :: $ halts -- ; } } return self :: $ response ; }
1379	protected function validateRelationship ( $ relation , ? string $ field = null ) : bool { $ path = $ field ? '/data/relationships' : '/' ; $ member = $ field ? : 'data' ; if ( ! is_object ( $ relation ) ) { $ this -> memberNotObject ( $ path , $ member ) ; return false ; } $ path = $ field ? "{$path}/{$field}" : $ path ; if ( ! property_exists ( $ relation , 'data' ) ) { $ this -> memberRequired ( $ path , 'data' ) ; return false ; } $ data = $ relation -> data ; if ( is_array ( $ data ) ) { return $ this -> validateToMany ( $ data , $ field ) ; } return $ this -> validateToOne ( $ data , $ field ) ; }
672	public function upgrade ( ) { $ owner = $ this -> owner ; if ( $ owner -> getIsNewRecord ( ) ) { throw new InvalidCallException ( 'Upgrading the model version is not possible on a new record.' ) ; } $ lock = $ this -> getLockAttribute ( ) ; $ version = $ owner -> $ lock ? : 0 ; $ owner -> updateAttributes ( [ $ lock => $ version + 1 ] ) ; }
4749	public function getAddonsForPlan ( array $ plans , string $ addonType = null ) : array { $ addonApi = new Addon ( $ this -> token , $ this -> organizationId , $ this -> cache , $ this -> ttl ) ; foreach ( $ plans as & $ plan ) { $ addons = [ ] ; foreach ( $ plan [ 'addons' ] as $ planAddon ) { $ addon = $ addonApi -> getAddon ( $ planAddon [ 'addon_code' ] ) ; if ( null !== $ addonType ) { if ( ( $ addon [ 'type' ] == $ addonType ) && ( in_array ( $ addonType , self :: $ addonTypes ) ) ) { $ addons [ ] = $ addon ; } } else { $ addons [ ] = $ addon ; } } $ plan [ 'addons' ] = $ addons ; } return $ plans ; }
3850	public function getServiceContainer ( ) { if ( ! $ this -> serviceContainer ) { $ this -> useDefaultServiceContainer ( ) ; } if ( is_callable ( $ this -> serviceContainer ) ) { return $ this -> serviceContainer = $ this -> serviceContainer -> __invoke ( ) ; } return $ this -> serviceContainer ; }
840	public function setSize ( $ size ) { if ( $ this -> getSize ( ) !== $ size ) { $ this -> changed = true ; parent :: setSize ( $ size ) ; } }
3491	public function withHeader ( string $ name , string $ value ) : Request { $ cloned = clone $ this ; $ cloned -> headers [ $ name ] = $ value ; return $ cloned ; }
8373	protected function configure ( ) { $ this -> setName ( 'worker/process' ) -> setHidden ( true ) -> setDescription ( 'Runs a given worker' ) -> setDefinition ( new InputDefinition ( [ new InputOption ( 'config' , 'c' , InputOption :: VALUE_REQUIRED , 'A YAML configuration file' ) , new InputOption ( 'jobId' , null , InputOption :: VALUE_REQUIRED , 'A Job UUID' ) , new InputOption ( 'name' , null , InputOption :: VALUE_REQUIRED , 'The queue name to work with. Defaults to `default`.' ) , ] ) ) ; }
155	public function scalar ( $ db = null ) { if ( $ this -> emulateExecution ) { return null ; } return $ this -> createCommand ( $ db ) -> queryScalar ( ) ; }
7778	protected function extractInput ( array $ data ) { $ input = [ ] ; foreach ( $ data as $ field => $ fieldData ) { $ input [ $ field ] = $ fieldData [ 0 ] ; } return $ input ; }
762	private function tokensMatch ( SqlToken $ patternToken , SqlToken $ token , $ offset = 0 , & $ firstMatchIndex = null , & $ lastMatchIndex = null ) { if ( $ patternToken -> getIsCollection ( ) !== $ token -> getIsCollection ( ) || ( ! $ patternToken -> getIsCollection ( ) && $ patternToken -> content !== $ token -> content ) ) { return false ; } if ( $ patternToken -> children === $ token -> children ) { $ firstMatchIndex = $ lastMatchIndex = $ offset ; return true ; } $ firstMatchIndex = $ lastMatchIndex = null ; $ wildcard = false ; for ( $ index = 0 , $ count = count ( $ patternToken -> children ) ; $ index < $ count ; $ index ++ ) { if ( $ patternToken [ $ index ] -> content === 'any' ) { $ wildcard = true ; continue ; } for ( $ limit = $ wildcard ? count ( $ token -> children ) : $ offset + 1 ; $ offset < $ limit ; $ offset ++ ) { if ( ! $ wildcard && ! isset ( $ token [ $ offset ] ) ) { break ; } if ( ! $ this -> tokensMatch ( $ patternToken [ $ index ] , $ token [ $ offset ] ) ) { continue ; } if ( $ firstMatchIndex === null ) { $ firstMatchIndex = $ offset ; $ lastMatchIndex = $ offset ; } else { $ lastMatchIndex = $ offset ; } $ wildcard = false ; $ offset ++ ; continue 2 ; } return false ; } return true ; }
4206	private function getPropInfo ( Event $ abs , \ ReflectionProperty $ reflectionProperty ) { $ obj = $ abs -> getSubject ( ) ; $ reflectionProperty -> setAccessible ( true ) ; $ className = \ get_class ( $ obj ) ; $ commentInfo = $ this -> getPropCommentInfo ( $ reflectionProperty ) ; $ declaringClassName = $ reflectionProperty -> getDeclaringClass ( ) -> getName ( ) ; $ propInfo = \ array_merge ( static :: $ basePropInfo , array ( 'desc' => $ commentInfo [ 'desc' ] , 'inheritedFrom' => $ declaringClassName !== $ className ? $ declaringClassName : null , 'isStatic' => $ reflectionProperty -> isStatic ( ) , 'type' => $ commentInfo [ 'type' ] , ) ) ; if ( $ reflectionProperty -> isPrivate ( ) ) { $ propInfo [ 'visibility' ] = 'private' ; } elseif ( $ reflectionProperty -> isProtected ( ) ) { $ propInfo [ 'visibility' ] = 'protected' ; } if ( $ abs [ 'collectPropertyValues' ] ) { $ propName = $ reflectionProperty -> getName ( ) ; if ( \ array_key_exists ( $ propName , $ abs [ 'propertyOverrideValues' ] ) ) { $ propInfo [ 'value' ] = $ abs [ 'propertyOverrideValues' ] [ $ propName ] ; $ propInfo [ 'valueFrom' ] = 'debug' ; } else { $ propInfo [ 'value' ] = $ reflectionProperty -> getValue ( $ obj ) ; } } return $ propInfo ; }
2816	public function getCollectionsAsArray ( ) { $ data = array ( ) ; foreach ( $ this -> getCollections ( ) as $ collection ) { $ data [ ] = array ( 'type' => $ collection -> getType ( ) , 'class' => $ collection -> getClass ( ) , 'sql' => $ collection -> getQuery ( ) , 'count' => $ collection -> getCount ( ) ) ; } return $ data ; }
5842	public function getAdditionalFields ( array & $ taskInfo , $ task , \ TYPO3 \ CMS \ Scheduler \ Controller \ SchedulerModuleController $ parentObject ) { $ editCommand = version_compare ( TYPO3_branch , '9.5' , '>=' ) ? $ parentObject -> getCurrentAction ( ) === Action :: EDIT : $ parentObject -> CMD === 'edit' ; if ( ! isset ( $ taskInfo [ 'scheduler_batchResize_directories' ] ) ) { $ taskInfo [ 'scheduler_batchResize_directories' ] = $ this -> defaultDirectories ; if ( $ editCommand ) { $ taskInfo [ 'scheduler_batchResize_directories' ] = $ task -> directories ; } } if ( ! isset ( $ taskInfo [ 'scheduler_batchResize_excludeDirectories' ] ) ) { $ taskInfo [ 'scheduler_batchResize_excludeDirectories' ] = $ this -> defaultExcludeDirectories ; if ( $ editCommand ) { $ taskInfo [ 'scheduler_batchResize_excludeDirectories' ] = $ task -> excludeDirectories ; } } $ additionalFields = [ ] ; $ fieldName = 'tx_scheduler[scheduler_batchResize_directories]' ; $ fieldId = 'scheduler_batchResize_directories' ; $ fieldValue = trim ( $ taskInfo [ 'scheduler_batchResize_directories' ] ) ; $ fieldHtml = '<textarea class="form-control" rows="4" name="' . $ fieldName . '" id="' . $ fieldId . '">' . htmlspecialchars ( $ fieldValue ) . '</textarea>' ; $ additionalFields [ $ fieldId ] = [ 'code' => $ fieldHtml , 'label' => 'LLL:EXT:image_autoresize/Resources/Private/Language/locallang_mod.xlf:label.batchResize.directories' , ] ; $ fieldName = 'tx_scheduler[scheduler_batchResize_excludeDirectories]' ; $ fieldId = 'scheduler_batchResize_excludeDirectories' ; $ fieldValue = trim ( $ taskInfo [ 'scheduler_batchResize_excludeDirectories' ] ) ; $ fieldHtml = '<textarea class="form-control" rows="4" name="' . $ fieldName . '" id="' . $ fieldId . '">' . htmlspecialchars ( $ fieldValue ) . '</textarea>' ; $ additionalFields [ $ fieldId ] = [ 'code' => $ fieldHtml , 'label' => 'LLL:EXT:image_autoresize/Resources/Private/Language/locallang_mod.xlf:label.batchResize.excludeDirectories' , ] ; return $ additionalFields ; }
3424	protected function normalizeFilter ( ) { $ this -> substituteField ( $ this -> filter , 'GROUPS' , 'GROUPS_ID' ) ; $ this -> substituteField ( $ this -> filter , 'GROUP_ID' , 'GROUPS_ID' ) ; return $ this -> filter ; }
11051	function build_all ( $ datatree , $ entry ) { if ( ! isset ( $ this -> masktree [ $ entry ] ) ) { $ this -> error ( 8 , 57 , $ entry ) ; } $ this -> datatree = $ datatree ; if ( is_array ( $ this -> datatree ) ) { $ this -> datatree [ '_parent' ] = NULL ; } elseif ( is_object ( $ this -> datatree ) ) { $ this -> datatree -> _parent = NULL ; } elseif ( isset ( $ this -> datatree ) ) { $ this -> error ( 9 , 58 ) ; $ this -> datatree = NULL ; } $ built = $ this -> build_mask ( $ this -> datatree , $ this -> masktree [ $ entry ] ) ; if ( ! isset ( $ this -> masktree [ '0reduce' ] ) ) { $ this -> masktree [ '0reduce' ] = _ETS_REDUCE_OFF ; } switch ( $ this -> masktree [ '0reduce' ] ) { case _ETS_REDUCE_OFF : break ; case _ETS_REDUCE_SPACES : $ built = preg_replace ( '/(\r\n|\r|\n)+/sm' , "\n" , preg_replace ( '/[ \t]*?(\r\n|\r|\n)+[\t ]*/sm' , "\n" , $ built ) ) ; break ; case _ETS_REDUCE_ALL : $ built = preg_replace ( '/[ \t]*?(\r\n|\r|\n)+[\t ]*/sm' , '' , $ built ) ; break ; } $ built = str_replace ( "\1n\1" , "\n" , $ built ) ; $ built = str_replace ( "\1r\1" , "\r" , $ built ) ; $ built = str_replace ( "\1t\1" , "\t" , $ built ) ; $ built = str_replace ( "\1s\1" , " " , $ built ) ; return $ built ; }
5916	public function resetPassword ( $ hash , $ password ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'hash' => $ hash , 'password' => $ password ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/accounts/users/resetpassword' , $ parameters ) ; return $ result ; }
7505	public function assignNamespace ( string $ namespace , $ prepend = false ) { if ( $ prepend ) { array_unshift ( $ this -> namespaces , $ namespace ) ; return ; } array_push ( $ this -> namespaces , $ namespace ) ; }
3070	protected function saveItemState ( ) { if ( $ this -> getRequestParameter ( 'itemDefinition' ) && $ this -> getRequestParameter ( 'itemState' ) ) { $ serviceContext = $ this -> getServiceContext ( ) ; $ itemIdentifier = $ this -> getRequestParameter ( 'itemDefinition' ) ; $ state = $ this -> getRequestParameter ( 'itemState' ) ? json_decode ( $ this -> getRequestParameter ( 'itemState' ) , true ) : new \ stdClass ( ) ; return $ this -> getRunnerService ( ) -> setItemState ( $ serviceContext , $ itemIdentifier , $ state ) ; } return false ; }
2403	public function trans ( $ strId , array $ arrParams = array ( ) , $ strDomain = 'contao_default' ) { return System :: getContainer ( ) -> get ( 'translator' ) -> trans ( $ strId , $ arrParams , $ strDomain ) ; }
6668	public function respond ( ) { if ( is_null ( $ this -> preparedResponse ) ) { $ this -> prepareResponse ( ) ; } if ( $ this -> status instanceof Status ) { header ( $ this -> status -> getHttpHeader ( ) ) ; } header ( "Content-Type: {$this->writer->getContentType()}" ) ; echo $ this -> preparedResponse ; return $ this ; }
7364	protected function updateInvoiceTotal ( SaleInterface $ sale ) { if ( ! $ sale instanceof InvoiceSubjectInterface ) { return false ; } $ changed = false ; $ invoice = $ this -> invoiceCalculator -> calculateInvoiceTotal ( $ sale ) ; if ( 0 != Money :: compare ( $ invoice , $ sale -> getInvoiceTotal ( ) , $ sale -> getCurrency ( ) -> getCode ( ) ) ) { $ sale -> setInvoiceTotal ( $ invoice ) ; $ changed = true ; } $ credit = $ this -> invoiceCalculator -> calculateCreditTotal ( $ sale ) ; if ( 0 != Money :: compare ( $ credit , $ sale -> getCreditTotal ( ) , $ sale -> getCurrency ( ) -> getCode ( ) ) ) { $ sale -> setCreditTotal ( $ credit ) ; $ changed = true ; } return $ changed ; }
6887	private function httpGet ( $ path , array $ query = array ( ) ) { $ url = new Uri ( $ this -> baseUrl . $ path ) ; foreach ( $ query as $ name => $ value ) { $ url = Uri :: withQueryValue ( $ url , $ name , $ value ) ; } $ request = new Request ( 'GET' , $ url , $ this -> buildHeaders ( ) ) ; try { $ response = $ this -> getHttpClient ( ) -> sendRequest ( $ request ) ; } catch ( \ RuntimeException $ e ) { throw new Exception \ PostcodeException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } if ( $ response -> getStatusCode ( ) != 200 ) { throw $ this -> createErrorException ( $ response ) ; } return $ response ; }
9959	public function unprotectCellsByColumnAndRow ( $ columnIndex1 , $ row1 , $ columnIndex2 , $ row2 ) { $ cellRange = Coordinate :: stringFromColumnIndex ( $ columnIndex1 ) . $ row1 . ':' . Coordinate :: stringFromColumnIndex ( $ columnIndex2 ) . $ row2 ; return $ this -> unprotectCells ( $ cellRange ) ; }
10047	protected function copyRecursive ( $ src , $ dst , $ depth , Logger $ logger ) { if ( $ depth == 0 ) { return ; } if ( ! is_file ( $ src ) && ! is_dir ( $ src ) ) { $ logger -> log ( "$src is not a valid source." , Logger :: WARNING ) ; return ; } if ( ! is_readable ( $ src ) ) { $ logger -> log ( "$src is not readable, skipping." , Logger :: WARNING ) ; return ; } if ( is_file ( $ dst ) || is_dir ( $ dst ) ) { $ logger -> log ( "$dst already exists, and cannot be overwritten." , Logger :: WARNING ) ; return ; } if ( is_dir ( $ src ) ) { mkdir ( $ dst ) ; } elseif ( is_file ( $ src ) ) { copy ( $ src , $ dst ) ; return ; } $ dh = opendir ( $ src ) ; while ( ( $ file = readdir ( $ dh ) ) !== false ) { if ( ( $ file === '.' ) || ( $ file === '..' ) ) { continue ; } $ this -> copyRecursive ( $ src . '/' . $ file , $ dst . '/' . $ file , $ depth - 1 , $ logger ) ; } }
695	public function beforeSend ( $ message ) { $ event = new MailEvent ( [ 'message' => $ message ] ) ; $ this -> trigger ( self :: EVENT_BEFORE_SEND , $ event ) ; return $ event -> isValid ; }
5258	public static function map ( $ query = [ ] , callable $ callback = null , $ limit = - 1 ) { if ( $ query instanceof QueryBuilder ) { $ query = $ query -> build ( ) ; } $ query [ 'from' ] = Arr :: get ( $ query , 'from' , 0 ) ; $ query [ 'size' ] = Arr :: get ( $ query , 'size' , 50 ) ; $ i = 0 ; $ models = static :: search ( $ query ) ; $ total = $ models -> getTotal ( ) ; while ( $ models ) { foreach ( $ models as $ model ) { if ( $ callback ) { $ callback ( $ model ) ; } $ i ++ ; } $ query [ 'from' ] += $ query [ 'size' ] ; if ( $ i >= $ total || ( $ limit > 0 && $ i >= $ limit ) ) { break ; } $ models = static :: search ( $ query ) ; } return $ total ; }
3034	public function getItems ( \ core_kernel_classes_Class $ itemClass , array $ propertyFilters = [ ] , $ offset = 0 , $ limit = 30 ) { $ data = $ this -> getTreeResourceLookupService ( ) -> getResources ( $ itemClass , [ ] , $ propertyFilters , $ offset , $ limit ) ; return $ this -> formatTreeData ( $ data ) ; }
5846	public function syslog ( $ message , $ severity = \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: OK ) { switch ( $ severity ) { case \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: NOTICE : $ severity = GeneralUtility :: SYSLOG_SEVERITY_NOTICE ; break ; case \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: INFO : $ severity = GeneralUtility :: SYSLOG_SEVERITY_INFO ; break ; case \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: OK : $ severity = GeneralUtility :: SYSLOG_SEVERITY_INFO ; break ; case \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: WARNING : $ severity = GeneralUtility :: SYSLOG_SEVERITY_WARNING ; break ; case \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: ERROR : $ severity = GeneralUtility :: SYSLOG_SEVERITY_ERROR ; break ; } GeneralUtility :: sysLog ( $ message , 'image_autoresize' , $ severity ) ; }
4173	public function hasMigrationFile ( ) { $ this -> count = $ this -> fileHas ( '/class [A-Z]\w+ extends Migration/i' ) -> getClasses ( ) -> count ( ) ; return $ this -> hasMigrationFile = $ this -> count > 0 ; }
5351	public function setDatabasePassword ( $ domainName , $ database , $ password ) { return $ this -> call ( self :: SERVICE , 'setDatabasePassword' , [ $ domainName , $ database , $ password ] ) ; }
4355	protected function checkTimestamp ( $ val ) { $ secs = 86400 * 90 ; $ tsNow = \ time ( ) ; if ( $ val > $ tsNow - $ secs && $ val < $ tsNow + $ secs ) { return \ date ( 'Y-m-d H:i:s' , $ val ) ; } return false ; }
4535	public function prePersist ( LifecycleEventArgs $ args ) { $ entity = $ args -> getEntity ( ) ; if ( ! $ entity instanceof Tenantable ) { return ; } if ( null !== $ entity -> getTenant ( ) ) { return ; } $ tenant = $ this -> container -> get ( TenantService :: class ) -> getContext ( ) ; $ entity -> setTenant ( $ tenant ) ; }
1678	protected function getSize ( ) { $ intSize = 0 ; foreach ( scan ( $ this -> strRootDir . '/' . $ this -> strFolder , true ) as $ strFile ) { if ( strncmp ( $ strFile , '.' , 1 ) === 0 ) { continue ; } if ( is_dir ( $ this -> strRootDir . '/' . $ this -> strFolder . '/' . $ strFile ) ) { $ objFolder = new self ( $ this -> strFolder . '/' . $ strFile ) ; $ intSize += $ objFolder -> size ; } else { $ objFile = new File ( $ this -> strFolder . '/' . $ strFile ) ; $ intSize += $ objFile -> size ; } } return $ intSize ; }
3517	public function getShowUnpublished ( ) { if ( ! $ this -> cookiesLoaded ) { $ key = $ this -> cookiePrefix . 'show_unpublished' ; $ queuedCookie = \ Cookie :: queued ( $ key , null ) ; $ showUnpublished = $ queuedCookie != null ? $ queuedCookie -> getValue ( ) : \ Cookie :: get ( $ key , false ) ; $ this -> useDB = $ showUnpublished ? 2 : 1 ; $ this -> cookiesLoaded = true ; } return $ this -> useDB === 2 ; }
3272	public function setConfig ( Config $ config ) { $ this -> config = $ config ; $ this -> getDatabase ( ) -> setConfig ( $ config ) ; }
10242	public static function getMatrixDimensions ( array & $ matrix ) { $ matrixRows = count ( $ matrix ) ; $ matrixColumns = 0 ; foreach ( $ matrix as $ rowKey => $ rowValue ) { if ( ! is_array ( $ rowValue ) ) { $ matrix [ $ rowKey ] = [ $ rowValue ] ; $ matrixColumns = max ( 1 , $ matrixColumns ) ; } else { $ matrix [ $ rowKey ] = array_values ( $ rowValue ) ; $ matrixColumns = max ( count ( $ rowValue ) , $ matrixColumns ) ; } } $ matrix = array_values ( $ matrix ) ; return [ $ matrixRows , $ matrixColumns ] ; }
3002	public function setContent ( $ data , $ mime , $ charset = NULL ) { if ( ! $ charset ) $ charset = $ this -> charset ; $ this -> message [ $ mime ] = [ 'content' => $ data , 'type' => $ mime . '; ' . $ charset ] ; }
10544	public function setSites ( array $ sites ) { $ this -> sites = array ( ) ; foreach ( $ sites as $ site ) $ this -> addSite ( $ site ) ; return $ this ; }
3032	public function getSessionState ( AssessmentTestSession $ session ) { $ deliveryExecution = $ this -> getDeliveryExecution ( $ session ) ; return $ deliveryExecution -> getState ( ) -> getUri ( ) ; }
1316	public function post ( $ path , array $ parameters = [ ] , $ json = false ) { return $ this -> http ( 'POST' , self :: API_HOST , $ path , $ parameters , $ json ) ; }
10914	public function execute ( ) { try { $ this -> output_buffer_level = ob_get_level ( ) ; ob_start ( ) ; $ response = $ this -> doExecute ( ) ; if ( ( is_object ( $ response ) && ! ( $ response instanceof Response ) ) || ( is_string ( $ response ) && class_exists ( $ response ) ) ) { $ response = $ this -> reflect ( $ response ) ; } if ( $ response instanceof Response ) throw $ response ; throw new HTTPError ( 500 , "App did not produce any response" ) ; } catch ( Response $ response ) { self :: $ logger -> debug ( "Response type {0} returned from controller: {1}" , [ get_class ( $ response ) , $ this -> app ] ) ; throw $ response ; } catch ( Throwable $ e ) { self :: $ logger -> debug ( "While executing controller: {0}" , [ $ this -> app ] ) ; self :: $ logger -> notice ( "Unexpected exception of type {0} thrown while processing request: {1}" , [ get_class ( $ e ) , $ e ] ) ; throw $ e ; } finally { $ this -> logScriptOutput ( ) ; } }
7097	public function normalizeStock ( StockSubjectInterface $ subject , $ format = null , array $ context = [ ] ) { $ translator = $ this -> constantHelper -> getTranslator ( ) ; $ formatter = $ this -> getFormatter ( ) ; if ( null !== $ eda = $ subject -> getEstimatedDateOfArrival ( ) ) { $ eda = $ formatter -> date ( $ eda ) ; } else { $ eda = $ translator -> trans ( 'ekyna_core.value.undefined' ) ; } $ stockUnits = $ this -> findStockUnits ( $ subject ) ; return [ 'mode_label' => $ this -> constantHelper -> renderStockSubjectModeLabel ( $ subject ) , 'mode_badge' => $ this -> constantHelper -> renderStockSubjectModeBadge ( $ subject ) , 'state_label' => $ this -> constantHelper -> renderStockSubjectStateLabel ( $ subject ) , 'state_badge' => $ this -> constantHelper -> renderStockSubjectStateBadge ( $ subject ) , 'in' => $ formatter -> number ( $ subject -> getInStock ( ) ) , 'available' => $ formatter -> number ( $ subject -> getAvailableStock ( ) ) , 'virtual' => $ formatter -> number ( $ subject -> getVirtualStock ( ) ) , 'floor' => $ formatter -> number ( $ subject -> getStockFloor ( ) ) , 'geocode' => $ subject -> getGeocode ( ) , 'replenishment' => $ formatter -> number ( $ subject -> getReplenishmentTime ( ) ) , 'eda' => $ eda , 'moq' => $ formatter -> number ( $ subject -> getMinimumOrderQuantity ( ) ) , 'quote_only' => $ subject -> isQuoteOnly ( ) ? $ translator -> trans ( 'ekyna_core.value.yes' ) : $ translator -> trans ( 'ekyna_core.value.no' ) , 'end_of_life' => $ subject -> isEndOfLife ( ) ? $ translator -> trans ( 'ekyna_core.value.yes' ) : $ translator -> trans ( 'ekyna_core.value.no' ) , 'stock_units' => $ this -> normalizer -> normalize ( $ stockUnits , $ format , $ context ) , ] ; }
2602	public function execute ( ) { $ result = $ this -> resultJsonFactory -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ dictionaryName = Config :: AUTH_DICTIONARY_NAME ; $ dictionary = $ this -> api -> getSingleDictionary ( $ activeVersion , $ dictionaryName ) ; if ( ( is_array ( $ dictionary ) && empty ( $ dictionary ) ) || $ dictionary == false ) { return $ result -> setData ( [ 'status' => false ] ) ; } else { return $ result -> setData ( [ 'status' => true ] ) ; } } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
7333	private function getStockUnitMapper ( EntityManagerInterface $ em ) { if ( null === $ this -> stockUnitMapper ) { $ this -> stockUnitMapper = new DiscriminatorMapper ( $ em , AbstractStockUnit :: class ) ; } return $ this -> stockUnitMapper ; }
8746	public function getListenerInstance ( EventDispatcher $ eventDispatcher = null , StreamableInterface $ stream = null ) { $ reflection = new \ ReflectionClass ( '\\Iber\\Phkey\\Environment\\' . $ this -> getEnvironment ( ) . '\\Matcher' ) ; $ matcher = $ reflection -> newInstance ( ) ; $ reflection = new \ ReflectionClass ( '\\Iber\\Phkey\\Environment\\' . $ this -> getEnvironment ( ) . '\\Listener' ) ; if ( null === $ eventDispatcher ) { $ eventDispatcher = new EventDispatcher ( ) ; } if ( null === $ stream ) { $ stream = new Stream ( ) ; } $ listener = $ reflection -> newInstance ( $ matcher , $ eventDispatcher , $ stream ) ; return $ listener ; }
594	private function composeCircularDependencyTrace ( $ circularDependencyName , array $ registered ) { $ dependencyTrace = [ ] ; $ startFound = false ; foreach ( $ registered as $ name => $ value ) { if ( $ name === $ circularDependencyName ) { $ startFound = true ; } if ( $ startFound && $ value === false ) { $ dependencyTrace [ ] = $ name ; } } $ dependencyTrace [ ] = $ circularDependencyName ; return implode ( ' -> ' , $ dependencyTrace ) ; }
4832	public function payout ( ) { if ( ! $ this -> payout_id ) { throw new GoCardless_ClientException ( "Cannot fetch payout for a bill that has not been paid out" ) ; } return GoCardless_Payout :: find_with_client ( $ this -> client , $ this -> payout_id ) ; }
8978	protected function getRateKey ( $ currencyCode , $ date , $ rateType , $ sourceName ) { return str_replace ( [ '%currency_code%' , '%date%' , '%rate_type%' , '%source_name%' ] , [ $ currencyCode , $ date -> format ( 'Y-m-d' ) , $ rateType , $ sourceName ] , '%currency_code%_%date%_%rate_type%_%source_name%' ) ; }
8808	public function get ( $ key = null ) { return ( is_null ( $ key ) ? $ _COOKIE : ( $ this -> has ( $ key ) ? $ _COOKIE [ $ key ] : null ) ) ; }
1460	protected function orderDesc ( ) { $ this -> query -> orderByDesc ( $ this -> column ) ; if ( $ this -> isNotPagingOnKey ( ) ) { $ this -> query -> orderByDesc ( $ this -> key ) ; } return $ this ; }
2288	public static function findUnactivatedByEmail ( $ strEmail , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ objDatabase = Database :: getInstance ( ) ; $ objResult = $ objDatabase -> prepare ( "SELECT * FROM $t WHERE email=? AND disable='1' AND EXISTS (SELECT * FROM tl_opt_in_related r LEFT JOIN tl_opt_in o ON r.pid=o.id WHERE r.relTable='$t' AND r.relId=$t.id AND o.createdOn>? AND o.confirmedOn=0)" ) -> limit ( 1 ) -> execute ( $ strEmail , strtotime ( '-24 hours' ) ) ; if ( $ objResult -> numRows < 1 ) { return null ; } $ objRegistry = Registry :: getInstance ( ) ; if ( $ objMember = $ objRegistry -> fetch ( $ t , $ objResult -> id ) ) { return $ objMember ; } return new static ( $ objResult ) ; }
12650	protected function readFileContents ( $ language ) { $ fileName = $ this -> getFileName ( $ language ) ; $ fs = $ this -> env -> getFileSystem ( ) ; if ( ! $ fs -> fileExists ( $ fileName ) ) { return array ( ) ; } $ content = json_decode ( preg_replace ( '/^.*?define\((.*)\);\s*/s' , '$1' , $ fs -> getFile ( $ fileName ) ) , true ) ; if ( $ language === $ this -> baseLang ) { $ content = $ content [ 'root' ] ; } $ outdateInfo = [ ] ; $ fileName = $ this -> getOutdateInfoFileName ( $ language ) ; if ( $ fs -> fileExists ( $ fileName ) ) { $ outdateInfo = json_decode ( $ fs -> getFile ( $ fileName ) , true ) ; } foreach ( $ content as $ id => $ text ) { $ outdated = isset ( $ outdateInfo [ $ id ] ) ? $ outdateInfo [ $ id ] : true ; $ content [ $ id ] = array ( 'id' => $ id , 'name' => $ id , 'content' => $ text , 'outdated' => $ outdated ) ; } return $ content ; }
10600	public function returnUrl ( ) { $ return = '' ; $ return .= empty ( $ this -> _urlParts [ 'scheme' ] ) ? '' : $ this -> _urlParts [ 'scheme' ] . '://' ; $ return .= empty ( $ this -> _urlParts [ 'user' ] ) ? '' : $ this -> _urlParts [ 'user' ] ; $ return .= empty ( $ this -> _urlParts [ 'pass' ] ) || empty ( $ this -> _urlParts [ 'user' ] ) ? '' : ':' . $ this -> _urlParts [ 'pass' ] ; $ return .= empty ( $ this -> _urlParts [ 'user' ] ) ? '' : '@' ; $ return .= empty ( $ this -> _urlParts [ 'host' ] ) ? '' : $ this -> _urlParts [ 'host' ] ; $ return .= empty ( $ this -> _urlParts [ 'port' ] ) ? '' : ':' . $ this -> _urlParts [ 'port' ] ; $ return .= empty ( $ this -> _urlParts [ 'path' ] ) ? '' : '/' . ltrim ( $ this -> _urlParts [ 'path' ] , '/' ) ; $ return .= empty ( $ this -> _urlParts [ 'query' ] ) ? '' : '?' . $ this -> _urlParts [ 'query' ] ; $ return .= empty ( $ this -> _urlParts [ 'fragment' ] ) ? '' : '#' . $ this -> _urlParts [ 'fragment' ] ; return $ return ; }
8443	public function exit ( $ id , $ pid , $ code , $ forceRetry = false , $ queueBackoffTime = null ) { $ this -> logger -> info ( 'Job ended' , [ 'exitCode' => $ code , 'pid' => $ pid , 'jobId' => $ id , 'queue' => $ this -> queue -> getName ( ) ] ) ; $ hash = explode ( ':' , $ id ) ; $ jobId = $ hash [ count ( $ hash ) - 1 ] ; try { $ job = $ this -> queue -> getJob ( $ jobId ) ; } catch ( JobNotFoundException $ e ) { $ this -> logger -> info ( 'Unable to process job exit code or retry status. Job data unavailable' , [ 'exitCode' => $ code , 'pid' => $ pid , 'jobId' => $ job -> getId ( ) , 'queue' => $ this -> queue -> getName ( ) ] ) ; return true ; } if ( $ code === 0 ) { $ this -> logger -> info ( 'Job succeeded and is now complete' , [ 'exitCode' => $ code , 'pid' => $ pid , 'jobId' => $ job -> getId ( ) , 'queue' => $ this -> queue -> getName ( ) ] ) ; return $ job -> end ( ) ; } else { $ retry = $ job -> getRetry ( ) ; if ( $ forceRetry === true ) { $ retry = true ; } if ( $ retry === true || $ retry > 0 ) { $ this -> logger -> info ( 'Rescheduling job' , [ 'exitCode' => $ code , 'pid' => $ pid , 'jobId' => $ job -> getId ( ) , 'queue' => $ this -> queue -> getName ( ) , 'time' => \ time ( ) + $ queueBackoffTime ?? 0 ] ) ; return $ job -> retry ( $ queueBackoffTime ) ; } else { $ this -> logger -> info ( 'Job failed' , [ 'exitCode' => $ code , 'pid' => $ pid , 'jobId' => $ job -> getId ( ) , 'queue' => $ this -> queue -> getName ( ) ] ) ; return $ job -> fail ( ) ; } } return ; }
3393	public function register ( Request $ request ) { $ this -> validator ( $ request -> all ( ) ) -> validate ( ) ; event ( new Registered ( $ user = $ this -> create ( $ request -> all ( ) ) ) ) ; $ this -> sendConfirmationToUser ( $ user ) ; return $ this -> registered ( $ request , $ user ) ? : redirect ( $ this -> redirectAfterRegistrationPath ( ) ) -> with ( 'confirmation' , __ ( 'confirmation::confirmation.confirmation_info' ) ) ; }
4851	protected function applyId ( & $ row , $ id , $ identifierField ) { $ ids = ( array ) $ id ; $ findId = function ( $ row ) use ( $ ids , $ identifierField ) { foreach ( $ ids as $ id ) { $ bool = true ; $ identifierField = $ this -> flatten ( $ identifierField ) ; foreach ( $ identifierField as $ identifier ) { $ bool = $ bool && ( mb_strtolower ( $ id [ $ identifier ] ) === mb_strtolower ( $ row [ $ identifier ] ) ) ; } if ( $ bool ) { return $ id [ 'id' ] ; } } return 0 ; } ; $ isDeep = $ this -> isDeep ( $ row ) ; if ( $ isDeep ) { foreach ( $ row as $ i => & $ r ) { $ r [ 'id' ] = $ findId ( $ r ) ; } } else { $ row [ 'id' ] = $ findId ( $ row ) ; } }
8023	public function synchronize ( \ Closure $ closure ) { $ this -> acquire ( ) ; call_user_func ( $ closure ) ; $ this -> release ( ) ; return $ this ; }
8194	public function render ( $ template , $ data = [ ] , $ return = true ) { if ( $ template instanceof Page ) { $ page = $ template ; $ file = $ page -> templateFile ( ) ; $ data = $ this -> data ( $ page , $ data ) ; } else { $ file = $ template ; $ data = $ this -> data ( null , $ data ) ; } if ( ! file_exists ( $ file ) ) { throw new Exception ( 'The template could not be found' ) ; } $ startData = Tpl :: $ data ; Tpl :: $ data = array_merge ( Tpl :: $ data , $ data ) ; if ( pathinfo ( $ file , PATHINFO_EXTENSION ) === 'twig' ) { $ twig = TwigEnv :: instance ( ) ; $ result = $ twig -> renderPath ( $ file , Tpl :: $ data , $ return , true ) ; } else { $ result = Tpl :: load ( $ file , [ ] , $ return ) ; } Tpl :: $ data = $ startData ; return $ result ; }
4926	public function getRegions ( $ type = null ) { if ( null === $ type ) { return array_keys ( $ this -> matrix ) ; } $ regions = [ ] ; foreach ( $ this -> matrix as $ region => $ types ) { if ( in_array ( $ type , $ types ) ) { $ regions [ ] = $ region ; } } return $ regions ; }
1367	protected function bootBladeDirectives ( ) { $ compiler = $ this -> app -> make ( BladeCompiler :: class ) ; $ compiler -> directive ( 'jsonapi' , Renderer :: class . '::compileWith' ) ; $ compiler -> directive ( 'encode' , Renderer :: class . '::compileEncode' ) ; }
456	public function dropForeignKey ( $ name , $ table ) { return 'ALTER TABLE ' . $ this -> db -> quoteTableName ( $ table ) . ' DROP CONSTRAINT ' . $ this -> db -> quoteColumnName ( $ name ) ; }
10426	private function body ( ResponseInterface $ response ) : ResponseInterface { if ( ! in_array ( $ response -> getStatusCode ( ) , $ this -> responseIsEmpty ) ) { $ stream = $ response -> getBody ( ) ; if ( $ stream -> isSeekable ( ) ) { $ stream -> rewind ( ) ; } $ bufferLenght = ( ! $ response -> getHeaderLine ( 'Content-Length' ) ) ? $ stream -> getSize ( ) : $ response -> getHeaderLine ( 'Content-Length' ) ; if ( isset ( $ bufferLenght ) ) { $ lengthToRead = $ bufferLenght ; while ( $ lengthToRead > 0 && ! $ stream -> eof ( ) ) { $ data = $ stream -> read ( min ( $ this -> sizeLimit , $ lengthToRead ) ) ; echo $ data ; $ lengthToRead -= strlen ( $ data ) ; } } else { while ( ! $ stream -> eof ( ) ) { echo $ stream -> read ( $ this -> size ) ; } } } return $ response ; }
7250	protected function validateDeliveryAddress ( SaleInterface $ sale , Constraint $ constraint ) { if ( ! $ sale -> isSameAddress ( ) && null === $ sale -> getDeliveryAddress ( ) ) { $ this -> context -> buildViolation ( $ constraint -> delivery_address_is_required ) -> atPath ( 'deliveryAddress' ) -> addViolation ( ) ; } elseif ( $ sale -> isSameAddress ( ) && null !== $ sale -> getDeliveryAddress ( ) ) { $ this -> context -> buildViolation ( $ constraint -> delivery_address_should_be_null ) -> atPath ( 'deliveryAddress' ) -> addViolation ( ) ; } }
12138	public function destroy ( QuestionRequest $ request , Question $ question ) { try { $ question -> delete ( ) ; return $ this -> response -> message ( trans ( 'messages.success.deleted' , [ 'Module' => trans ( 'forum::question.name' ) ] ) ) -> code ( 202 ) -> status ( 'success' ) -> url ( guard_url ( 'forum/question' ) ) -> redirect ( ) ; } catch ( Exception $ e ) { return $ this -> response -> message ( $ e -> getMessage ( ) ) -> code ( 400 ) -> status ( 'error' ) -> url ( guard_url ( 'forum/question/' . $ question -> getRouteKey ( ) ) ) -> redirect ( ) ; } }
11787	public static function getAgeByDate ( string $ sBirthday ) : int { list ( $ iYear , $ iMonth , $ iDay ) = preg_split ( '/[-.]/' , $ sBirthday ) ; $ aToday = array ( ) ; $ aToday [ 'mois' ] = date ( 'n' ) ; $ aToday [ 'jour' ] = date ( 'j' ) ; $ aToday [ 'annee' ] = date ( 'Y' ) ; $ iYears = $ aToday [ 'annee' ] - $ iYear ; if ( $ aToday [ 'mois' ] <= $ iMonth ) { if ( $ iMonth == $ aToday [ 'mois' ] ) { if ( $ iDay > $ aToday [ 'jour' ] ) { $ iYears -- ; } } else { $ iYears -- ; } } return $ iYears ; }
10552	public function resolveApp ( ) { $ this -> determineVirtualHost ( ) ; $ path = $ this -> vhost -> getPath ( $ this -> request -> url ) ; $ resolved = $ this -> resolver -> resolve ( "app" , $ path ) ; if ( $ resolved !== null ) { if ( $ resolved [ 'ext' ] ) { $ mime = new FileType ( $ resolved [ 'ext' ] , "" ) ; if ( ! empty ( $ mime ) ) { $ str = $ mime -> getMimeType ( ) . ";q=1.5," . ( string ) $ this -> request -> accept ; $ this -> request -> setAccept ( new Accept ( $ str ) ) ; } $ this -> suffix = $ resolved [ 'ext' ] ; } $ this -> route = $ resolved [ 'route' ] ; $ this -> app = $ resolved [ 'path' ] ; $ this -> arguments = new Dictionary ( $ resolved [ 'remainder' ] ) ; } else { $ this -> route = null ; $ this -> app = null ; $ this -> arguments = new Dictionary ( ) ; } }
9293	protected function getAssetsUrl ( ) { if ( ! isset ( $ this -> _assetsUrl ) ) { $ path = dirname ( __FILE__ ) . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . 'assets' ; $ this -> _assetsUrl = Yii :: app ( ) -> assetManager -> publish ( $ path , false , - 1 , $ this -> forceCopyAssets ) ; } return $ this -> _assetsUrl ; }
11316	public function handleUseRequest ( $ data , $ transactionId , $ transactionKey ) { if ( ! $ this -> objCredits ) { return null ; } if ( isset ( $ _POST [ 'transaction_id' ] ) && isset ( $ _POST [ 'transaction_secret' ] ) ) { $ valid = $ this -> objCredits -> isRequestValid ( $ _POST [ 'transaction_id' ] , $ _POST [ 'transaction_secret' ] ) ; if ( $ valid ) { $ amount = $ _POST [ 'transaction_amount' ] ; $ this -> objUser -> useCredit ( $ amount , $ data ) ; return true ; } else { $ this -> error = 'This request was not valid or already executed. Ignore.' ; } } else { $ this -> error = 'No post data received.' ; } return false ; }
4409	protected function render ( $ template , $ parameters ) { $ twig = new Twig_Environment ( new Twig_Loader_Filesystem ( $ this -> skeletonDirs ) , array ( 'debug' => true , 'cache' => false , 'strict_variables' => true , 'autoescape' => false , ) ) ; return $ twig -> render ( $ template , $ parameters ) ; }
2165	public static function convertMultiField ( $ table , $ field ) { $ objDatabase = Database :: getInstance ( ) ; $ objRow = $ objDatabase -> query ( "SELECT id, $field FROM $table WHERE $field!=''" ) ; $ objDesc = $ objDatabase -> query ( "DESC $table $field" ) ; if ( $ objDesc -> Type != 'blob' ) { $ objDatabase -> query ( "ALTER TABLE `$table` CHANGE `$field` `$field` blob NULL" ) ; $ objDatabase -> query ( "UPDATE `$table` SET `$field`=NULL WHERE `$field`=''" ) ; } while ( $ objRow -> next ( ) ) { $ arrValues = StringUtil :: deserialize ( $ objRow -> $ field , true ) ; if ( empty ( $ arrValues ) ) { continue ; } $ objHelper = static :: generateHelperObject ( $ arrValues ) ; if ( $ objHelper -> isUuid ) { continue ; } foreach ( $ arrValues as $ k => $ v ) { if ( $ objHelper -> isNumeric ) { $ objFile = FilesModel :: findByPk ( $ objHelper -> value [ $ k ] ) ; $ arrValues [ $ k ] = $ objFile -> uuid ; } else { $ objFile = FilesModel :: findByPath ( $ objHelper -> value [ $ k ] ) ; $ arrValues [ $ k ] = $ objFile -> uuid ; } } $ objDatabase -> prepare ( "UPDATE $table SET $field=? WHERE id=?" ) -> execute ( serialize ( $ arrValues ) , $ objRow -> id ) ; } }
11632	private function groupPvTrans ( $ transData ) { $ result = [ ] ; foreach ( $ transData as $ one ) { $ debitAccId = $ one -> get ( DTrans :: A_ACC_ID_DEBIT ) ; $ creditAccId = $ one -> get ( DTrans :: A_ACC_ID_CREDIT ) ; $ value = $ one -> get ( DTrans :: A_AMOUNT ) ; if ( isset ( $ result [ $ debitAccId ] ) ) { $ result [ $ debitAccId ] -= $ value ; } else { $ result [ $ debitAccId ] = - $ value ; } if ( isset ( $ result [ $ creditAccId ] ) ) { $ result [ $ creditAccId ] += $ value ; } else { $ result [ $ creditAccId ] = $ value ; } } return $ result ; }
1404	public function add ( $ record , array $ relationship , EncodingParametersInterface $ parameters ) { $ related = $ this -> findRelated ( $ record , $ relationship ) ; $ relation = $ this -> getRelation ( $ record , $ this -> key ) ; $ existing = $ relation -> getQuery ( ) -> whereKey ( $ related -> modelKeys ( ) ) -> get ( ) ; $ relation -> saveMany ( $ related -> diff ( $ existing ) ) ; $ record -> refresh ( ) ; return $ record ; }
5938	public function addFunctionality ( $ item ) { if ( ! ( $ item instanceof Functionality ) ) { if ( is_array ( $ item ) ) { try { $ item = new Functionality ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate Functionality. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "Functionality"!' , E_USER_WARNING ) ; } } $ this -> functionalities [ ] = $ item ; return $ this ; }
5394	public function paintError ( $ message ) { parent :: paintError ( $ message ) ; print $ this -> getIndent ( 1 ) ; print '<' . $ this -> namespace . 'exception>' ; print $ this -> toParsedXml ( $ message ) ; print '</' . $ this -> namespace . "exception>\n" ; }
7432	public function guess ( string $ path ) : string { if ( ! is_file ( $ path ) ) { throw new FileNotFoundException ( $ path ) ; } if ( ! is_readable ( $ path ) ) { throw new AccessDeniedException ( $ path ) ; } if ( 0 == count ( $ this -> guesserList ) ) { $ msg = 'Unable to guess the mime type as no guessers are available' ; if ( ! FileInfoMimeType :: isSupported ( ) ) { $ msg .= ' (Did you enable the php_fileinfo extension?)' ; } throw new \ LogicException ( $ msg ) ; } foreach ( $ this -> guesserList as $ guesser ) { if ( '' != $ mimeType = $ guesser -> guess ( $ path ) ) { return $ mimeType ; } } return '' ; }
12691	protected function outputError ( $ errorNumber , $ test , $ exception ) { $ feature = null ; $ scenario = null ; $ testDescription = null ; $ node = $ test ; while ( $ node !== null ) { $ class = get_class ( $ node ) ; $ description = str_replace ( "\n " , "\n " , $ node -> getDescription ( ) ) ; if ( $ description === '' ) { $ node = $ node -> getParent ( ) ; continue ; } if ( $ class === 'Peridot\Core\Test' ) { $ testDescription = $ description ; } elseif ( $ class === 'Peridot\Core\Suite' ) { if ( strpos ( $ description , 'Feature:' ) === 0 ) { $ feature = $ description ; } else { $ scenario = trim ( $ description ) ; } } $ node = $ node -> getParent ( ) ; } if ( $ this -> lastFeature !== $ feature ) { $ this -> output -> writeln ( " " . $ feature . "\n" ) ; $ this -> lastFeature = $ feature ; $ this -> lastScenario = null ; } if ( $ this -> lastScenario !== $ scenario ) { $ this -> output -> writeln ( " " . $ scenario . "\n" ) ; $ this -> lastScenario = $ scenario ; } $ this -> output -> writeln ( $ this -> color ( 'error' , sprintf ( " %d) %s" , $ errorNumber , $ testDescription ) ) ) ; $ message = sprintf ( " %s" , str_replace ( "\n" , "\n " , $ exception -> getMessage ( ) ) ) ; $ this -> output -> writeln ( $ this -> color ( 'pending' , $ message ) ) ; $ class = method_exists ( $ exception , 'getClass' ) ? $ exception -> getClass ( ) : get_class ( $ exception ) ; $ trace = method_exists ( $ exception , 'getTrueTrace' ) ? $ exception -> getTrueTrace ( ) : $ exception -> getTrace ( ) ; array_unshift ( $ trace , [ 'function' => $ class . ' thrown' , 'file' => $ exception -> getFile ( ) , 'line' => $ exception -> getLine ( ) ] ) ; $ this -> outputTrace ( $ trace ) ; }
5727	public function recordIsDeletedFromStage ( ) { if ( $ this -> owner -> hasMethod ( 'getIsDeletedFromStage' ) ) { return $ this -> owner -> IsDeletedFromStage ; } if ( ! $ this -> owner -> record -> checkVersioned ( ) ) { return false ; } if ( ! $ this -> owner -> record -> isInDB ( ) ) { return true ; } $ class = $ this -> owner -> record -> class ; $ stageVersion = Versioned :: get_versionnumber_by_stage ( $ class , 'Stage' , $ this -> owner -> record -> ID ) ; return ! ( $ stageVersion ) ; }
2684	private function _fetch ( $ uri , $ method = \ Zend_Http_Client :: GET , $ body = '' , $ test = false , $ testApiKey = null , $ logError = true ) { $ apiKey = ( $ test == true ) ? $ testApiKey : $ this -> config -> getApiKey ( ) ; if ( is_array ( $ body ) == true ) { $ body = http_build_query ( $ body ) ; } $ headers = [ self :: FASTLY_HEADER_AUTH . ': ' . $ apiKey , 'Accept: application/json' ] ; $ options = [ ] ; switch ( $ method ) { case \ Zend_Http_Client :: DELETE : $ options [ CURLOPT_CUSTOMREQUEST ] = \ Zend_Http_Client :: DELETE ; break ; case \ Zend_Http_Client :: PUT : $ headers [ ] = 'Content-Type: application/x-www-form-urlencoded' ; $ options [ CURLOPT_CUSTOMREQUEST ] = \ Zend_Http_Client :: PUT ; if ( $ body != '' ) { $ options [ CURLOPT_POSTFIELDS ] = $ body ; } break ; case \ Zend_Http_Client :: PATCH : $ options [ CURLOPT_CUSTOMREQUEST ] = \ Zend_Http_Client :: PATCH ; $ headers [ ] = 'Content-Type: text/json' ; if ( $ body != '' ) { $ options [ CURLOPT_POSTFIELDS ] = $ body ; } break ; } $ client = $ this -> curlFactory -> create ( ) ; $ client -> setOptions ( $ options ) ; $ client -> write ( $ method , $ uri , '1.1' , $ headers , $ body ) ; $ response = $ client -> read ( ) ; $ client -> close ( ) ; $ responseBody = \ Zend_Http_Response :: extractBody ( $ response ) ; $ responseCode = \ Zend_Http_Response :: extractCode ( $ response ) ; $ responseMessage = \ Zend_Http_Response :: extractMessage ( $ response ) ; if ( $ responseCode == '429' ) { throw new LocalizedException ( __ ( $ responseMessage ) ) ; } elseif ( $ responseCode != '200' ) { if ( $ logError == true ) { $ this -> logger -> critical ( 'Return status ' . $ responseCode , $ uri ) ; } return false ; } return json_decode ( $ responseBody ) ; }
8558	public function setFinancialEventGroupList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'FinancialEventGroupList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
5697	public function baseTransform ( ) { parent :: baseTransform ( ) ; $ disabled = ( ! $ this -> gridFieldRequest -> getPreviousRecordID ( ) ) ; return $ this -> setDisabled ( $ disabled ) ; }
2134	public static function remove ( $ strKey ) { $ objConfig = static :: getInstance ( ) ; if ( strncmp ( $ strKey , '$GLOBALS' , 8 ) !== 0 ) { $ strKey = "\$GLOBALS['TL_CONFIG']['$strKey']" ; } $ objConfig -> delete ( $ strKey ) ; }
12128	public function run ( InputInterface $ input , OutputInterface $ output ) { $ this -> returnCode = static :: RETURN_SUCCESS ; $ this -> doPreRun ( $ input , $ output ) ; if ( ! $ this -> executeDependencies ( $ input , $ output ) ) { $ this -> returnCode = static :: RETURN_ERROR ; } else { $ this -> returnCode = ( int ) $ this -> execute ( $ input , $ output ) ; } $ this -> doPostRun ( $ input , $ output , $ this -> returnCode ) ; return $ this -> returnCode ; }
1089	protected function getStub ( $ name ) { if ( stripos ( $ name , '.php' ) === FALSE ) $ name = $ name . '.php' ; return $ this -> files -> get ( $ this -> getStubPath ( ) . '/' . $ name ) ; }
11178	public function getApi ( ) { $ api = $ this -> get ( Keys :: EXT_API ) ; if ( is_array ( $ api ) ) { return $ api ; } return false ; }
5889	public function getViewer ( IViewer $ viewer ) { $ html = $ viewer -> fetchObject ( $ this ) ; $ iterator = new \ RecursiveIteratorIterator ( $ this , \ RecursiveIteratorIterator :: SELF_FIRST ) ; foreach ( $ iterator as $ node ) { $ siblings = array ( ) ; for ( $ level = 0 ; $ level < $ iterator -> getDepth ( ) ; $ level ++ ) { $ siblings [ ] = ( $ iterator -> getSubIterator ( $ level ) -> hasNext ( ) ) ? 1 : 0 ; } $ siblings [ ] = ( ! $ iterator -> getSubIterator ( $ level ) -> hasNext ( ) ) ? 1 : 0 ; $ html .= $ viewer -> fetchObject ( $ node , $ siblings ) ; } return $ html ; }
7259	protected function getRealGrossBase ( Model \ SaleInterface $ sale ) : float { $ cache = $ this -> cache ; $ this -> cache = false ; $ base = $ this -> calculateSaleItems ( $ sale ) -> getBase ( ) ; $ this -> cache = $ cache ; return $ base ; }
65	public function normalizePath ( $ path ) { $ parts = array ( ) ; $ path = strtr ( $ path , '\\' , '/' ) ; $ prefix = '' ; $ absolute = false ; if ( preg_match ( '{^( [0-9a-z]{2,}+: (?: // (?: [a-z]: )? )? | [a-z]: )}ix' , $ path , $ match ) ) { $ prefix = $ match [ 1 ] ; $ path = substr ( $ path , strlen ( $ prefix ) ) ; } if ( substr ( $ path , 0 , 1 ) === '/' ) { $ absolute = true ; $ path = substr ( $ path , 1 ) ; } $ up = false ; foreach ( explode ( '/' , $ path ) as $ chunk ) { if ( '..' === $ chunk && ( $ absolute || $ up ) ) { array_pop ( $ parts ) ; $ up = ! ( empty ( $ parts ) || '..' === end ( $ parts ) ) ; } elseif ( '.' !== $ chunk && '' !== $ chunk ) { $ parts [ ] = $ chunk ; $ up = '..' !== $ chunk ; } } return $ prefix . ( $ absolute ? '/' : '' ) . implode ( '/' , $ parts ) ; }
344	public static function mailto ( $ text , $ email = null , $ options = [ ] ) { $ options [ 'href' ] = 'mailto:' . ( $ email === null ? $ text : $ email ) ; return static :: tag ( 'a' , $ text , $ options ) ; }
2846	public function getUrl ( $ path , array $ params = array ( ) ) { $ path = self :: MODULE_ROUTE . $ path ; $ params [ '_store' ] = $ this -> getRouteStoreId ( ) ; $ params [ '_nosid' ] = true ; return $ this -> _getUrl ( $ path , $ params ) ; }
4962	public function addViewModel ( $ name , $ model , $ priority = 0 ) { $ this -> models -> insert ( $ name , $ model , $ priority ) ; return $ this ; }
5787	public function routeGetLogout ( Request $ request , Response $ response ) { $ this -> events -> setAdministratorId ( $ this -> authentication -> getAdministratorId ( ) ) ; if ( null === $ username = $ this -> authentication -> getAdministratorUsername ( ) ) { $ this -> events -> insertWarning ( EVENT_LOGOUT_FAULT ) ; } else { $ this -> events -> insertInfo ( EVENT_LOGOUT ) ; $ this -> authentication -> logout ( ) ; } return $ response -> withRedirect ( $ this -> router -> pathFor ( ROUTE_HOME ) ) ; }
931	public function clear ( ) { @ trigger_error ( __METHOD__ . ' is deprecated and will be removed in 3.0.' , E_USER_DEPRECATED ) ; Tokens :: setLegacyMode ( true ) ; $ this -> content = '' ; $ this -> id = null ; $ this -> isArray = false ; }
10140	private function readRecordData ( $ data , $ pos , $ len ) { $ data = substr ( $ data , $ pos , $ len ) ; if ( $ this -> encryption == self :: MS_BIFF_CRYPTO_NONE || $ pos < $ this -> encryptionStartPos ) { return $ data ; } $ recordData = '' ; if ( $ this -> encryption == self :: MS_BIFF_CRYPTO_RC4 ) { $ oldBlock = floor ( $ this -> rc4Pos / self :: REKEY_BLOCK ) ; $ block = floor ( $ pos / self :: REKEY_BLOCK ) ; $ endBlock = floor ( ( $ pos + $ len ) / self :: REKEY_BLOCK ) ; if ( $ block != $ oldBlock || $ pos < $ this -> rc4Pos || ! $ this -> rc4Key ) { $ this -> rc4Key = $ this -> makeKey ( $ block , $ this -> md5Ctxt ) ; $ step = $ pos % self :: REKEY_BLOCK ; } else { $ step = $ pos - $ this -> rc4Pos ; } $ this -> rc4Key -> RC4 ( str_repeat ( "\0" , $ step ) ) ; while ( $ block != $ endBlock ) { $ step = self :: REKEY_BLOCK - ( $ pos % self :: REKEY_BLOCK ) ; $ recordData .= $ this -> rc4Key -> RC4 ( substr ( $ data , 0 , $ step ) ) ; $ data = substr ( $ data , $ step ) ; $ pos += $ step ; $ len -= $ step ; ++ $ block ; $ this -> rc4Key = $ this -> makeKey ( $ block , $ this -> md5Ctxt ) ; } $ recordData .= $ this -> rc4Key -> RC4 ( substr ( $ data , 0 , $ len ) ) ; $ this -> rc4Pos = $ pos + $ len ; } elseif ( $ this -> encryption == self :: MS_BIFF_CRYPTO_XOR ) { throw new Exception ( 'XOr encryption not supported' ) ; } return $ recordData ; }
768	protected function regenerateCsrfToken ( ) { $ request = Yii :: $ app -> getRequest ( ) ; if ( $ request -> enableCsrfCookie || $ this -> enableSession ) { $ request -> getCsrfToken ( true ) ; } }
9436	public function get ( ) { if ( $ this -> r || $ this -> i ) { if ( ! is_object ( $ this -> i ) ) { return new Complex ( self :: random ( $ this -> r -> min , $ this -> r -> max ) , 0 ) ; } if ( ! is_object ( $ this -> r ) ) { return new Complex ( 0 , self :: random ( $ this -> i -> min , $ this -> i -> max ) ) ; } return new Complex ( self :: random ( $ this -> r -> min , $ this -> r -> max ) , self :: random ( $ this -> i -> min , $ this -> i -> max ) ) ; } if ( $ this -> rho || $ this -> theta ) { if ( ! is_object ( $ this -> theta ) ) { return new Complex ( self :: random ( $ this -> rho -> min , $ this -> rho -> max ) , 0 , Complex :: TRIGONOMETRIC ) ; } if ( ! is_object ( $ this -> rho ) ) { return new Complex ( 0 , self :: random ( $ this -> theta -> min , $ this -> theta -> max ) , Complex :: TRIGONOMETRIC ) ; } return new Complex ( self :: random ( $ this -> rho -> min , $ this -> rho -> max ) , self :: random ( $ this -> theta -> min , $ this -> theta -> max ) , Complex :: TRIGONOMETRIC ) ; } }
3353	public function updateInfo ( ) { $ this -> cached_data = ( array ) $ this -> api -> __preparedRequest ( 'file' , 'GET' , array ( 'uuid' => $ this -> uuid ) ) ; return $ this -> cached_data ; }
4860	public function push ( JobInterface $ job , array $ options = [ ] ) { $ envelope = $ this -> createEnvelope ( $ job , $ options ) ; $ result = $ this -> mongoCollection -> insertOne ( $ envelope ) ; $ job -> setId ( ( string ) $ result -> getInsertedId ( ) ) ; }
8831	protected function getCheckboxCheckedState ( $ name , $ value , $ checked ) { $ posted = $ this -> getValueAttribute ( $ name , $ checked ) ; if ( is_array ( $ posted ) ) { return in_array ( $ value , $ posted ) ; } else { return ( bool ) $ posted ; } }
8318	public function minLength ( $ n ) { $ this -> constraints [ ] = ( function ( Password $ str ) use ( $ n ) { if ( mb_strlen ( $ str ) < $ n ) { return sprintf ( "Minimum password length is %d characters." , $ n ) ; } else { return true ; } } ) ; return $ this ; }
12831	private function onTokenFound ( $ token ) { if ( is_array ( $ token ) ) $ token = array_pop ( $ token ) ; $ token = trim ( $ token ) ; $ tokenParts = explode ( ' ' , $ token ) ; $ tag = array_shift ( $ tokenParts ) ; $ params = implode ( ' ' , $ tokenParts ) ; if ( $ this -> _blocks -> has ( $ tag ) ) { if ( $ this -> _blocks -> getDeepValue ( $ tag . '/runtime' ) ) { $ res = '<?php $this->_compiler->invokeBlock(\'' . $ tag . '\', ' . $ this -> compileExpression ( $ params ) . '); ?>' ; } else { $ res = $ this -> onBlockTagOpen ( $ tag , $ params ) ; } } elseif ( substr ( $ tag , 0 , strlen ( $ this -> _config [ 'blockClose' ] ) ) == $ this -> _config [ 'blockClose' ] ) { $ tag = substr ( $ tag , strlen ( $ this -> _config [ 'blockClose' ] ) ) ; $ res = $ this -> onBlockTagClose ( $ tag , $ params ) ; } else { $ res = $ this -> onVarEchoToken ( $ token , $ params ) ; } return $ res ; }
7329	private function configurePaymentTermSubjectMapping ( LoadClassMetadataEventArgs $ eventArgs ) { $ metadata = $ eventArgs -> getClassMetadata ( ) ; $ class = $ metadata -> getName ( ) ; if ( ! is_subclass_of ( $ class , Payment \ PaymentTermSubjectInterface :: class ) ) { return ; } if ( in_array ( $ class , $ this -> paymentTermSubjectClassCache ) ) { return ; } if ( ! $ metadata -> hasAssociation ( 'paymentTerm' ) ) { $ metadata -> mapManyToOne ( [ 'fieldName' => 'paymentTerm' , 'targetEntity' => Payment \ PaymentTermInterface :: class , 'joinColumns' => [ [ 'name' => 'payment_term_id' , 'referencedColumnName' => 'id' , 'onDelete' => 'RESTRICT' , 'nullable' => true , ] , ] , ] ) ; } $ this -> paymentTermSubjectClassCache [ ] = $ class ; }
1727	public function findBy ( $ strColumn , $ varValue ) { $ objResult = $ this -> Database -> prepare ( "SELECT * FROM " . $ this -> strTable . " WHERE " . Database :: quoteIdentifier ( $ strColumn ) . "=?" ) -> limit ( 1 ) -> execute ( $ varValue ) ; if ( $ objResult -> numRows > 0 ) { $ this -> arrData = $ objResult -> row ( ) ; return true ; } return false ; }
11838	public function set ( $ key , $ value ) { if ( $ this -> cacheEnabled ) { $ this -> cacheEngine -> set ( $ key , $ value ) ; } }
12959	public function update ( $ table , $ data = array ( ) , $ where = '1=1' ) { if ( ! $ this -> getDb ( ) -> update ( $ table , $ data , $ where ) ) { throw new DbException ( "Failed updating " . $ table ) ; } return true ; }
3583	protected function joinMeta ( Builder $ query , $ column ) { $ query -> prefixColumnsForJoin ( ) ; $ alias = $ this -> generateMetaAlias ( ) ; $ table = ( new Attribute ) -> getTable ( ) ; $ query -> leftJoin ( "{$table} as {$alias}" , function ( $ join ) use ( $ alias , $ column ) { $ join -> on ( "{$alias}.metable_id" , '=' , $ this -> getQualifiedKeyName ( ) ) -> where ( "{$alias}.metable_type" , '=' , $ this -> getMorphClass ( ) ) -> where ( "{$alias}.meta_key" , '=' , $ column ) ; } ) ; return $ alias ; }
9482	private function prepare ( array $ folders ) { return collect ( $ folders ) -> mapWithKeys ( function ( $ folder ) { $ path = base_path ( $ folder ) ; return [ $ folder => [ 'chmod' => ( int ) substr ( sprintf ( '%o' , fileperms ( $ path ) ) , - 4 ) , 'writable' => is_writable ( $ path ) , ] , ] ; } ) ; }
3301	public function request ( $ method , $ url , $ options = [ ] ) { $ method = strtoupper ( $ method ) ; $ options = array_merge ( self :: $ defaults , [ 'headers' => $ this -> headers ] , $ options ) ; return $ this -> getClient ( ) -> request ( $ method , $ url , $ options ) ; }
9439	public function alias ( $ id , $ original ) { $ this -> instances [ $ id ] = $ this -> get ( $ original ) ; return $ this ; }
1612	private function _setCriteriaIdByType ( $ criteria , Element $ type , $ id ) { switch ( $ type :: className ( ) ) { case 'Entry' : $ criteria -> sectionId = $ id ; break ; case 'Category' : $ criteria -> groupId = $ id ; break ; } }
11344	public function removeField ( $ name ) { for ( $ i = 0 ; $ i < count ( $ this -> fields ) ; $ i ++ ) { if ( $ this -> fields [ $ i ] -> getName ( ) == $ name ) { array_splice ( $ this -> fields , $ i , 1 ) ; break ; } } }
2145	public function replace ( $ strBuffer , $ blnCache = true ) { $ strBuffer = $ this -> doReplace ( $ strBuffer , $ blnCache ) ; while ( strpos ( $ strBuffer , '{{' ) !== false && ( $ strTmp = $ this -> doReplace ( $ strBuffer , $ blnCache ) ) != $ strBuffer ) { $ strBuffer = $ strTmp ; } return $ strBuffer ; }
7431	public static function getInstance ( ) : MimeType { if ( null === self :: $ instance ) { self :: $ instance = new self ( ) ; } return self :: $ instance ; }
10272	function addCustomProperties ( $ mailingId , $ properties ) { $ xml = new SimpleXMLElement ( "<?xml version=\"1.0\"?><properties></properties>" ) ; if ( is_array ( $ properties ) ) { foreach ( $ properties as $ property ) { $ this -> sxml_append ( $ xml , $ property -> toXML ( ) ) ; } } else { $ this -> sxml_append ( $ xml , $ properties -> toXML ( ) ) ; } return $ this -> post ( "mailings/${mailingId}/settings/properties" , $ xml -> asXML ( ) ) ; }
7728	public function quickReplies ( $ text , $ quickReplies ) { $ this -> setText ( $ text ) ; foreach ( $ quickReplies as $ quickReplie ) { $ this -> setQuickReplies ( $ quickReplie ) ; } return $ this ; }
10512	private function orderObserversForPriority ( $ a , $ b ) { if ( $ a -> order > $ b -> order ) { return + 1 ; } elseif ( $ a -> order == $ b -> order ) { return 0 ; } return - 1 ; }
9817	public function setView ( $ pValue ) { if ( $ pValue === null ) { $ pValue = self :: SHEETVIEW_NORMAL ; } if ( in_array ( $ pValue , self :: $ sheetViewTypes ) ) { $ this -> sheetviewType = $ pValue ; } else { throw new PhpSpreadsheetException ( 'Invalid sheetview layout type.' ) ; } return $ this ; }
4827	public static function find ( $ id ) { $ endpoint = self :: $ endpoint . '/' . $ id ; return new self ( GoCardless :: $ client , GoCardless :: $ client -> request ( 'get' , $ endpoint ) ) ; }
3132	public function init ( RunnerServiceContext $ context ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ session = $ context -> getTestSession ( ) ; if ( $ session -> getState ( ) === AssessmentTestSessionState :: INITIAL ) { $ session -> beginTestSession ( ) ; $ event = new TestInitEvent ( $ session ) ; $ this -> getServiceManager ( ) -> get ( EventManager :: SERVICE_ID ) -> trigger ( $ event ) ; \ common_Logger :: i ( "Assessment Test Session begun." ) ; if ( $ context -> isAdaptive ( ) ) { \ common_Logger :: t ( "Very first item is adaptive." ) ; $ nextCatItemId = $ context -> selectAdaptiveNextItem ( ) ; $ context -> persistCurrentCatItemId ( $ nextCatItemId ) ; $ context -> persistSeenCatItemIds ( $ nextCatItemId ) ; } } elseif ( $ session -> getState ( ) === AssessmentTestSessionState :: SUSPENDED ) { $ session -> resume ( ) ; } $ session -> initItemTimer ( ) ; if ( $ session -> isTimeout ( ) === false ) { TestRunnerUtils :: beginCandidateInteraction ( $ session ) ; } $ this -> getServiceManager ( ) -> get ( ExtendedStateService :: SERVICE_ID ) -> clearEvents ( $ session -> getSessionId ( ) ) ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'init' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return true ; }
10349	public function validateArgSet ( $ set ) { if ( isset ( $ set ) ) { foreach ( $ set as $ arg ) { if ( ! isset ( $ this -> { $ arg } ) ) { throw new \ Exception ( 'Response not valid: ' . $ arg . ' has not been set!' ) ; } } } }
8088	public function generateUserPassword ( User $ user , $ password , $ generateOld = false ) { $ registrationDate = $ user -> RegDate ; $ pre = $ this -> encode ( $ registrationDate ) ; $ pos = substr ( $ registrationDate , 5 , 1 ) ; $ post = $ this -> encode ( $ registrationDate * ( substr ( $ registrationDate , $ pos , 1 ) ) ) ; $ finalString = $ pre . $ password . $ post ; return $ generateOld ? md5 ( $ finalString ) : sha1 ( $ finalString ) ; }
3195	public function setConsumedExtraTime ( $ time ) { $ this -> consumedExtraTime = max ( $ this -> consumedExtraTime , floatval ( $ time ) ) ; return $ this ; }
1195	private function getExtensions ( ) { if ( null === $ this -> sorted ) { krsort ( $ this -> extensions ) ; $ this -> sorted = ! empty ( $ this -> extensions ) ? call_user_func_array ( 'array_merge' , $ this -> extensions ) : array ( ) ; } return $ this -> sorted ; }
12051	protected function _createRendererException ( $ message = null , $ code = null , RootException $ previous = null , RendererInterface $ renderer = null ) { return new RendererException ( $ message , $ code , $ previous , $ renderer ) ; }
3981	private function getChildModelCaption ( $ metaModel , $ screen ) { $ caption = [ '' , sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'metamodel_edit_as_child' ] [ 'label' ] , $ metaModel -> getName ( ) ) ] ; foreach ( $ screen [ 'label' ] as $ langCode => $ label ) { if ( ! empty ( $ label ) && $ langCode === $ GLOBALS [ 'TL_LANGUAGE' ] ) { $ caption = [ $ screen [ 'description' ] [ $ langCode ] , $ label ] ; } } return $ caption ; }
6355	public function setTimestamp ( $ ts = false ) { $ m = [ ] ; $ da = [ ] ; $ strtime = '' ; if ( ! $ ts || $ ts === "\0\0\0\0\0\0\0\0\0\0\0\0\0\0" ) { $ uts = self :: time ( ) ; $ strtime = "@$uts" ; } elseif ( preg_match ( '/^(\d{4})\-(\d\d)\-(\d\d) (\d\d):(\d\d):(\d\d)$/D' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^(\d{4}):(\d\d):(\d\d) (\d\d):(\d\d):(\d\d)$/D' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^(\d{4})(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)$/D' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^(-?\d{1,13})$/D' , $ ts , $ m ) ) { $ strtime = "@{$m[1]}" ; } elseif ( preg_match ( '/^(-?\d{1,13})(\.\d+)$/D' , $ ts , $ m ) ) { $ strtime = 'unixmicro' ; } elseif ( preg_match ( '/^\d{2}-\d{2}-\d{4} \d{2}:\d{2}:\d{2}.\d{6}$/' , $ ts ) ) { $ strtime = preg_replace ( '/(\d\d)\.(\d\d)\.(\d\d)(\.(\d+))?/' , "$1:$2:$3" , str_replace ( '+00:00' , 'UTC' , $ ts ) ) ; } elseif ( preg_match ( '/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})(?:\.*\d*)?Z?$/' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^(\d{4})(\d{2})(\d{2})T(\d{2})(\d{2})(\d{2})(?:\.*\d*)?Z?$/' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^(\d{4})\-(\d\d)\-(\d\d) (\d\d):(\d\d):(\d\d)\.*\d*[\+\- ](\d\d)$/' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^(\d{4})\-(\d\d)\-(\d\d) (\d\d):(\d\d):(\d\d)\.*\d* GMT$/' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^[ \t\r\n]*([A-Z][a-z]{2},[ \t\r\n]*)?' . '\d\d?[ \t\r\n]*[A-Z][a-z]{2}[ \t\r\n]*\d{2}(?:\d{2})?' . '[ \t\r\n]*\d\d[ \t\r\n]*:[ \t\r\n]*\d\d[ \t\r\n]*:[ \t\r\n]*\d\d/S' , $ ts ) ) { $ strtime = strtok ( $ ts , ';' ) ; } elseif ( preg_match ( '/^[A-Z][a-z]{5,8}, \d\d-[A-Z][a-z]{2}-\d{2} \d\d:\d\d:\d\d/' , $ ts ) ) { $ strtime = $ ts ; } elseif ( preg_match ( '/^[A-Z][a-z]{2} [A-Z][a-z]{2} +\d{1,2} \d\d:\d\d:\d\d \d{4}/' , $ ts ) ) { $ strtime = $ ts ; } else { throw new TimestampException ( __METHOD__ . ": Invalid timestamp - $ts" ) ; } if ( ! $ strtime ) { $ da = array_map ( 'intval' , $ da ) ; $ da [ 0 ] = "%04d-%02d-%02dT%02d:%02d:%02d.00+00:00" ; $ strtime = call_user_func_array ( "sprintf" , $ da ) ; } try { if ( $ strtime === 'unixmicro' ) { $ final = DateTime :: createFromFormat ( 'U.u' , $ ts , new DateTimeZone ( 'GMT' ) ) ; } else { $ final = new DateTime ( $ strtime , new DateTimeZone ( 'GMT' ) ) ; } } catch ( Exception $ e ) { throw new TimestampException ( __METHOD__ . ': Invalid timestamp format.' , $ e -> getCode ( ) , $ e ) ; } if ( $ final === false ) { throw new TimestampException ( __METHOD__ . ': Invalid timestamp format.' ) ; } $ this -> timestamp = $ final ; }
5196	public function addSearchResult ( $ index , $ type , array $ documents ) { $ result = [ 'took' => 5 , 'timed_out' => false , '_shards' => [ 'total' => 5 , 'successful' => 5 , 'failed' => 0 ] , 'hits' => [ 'total' => count ( $ documents ) , 'max_score' => 1 , 'hits' => [ ] ] ] ; foreach ( $ documents as $ document ) { $ result [ 'hits' ] [ 'hits' ] [ ] = [ '_index' => $ index , '_type' => $ type , '_id' => $ document [ 'id' ] , '_score' => 1 , '_source' => $ document ] ; } return $ this -> addResult ( 'search' , $ result ) ; }
1602	private function _getSocialFallback ( ) { $ image = null ; $ assets = \ Craft :: $ app -> assets ; $ fieldFallback = $ this -> _fieldSettings [ 'socialImage' ] ; if ( ! empty ( $ fieldFallback ) ) $ image = $ assets -> getAssetById ( ( int ) $ fieldFallback [ 0 ] ) ; else { $ seoFallback = $ this -> _seoSettings [ 'socialImage' ] ; if ( ! empty ( $ seoFallback ) ) $ image = $ assets -> getAssetById ( ( int ) $ seoFallback [ 0 ] ) ; } return [ 'title' => $ this -> title , 'description' => $ this -> description , 'image' => $ image , ] ; }
2873	public function getRequestFilters ( Mage_Core_Controller_Request_Http $ request ) { if ( ! $ this -> requestFilterValues ) { $ filters = $ this -> getFilterParams ( ) ; $ this -> requestFilterValues = array ( ) ; foreach ( $ filters as $ filter ) { $ param = $ request -> getParam ( $ filter , null ) ; if ( $ param !== null ) { $ this -> requestFilterValues [ $ filter ] = $ param ; } } } return $ this -> requestFilterValues ; }
517	public function actionFresh ( ) { if ( YII_ENV_PROD ) { $ this -> stdout ( "YII_ENV is set to 'prod'.\nRefreshing migrations is not possible on production systems.\n" ) ; return ExitCode :: OK ; } if ( $ this -> confirm ( "Are you sure you want to reset the database and start the migration from the beginning?\nAll data will be lost irreversibly!" ) ) { $ this -> truncateDatabase ( ) ; $ this -> actionUp ( ) ; } else { $ this -> stdout ( 'Action was cancelled by user. Nothing has been performed.' ) ; } }
9055	public function addColumnToRename ( string $ name , Column $ column ) : self { $ this -> oldColumns [ $ name ] = $ column ; return $ this ; }
7006	private function formatD ( & $ str ) { if ( strstr ( $ str , '%D' ) ) $ str = str_replace ( '%D' , $ this -> dayName ( false ) , $ str ) ; }
12877	public function generateAndroidManifest ( ) { $ pinicon = $ this -> owner -> AndroidPinicon ( ) ; if ( $ pinicon -> exists ( ) ) { $ manifest = new stdClass ( ) ; $ manifest -> name = $ this -> owner -> PiniconTitle ; $ manifest -> icons = array ( ) ; array_push ( $ manifest -> icons , array ( 'src' => $ pinicon -> Fill ( 36 , 36 ) -> getAbsoluteURL ( ) , 'sizes' => '36x36' , 'type' => 'image/png' , 'density' => 0.75 ) ) ; array_push ( $ manifest -> icons , array ( 'src' => $ pinicon -> Fill ( 48 , 48 ) -> getAbsoluteURL ( ) , 'sizes' => '48x48' , 'type' => 'image/png' , 'density' => 1 ) ) ; array_push ( $ manifest -> icons , array ( 'src' => $ pinicon -> Fill ( 72 , 72 ) -> getAbsoluteURL ( ) , 'sizes' => '72x72' , 'type' => 'image/png' , 'density' => 1.5 ) ) ; array_push ( $ manifest -> icons , array ( 'src' => $ pinicon -> Fill ( 96 , 96 ) -> getAbsoluteURL ( ) , 'sizes' => '96x96' , 'type' => 'image/png' , 'density' => 2 ) ) ; array_push ( $ manifest -> icons , array ( 'src' => $ pinicon -> Fill ( 144 , 144 ) -> getAbsoluteURL ( ) , 'sizes' => '144x144' , 'type' => 'image/png' , 'density' => 3 ) ) ; array_push ( $ manifest -> icons , array ( 'src' => $ pinicon -> Fill ( 192 , 192 ) -> getAbsoluteURL ( ) , 'sizes' => '192x192' , 'type' => 'image/png' , 'density' => 4 ) ) ; $ bytes = file_put_contents ( Director :: baseFolder ( ) . '/manifest.json' , json_encode ( $ manifest ) ) ; if ( $ bytes !== false ) { return true ; } } return false ; }
1808	public function getContentElements ( ) { $ groups = array ( ) ; foreach ( $ GLOBALS [ 'TL_CTE' ] as $ k => $ v ) { foreach ( array_keys ( $ v ) as $ kk ) { $ groups [ $ k ] [ ] = $ kk ; } } return $ groups ; }
10735	public function setUpper ( $ upper ) : self { if ( ! is_numeric ( $ upper ) ) { throw new InvalidArgumentException ( __METHOD__ . "() expects parameter one, upper, to be a number" ) ; } $ this -> upper = $ upper ; return $ this ; }
12907	public function store ( FilterRequest $ request ) { $ this -> fieldManager = $ this -> getFieldManager ( ) ; $ this -> validate ( $ request -> request , $ this -> fieldManager -> store ( ) ) ; $ input = $ request -> all ( ) ; $ resource = $ this -> repository -> create ( $ input ) ; if ( ! $ resource ) { } return $ this -> created ( $ resource ) ; }
7589	protected function configureType ( ) { switch ( $ this -> type ) { case 'POST' : $ this -> setOption ( CURLOPT_POST , true ) ; break ; case 'DELETE' : case 'PUT' : $ this -> setOption ( CURLOPT_CUSTOMREQUEST , $ this -> type ) ; break ; } }
9701	public function addXfWriter ( Style $ style , $ isStyleXf = false ) { $ xfWriter = new Xf ( $ style ) ; $ xfWriter -> setIsStyleXf ( $ isStyleXf ) ; $ fontIndex = $ this -> addFont ( $ style -> getFont ( ) ) ; $ xfWriter -> setFontIndex ( $ fontIndex ) ; $ xfWriter -> setFgColor ( $ this -> addColor ( $ style -> getFill ( ) -> getStartColor ( ) -> getRGB ( ) ) ) ; $ xfWriter -> setBgColor ( $ this -> addColor ( $ style -> getFill ( ) -> getEndColor ( ) -> getRGB ( ) ) ) ; $ xfWriter -> setBottomColor ( $ this -> addColor ( $ style -> getBorders ( ) -> getBottom ( ) -> getColor ( ) -> getRGB ( ) ) ) ; $ xfWriter -> setTopColor ( $ this -> addColor ( $ style -> getBorders ( ) -> getTop ( ) -> getColor ( ) -> getRGB ( ) ) ) ; $ xfWriter -> setRightColor ( $ this -> addColor ( $ style -> getBorders ( ) -> getRight ( ) -> getColor ( ) -> getRGB ( ) ) ) ; $ xfWriter -> setLeftColor ( $ this -> addColor ( $ style -> getBorders ( ) -> getLeft ( ) -> getColor ( ) -> getRGB ( ) ) ) ; $ xfWriter -> setDiagColor ( $ this -> addColor ( $ style -> getBorders ( ) -> getDiagonal ( ) -> getColor ( ) -> getRGB ( ) ) ) ; if ( $ style -> getNumberFormat ( ) -> getBuiltInFormatCode ( ) === false ) { $ numberFormatHashCode = $ style -> getNumberFormat ( ) -> getHashCode ( ) ; if ( isset ( $ this -> addedNumberFormats [ $ numberFormatHashCode ] ) ) { $ numberFormatIndex = $ this -> addedNumberFormats [ $ numberFormatHashCode ] ; } else { $ numberFormatIndex = 164 + count ( $ this -> numberFormats ) ; $ this -> numberFormats [ $ numberFormatIndex ] = $ style -> getNumberFormat ( ) ; $ this -> addedNumberFormats [ $ numberFormatHashCode ] = $ numberFormatIndex ; } } else { $ numberFormatIndex = ( int ) $ style -> getNumberFormat ( ) -> getBuiltInFormatCode ( ) ; } $ xfWriter -> setNumberFormatIndex ( $ numberFormatIndex ) ; $ this -> xfWriters [ ] = $ xfWriter ; $ xfIndex = count ( $ this -> xfWriters ) - 1 ; return $ xfIndex ; }
7961	public function canResetDslamPort ( $ forceReload = false ) { if ( ! $ this -> properties || $ forceReload ) $ this -> getProperties ( ) ; return $ this -> properties -> capabilities -> canResetDslamPort ; }
1215	public static function isEqual ( $ a , $ b ) { if ( $ a === $ b ) { return true ; } elseif ( $ a instanceof \ stdClass ) { return self :: isEqual ( ( array ) $ a , $ b ) ; } elseif ( $ b instanceof \ stdClass ) { return self :: isEqual ( $ a , ( array ) $ b ) ; } elseif ( $ a instanceof JmesPathableArrayInterface ) { return Utils :: isEqual ( iterator_to_array ( $ a ) , $ b ) ; } elseif ( $ b instanceof JmesPathableArrayInterface ) { return Utils :: isEqual ( $ a , iterator_to_array ( $ b ) ) ; } elseif ( $ a instanceof JmesPathableObjectInterface ) { return Utils :: isEqual ( $ a -> toArray ( ) , $ b ) ; } elseif ( $ b instanceof JmesPathableObjectInterface ) { return Utils :: isEqual ( $ a , $ b -> toArray ( ) ) ; } else { return false ; } }
12969	public function transformFromFront ( array $ array ) { $ transformation = $ this -> getTransformation ( ) ; $ fillables = $ this -> getFillable ( ) ; $ transformed = [ ] ; foreach ( $ fillables as $ name ) { if ( ! key_exists ( $ name , $ array ) ) { continue ; } $ transformed [ $ name ] = $ array [ $ name ] ; } foreach ( $ transformation as $ name => $ new_name ) { if ( ! key_exists ( $ new_name , $ array ) ) { continue ; } $ transformed [ $ name ] = $ array [ $ new_name ] ; } return $ transformed ; }
12372	public function addRule ( string $ name , callable $ func , $ errorMsg = null ) : self { $ this -> rules [ $ name ] = array ( $ func , $ errorMsg ) ; return $ this ; }
7138	protected function getConstraintsForStep ( $ step ) { $ constraints = [ new Valid ( ) ] ; if ( $ step === static :: SHIPMENT_STEP ) { $ constraints [ ] = new Constraints \ SaleShipmentStep ( ) ; } if ( $ step === static :: PAYMENT_STEP ) { $ constraints [ ] = new Constraints \ SaleShipmentStep ( ) ; $ constraints [ ] = new Constraints \ RelayPoint ( ) ; $ constraints [ ] = new Constraints \ SalePaymentStep ( ) ; } return $ constraints ; }
7806	protected function getNearestDateTimeFromDayAndMonth ( \ DateTime $ target , $ day , $ month ) { $ initialGuess = new \ DateTime ( ) ; $ initialGuess -> setDate ( $ target -> format ( 'Y' ) , $ month , $ day ) ; $ initialGuess -> setTime ( 0 , 0 , 0 ) ; $ initialGuessDiff = $ target -> diff ( $ initialGuess ) ; $ yearEarlier = clone $ initialGuess ; $ yearEarlier -> modify ( '-1 year' ) ; $ yearEarlierDiff = $ target -> diff ( $ yearEarlier ) ; if ( $ yearEarlierDiff -> days < $ initialGuessDiff -> days ) { return $ yearEarlier ; } $ yearLater = clone $ initialGuess ; $ yearLater -> modify ( '+1 year' ) ; $ yearLaterDiff = $ target -> diff ( $ yearLater ) ; if ( $ yearLaterDiff -> days < $ initialGuessDiff -> days ) { return $ yearLater ; } return $ initialGuess ; }
9252	protected function initializeContainer ( ) { $ this -> registerDefaultExtensions ( ) ; $ initializer = $ this -> getContainerInitializer ( ) ; $ this -> container = $ initializer -> initializeContainer ( $ this , $ this -> extensions , $ this -> compilerPasses ) ; $ this -> container -> set ( 'app' , $ this ) ; return $ this -> container ; }
516	public function actionMark ( $ version ) { $ originalVersion = $ version ; if ( ( $ namespaceVersion = $ this -> extractNamespaceMigrationVersion ( $ version ) ) !== false ) { $ version = $ namespaceVersion ; } elseif ( ( $ migrationName = $ this -> extractMigrationVersion ( $ version ) ) !== false ) { $ version = $ migrationName ; } elseif ( $ version !== static :: BASE_MIGRATION ) { throw new Exception ( "The version argument must be either a timestamp (e.g. 101129_185401)\nor the full name of a migration (e.g. m101129_185401_create_user_table)\nor the full name of a namespaced migration (e.g. app\\migrations\\M101129185401CreateUserTable)." ) ; } $ migrations = $ this -> getNewMigrations ( ) ; foreach ( $ migrations as $ i => $ migration ) { if ( strpos ( $ migration , $ version ) === 0 ) { if ( $ this -> confirm ( "Set migration history at $originalVersion?" ) ) { for ( $ j = 0 ; $ j <= $ i ; ++ $ j ) { $ this -> addMigrationHistory ( $ migrations [ $ j ] ) ; } $ this -> stdout ( "The migration history is set at $originalVersion.\nNo actual migration was performed.\n" , Console :: FG_GREEN ) ; } return ExitCode :: OK ; } } $ migrations = array_keys ( $ this -> getMigrationHistory ( null ) ) ; $ migrations [ ] = static :: BASE_MIGRATION ; foreach ( $ migrations as $ i => $ migration ) { if ( strpos ( $ migration , $ version ) === 0 ) { if ( $ i === 0 ) { $ this -> stdout ( "Already at '$originalVersion'. Nothing needs to be done.\n" , Console :: FG_YELLOW ) ; } else { if ( $ this -> confirm ( "Set migration history at $originalVersion?" ) ) { for ( $ j = 0 ; $ j < $ i ; ++ $ j ) { $ this -> removeMigrationHistory ( $ migrations [ $ j ] ) ; } $ this -> stdout ( "The migration history is set at $originalVersion.\nNo actual migration was performed.\n" , Console :: FG_GREEN ) ; } } return ExitCode :: OK ; } } throw new Exception ( "Unable to find the version '$originalVersion'." ) ; }
4443	public function multiget ( array $ jids ) : array { if ( empty ( $ jids ) ) { return [ ] ; } $ results = call_user_func_array ( [ $ this -> client , 'multiget' ] , $ jids ) ; $ jobs = json_decode ( $ results , true ) ? : [ ] ; $ ret = [ ] ; foreach ( $ jobs as $ data ) { $ job = new BaseJob ( $ this -> client , $ data ) ; $ job -> setEventsManager ( $ this -> client -> getEventsManager ( ) ) ; $ ret [ $ job -> jid ] = $ job ; } return $ ret ; }
4760	public function updateStats ( $ stats , $ delta = 1 , $ sampleRate = 1 ) { if ( ! is_array ( $ stats ) ) { $ stats = array ( $ stats ) ; } $ data = array ( ) ; foreach ( $ stats as $ stat ) { $ data [ $ stat ] = "$delta|c" ; } $ this -> queue ( $ data , $ sampleRate ) ; }
1276	private function isMailInnovations ( ) { $ patterns = [ '/^MI\d{6}\d{1,22}$/' , '/^94071\d{17}$/' , '/^7\d{19}$/' , '/^93033\d{17}$/' , '/^M\d{9}$/' , '/^82\d{10}$/' , '/^EC\d{9}US$/' , '/^927\d{23}$/' , '/^927\d{19}$/' , '/^EA\d{9}US$/' , '/^CP\d{9}US$/' , '/^92055\d{17}$/' , '/^14\d{18}$/' , '/^92088\d{17}$/' , '/^RA\d{9}US$/' , '/^9202\d{16}US$/' , '/^23\d{16}US$/' , '/^94\d{20}$/' , '/^03\d{18}$/' ] ; foreach ( $ patterns as $ pattern ) { if ( preg_match ( $ pattern , $ this -> trackingNumber ) ) { return true ; } } return false ; }
51	public function addRepository ( RepositoryInterface $ repository ) { if ( $ repository instanceof self ) { foreach ( $ repository -> getRepositories ( ) as $ repo ) { $ this -> addRepository ( $ repo ) ; } } else { $ this -> repositories [ ] = $ repository ; } }
2129	protected function initialize ( ) { if ( static :: $ blnHasLcf === null ) { static :: preload ( ) ; } $ strCacheDir = System :: getContainer ( ) -> getParameter ( 'kernel.cache_dir' ) ; if ( file_exists ( $ strCacheDir . '/contao/config/config.php' ) ) { include $ strCacheDir . '/contao/config/config.php' ; } else { try { $ files = System :: getContainer ( ) -> get ( 'contao.resource_locator' ) -> locate ( 'config/config.php' , null , false ) ; } catch ( \ InvalidArgumentException $ e ) { $ files = array ( ) ; } foreach ( $ files as $ file ) { include $ file ; } } if ( static :: $ blnHasLcf ) { include $ this -> strRootDir . '/system/config/localconfig.php' ; } static :: loadParameters ( ) ; }
4625	public function prepare ( Command $ command , Node $ node ) { if ( $ this -> connection ) { $ this -> resetConnection ( ) ; } parent :: prepare ( $ command , $ node ) ; $ this -> buildPath ( ) ; $ this -> prepareConnection ( ) ; $ this -> prepareRequest ( ) ; return $ this ; }
8500	protected function setSSLCurlOptions ( $ ch ) { curl_setopt ( $ ch , CURLOPT_SSL_VERIFYPEER , $ this -> _config [ 'SSL_VerifyPeer' ] ) ; curl_setopt ( $ ch , CURLOPT_SSL_VERIFYHOST , $ this -> _config [ 'SSL_VerifyHost' ] ) ; }
9619	public function checkAnswer ( $ extraParams = array ( ) ) { $ remoteIp = $ _SERVER [ "REMOTE_ADDR" ] ; $ challenge = $ _POST [ "recaptcha_challenge_field" ] ; $ response = $ _POST [ "recaptcha_response_field" ] ; if ( ! $ this -> getPrivateKey ( ) ) { throw new \ Exception ( "To use reCAPTCHA you must get an API key from <a href='https://www.google.com/recaptcha/admin/create'>https://www.google.com/recaptcha/admin/create</a>" ) ; } if ( ! $ remoteIp ) { throw new \ Exception ( "For security reasons, you must pass the remote ip to reCAPTCHA" ) ; } if ( ! $ challenge ) { $ this -> valid = false ; $ this -> error = 'incorrect-captcha-sol' ; } else { $ response = $ this -> httpPost ( self :: RECAPTCHA_VERIFY_SERVER , '/recaptcha/api/verify' , array ( 'privatekey' => $ this -> getPrivateKey ( ) , 'remoteip' => $ remoteIp , 'challenge' => $ challenge , 'response' => $ response , ) + $ extraParams ) ; $ answers = explode ( "\n" , $ response [ 1 ] ) ; if ( trim ( $ answers [ 0 ] ) == 'true' ) { $ this -> valid = true ; } else { $ this -> valid = false ; $ this -> error = $ answers [ 1 ] ; } } return $ this ; }
9523	private function getConfig ( ) { $ yaml = new Parser ( ) ; $ configFile = getenv ( 'TRAVIS_BUILD_DIR' ) . '/.travis.yml' ; $ config = $ yaml -> parse ( file_get_contents ( $ configFile ) ) ; $ config = $ config [ 'travisdeployer' ] ; $ this -> branches = $ config [ 'branches' ] ; if ( count ( $ this -> branches ) === 0 ) { die ( 'No branches are configured to deploy to.' . PHP_EOL ) ; } $ this -> verbose = filter_input ( FILTER_VALIDATE_BOOLEAN , $ config [ 'verbose' ] ) ; }
6062	public function download ( $ id , $ template = null , $ templateType = 'image' , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'template' => $ template , 'templateType' => $ templateType ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/media/' . $ id . '/download' , $ parameters , $ cachePolicy ) ; $ tmpFile = tmpfile ( ) ; if ( false === fwrite ( $ tmpFile , $ result ) ) { throw new \ RuntimeException ( 'Could not write download data to temporary file!' ) ; } if ( false === fseek ( $ tmpFile , 0 ) ) { throw new \ RuntimeException ( 'Could not reset file pointer of temporary file!' ) ; } $ result = $ tmpFile ; return $ result ; }
9664	public static function registerReader ( $ readerType , $ readerClass ) { if ( ! is_a ( $ readerClass , Reader \ IReader :: class , true ) ) { throw new Reader \ Exception ( 'Registered readers must implement ' . Reader \ IReader :: class ) ; } self :: $ readers [ $ readerType ] = $ readerClass ; }
6364	public function nullsFirst ( ) : Ordering { return Ordering :: from ( Collections :: comparatorFrom ( function ( $ object1 , $ object2 ) { return $ object1 === null ? - 1 : ( $ object2 === null ? 1 : $ this -> compare ( $ object1 , $ object2 ) ) ; } ) ) ; }
5529	protected function chainMockReturns ( ) { $ code = " function returns(\$method, \$value, \$args = false) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->returns(\$method, \$value, \$args);\n" ; $ code .= " }\n" ; $ code .= " function returnsAt(\$timing, \$method, \$value, \$args = false) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->returnsAt(\$timing, \$method, \$value, \$args);\n" ; $ code .= " }\n" ; $ code .= " function returnsByValue(\$method, \$value, \$args = false) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->returns(\$method, \$value, \$args);\n" ; $ code .= " }\n" ; $ code .= " function returnsByValueAt(\$timing, \$method, \$value, \$args = false) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->returnsByValueAt(\$timing, \$method, \$value, \$args);\n" ; $ code .= " }\n" ; $ code .= " function returnsByReference(\$method, &\$ref, \$args = false) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->returnsByReference(\$method, \$ref, \$args);\n" ; $ code .= " }\n" ; $ code .= " function returnsByReferenceAt(\$timing, \$method, &\$ref, \$args = false) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->returnsByReferenceAt(\$timing, \$method, \$ref, \$args);\n" ; $ code .= " }\n" ; return $ code ; }
830	private function processException ( $ name , $ e ) { $ this -> dispatchEvent ( FixerFileProcessedEvent :: NAME , new FixerFileProcessedEvent ( FixerFileProcessedEvent :: STATUS_EXCEPTION ) ) ; $ this -> errorsManager -> report ( new Error ( Error :: TYPE_EXCEPTION , $ name , $ e ) ) ; }
529	public function actionPackage ( array $ what ) { $ this -> validateWhat ( $ what , [ 'app' ] ) ; $ versions = $ this -> getCurrentVersions ( $ what ) ; $ this -> stdout ( "You are about to generate packages for the following things:\n\n" ) ; foreach ( $ what as $ ext ) { if ( strncmp ( 'app-' , $ ext , 4 ) === 0 ) { $ this -> stdout ( ' - ' ) ; $ this -> stdout ( substr ( $ ext , 4 ) , Console :: FG_RED ) ; $ this -> stdout ( ' application version ' ) ; } elseif ( $ ext === 'framework' ) { $ this -> stdout ( ' - Yii Framework version ' ) ; } else { $ this -> stdout ( ' - ' ) ; $ this -> stdout ( $ ext , Console :: FG_RED ) ; $ this -> stdout ( ' extension version ' ) ; } $ this -> stdout ( $ versions [ $ ext ] , Console :: BOLD ) ; $ this -> stdout ( "\n" ) ; } $ this -> stdout ( "\n" ) ; $ packagePath = "{$this->basePath}/packages" ; $ this -> stdout ( "Packages will be stored in $packagePath\n\n" ) ; if ( ! $ this -> confirm ( 'Continue?' , false ) ) { $ this -> stdout ( "Canceled.\n" ) ; return 1 ; } foreach ( $ what as $ ext ) { if ( $ ext === 'framework' ) { throw new Exception ( 'Can not package framework.' ) ; } elseif ( strncmp ( 'app-' , $ ext , 4 ) === 0 ) { $ this -> packageApplication ( substr ( $ ext , 4 ) , $ versions [ $ ext ] , $ packagePath ) ; } else { throw new Exception ( 'Can not package extension.' ) ; } } $ this -> stdout ( "\ndone. verify the versions composer installed above and push it to github!\n\n" ) ; return 0 ; }
6728	public function set_total_votes ( $ post_id , $ votes ) { $ votes = json_encode ( $ votes , true ) ; if ( ! add_post_meta ( $ post_id , 'imdbTotalVotes' , $ votes , true ) ) { update_post_meta ( $ post_id , 'imdbTotalVotes' , $ votes ) ; } }
4858	public function getList ( $ namespace , $ callback ) { $ session = new Container ( $ namespace ) ; $ params = $ session -> params ? : array ( ) ; if ( ! $ session -> list ) { $ session -> list = is_array ( $ callback ) ? call_user_func ( $ callback , $ session -> params ) : $ callback -> getPaginationList ( $ session -> params ) ; } return $ session -> list ; }
7219	public function up ( $ limit = null ) { $ applied = 0 ; $ migrations = $ this -> migrations_list ; $ limit = ( int ) $ limit ; if ( $ limit > 0 ) { $ migrations = array_slice ( $ migrations , 0 , $ limit ) ; } foreach ( $ migrations as $ migration ) { if ( $ migration [ 'applied' ] ) continue ; $ name = $ migration [ 'name' ] ; $ this -> info ( 'Loading migration #:name' , [ ':name' => $ name ] ) ; $ obj = $ this -> load_migration ( $ migration ) ; $ obj -> init ( ) ; if ( $ obj -> up ( ) === false ) { $ this -> error ( 'Migration #:name failed. Stop.' , [ ':name' => $ name ] ) ; return ; } ; DB :: begin ( ) ; try { $ obj -> safe_up ( ) ; DB :: commit ( ) ; } catch ( \ Throwable $ e ) { DB :: rollback ( ) ; } DB :: insert ( 'INSERT INTO`' . $ this -> migrate_table . '`(`name`, `date`) VALUES(:name, :date)' , [ ':name' => $ name , ':date' => time ( ) ] ) ; $ this -> info ( 'Migration up successfully' , [ ':name' => $ name ] ) ; $ applied ++ ; } if ( ! $ applied ) { $ this -> warning ( 'No new migration found' ) ; } }
11818	public function setServiceLocator ( ServiceLocatorInterface $ serviceLocator ) { $ this -> serviceLocator = $ serviceLocator ; $ config = $ serviceLocator -> getServiceLocator ( ) -> get ( 'config' ) ; if ( isset ( $ config [ 'rznviewcomponent' ] ) ) { $ this -> config = $ config [ 'rznviewcomponent' ] ; } return $ this ; }
11888	public function getFamiliarity ( $ user = null ) { if ( is_null ( $ user ) ) { $ user = $ this -> getUser ( false ) ; } if ( is_object ( $ user ) ) { $ user = $ user -> primaryKey ; } $ familarityKey = md5 ( $ user ) ; if ( ! isset ( $ this -> _familiarity [ $ familarityKey ] ) ) { $ this -> _familiarity [ $ familarityKey ] = false ; $ familiarityClass = Yii :: $ app -> classes [ 'ObjectFamiliarity' ] ; if ( ! empty ( $ user ) ) { $ attributes = [ ] ; $ attributes [ $ this -> objectField ] = $ this -> owner -> primaryKey ; $ attributes [ $ this -> userField ] = $ user ; $ this -> _familiarity [ $ familarityKey ] = $ familiarityClass :: find ( ) -> where ( $ attributes ) -> one ( ) ; if ( empty ( $ this -> _familiarity [ $ familarityKey ] ) ) { $ this -> _familiarity [ $ familarityKey ] = new $ familiarityClass ( ) ; $ this -> _familiarity [ $ familarityKey ] -> attributes = $ attributes ; } } } return $ this -> _familiarity [ $ familarityKey ] ; }
9211	protected function getFile ( ) { $ file = ( $ this -> params [ 'dev' ] ? $ this -> seedDevFile : $ this -> seedFile ) ; if ( ! empty ( $ this -> params [ 'file' ] ) ) { $ file = $ this -> params [ 'file' ] ; } return $ file ; }
1709	public function renderContaoBackendTemplate ( array $ blocks = [ ] ) : string { $ request = $ this -> requestStack -> getCurrentRequest ( ) ; if ( null === $ request || ! $ this -> scopeMatcher -> isBackendRequest ( $ request ) ) { return '' ; } $ controller = $ this -> framework -> createInstance ( BackendCustom :: class ) ; $ template = $ controller -> getTemplateObject ( ) ; foreach ( $ blocks as $ key => $ content ) { $ template -> { $ key } = $ content ; } $ response = $ controller -> run ( ) ; return $ response -> getContent ( ) ; }
4442	public function completed ( int $ offset = 0 , int $ count = 25 ) { return $ this -> client -> jobs ( 'complete' , null , $ offset , $ count ) ; }
4857	public function getParams ( $ namespace , $ defaults , $ params = null ) { $ session = new Container ( $ namespace ) ; $ sessionParams = $ session -> params ? : array ( ) ; $ params = $ params ? : clone $ this -> getController ( ) -> getRequest ( ) -> getQuery ( ) ; if ( $ params -> get ( 'clear' ) ) { $ sessionParams = array ( ) ; unset ( $ params [ 'clear' ] ) ; } $ changed = false ; foreach ( $ defaults as $ key => $ default ) { if ( is_numeric ( $ key ) ) { $ key = $ default ; $ default = null ; } $ value = $ params -> get ( $ key ) ; if ( null === $ value ) { if ( isset ( $ sessionParams [ $ key ] ) ) { $ params -> set ( $ key , $ sessionParams [ $ key ] ) ; } elseif ( null !== $ default ) { $ params -> set ( $ key , $ default ) ; $ sessionParams [ $ key ] = $ default ; $ changed = true ; } } else { if ( ! isset ( $ sessionParams [ $ key ] ) || $ sessionParams [ $ key ] != $ value ) { $ changed = true ; $ sessionParams [ $ key ] = $ value ; } } } if ( $ changed ) { unset ( $ session -> list ) ; $ session -> params = $ sessionParams ; } return $ params ; }
5352	public function getSupportedNamespaces ( ) { if ( empty ( $ this -> data -> namespaces ) || ! is_array ( $ this -> data -> namespaces ) ) { return array ( ) ; } return $ this -> data -> namespaces ; }
6250	protected function filterNestedEmptyGroups ( AclPresenceInterface $ presence ) { if ( $ presence [ 'type' ] !== AclPresenceType :: GROUP ) { return 1 ; } $ permissions = $ presence -> permissions ( ) ; if ( ! $ permissions ) { return 0 ; } if ( is_string ( $ permissions ) ) { return 1 ; } return count ( $ permissions ) ; }
4758	protected function transformCacheAnnotation ( Cache $ cache ) { return array ( 'expires' => $ cache -> getExpires ( ) , 'maxage' => $ cache -> getMaxAge ( ) , 'smaxage' => $ cache -> getSMaxAge ( ) , 'public' => $ this -> transformBoolean ( $ cache -> isPublic ( ) ) , 'vary' => $ cache -> getVary ( ) , 'lastModified' => $ cache -> getLastModified ( ) , 'etag' => $ cache -> getETag ( ) , ) ; }
4676	public function render ( $ region = "main" ) { if ( ! isset ( $ this -> views [ $ region ] ) ) { return $ this ; } mergesort ( $ this -> views [ $ region ] , function ( $ viewA , $ viewB ) { $ sortA = $ viewA -> sortOrder ( ) ; $ sortB = $ viewB -> sortOrder ( ) ; if ( $ sortA == $ sortB ) { return 0 ; } return $ sortA < $ sortB ? - 1 : 1 ; } ) ; foreach ( $ this -> views [ $ region ] as $ view ) { $ view -> render ( $ this -> di ) ; } }
225	protected function asPercentStringFallback ( $ value , $ decimals = null ) { if ( empty ( $ value ) ) { $ value = 0 ; } if ( $ decimals === null ) { $ decimals = 0 ; } $ value = $ this -> normalizeNumericStringValue ( ( string ) $ value ) ; $ separatorPosition = strrpos ( $ value , '.' ) ; if ( $ separatorPosition !== false ) { $ integerPart = substr ( $ value , 0 , $ separatorPosition ) ; $ fractionalPart = str_pad ( substr ( $ value , $ separatorPosition + 1 ) , 2 , '0' ) ; $ integerPart .= substr ( $ fractionalPart , 0 , 2 ) ; $ fractionalPart = substr ( $ fractionalPart , 2 ) ; if ( $ fractionalPart === '' ) { $ multipliedValue = $ integerPart ; } else { $ multipliedValue = $ integerPart . '.' . $ fractionalPart ; } } else { $ multipliedValue = $ value . '00' ; } return $ this -> asDecimalStringFallback ( $ multipliedValue , $ decimals ) . '%' ; }
4968	public function fromQuery ( $ param = null , $ default = null ) { if ( $ param === null ) { return $ this -> event -> getRequest ( ) -> getQuery ( $ param , $ default ) -> toArray ( ) ; } return $ this -> event -> getRequest ( ) -> getQuery ( $ param , $ default ) ; }
3953	public function get ( $ strAttributeName ) { return array_key_exists ( $ strAttributeName , $ this -> arrData ) ? $ this -> arrData [ $ strAttributeName ] : null ; }
1755	public static function getTimeZones ( ) { $ arrReturn = array ( ) ; $ timezones = array ( ) ; require __DIR__ . '/../../config/timezones.php' ; foreach ( $ timezones as $ strGroup => $ arrTimezones ) { foreach ( $ arrTimezones as $ strTimezone ) { $ arrReturn [ $ strGroup ] [ ] = $ strTimezone ; } } return $ arrReturn ; }
5753	public function getRoleIdsForRoles ( array $ roles ) : array { if ( count ( $ roles ) == 0 ) { throw new \ InvalidArgumentException ( "Roles array must be populated." ) ; } $ roleIds = [ ] ; foreach ( $ roles as $ role ) { if ( null === $ roleIds [ ] = $ this -> getRoleIdForRole ( $ role ) ) { throw new \ InvalidArgumentException ( "Role $role does not exist" ) ; } } return $ roleIds ; }
10367	public function register ( RegisterRequest $ request ) { $ this -> bus -> pipeThrough ( $ this -> pipesOf ( 'register' ) ) -> dispatchFrom ( RegisterJob :: class , $ request ) ; return redirect ( ) -> route ( config ( '_auth.register.redirect' ) ) -> withSuccess ( trans ( 'auth::register.success' ) ) ; }
2438	public function appendData ( $ varData ) { if ( \ is_object ( $ varData ) ) { $ varData = get_object_vars ( $ varData ) ; } if ( ! \ is_array ( $ varData ) ) { throw new \ Exception ( 'Array or object required to append session data' ) ; } foreach ( $ varData as $ k => $ v ) { if ( \ in_array ( $ k , $ this -> mappedKeys ) ) { $ this -> session -> set ( $ k , $ v ) ; } else { $ this -> sessionBag -> set ( $ k , $ v ) ; } } }
5367	public function paintException ( $ message ) { parent :: paintException ( $ message ) ; $ this -> results [ ] = new SimpleResultOfException ( parent :: getTestList ( ) , $ message ) ; }
2168	protected function createContentElement ( Result $ objElement , $ strPtable , $ strField ) { $ set = array ( 'pid' => $ objElement -> id , 'ptable' => $ strPtable , 'sorting' => 128 , 'tstamp' => $ objElement -> tstamp , 'type' => 'text' , 'text' => $ objElement -> $ strField , 'addImage' => $ objElement -> addImage , 'singleSRC' => $ objElement -> singleSRC , 'alt' => $ objElement -> alt , 'size' => $ objElement -> size , 'imagemargin' => $ objElement -> imagemargin , 'imageUrl' => $ objElement -> imageUrl , 'fullsize' => $ objElement -> fullsize , 'caption' => $ objElement -> caption , 'floating' => $ objElement -> floating ) ; $ this -> Database -> prepare ( "INSERT INTO tl_content %s" ) -> set ( $ set ) -> execute ( ) ; }
1047	public static function create ( array $ params , bool $ readonly = false ) : OperationParams { $ instance = new static ( ) ; $ params = array_change_key_case ( $ params , CASE_LOWER ) ; $ instance -> originalInput = $ params ; $ params += [ 'query' => null , 'queryid' => null , 'documentid' => null , 'id' => null , 'operationname' => null , 'variables' => null , 'extensions' => null , ] ; if ( $ params [ 'variables' ] === '' ) { $ params [ 'variables' ] = null ; } foreach ( [ 'extensions' , 'variables' ] as $ param ) { if ( ! is_string ( $ params [ $ param ] ) ) { continue ; } $ tmp = json_decode ( $ params [ $ param ] , true ) ; if ( json_last_error ( ) ) { continue ; } $ params [ $ param ] = $ tmp ; } $ instance -> query = $ params [ 'query' ] ; $ instance -> queryId = $ params [ 'queryid' ] ? : $ params [ 'documentid' ] ? : $ params [ 'id' ] ; $ instance -> operation = $ params [ 'operationname' ] ; $ instance -> variables = $ params [ 'variables' ] ; $ instance -> extensions = $ params [ 'extensions' ] ; $ instance -> readOnly = $ readonly ; if ( isset ( $ instance -> extensions [ 'persistedQuery' ] [ 'sha256Hash' ] ) && empty ( $ instance -> query ) && empty ( $ instance -> queryId ) ) { $ instance -> queryId = $ instance -> extensions [ 'persistedQuery' ] [ 'sha256Hash' ] ; } return $ instance ; }
6302	protected function getBar ( $ name = 'default' ) { $ this -> events -> fire ( 'navigation.bar' , [ [ 'name' => $ name ] ] ) ; if ( $ name !== 'default' && ! array_key_exists ( $ name , $ this -> bar ) ) { $ name = 'default' ; } if ( ! array_key_exists ( $ name , $ this -> bar ) ) { $ this -> bar [ $ name ] = [ ] ; } $ nav = $ this -> bar [ $ name ] ; return $ this -> process ( $ nav ) ; }
11426	public function blacklist ( $ beginOpenid = null ) { $ params = [ 'begin_openid' => $ beginOpenid ] ; return $ this -> parseJSON ( 'json' , [ self :: API_GET_BLACK_LIST , $ params ] ) ; }
9099	public function serve ( ServiceCallback $ callback ) { $ this -> bind ( ) ; $ this -> listen ( ) ; $ runOn = true ; while ( $ runOn ) { $ clientHandle = @ socket_accept ( $ this -> handle ) ; if ( ! is_resource ( $ clientHandle ) ) { $ code = socket_last_error ( $ this -> handle ) ; throw new SocketException ( socket_strerror ( $ code ) , array ( ) , $ code ) ; } $ address = null ; $ port = 0 ; if ( ! @ socket_getpeername ( $ clientHandle , $ address , $ port ) ) { $ code = socket_last_error ( $ clientHandle ) ; throw new SocketException ( socket_strerror ( $ code ) , array ( ) , $ code ) ; } $ client = new ClientSocket ( new Endpoint ( $ address , $ port ) , $ clientHandle ) ; $ runOn = boolval ( $ callback -> callback ( $ client ) ) ; } }
5588	public function setCookies ( array $ lstCookies ) { foreach ( $ lstCookies as $ aCookies ) { $ this -> cookie_jar -> setCookie ( $ aCookies [ 'name' ] , $ aCookies [ 'value' ] , $ aCookies [ 'host' ] , $ aCookies [ 'path' ] , $ aCookies [ 'expiry' ] ) ; } }
11379	public function putAction ( ) { if ( ! preg_match ( '/\/page\/(\w+[\-\w]*)\/text\/(..)\/(\w+)$/' , $ this -> name , $ matches ) ) { throw new InvalidParameterException ( "Invalid parameters" ) ; } list ( $ dummy , $ pageName , $ language , $ oldName ) = $ matches ; $ request = $ this -> environment -> getRequestHelper ( ) ; $ newName = $ request -> getIdentifierParam ( 'name' ) ; $ content = $ request -> getParam ( 'content' , '' ) ; try { $ pageTexts = $ this -> getTextModel ( $ pageName ) ; $ text = $ pageTexts -> modifyTextContainer ( $ oldName , $ newName , $ this -> filter ( $ content ) , $ language ) ; $ this -> environment -> sendJSONResult ( $ text ) ; } catch ( \ Exception $ e ) { throw new InvalidParameterException ( $ e -> getMessage ( ) ) ; } }
11547	public function addGroup ( Group $ group ) { $ group -> setService ( $ this ) ; $ this -> groups [ $ group -> getName ( ) ] = $ group ; }
4440	public static function sigName ( int $ signal ) : string { $ signals = [ 'SIGHUP' , 'SIGINT' , 'SIGQUIT' , 'SIGILL' , 'SIGTRAP' , 'SIGABRT' , 'SIGIOT' , 'SIGBUS' , 'SIGFPE' , 'SIGKILL' , 'SIGUSR1' , 'SIGSEGV' , 'SIGUSR2' , 'SIGPIPE' , 'SIGALRM' , 'SIGTERM' , 'SIGSTKFLT' , 'SIGCLD' , 'SIGCHLD' , 'SIGCONT' , 'SIGSTOP' , 'SIGTSTP' , 'SIGTTIN' , 'SIGTTOU' , 'SIGURG' , 'SIGXCPU' , 'SIGXFSZ' , 'SIGVTALRM' , 'SIGPROF' , 'SIGWINCH' , 'SIGPOLL' , 'SIGIO' , 'SIGPWR' , 'SIGSYS' , 'SIGBABY' , ] ; foreach ( $ signals as $ name ) { if ( defined ( $ name ) && constant ( $ name ) === $ signal ) { return $ name ; } } return 'UNKNOWN' ; }
8041	public function formatEventsToJson ( array $ calendarEvents ) { $ array = [ ] ; foreach ( $ calendarEvents as $ event ) { $ start = $ this -> carbon -> copy ( ) -> setTimestamp ( strtotime ( $ event -> start ) ) -> toIso8601String ( ) ; $ end = $ this -> carbon -> copy ( ) -> setTimestamp ( strtotime ( $ event -> end ) ) -> toIso8601String ( ) ; $ allDay = $ event -> all_day == 1 ; $ data = [ 'title' => $ event -> title , 'description' => $ event -> description , 'start' => $ start , 'end' => $ end , 'allDay' => $ allDay , 'borderColor' => $ event -> border_color , 'textColor' => $ event -> text_color , 'backgroundColor' => $ event -> background_color , ] ; $ array [ ] = $ data ; if ( $ event -> calendarEventRepeatDates ( ) -> count ( ) > 0 ) { foreach ( $ event -> calendarEventRepeatDates ( ) -> get ( ) as $ repeatDate ) { $ start = $ this -> carbon -> copy ( ) -> setTimestamp ( strtotime ( $ repeatDate -> start ) ) -> toIso8601String ( ) ; $ end = $ this -> carbon -> copy ( ) -> setTimestamp ( strtotime ( $ repeatDate -> end ) ) -> toIso8601String ( ) ; $ data [ 'start' ] = $ start ; $ data [ 'end' ] = $ end ; $ array [ ] = $ data ; } } } return $ array ; }
3688	private function calculateSubfilter ( $ operation , IFilter $ filter ) { if ( ! is_array ( $ operation ) ) { throw new \ RuntimeException ( 'Error Processing subfilter: ' . var_export ( $ operation , true ) , 1 ) ; } switch ( $ operation [ 'operation' ] ) { case 'AND' : case 'OR' : $ this -> getAndOrFilter ( $ filter , $ operation ) ; break ; case '=' : case '>' : case '<' : $ this -> getFilterForComparingOperator ( $ this -> getAttributeFromFilterOperation ( $ operation ) , $ filter , $ operation ) ; break ; case 'IN' : $ this -> getFilterForInList ( $ filter , $ operation ) ; break ; case 'LIKE' : $ this -> getFilterForLike ( $ this -> getAttributeFromFilterOperation ( $ operation ) , $ filter , $ operation ) ; break ; default : throw new \ RuntimeException ( 'Error processing filter array - unknown operation ' . var_export ( $ operation , true ) , 1 ) ; } }
11874	protected function renewAccessToken ( ) { $ token = $ this -> authorizer -> getApi ( ) -> getAuthorizerToken ( $ this -> authorizer -> getAppId ( ) , $ this -> authorizer -> getRefreshToken ( ) ) ; $ this -> authorizer -> setAccessToken ( $ token [ 'authorizer_access_token' ] , $ token [ 'expires_in' ] - 1500 ) ; return $ token [ 'authorizer_access_token' ] ; }
5611	public function paintMethodStart ( $ message ) { parent :: paintMethodStart ( $ message ) ; $ node = new TreemapNode ( 'Method' , $ message ) ; $ this -> _stack -> push ( $ node ) ; }
4484	protected function registerSignalHandler ( WorkerInterface $ worker ) : void { $ this -> logger -> info ( 'Register a signal handler that a worker should respond to' ) ; SignalHandler :: create ( SignalHandler :: KNOWN_SIGNALS , function ( int $ signal , string $ signalName ) use ( $ worker ) { $ this -> logger -> info ( '{type}: Was received recognized signal {signal}' , [ 'type' => $ worker -> getName ( ) , 'signal' => $ signalName , ] ) ; switch ( $ signal ) { case SIGTERM : $ worker -> shutDownNow ( ) ; break ; case SIGINT : $ worker -> shutDownNow ( ) ; break ; case SIGQUIT : $ worker -> shutdown ( ) ; break ; case SIGUSR1 : $ worker -> killChildren ( ) ; break ; case SIGUSR2 : $ worker -> pauseProcessing ( ) ; break ; case SIGCONT : $ worker -> unPauseProcessing ( ) ; break ; } } ) ; }
3587	protected function getMetaWhereConstraint ( $ method , ArgumentBag $ args ) { $ column = $ args -> get ( 'column' ) ; $ args -> set ( 'column' , 'meta_value' ) ; if ( $ method === 'whereBetween' ) { return $ this -> getMetaBetweenConstraint ( $ column , $ args -> get ( 'values' ) ) ; } return function ( $ query ) use ( $ column , $ method , $ args ) { $ query -> where ( 'meta_key' , $ column ) ; if ( $ args -> get ( 'value' ) || $ args -> get ( 'values' ) ) { call_user_func_array ( [ $ query , $ method ] , $ args -> all ( ) ) ; } } ; }
7048	protected function formatPhoneNumber ( PhoneNumber $ number = null ) { if ( $ number ) { return $ this -> phoneNumberUtil -> format ( $ number , PhoneNumberFormat :: INTERNATIONAL ) ; } return null ; }
7764	private function documentOperations ( $ operations ) { if ( null === $ operations ) { return null ; } $ result = array ( ) ; foreach ( $ operations as $ operation ) { $ statusCodes = array ( ) ; foreach ( $ operation -> getStatusCodes ( ) as $ code => $ description ) { $ statusCodes [ ] = array ( 'code' => $ code , 'description' => $ description ) ; } $ result [ ] = array ( '@id' => '_:' . $ operation -> getName ( ) , '@type' => $ operation -> getType ( ) ? : 'hydra:Operation' , 'method' => $ operation -> getMethod ( ) , 'label' => ( $ operation -> getTitle ( ) ) ? : $ operation -> getDescription ( ) , 'description' => ( null === $ operation -> getTitle ( ) ) ? null : $ operation -> getDescription ( ) , 'expects' => $ this -> getTypeReferenceIri ( $ operation -> getExpects ( ) ) , 'returns' => $ this -> getTypeReferenceIri ( $ operation -> getReturns ( ) ) , 'statusCodes' => $ statusCodes ) ; } return $ result ; }
9878	private function writeWorkbookPr ( XMLWriter $ objWriter ) { $ objWriter -> startElement ( 'workbookPr' ) ; if ( Date :: getExcelCalendar ( ) == Date :: CALENDAR_MAC_1904 ) { $ objWriter -> writeAttribute ( 'date1904' , '1' ) ; } $ objWriter -> writeAttribute ( 'codeName' , 'ThisWorkbook' ) ; $ objWriter -> endElement ( ) ; }
5119	private function assessOptions ( array $ options ) : void { $ defaultOptions = [ 'rest_server' => self :: REST_SERVER , 'auth_url' => self :: AUTHENTICATION , 'max_attempt' => self :: DEFAULT_MAX_ATTEMPT , 'default_headers' => [ 'Accept' => 'application/json' , ] , ] ; $ this -> options = new Collection ( array_merge ( $ defaultOptions , $ options ) ) ; if ( isset ( $ options [ 'access_token' ] ) ) { $ this -> setAuthorizationHeader ( $ options [ 'access_token' ] ) ; } if ( isset ( $ options [ 'recycle_token' ] ) && is_callable ( $ options [ 'recycle_token' ] ) ) { $ this -> recycleToken ( $ options [ 'recycle_token' ] ) ; } if ( isset ( $ options [ 'token_saver' ] ) && is_callable ( $ options [ 'token_saver' ] ) ) { $ this -> setTokenSaver ( $ options [ 'token_saver' ] ) ; } $ this -> httpClient = new Client ( [ 'base_uri' => $ this -> options -> get ( 'rest_server' ) , ] ) ; }
12762	public function set ( $ name , $ value , $ expire = 0 , $ path = null , $ domain = null , $ secure = false , $ httpOnly = false ) { if ( $ expire === - 1 ) { $ expire = time ( ) + 3600 * 24 * 365 ; } else { $ expire *= 60 ; } $ value = base64_encode ( $ value ) ; if ( $ path != null ) { if ( $ domain != null ) { if ( $ secure ) { if ( $ httpOnly ) { setcookie ( $ name , $ value , $ expire , $ path , $ domain , $ secure , $ httpOnly ) ; } else { setcookie ( $ name , $ value , $ expire , $ path , $ domain , $ secure ) ; } } else { setcookie ( $ name , $ value , $ expire , $ path , $ domain ) ; } } else { setcookie ( $ name , $ value , $ expire , $ path ) ; } } else { setcookie ( $ name , $ value , $ expire ) ; } }
1588	public function getMeta ( ) { $ meta = $ this -> hasMeta ( ) ? $ this -> get ( DocumentInterface :: KEYWORD_META ) : new StandardObject ( ) ; if ( ! is_null ( $ meta ) && ! $ meta instanceof StandardObjectInterface ) { throw new RuntimeException ( 'Data member is not an object.' ) ; } return $ meta ; }
4282	public function stream_truncate ( $ size ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ success = \ ftruncate ( $ this -> handle , $ size ) ; self :: register ( ) ; return $ success ; }
11948	public function getSignature ( $ baseString , array $ params ) { unset ( $ params [ 'oauth_signature' ] ) ; if ( $ this -> signature_method === 'HMAC-SHA1' ) { $ result = $ this -> sign_HMAC_SHA1 ( $ baseString ) ; } else if ( $ this -> signature_method == 'RSA-SHA1' ) { $ result = $ this -> sign_RSA_SHA1 ( $ baseString ) ; } else if ( $ this -> signature_method == 'PLAINTEXT' ) { $ result = $ this -> sign_PLAINTEXT ( $ baseString ) ; } else { throw new ArtaxServiceException ( 'Unknown signature method: ' . $ this -> signature_method ) ; } return base64_encode ( $ result ) ; }
6173	public function read ( $ path , $ file ) { return $ this -> driver -> read ( $ this -> root . $ path , $ file ) ; }
8446	private function convertQuestion ( Question $ question ) { $ buttons = Collection :: make ( $ question -> getButtons ( ) ) -> map ( function ( $ button ) { return [ 'label' => $ button [ 'text' ] , 'metadata' => $ button [ 'value' ] ] ; } ) ; return [ 'text' => $ question -> getText ( ) , 'quick_reply' => [ 'type' => 'options' , 'options' => $ buttons -> toArray ( ) , ] , ] ; }
3368	public function generateFromMetadata ( array $ metadata ) { $ this -> metadata = $ metadata ; $ this -> visitedAssociations = [ ] ; $ str = [ ] ; foreach ( $ metadata as $ class ) { $ parent = $ this -> getParent ( $ class ) ; if ( $ parent ) { $ str [ ] = $ this -> getClassString ( $ parent ) . '^' . $ this -> getClassString ( $ class ) ; } $ associations = $ class -> getAssociationNames ( ) ; if ( empty ( $ associations ) && ! isset ( $ this -> visitedAssociations [ $ class -> getName ( ) ] ) ) { $ str [ ] = $ this -> getClassString ( $ class ) ; continue ; } foreach ( $ associations as $ associationName ) { if ( $ parent && in_array ( $ associationName , $ parent -> getAssociationNames ( ) ) ) { continue ; } if ( $ this -> visitAssociation ( $ class -> getName ( ) , $ associationName ) ) { $ str [ ] = $ this -> getAssociationString ( $ class , $ associationName ) ; } } } return implode ( ',' , $ str ) ; }
3181	public function getMaximumRemainingTime ( ) { if ( ( $ timeLimits = $ this -> getSource ( ) -> getTimeLimits ( ) ) !== null && ( $ maxTime = $ timeLimits -> getMaxTime ( ) ) !== null ) { return $ this -> getRemainingTimeFrom ( $ maxTime ) ; } return false ; }
12585	static function run_convert_configuration ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { self :: setConfigDir ( $ cliopts ) ; $ extname = @ $ args [ 0 ] ; if ( $ extname == '' ) { $ extname = dirname ( __FILE__ ) ; } while ( ! is_file ( "ant/$extname.properties" ) ) { $ extname = pake_input ( 'What is the name of the current extension?' ) ; if ( ! is_file ( "ant/$extname.properties" ) ) { pake_echo ( "File ant/$extname.properties not found" ) ; } } self :: convertPropertyFileToYamlFile ( "ant/$extname.properties" , self :: getConfigDir ( ) . "/options-$extname.yaml" , array ( $ extname => '' , 'external' => 'dependencies' , 'dependency' => 'extensions' , 'repository' => array ( 'svn' , 'url' ) ) , "extension:\n name: $extname\n\n" ) ; foreach ( array ( 'files.to.parse.txt' => 'to_parse' , 'files.to.exclude.txt' => 'to_exclude' ) as $ file => $ option ) { $ src = "ant/$file" ; if ( file_exists ( $ src ) ) { if ( count ( $ in = file ( $ src , FILE_SKIP_EMPTY_LINES | FILE_IGNORE_NEW_LINES ) ) ) { $ in = "\n\nfiles:\n $option: [" . implode ( ', ' , $ in ) . "]\n" ; file_put_contents ( self :: getConfigDir ( ) . "options-$extname.yaml" , $ in , FILE_APPEND ) ; } } } }
5128	public function readQDateTime ( ) { $ day = $ this -> readUInt ( ) ; $ msec = $ this -> readUInt ( ) ; $ this -> readBool ( ) ; if ( $ day === 0 && $ msec === 0xFFFFFFFF ) { return null ; } $ time = ( $ day - 2440588 ) * 86400 + $ msec / 1000 ; $ dt = \ DateTime :: createFromFormat ( 'U.u' , sprintf ( '%.6F' , $ time ) ) ; $ dt -> setTimezone ( new \ DateTimeZone ( date_default_timezone_get ( ) ) ) ; return $ dt ; }
2335	public function onKernelRequest ( GetResponseEvent $ event ) : void { if ( ! $ event -> isMasterRequest ( ) ) { return ; } $ this -> tokenStorage -> initialize ( $ this -> getTokensFromCookies ( $ event -> getRequest ( ) -> cookies ) ) ; }
11192	public function exists ( $ uri = false , $ httpMethod = false ) { if ( $ uri && $ httpMethod ) { $ this -> routeProcess ( $ uri , $ httpMethod ) ; } if ( ! isset ( $ this -> controllerPath ) ) { return false ; } return true ; }
10384	protected static function set_new_params ( $ type , $ hash , $ url , $ extension ) { $ data = [ 'name' => self :: $ id , 'url' => $ url . $ hash . $ extension , 'deps' => self :: unify_params ( $ type , 'deps' ) , 'version' => self :: unify_params ( $ type , 'version' , '1.0.0' ) , ] ; switch ( $ type ) { case 'style' : $ data [ 'media' ] = self :: unify_params ( $ type , 'media' , 'all' ) ; break ; case 'script' : $ data [ 'params' ] = self :: unify_params ( $ type , 'params' ) ; $ data [ 'footer' ] = self :: unify_params ( $ type , 'footer' , false ) ; $ data [ 'params' ] [ 'nonce' ] = wp_create_nonce ( self :: $ id ) ; break ; default : } self :: $ data [ $ type ] = [ $ data [ 'name' ] => $ data ] ; return true ; }
5872	public static function getTransformation ( $ orientation ) { $ transformation = '' ; if ( ( isset ( $ GLOBALS [ 'TYPO3_CONF_VARS' ] [ 'GFX' ] [ 'processor' ] ) && $ GLOBALS [ 'TYPO3_CONF_VARS' ] [ 'GFX' ] [ 'processor' ] === 'ImageMagick' ) || ( isset ( $ GLOBALS [ 'TYPO3_CONF_VARS' ] [ 'GFX' ] [ 'im_version_5' ] ) && $ GLOBALS [ 'TYPO3_CONF_VARS' ] [ 'GFX' ] [ 'im_version_5' ] !== 'gm' ) ) { if ( $ orientation >= 2 && $ orientation <= 8 ) { $ transformation = '-auto-orient' ; } } else { switch ( $ orientation ) { case 2 : $ transformation = '-flip horizontal' ; break ; case 3 : $ transformation = '-rotate 180' ; break ; case 4 : $ transformation = '-flip vertical' ; break ; case 5 : $ transformation = '-transpose' ; break ; case 6 : $ transformation = '-rotate 90' ; break ; case 7 : $ transformation = '-transverse' ; break ; case 8 : $ transformation = '-rotate 270' ; break ; } } return $ transformation ; }
9951	public function duplicateConditionalStyle ( array $ pCellStyle , $ pRange = '' ) { foreach ( $ pCellStyle as $ cellStyle ) { if ( ! ( $ cellStyle instanceof Conditional ) ) { throw new Exception ( 'Style is not a conditional style' ) ; } } list ( $ rangeStart , $ rangeEnd ) = Coordinate :: rangeBoundaries ( $ pRange . ':' . $ pRange ) ; if ( $ rangeStart [ 0 ] > $ rangeEnd [ 0 ] && $ rangeStart [ 1 ] > $ rangeEnd [ 1 ] ) { $ tmp = $ rangeStart ; $ rangeStart = $ rangeEnd ; $ rangeEnd = $ tmp ; } for ( $ col = $ rangeStart [ 0 ] ; $ col <= $ rangeEnd [ 0 ] ; ++ $ col ) { for ( $ row = $ rangeStart [ 1 ] ; $ row <= $ rangeEnd [ 1 ] ; ++ $ row ) { $ this -> setConditionalStyles ( Coordinate :: stringFromColumnIndex ( $ col ) . $ row , $ pCellStyle ) ; } } return $ this ; }
1110	protected function keyForScope ( $ node ) { return implode ( '-' , array_map ( function ( $ column ) use ( $ node ) { $ value = $ node -> getAttribute ( $ column ) ; if ( is_null ( $ value ) ) return 'NULL' ; return $ value ; } , $ node -> getScopedColumns ( ) ) ) ; }
8108	public function getReviewFrom ( ) { $ from = $ this -> owner -> getField ( 'ReviewFrom' ) ; if ( $ from ) { return $ from ; } return Config :: inst ( ) -> get ( Email :: class , 'admin_email' ) ; }
11612	protected function _resolveContainer ( BaseContainerInterface $ container ) { $ parent = null ; while ( $ container instanceof ContainerAwareInterface ) { $ parent = $ container -> getContainer ( ) ; if ( ! ( $ parent instanceof BaseContainerInterface ) ) { break ; } $ container = $ parent ; } return $ container ; }
10082	protected function registerConfigurator ( ) { $ this -> app -> singleton ( 'auja.database' , function ( $ app ) { $ config = $ app [ 'config' ] [ 'auja-laravel' ] ? : $ app [ 'config' ] [ 'auja-laravel::config' ] ; switch ( $ config [ 'database' ] ) { case 'mysql' : return new MySQLDatabaseHelper ( ) ; break ; default : throw new NoDatabaseHelperException ( 'No Auja database helper for ' . $ config [ 'database' ] ) ; break ; } } ) ; $ this -> app -> bind ( 'Label305\AujaLaravel\Database\DatabaseHelper' , 'auja.database' ) ; $ this -> app -> singleton ( 'auja.configurator' , function ( $ app ) { return new AujaConfigurator ( $ app , $ app [ 'auja.database' ] ) ; } ) ; $ this -> app -> bind ( 'Label305\AujaLaravel\Config\AujaConfigurator' , 'auja.configurator' ) ; }
2567	protected function checkAllNotEmpty ( ) { $ foundEmpty = false ; $ args = func_get_args ( ) ; foreach ( $ args as $ arg ) { if ( empty ( $ arg ) ) { $ foundEmpty = true ; break ; } } return ! $ foundEmpty ; }
72	public function authorizeOAuth ( $ originUrl ) { if ( $ originUrl !== 'bitbucket.org' ) { return false ; } if ( 0 === $ this -> process -> execute ( 'git config bitbucket.accesstoken' , $ output ) ) { $ this -> io -> setAuthentication ( $ originUrl , 'x-token-auth' , trim ( $ output ) ) ; return true ; } return false ; }
7414	public function read ( ) { $ data = '' ; $ fileObj = $ this -> openFile ( ) ; while ( ! $ fileObj -> eof ( ) ) { $ data .= $ fileObj -> fread ( 4096 ) ; } $ fileObj = null ; return $ data ; }
7458	public function background ( ) : Font { if ( $ this -> color !== null ) { $ this -> turnToBackground ( ) ; } $ this -> background = true ; return $ this ; }
3912	protected function remapSorting ( $ arrFiles , $ arrSource ) { $ files = array ( ) ; $ source = array ( ) ; foreach ( array_keys ( $ arrFiles ) as $ k ) { $ files [ ] = $ arrFiles [ $ k ] ; $ source [ ] = $ arrSource [ $ k ] ; } $ this -> addClasses ( $ source ) ; return array ( 'files' => $ files , 'source' => $ source ) ; }
6481	private function createDefaultResponseContentNegotiationResult ( string $ type , ? string $ language , array $ acceptCharsetHeaders ) : ContentNegotiationResult { $ selectedMediaTypeFormatter = null ; foreach ( $ this -> mediaTypeFormatters as $ mediaTypeFormatter ) { if ( $ mediaTypeFormatter -> canWriteType ( $ type ) ) { $ selectedMediaTypeFormatter = $ mediaTypeFormatter ; break ; } } if ( $ selectedMediaTypeFormatter === null ) { return new ContentNegotiationResult ( null , null , null , $ language ) ; } $ encoding = $ this -> encodingMatcher -> getBestEncodingMatch ( $ selectedMediaTypeFormatter , $ acceptCharsetHeaders , null ) ; return new ContentNegotiationResult ( $ selectedMediaTypeFormatter , $ selectedMediaTypeFormatter -> getDefaultMediaType ( ) , $ encoding , $ language ) ; }
3933	private function setDescription ( PropertyInterface $ property , $ propInfo ) { if ( $ property -> getDescription ( ) || ! isset ( $ propInfo [ 'description' ] ) ) { return ; } $ property -> setDescription ( $ propInfo [ 'description' ] ) ; }
9465	public function getSummary ( ) { $ string = "---\n" ; foreach ( $ this -> getWords ( ) as $ k => $ v ) { $ string .= '[' . $ k . ']: Docs:' . $ v [ 'docs' ] . ' | Hits:' . $ v [ 'hits' ] . "\n" ; } return $ string ; }
11149	protected function process ( array $ requestParams ) { $ request = new ExtDirectRequest ( $ this -> useCache ( ) , $ this -> getApplicationPath ( ) , $ this -> getApplicationNameSpace ( ) ) ; $ response = new ExtDirectResponse ( ) ; $ requestParameters = new Parameters ( ) ; try { $ request -> setApplicationPath ( $ this -> getApplicationPath ( ) ) ; $ requestParameters -> setParameters ( $ requestParams ) ; $ request -> injectParameters ( $ requestParameters ) ; $ response -> injectParameters ( $ requestParameters ) ; $ request -> injectResponse ( $ response ) ; $ request -> setParamMethod ( $ this -> getParamMethod ( ) ) ; $ request -> setMethodCalls ( $ this -> getMethodsToCall ( ) ) ; $ request -> run ( ) ; } catch ( ExtDirectApplicationException $ e ) { $ result = $ e -> getResponse ( ) ; if ( ! empty ( $ result ) ) { $ response -> setResult ( array ( "success" => false , "message" => $ e -> getMessage ( ) , "actions" => $ result ) ) ; } else { $ response -> setResult ( array ( "success" => false , "message" => $ e -> getMessage ( ) ) ) ; } } catch ( \ Exception $ e ) { $ response -> setResult ( array ( "success" => false , "message" => $ e -> getMessage ( ) ) ) ; } return $ response ; }
6845	public static function seconds ( $ step = 1 , $ start = 0 , $ end = 60 ) { $ step = ( int ) $ step ; $ seconds = array ( ) ; for ( $ i = $ start ; $ i < $ end ; $ i += $ step ) { $ seconds [ $ i ] = sprintf ( '%02d' , $ i ) ; } return $ seconds ; }
11415	private function calcBonus ( $ dwnlCurrent , $ dwnlCompress , $ levels ) { $ result = [ ] ; $ mapCustomer = $ this -> hlpDwnlTree -> mapById ( $ dwnlCurrent , ECustomer :: A_CUSTOMER_REF ) ; foreach ( $ dwnlCompress as $ one ) { $ custId = $ one -> getCustomerRef ( ) ; $ pvValue = $ one -> getPv ( ) ; $ customer = $ mapCustomer [ $ custId ] ; $ scheme = $ this -> hlpScheme -> getSchemeByCustomer ( $ customer ) ; if ( $ scheme == Cfg :: SCHEMA_DEFAULT ) { $ bonusValue = $ this -> hlpCalc -> calcForLevelPercent ( $ pvValue , $ levels ) ; if ( $ bonusValue > 0 ) { $ entry = new DBonus ( ) ; $ entry -> setCustomerRef ( $ custId ) ; $ entry -> setValue ( $ bonusValue ) ; $ result [ ] = $ entry ; } } } return $ result ; }
9390	public function getSortValBeforeAll ( $ groupingId = null ) { if ( $ groupingId === null && $ this -> grpColumn ) { throw new SortableException ( 'groupingId may be omitted only when grpColumn is not configured.' ) ; } $ query = ( new Query ( ) ) -> select ( [ $ this -> pkColumn , $ this -> srtColumn ] ) -> from ( $ this -> targetTable ) -> where ( [ 'and' , $ this -> grpColumn ? [ '=' , $ this -> grpColumn , $ groupingId ] : [ ] , $ this -> skipRowsClause ( ) ] ) -> orderBy ( [ $ this -> srtColumn => SORT_ASC ] ) -> limit ( 1 ) ; $ result = $ query -> one ( $ this -> db ) ; if ( $ result && $ result [ $ this -> srtColumn ] == 1 ) { $ this -> rebuildSortAfter ( $ result [ $ this -> pkColumn ] , true ) ; $ sortVal = $ this -> getIniSortVal ( ) ; } else if ( $ result ) { $ sortVal = ceil ( $ result [ $ this -> srtColumn ] / 2 ) ; } else $ sortVal = $ this -> getIniSortVal ( ) ; return ( int ) $ sortVal ; }
7461	public function sendPasswordResetEmail ( UserInterface $ user , $ subject = 'Password reset request' ) { $ hashedEntity = $ this -> createHash ( $ user ) ; $ this -> emailHelper -> createAndSendMessageFromTemplate ( 'OrkestraApplicationBundle:Email:setPassword.html.twig' , array ( 'user' => $ user , 'hash' => $ hashedEntity -> getHash ( ) ) , $ subject , $ user -> getEmail ( ) ) ; return $ hashedEntity ; }
10021	public function addCellStyleXf ( Style $ pStyle ) { $ this -> cellStyleXfCollection [ ] = $ pStyle ; $ pStyle -> setIndex ( count ( $ this -> cellStyleXfCollection ) - 1 ) ; }
12324	protected function doExecute ( InputInterface $ input , OutputInterface $ output ) { if ( $ this -> askQuestions ( $ input , $ output ) == static :: RETURN_ERROR ) { return static :: RETURN_ERROR ; } $ data = $ this -> prepareData ( $ input ) ; $ this -> doPreExecuteTasks ( $ input , $ output , $ data ) ; $ return = $ this -> executeTasks ( $ input , $ output , $ data ) ; $ this -> doPostExecuteTasks ( $ input , $ output , $ data , $ return ) ; return $ return ; }
8770	protected function bindPathsInContainer ( ) { $ this -> instance ( 'path' , $ this -> path ( ) ) ; $ this -> instance ( 'path.base' , $ this -> basePath ( ) ) ; $ this -> instance ( 'path.lang' , $ this -> langPath ( ) ) ; $ this -> instance ( 'path.config' , $ this -> configPath ( ) ) ; $ this -> instance ( 'path.storage' , $ this -> storagePath ( ) ) ; $ this -> instance ( 'path.database' , $ this -> databasePath ( ) ) ; $ this -> instance ( 'path.cache' , $ this -> cachePath ( ) ) ; $ this -> instance ( 'path.public' , $ this -> publicPath ( ) ) ; }
2131	public function save ( ) { if ( $ this -> strTop == '' ) { $ this -> strTop = '<?php' ; } $ strFile = trim ( $ this -> strTop ) . "\n\n" ; $ strFile .= "### INSTALL SCRIPT START ###\n" ; foreach ( $ this -> arrData as $ k => $ v ) { $ strFile .= "$k = $v\n" ; } $ strFile .= "### INSTALL SCRIPT STOP ###\n" ; $ this -> strBottom = trim ( $ this -> strBottom ) ; if ( $ this -> strBottom != '' ) { $ strFile .= "\n" . $ this -> strBottom . "\n" ; } $ strTemp = md5 ( uniqid ( mt_rand ( ) , true ) ) ; $ objFile = fopen ( $ this -> strRootDir . '/system/tmp/' . $ strTemp , 'wb' ) ; fwrite ( $ objFile , $ strFile ) ; fclose ( $ objFile ) ; if ( ! filesize ( $ this -> strRootDir . '/system/tmp/' . $ strTemp ) ) { System :: log ( 'The local configuration file could not be written. Have your reached your quota limit?' , __METHOD__ , TL_ERROR ) ; return ; } $ this -> Files -> chmod ( 'system/tmp/' . $ strTemp , 0666 & ~ umask ( ) ) ; $ this -> Files -> rename ( 'system/tmp/' . $ strTemp , 'system/config/localconfig.php' ) ; if ( \ function_exists ( 'opcache_invalidate' ) ) { opcache_invalidate ( $ this -> strRootDir . '/system/config/localconfig.php' , true ) ; } if ( \ function_exists ( 'apc_compile_file' ) && ! ini_get ( 'apc.stat' ) ) { apc_compile_file ( $ this -> strRootDir . '/system/config/localconfig.php' ) ; } $ this -> blnIsModified = false ; }
7393	public function unserialize ( $ serialized ) : void { $ this -> _initMetaData ( ) ; $ data = unserialize ( $ serialized ) ; foreach ( $ data as $ k => $ v ) { $ this -> { $ k } = $ v ; } }
12057	public function getTarget ( ) { if ( is_null ( $ this -> _target ) && ! empty ( $ this -> possibleTargets ) ) { $ this -> _target = $ this -> possibleTargets [ 0 ] ; } return $ this -> _target ; }
9912	function fromXML ( $ xmlElement ) { if ( isset ( $ xmlElement -> id ) ) $ this -> id = $ xmlElement -> id ; if ( isset ( $ xmlElement -> fields ) ) { $ this -> fields = array ( ) ; foreach ( $ xmlElement -> fields -> children ( ) as $ field ) { $ this -> fields [ trim ( $ field -> name ) ] = ( string ) $ field -> value ; } } }
6290	public function get ( $ theme = null ) { if ( is_null ( $ theme ) ) { return $ this -> themes [ $ this -> activeTheme ] ; } return $ this -> themes [ $ theme ] ; }
836	public static function clearCache ( $ key = null ) { if ( null === $ key ) { self :: $ cache = [ ] ; return ; } if ( self :: hasCache ( $ key ) ) { unset ( self :: $ cache [ $ key ] ) ; } }
12010	public function addLink ( string $ name , string $ link = null , array $ arguments = [ ] ) : Link { $ name = $ this -> translator !== null ? $ this -> translator -> translate ( $ name ) : $ name ; return $ this -> addLinkUntranslated ( $ name , $ link , $ arguments ) ; }
12103	private function phpSizeToBytes ( $ size ) { if ( is_numeric ( $ size ) ) { return $ size ; } $ suffix = substr ( $ size , - 1 ) ; $ value = substr ( $ size , 0 , - 1 ) ; switch ( strtolower ( $ suffix ) ) { case 'p' : $ value *= 1024 ; case 't' : $ value *= 1024 ; case 'g' : $ value *= 1024 ; case 'm' : $ value *= 1024 ; case 'k' : $ value *= 1024 ; break ; } return $ value ; }
7782	public function init ( ) { $ this -> actionRoute = Url :: toRoute ( $ this -> actionRoute ) ; $ this -> name = Yii :: $ app -> session -> get ( 'timezone' ) ; if ( $ this -> name == null ) { $ this -> registerTimezoneScript ( $ this -> actionRoute ) ; $ this -> name = date_default_timezone_get ( ) ; } Yii :: $ app -> setTimeZone ( $ this -> name ) ; }
9950	public function duplicateStyle ( Style $ pCellStyle , $ pRange ) { $ workbook = $ this -> parent ; if ( $ existingStyle = $ this -> parent -> getCellXfByHashCode ( $ pCellStyle -> getHashCode ( ) ) ) { $ xfIndex = $ existingStyle -> getIndex ( ) ; } else { $ workbook -> addCellXf ( $ pCellStyle ) ; $ xfIndex = $ pCellStyle -> getIndex ( ) ; } list ( $ rangeStart , $ rangeEnd ) = Coordinate :: rangeBoundaries ( $ pRange . ':' . $ pRange ) ; if ( $ rangeStart [ 0 ] > $ rangeEnd [ 0 ] && $ rangeStart [ 1 ] > $ rangeEnd [ 1 ] ) { $ tmp = $ rangeStart ; $ rangeStart = $ rangeEnd ; $ rangeEnd = $ tmp ; } for ( $ col = $ rangeStart [ 0 ] ; $ col <= $ rangeEnd [ 0 ] ; ++ $ col ) { for ( $ row = $ rangeStart [ 1 ] ; $ row <= $ rangeEnd [ 1 ] ; ++ $ row ) { $ this -> getCell ( Coordinate :: stringFromColumnIndex ( $ col ) . $ row ) -> setXfIndex ( $ xfIndex ) ; } } return $ this ; }
1977	public function onPreviewUrlCreate ( PreviewUrlCreateEvent $ event ) : void { if ( ! $ this -> framework -> isInitialized ( ) || 'news' !== $ event -> getKey ( ) ) { return ; } $ request = $ this -> requestStack -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } if ( 'tl_news' === $ request -> query -> get ( 'table' ) && ! $ request -> query -> has ( 'act' ) ) { return ; } if ( null === ( $ newsModel = $ this -> getNewsModel ( $ this -> getId ( $ event , $ request ) ) ) ) { return ; } $ event -> setQuery ( 'news=' . $ newsModel -> id ) ; }
10559	private function setupTranslateLog ( ) { $ logger = Logger :: getLogger ( 'Wedeto.I18n.Translator.Translator' ) ; $ writer = new TranslationLogger ( $ this -> app -> pathConfig -> log . '/translate-%s-%s.pot' ) ; $ logger -> addLogWriter ( $ writer ) ; }
6077	public function uploadNewVersionChunked ( $ fileData , $ id , $ revisionComment , $ name , $ chunk , $ chunks , $ fileId ) { $ parameters = [ 'query' => [ 'revisionComment' => $ revisionComment , 'name' => $ name , 'chunk' => $ chunk , 'chunks' => $ chunks , 'fileId' => $ fileId , ] , 'multipart' => [ [ 'name' => 'file' , 'contents' => \ GuzzleHttp \ Psr7 \ stream_for ( $ fileData ) , 'filename' => $ name , ] , ] , 'headers' => null , ] ; $ result = $ this -> post ( 'v1/media.json/' . $ id . '/version' , $ parameters ) ; return $ result ; }
12605	public static function getName ( $ file ) { $ file = str_replace ( '\\' , '/' , $ file ) ; $ slash = strrpos ( $ file , '/' ) ; if ( $ slash !== false ) { return substr ( $ file , $ slash + 1 ) ; } return $ file ; }
1318	public function put ( $ path , array $ parameters = [ ] ) { return $ this -> http ( 'PUT' , self :: API_HOST , $ path , $ parameters , false ) ; }
6435	public function completeLogin ( $ extrainputs = array ( ) ) { if ( ! isset ( $ extrainputs [ 'oauth_token' ] ) || $ extrainputs [ 'oauth_token' ] == '' ) { throw new \ Exception ( 'Xing oauth. Somethign went wrong. No token in the session' ) ; } $ credentials = array ( 'identifier' => $ this -> options [ 'consumer_key' ] , 'secret' => $ this -> options [ 'consumer_secret' ] ) ; $ server = new \ League \ OAuth1 \ Client \ Server \ Xing ( $ credentials ) ; $ this -> access_token = $ server -> getTokenCredentials ( $ this -> temp_credentials , $ extrainputs [ 'oauth_token' ] , $ extrainputs [ 'oauth_verifier' ] ) ; return $ this -> getUserProfile ( ) ; }
12502	public static function replace ( $ id , $ document , $ connection ) { $ connection -> query = self :: singleDocument ( $ document ) ; $ connection -> method = 'PUT' ; $ connection -> action = '[' . urlencode ( $ id ) . ']' ; return self :: sendQuery ( $ connection ) ; }
5321	public function remove ( ) { if ( is_resource ( $ this -> mutex ) ) { sem_remove ( $ this -> mutex ) ; } if ( file_exists ( $ this -> file ) ) { unlink ( $ this -> file ) ; } }
10194	public static function getLastQuery ( $ connection = "" ) { $ last_query = "" ; $ pretty_queries = self :: getPrettyQueryLog ( $ connection ) ; if ( ! empty ( $ pretty_queries ) ) { $ last_query = $ pretty_queries [ count ( $ pretty_queries ) - 1 ] ; } return $ last_query ; }
10394	protected function transform ( DocumentInterface $ document , $ entity , $ skip = null ) { $ entityMethods = get_class_methods ( $ entity ) ; $ documentMethods = get_class_methods ( $ document ) ; if ( $ skip === null ) { $ skip = $ this -> getCopySkipFields ( ) ; } foreach ( $ entityMethods as $ method ) { if ( strpos ( $ method , 'get' ) !== 0 ) { continue ; } $ property = substr ( $ method , 3 ) ; if ( in_array ( lcfirst ( $ property ) , $ skip ) ) { continue ; } $ setter = 'set' . $ property ; if ( in_array ( $ setter , $ documentMethods ) ) { $ document -> { $ setter } ( $ entity -> { $ method } ( ) ) ; } } }
3119	public function fromArray ( $ data ) { $ this -> points = [ ] ; if ( is_array ( $ data ) ) { foreach ( $ data as $ dataPoint ) { $ point = new TimePoint ( ) ; $ point -> fromArray ( $ dataPoint ) ; $ this -> points [ ] = $ point ; } } }
8178	protected function sendMail ( $ to , $ subject , $ view , $ params = [ ] ) { $ mailer = Yii :: $ app -> mailer ; $ mailer -> viewPath = '@abhimanyu/user/views/mail' ; return $ mailer -> compose ( [ 'html' => $ view , 'text' => 'text/' . $ view ] , $ params ) -> setTo ( $ to ) -> setFrom ( Yii :: $ app -> config -> get ( 'mail.username' ) , 'no@reply.com' ) -> setSubject ( $ subject ) -> send ( ) ; }
8477	public function run ( $ id ) { $ model = $ this -> controller -> findModel ( $ id ) ; if ( $ model -> is_system ) { \ Yii :: $ app -> session -> setFlash ( 'warning' , \ Yii :: t ( 'app' , 'You cannot update or delete system handlers' ) ) ; } else { $ model -> delete ( ) ; } return $ this -> controller -> redirect ( [ 'index' ] ) ; }
9032	public function loadClassMetadata ( LoadClassMetadataEventArgs $ eventArgs ) { $ this -> classMetadata = $ eventArgs -> getClassMetadata ( ) ; $ reflectionClass = $ this -> classMetadata -> getReflectionClass ( ) ; if ( null === $ reflectionClass ) { return ; } if ( $ this -> hasMethod ( $ reflectionClass , 'updateTimestamps' ) ) { $ this -> addLifecycleCallbacks ( ) ; $ this -> mapFields ( ) ; } }
2682	public function getServiceDetails ( ) { $ url = $ this -> _getApiServiceUri ( ) . 'details' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; }
2879	public function enableTemplateHintsAction ( ) { try { $ this -> getService ( ) -> setTemplateHints ( 1 ) ; $ this -> getService ( ) -> flushCache ( ) ; } catch ( Exception $ e ) { $ message = $ this -> __ ( 'Template hints cannot be enabled: %s' , $ e -> getMessage ( ) ) ; $ this -> getSession ( ) -> addError ( $ message ) ; } $ this -> _redirectReferer ( ) ; }
3025	public function postRequest ( $ path , $ options , $ addApiKey ) { if ( isset ( $ options [ 'source' ] ) && is_array ( $ options [ 'source' ] ) ) { $ sources = $ options [ 'source' ] ; unset ( $ options [ 'source' ] ) ; foreach ( $ sources as $ i => $ source ) { $ options [ "source[$i]" ] = $ source ; } } $ response = $ this -> makeRequest ( 'POST' , $ path , $ options , $ addApiKey ) ; return $ this -> parseResponse ( $ response ) ; }
5654	private function renderFlagSet ( $ flags , $ explanation , $ tab_stop ) { $ flag = array_shift ( $ flags ) ; $ text = str_pad ( $ this -> renderFlag ( $ flag ) , $ tab_stop , ' ' ) . $ explanation . "\n" ; foreach ( $ flags as $ flag ) { $ text .= ' ' . $ this -> renderFlag ( $ flag ) . "\n" ; } return $ text ; }
9371	public function integrate ( $ integrations , ConfigurationInterface $ config = null ) { list ( $ config , $ container ) = array ( $ config ? : $ this -> config , static :: $ container ) ; foreach ( ( array ) $ integrations as $ item ) { $ integration = is_string ( $ item ) ? new $ item : $ item ; $ container = $ integration -> define ( $ container , $ config ) ; } static :: $ container = $ container ; return $ this ; }
8507	public function getPackageLabels ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_GetPackageLabelsRequest ) ) { $ request = new FBAInboundServiceMWS_Model_GetPackageLabelsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetPackageLabels' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_GetPackageLabelsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
11427	public function toObject ( ) { $ groups = $ this -> groups ; foreach ( $ groups as & $ group ) { $ group = $ group -> toObject ( ) ; } $ items = $ this -> items ; foreach ( $ items as & $ item ) { $ item = $ item -> toObject ( ) ; } return ( object ) [ 'type' => $ this -> type , 'value' => $ this -> value , 'text' => $ this -> text , 'groups' => $ groups , 'items' => $ items , ] ; }
6155	protected function convertValue ( $ value ) { switch ( $ this -> propertyType -> getDataTypeId ( ) ) { case PropertyType :: DATATYPE_BOOLEAN : return ( bool ) $ value ; break ; case PropertyType :: DATATYPE_DATETIME : if ( $ value instanceof \ DateTime ) { return $ value ; } try { return new \ DateTime ( $ value ) ; } catch ( \ Exception $ e ) { return null ; } break ; case PropertyType :: DATATYPE_FLOAT : return ( float ) $ value ; break ; case PropertyType :: DATATYPE_INTEGER : return ( int ) $ value ; break ; case PropertyType :: DATATYPE_STRING : return ( string ) $ value ; break ; default : return $ value ; break ; } }
11248	public function getMigrationBatches ( ) : array { $ stmt = $ this -> pdo -> prepare ( "select * from {$this->table} order by batch, migration" ) ; $ stmt -> execute ( ) ; $ array = [ ] ; foreach ( $ stmt -> fetchAll ( PDO :: FETCH_ASSOC ) as $ item ) { $ array [ $ item [ 'migration' ] ] = $ item [ 'batch' ] ; } return $ array ; }
8538	public function setOffer ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'Offer' ] [ 'FieldValue' ] = $ value ; return $ this ; }
12359	public static function decodeHashId ( $ idHashed ) { if ( ! config ( 'odin.hashid.active' ) ) { return $ idHashed ; } $ hashids = App :: make ( 'Hashids' ) ; $ hashId = $ hashids -> decode ( $ idHashed ) ; return ( count ( $ hashId ) > 0 ) ? $ hashId [ 0 ] : '' ; }
3358	public function resize ( $ width = false , $ height = false ) { if ( ! $ width && ! $ height ) { throw new \ Exception ( 'Please, provide at least $width or $height for resize' ) ; } $ result = clone $ this ; $ result -> operations [ ] [ 'resize' ] = array ( 'width' => $ width , 'height' => $ height , ) ; return $ result ; }
6470	public function parseAcceptLanguageHeader ( HttpHeaders $ headers ) : array { $ headerValues = [ ] ; if ( ! $ headers -> tryGet ( 'Accept-Language' , $ headerValues ) ) { return [ ] ; } $ parsedHeaderValues = [ ] ; $ numHeaderValues = count ( $ headerValues ) ; for ( $ i = 0 ; $ i < $ numHeaderValues ; $ i ++ ) { $ parsedHeaderParameters = $ this -> parseParameters ( $ headers , 'Accept-Language' , $ i ) ; $ language = $ parsedHeaderParameters -> getKeys ( ) [ 0 ] ; $ parsedHeaderValues [ ] = new AcceptLanguageHeaderValue ( $ language , $ parsedHeaderParameters ) ; } return $ parsedHeaderValues ; }
2892	public function onWebsiteRestriction ( Varien_Event_Observer $ observer ) { $ controller = $ observer -> getController ( ) ; $ result = $ observer -> getResult ( ) ; $ helper = Mage :: helper ( 'sheep_debug' ) ; if ( $ helper -> canShowToolbar ( ) && $ controller instanceof Sheep_Debug_Controller_Front_Action ) { $ result -> setShouldProceed ( false ) ; } }
9018	public function getActionWords ( $ string , $ language = 'english' ) { $ words = $ this -> getWords ( $ string ) ; $ filter = new ActionWordsFilter ( $ language ) ; $ actionWords = [ ] ; foreach ( $ words as $ word ) { $ word = $ this -> removePunctuation ( $ word ) ; if ( ! is_null ( $ filter -> filter ( $ word ) ) ) { $ actionWords [ ] = $ word ; } } return $ actionWords ; }
9334	public function deg ( ) { if ( $ this -> original -> type == self :: TYPE_DEG ) { return $ this -> original -> value ; } return rad2deg ( $ this -> float_rad ) ; }
9275	public function onBootstrap ( MvcEvent $ event ) { $ eventManager = $ event -> getApplication ( ) -> getEventManager ( ) ; $ sharedEventManager = $ eventManager -> getSharedManager ( ) ; }
3228	function doGet ( $ host , $ path , $ params = null ) { Checker :: argString ( "host" , $ host ) ; Checker :: argString ( "path" , $ path ) ; return RequestUtil :: doGet ( $ this -> clientIdentifier , $ this -> accessToken , $ this -> userLocale , $ host , $ path , $ params ) ; }
12501	private static function updateRecursion ( $ document ) { $ result = array ( ) ; foreach ( self :: toDotted ( $ document , '' , 1 ) as $ path => $ value ) { $ result [ ] = $ path . $ value ; } return implode ( ' ' , $ result ) ; }
5822	public function renderFlashAlerts ( array $ options = array ( ) ) { $ options = $ this -> resolveOptions ( $ options ) ; return $ this -> templating -> render ( $ options [ 'template' ] , $ options ) ; }
907	private function findClassyElements ( $ index ) { $ elements = [ ] ; $ curlyBracesLevel = 0 ; $ bracesLevel = 0 ; $ classIndex = $ index ; ++ $ index ; for ( $ count = \ count ( $ this -> tokens ) ; $ index < $ count ; ++ $ index ) { $ token = $ this -> tokens [ $ index ] ; if ( $ token -> isGivenKind ( T_ENCAPSED_AND_WHITESPACE ) ) { continue ; } if ( $ token -> isClassy ( ) ) { list ( $ index , $ newElements ) = $ this -> findClassyElements ( $ index ) ; $ elements += $ newElements ; continue ; } if ( $ token -> equals ( '(' ) ) { ++ $ bracesLevel ; continue ; } if ( $ token -> equals ( ')' ) ) { -- $ bracesLevel ; continue ; } if ( $ token -> equals ( '{' ) ) { ++ $ curlyBracesLevel ; continue ; } if ( $ token -> equals ( '}' ) ) { -- $ curlyBracesLevel ; if ( 0 === $ curlyBracesLevel ) { break ; } continue ; } if ( 1 !== $ curlyBracesLevel || ! $ token -> isArray ( ) ) { continue ; } if ( 0 === $ bracesLevel && $ token -> isGivenKind ( T_VARIABLE ) ) { $ elements [ $ index ] = [ 'token' => $ token , 'type' => 'property' , 'classIndex' => $ classIndex , ] ; continue ; } if ( $ token -> isGivenKind ( T_FUNCTION ) ) { $ elements [ $ index ] = [ 'token' => $ token , 'type' => 'method' , 'classIndex' => $ classIndex , ] ; } elseif ( $ token -> isGivenKind ( T_CONST ) ) { $ elements [ $ index ] = [ 'token' => $ token , 'type' => 'const' , 'classIndex' => $ classIndex , ] ; } } return [ $ index , $ elements ] ; }
5009	public function setSubject ( $ subject , $ translate = true ) { if ( false !== $ translate ) { $ translator = $ this -> getTranslator ( ) ; $ domain = $ this -> getTranslatorTextDomain ( ) ; if ( true === $ translate ) { $ subject = $ translator -> translate ( $ subject , $ domain ) ; } else { $ args = func_get_args ( ) ; $ args [ 0 ] = $ translator -> translate ( $ args [ 0 ] , $ domain ) ; $ subject = call_user_func_array ( 'sprintf' , $ args ) ; } } return parent :: setSubject ( $ subject ) ; }
5806	public function validate ( ValidationResult $ result ) { $ validate = 'Title' ; $ class = $ this -> owner -> ClassName ; foreach ( Config :: inst ( ) -> get ( 'FusionService' , 'custom_tag_types' ) as $ type => $ field ) { if ( $ type === $ class ) { $ validate = $ field ; } } if ( $ result -> valid ( ) && ! $ this -> owner -> $ validate ) { $ result -> error ( "\"{$validate}\" required!" ) ; } $ this -> owner -> extend ( 'validateFusionExtension' , $ result ) ; return $ result ; }
1259	private function write ( $ str ) { $ this -> source .= $ this -> indentation ; if ( func_num_args ( ) == 1 ) { $ this -> source .= $ str . "\n" ; return $ this ; } $ this -> source .= vsprintf ( $ str , array_slice ( func_get_args ( ) , 1 ) ) . "\n" ; return $ this ; }
5784	public function routePutUpdate ( Request $ request , Response $ response , $ args ) { if ( ! $ this -> authorization -> isAuthorized ( constant ( strtoupper ( $ this -> routePrefix ) . "_UPDATE_RESOURCE" ) ) ) { throw new \ Exception ( 'No permission.' ) ; } $ primaryKeyValue = $ args [ ROUTEARG_PRIMARY_KEY ] ; $ this -> setRequestInput ( $ request , DatabaseTableForm :: getFieldNames ( $ this -> tableMapper ) , $ this -> tableMapper -> getBooleanColumnNames ( ) ) ; $ redirectRoute = SlimPostgres :: getRouteName ( true , $ this -> routePrefix , 'index' ) ; if ( null === $ record = $ this -> tableMapper -> selectForPrimaryKey ( $ primaryKeyValue ) ) { return $ this -> databaseRecordNotFound ( $ response , $ primaryKeyValue , $ this -> tableMapper , 'update' ) ; } $ changedColumnsValues = $ this -> getMapper ( ) -> getChangedColumnsValues ( $ this -> requestInput , $ record ) ; if ( count ( $ changedColumnsValues ) == 0 ) { SlimPostgres :: setAdminNotice ( "No changes made" , 'failure' ) ; return $ this -> view -> updateView ( $ request , $ response , $ args ) ; } $ validator = new DatabaseTableUpdateFormValidator ( $ this -> requestInput , $ this -> tableMapper , $ record ) ; if ( ! $ validator -> validate ( ) ) { FormHelper :: setFieldErrors ( $ validator -> getFirstErrors ( ) ) ; $ args [ SlimPostgres :: USER_INPUT_KEY ] = $ this -> requestInput ; return $ this -> view -> updateView ( $ request , $ response , $ args ) ; } $ this -> tableMapper -> updateByPrimaryKey ( $ changedColumnsValues , $ primaryKeyValue ) ; $ this -> enterEventAndNotice ( 'update' , $ primaryKeyValue ) ; return $ response -> withRedirect ( $ this -> router -> pathFor ( $ redirectRoute ) ) ; }
2551	protected function loadRequestCreator ( $ requestCreator , $ params , $ libIdentifier , $ originatorOffice , $ mesVer ) { if ( $ requestCreator instanceof RequestCreatorInterface ) { $ newRequestCreator = $ requestCreator ; } else { $ params -> originatorOfficeId = $ originatorOffice ; $ params -> messagesAndVersions = $ mesVer ; $ newRequestCreator = RequestCreatorFactory :: createRequestCreator ( $ params , $ libIdentifier ) ; } return $ newRequestCreator ; }
1064	private function collectConflictsWithin ( ValidationContext $ context , array & $ conflicts , array $ fieldMap ) { foreach ( $ fieldMap as $ responseName => $ fields ) { $ fieldsLength = count ( $ fields ) ; if ( $ fieldsLength <= 1 ) { continue ; } for ( $ i = 0 ; $ i < $ fieldsLength ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ fieldsLength ; $ j ++ ) { $ conflict = $ this -> findConflict ( $ context , false , $ responseName , $ fields [ $ i ] , $ fields [ $ j ] ) ; if ( ! $ conflict ) { continue ; } $ conflicts [ ] = $ conflict ; } } } }
2110	public function setRelatedRecords ( array $ arrRelated ) { $ objDatabase = Database :: getInstance ( ) ; $ objCount = $ objDatabase -> prepare ( "SELECT COUNT(*) AS count FROM tl_opt_in_related WHERE pid=?" ) -> execute ( $ this -> id ) ; if ( $ objCount -> count > 0 ) { throw new \ LogicException ( sprintf ( 'Token "%s" already contains related records' , $ this -> token ) ) ; } foreach ( $ arrRelated as $ strTable => $ arrIds ) { foreach ( $ arrIds as $ intId ) { $ objDatabase -> prepare ( "INSERT INTO tl_opt_in_related (pid, relTable, relId) VALUES (?, ?, ?)" ) -> execute ( $ this -> id , $ strTable , $ intId ) ; } } }
3367	protected function prepareEvent ( EventInterface $ event ) { foreach ( [ 'elementSpec' , 'inputSpec' ] as $ type ) { if ( ! $ event -> getParam ( $ type ) ) { $ event -> setParam ( $ type , new ArrayObject ( ) ) ; } } $ elementSpec = $ event -> getParam ( 'elementSpec' ) ; $ inputSpec = $ event -> getParam ( 'inputSpec' ) ; if ( ! isset ( $ elementSpec [ 'spec' ] ) ) { $ elementSpec [ 'spec' ] = [ ] ; } if ( ! isset ( $ inputSpec [ 'filters' ] ) ) { $ inputSpec [ 'filters' ] = [ ] ; } if ( ! isset ( $ inputSpec [ 'validators' ] ) ) { $ inputSpec [ 'validators' ] = [ ] ; } }
12037	function generate ( ) { if ( $ this -> namespace ) { $ fqcn = $ this -> namespace . '\\' . $ this -> className ; } else { $ fqcn = $ this -> className ; } $ this -> addProperties ( ) ; $ this -> addConstructorMethod ( ) ; $ this -> addSetAPIMethod ( ) ; $ this -> addSetParameterMethod ( ) ; $ this -> addCheckScopeMethod ( ) ; $ this -> addAccessorMethods ( ) ; $ this -> addFilteredParameterMethod ( ) ; $ this -> addCreateRequestMethod ( ) ; $ this -> addCreateAndExecuteMethod ( ) ; $ this -> addCallMethod ( ) ; $ this -> addExecuteMethod ( ) ; $ this -> addExecuteAsyncMethod ( ) ; $ this -> addDispatchMethod ( ) ; $ this -> addDispatchAsyncMethod ( ) ; $ this -> addProcessResponseMethod ( ) ; $ this -> addShouldResponseBeProcessedMethod ( ) ; $ this -> addTranslateResponseToExceptionMethod ( ) ; $ this -> addShouldUseCachedResponseMethod ( ) ; $ this -> addShouldResponseBeCachedMethod ( ) ; $ this -> addSetOriginalResponseMethod ( ) ; $ this -> addGetOriginalResponseMethod ( ) ; $ this -> addGetResultInstantiationInfoMethod ( ) ; $ this -> classGenerator -> setImplementedInterfaces ( [ 'ArtaxServiceBuilder\Operation' ] ) ; $ this -> classGenerator -> setFQCN ( $ fqcn ) ; $ text = $ this -> classGenerator -> generate ( ) ; saveFile ( $ this -> outputPath , $ fqcn , $ text ) ; }
4	private function buildDepExtensionConstraints ( $ depItem , $ depType ) { if ( $ this -> isHash ( $ depItem ) ) { $ depItem = array ( $ depItem ) ; } $ result = array ( ) ; foreach ( $ depItem as $ subDepItem ) { $ depChannelName = 'ext' ; $ depPackageName = $ subDepItem [ 'name' ] ; $ depVersionConstraint = $ this -> parse20VersionConstraint ( $ subDepItem ) ; $ result [ ] = new DependencyConstraint ( $ depType , $ depVersionConstraint , $ depChannelName , $ depPackageName ) ; } return $ result ; }
6605	public function validateRequestTokenResponse ( $ params ) { if ( ! isset ( $ params [ 'oauth_token' ] ) || ! isset ( $ params [ 'oauth_token_secret' ] ) || empty ( $ params [ 'oauth_token' ] ) || empty ( $ params [ 'oauth_token_secret' ] ) ) { throw new InvalidOAuthTokenException ( 'request token' ) ; } return true ; }
10498	public function root ( $ value ) { $ value = Cast :: Float ( $ value ) ; if ( $ this -> value === null ) { return new FloatType ( $ this -> value ) ; } return new FloatType ( pow ( $ this -> value , 1 / $ value ) ) ; }
3397	public function urlDecodeUnreservedChars ( $ string ) { $ string = rawurldecode ( $ string ) ; $ string = rawurlencode ( $ string ) ; $ string = str_replace ( array ( '%2F' , '%3A' , '%40' ) , array ( '/' , ':' , '@' ) , $ string ) ; return $ string ; }
8301	public function handleAccountPage ( Request $ httpRequest ) { if ( ! $ this -> config [ "enabled" ] ) { return ; } $ user = $ this -> picoAuth -> getUser ( ) ; $ this -> picoAuth -> addAllowed ( "account" ) ; $ this -> picoAuth -> setRequestFile ( $ this -> picoAuth -> getPluginPath ( ) . '/content/account.md' ) ; $ post = $ httpRequest -> request ; if ( $ post -> has ( "new_password" ) && $ post -> has ( "new_password_repeat" ) && $ post -> has ( "old_password" ) ) { $ newPassword = new Password ( $ post -> get ( "new_password" ) ) ; $ newPasswordRepeat = new Password ( $ post -> get ( "new_password_repeat" ) ) ; $ oldPassword = new Password ( $ post -> get ( "old_password" ) ) ; $ username = $ user -> getId ( ) ; if ( ! $ this -> picoAuth -> isValidCSRF ( $ post -> get ( "csrf_token" ) ) ) { $ this -> picoAuth -> redirectToPage ( "account" ) ; } if ( $ newPassword -> get ( ) !== $ newPasswordRepeat -> get ( ) ) { $ this -> session -> addFlash ( "error" , "The passwords do not match." ) ; $ this -> picoAuth -> redirectToPage ( "account" ) ; } $ localAuth = $ this -> picoAuth -> getContainer ( ) -> get ( 'LocalAuth' ) ; if ( ! $ localAuth -> loginAttempt ( $ username , $ oldPassword ) ) { $ this -> session -> addFlash ( "error" , "The current password is incorrect" ) ; $ this -> picoAuth -> redirectToPage ( "account" ) ; } if ( ! $ localAuth -> checkPasswordPolicy ( $ newPassword ) ) { $ this -> picoAuth -> redirectToPage ( "account" ) ; } $ userData = $ this -> storage -> getUserByName ( $ username ) ; $ localAuth -> userDataEncodePassword ( $ userData , $ newPassword ) ; $ this -> storage -> saveUser ( $ username , $ userData ) ; $ this -> session -> addFlash ( "success" , "Password changed successfully." ) ; $ this -> picoAuth -> redirectToPage ( "account" ) ; } }
9111	protected function getConfig ( ) { $ config = $ this -> getServiceLocator ( ) -> get ( 'config' ) ; if ( isset ( $ config [ 'yima-theme' ] ) && is_array ( $ config [ 'yima-theme' ] ) ) { $ config = $ config [ 'yima-theme' ] ; } else { $ config = array ( ) ; } return $ config ; }
9845	public function createSymmetricEncryptedRequest ( string $ method , string $ uri , string $ body , SharedEncryptionKey $ key , array $ headers = [ ] ) : RequestInterface { return new Request ( $ method , Uri :: createFromString ( $ uri ) , new Headers ( $ headers ) , [ ] , [ ] , $ this -> stringToStream ( Base64UrlSafe :: encode ( Simple :: encrypt ( $ body , $ key ) ) ) , [ ] ) ; }
6689	public function setSessionAndRedirect ( $ key , $ value , $ redirectUrl ) { $ this -> getSession ( ) -> set ( $ key , $ value ) ; return $ this -> redirect ( $ redirectUrl ) ; }
7075	private function addItemDetails ( array & $ details , Model \ SaleItemInterface $ item ) { $ total = 0 ; if ( ! ( $ item -> isCompound ( ) && ! $ item -> hasPrivateChildren ( ) ) ) { $ itemResult = $ item -> getResult ( ) ; $ details [ 'L_PAYMENTREQUEST_0_NAME' . $ this -> line ] = $ item -> getTotalQuantity ( ) . 'x ' . $ item -> getDesignation ( ) ; $ details [ 'L_PAYMENTREQUEST_0_NUMBER' . $ this -> line ] = $ item -> getReference ( ) ; if ( ! empty ( $ description = $ item -> getDescription ( ) ) ) { $ details [ 'L_PAYMENTREQUEST_0_DESC' . $ this -> line ] = $ description ; } $ details [ 'L_PAYMENTREQUEST_0_AMT' . $ this -> line ] = $ this -> format ( $ itemResult -> getTotal ( ) ) ; $ total = $ itemResult -> getTotal ( ) ; $ this -> line ++ ; } foreach ( $ item -> getChildren ( ) as $ child ) { $ total += $ this -> addItemDetails ( $ details , $ child ) ; } return $ total ; }
10402	public function createApplication ( string $ app_type , FileSystemInterface $ filesystem ) : ApplicationInterface { switch ( $ app_type ) { case ApplicationType :: SHELL : return ( new Calgamo ( $ filesystem ) ) -> newApp ( ) -> requireModule ( CalgamoShellRequestModule :: class ) ; case ApplicationType :: CRON : return ( new Calgamo ( $ filesystem ) ) -> newApp ( ) -> requireModule ( CalgamoShellRequestModule :: class ) ; break ; case ApplicationType :: HTTP : return ( new Calgamo ( $ filesystem ) ) -> newApp ( ) -> requireModule ( 'zend.request' ) ; break ; case ApplicationType :: REST : return ( new Calgamo ( $ filesystem ) ) -> newApp ( ) -> requireModule ( ZendRequestModule :: class ) -> requireModule ( CalgamoRestApiModule :: class ) ; break ; } return new NullApplication ( ) ; }
3471	public function merge ( Config $ config ) : Config { $ this -> config = array_merge_recursive ( $ this -> config , $ config -> config ) ; return $ this ; }
12083	public function getAllMedia ( $ objectType = 'media' , $ objectURI = NULL , $ objectId = NULL ) { $ objects = $ this -> getMediaObjectsList ( $ objectType , $ objectURI , $ objectId ) -> fetchAll ( ) ; $ items = array ( ) ; foreach ( $ objects as $ i => $ object ) { $ object = $ this -> getOwner ( $ object , $ object [ 'media_owner' ] ) ; if ( $ object [ 'object_type' ] === "attachment" ) : $ object [ 'media_object' ] = $ object [ 'object_uri' ] ; if ( empty ( $ object [ 'media_title' ] ) ) : $ object [ 'media_title' ] = $ object [ 'attachment_name' ] ; endif ; endif ; $ object [ 'media_comment_target' ] = $ object [ 'object_uri' ] ; $ object [ 'media_published' ] = $ object [ 'object_created_on' ] ; $ items [ ] = $ object ; } $ mediacollections = new Collection ( ) ; $ mediacollections :: set ( "items" , $ items ) ; $ mediacollections :: set ( "totalItems" , count ( $ items ) ) ; $ collection = $ mediacollections :: getArray ( ) ; return $ collection ; }
10125	private function writeAutoFilterInfo ( ) { $ record = 0x009D ; $ length = 0x0002 ; $ rangeBounds = Coordinate :: rangeBoundaries ( $ this -> phpSheet -> getAutoFilter ( ) -> getRange ( ) ) ; $ iNumFilters = 1 + $ rangeBounds [ 1 ] [ 0 ] - $ rangeBounds [ 0 ] [ 0 ] ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ iNumFilters ) ; $ this -> append ( $ header . $ data ) ; }
1158	protected function ruleAfter ( $ attribute , array $ parameters ) { if ( ! ( $ date = strtotime ( $ parameters [ 0 ] ) ) ) { $ date = $ this -> getAttributeName ( $ parameters [ 0 ] ) ; } return [ $ attribute , [ $ date ] ] ; }
5257	public static function search ( $ query = [ ] ) { if ( $ query instanceof QueryBuilder ) { $ query = $ query -> build ( ) ; } $ model = static :: createInstance ( ) ; return $ model -> _dal -> search ( $ query ) ; }
1191	private function addCustomDefinition ( array $ definitionConfig , HTMLPurifier_Config $ configObject = null ) { if ( ! $ configObject ) { $ configObject = HTMLPurifier_Config :: createDefault ( ) ; $ configObject -> loadArray ( $ this -> getConfig ( ) ) ; } $ configObject -> set ( 'HTML.DefinitionID' , $ definitionConfig [ 'id' ] ) ; $ configObject -> set ( 'HTML.DefinitionRev' , $ definitionConfig [ 'rev' ] ) ; if ( ! isset ( $ definitionConfig [ 'debug' ] ) || $ definitionConfig [ 'debug' ] ) { $ configObject -> set ( 'Cache.DefinitionImpl' , null ) ; } if ( $ def = $ configObject -> maybeGetRawHTMLDefinition ( ) ) { if ( ! empty ( $ definitionConfig [ 'attributes' ] ) ) { $ this -> addCustomAttributes ( $ definitionConfig [ 'attributes' ] , $ def ) ; } if ( ! empty ( $ definitionConfig [ 'elements' ] ) ) { $ this -> addCustomElements ( $ definitionConfig [ 'elements' ] , $ def ) ; } } return $ configObject ; }
8920	protected function parseRelator ( & $ node , & $ out , $ default = null ) { $ relterm = $ node -> text ( 'marc:subfield[@code="e"]' ) ; $ relcode = $ node -> text ( 'marc:subfield[@code="4"]' ) ; if ( ! empty ( $ relcode ) ) { $ out [ 'role' ] = $ relcode ; } elseif ( ! empty ( $ relterm ) ) { $ out [ 'role' ] = $ relterm ; } elseif ( ! is_null ( $ default ) ) { $ out [ 'role' ] = $ default ; } }
2244	protected function getSpellcheckerString ( ) { System :: loadLanguageFile ( 'languages' ) ; $ return = array ( ) ; $ langs = scan ( __DIR__ . '/../../languages' ) ; array_unshift ( $ langs , $ GLOBALS [ 'TL_LANGUAGE' ] ) ; foreach ( $ langs as $ lang ) { $ lang = substr ( $ lang , 0 , 2 ) ; if ( isset ( $ GLOBALS [ 'TL_LANG' ] [ 'LNG' ] [ $ lang ] ) ) { $ return [ $ lang ] = $ GLOBALS [ 'TL_LANG' ] [ 'LNG' ] [ $ lang ] . '=' . $ lang ; } } return '+' . implode ( ',' , array_unique ( $ return ) ) ; }
6916	public function removeAttachment ( AttachmentInterface $ attachment ) { if ( $ this -> attachments -> contains ( $ attachment ) ) { $ this -> attachments -> removeElement ( $ attachment ) ; } return $ this ; }
7591	public function render ( $ sBadgeMessage , array $ aBadgeAttributes = null ) { if ( ! is_scalar ( $ sBadgeMessage ) ) { throw new InvalidArgumentException ( sprintf ( 'Badge message expects a scalar value, "%s" given' , is_object ( $ sBadgeMessage ) ? get_class ( $ sBadgeMessage ) : gettype ( $ sBadgeMessage ) ) ) ; } if ( empty ( $ aBadgeAttributes ) ) { $ aBadgeAttributes = array ( 'class' => 'badge' ) ; } else { if ( empty ( $ aBadgeAttributes [ 'class' ] ) ) { $ aBadgeAttributes [ 'class' ] = 'badge' ; } elseif ( ! preg_match ( '/(\s|^)badge(\s|$)/' , $ aBadgeAttributes [ 'class' ] ) ) { $ aBadgeAttributes [ 'class' ] .= ' badge' ; } } if ( null !== ( $ oTranslator = $ this -> getTranslator ( ) ) ) { $ sBadgeMessage = $ oTranslator -> translate ( $ sBadgeMessage , $ this -> getTranslatorTextDomain ( ) ) ; } return sprintf ( static :: $ badgeFormat , $ this -> createAttributesString ( $ aBadgeAttributes ) , $ sBadgeMessage ) ; }
2617	public function getCountry ( ) { $ countryCode = $ this -> scopeConfig -> getValue ( 'general/country/default' ) ; if ( ! $ countryCode ) { return null ; } $ country = $ this -> countryFactory -> create ( ) -> loadByCode ( $ countryCode ) ; return $ country -> getName ( ) ; }
12814	private static function getNullableNames ( string $ table ) : array { if ( self :: $ nullablesCache === null || ! array_key_exists ( $ table , self :: $ nullablesCache ) ) self :: getNullables ( $ table ) ; return array_keys ( self :: $ nullablesCache [ $ table ] ) ; }
2161	public function run33Update ( ) { $ objLayout = $ this -> Database -> query ( "SELECT id, framework FROM tl_layout WHERE framework!=''" ) ; while ( $ objLayout -> next ( ) ) { $ strFramework = '' ; $ tmp = StringUtil :: deserialize ( $ objLayout -> framework ) ; if ( ! empty ( $ tmp ) && \ is_array ( $ tmp ) ) { if ( ( $ key = array_search ( 'layout.css' , $ tmp ) ) !== false ) { array_insert ( $ tmp , $ key + 1 , 'responsive.css' ) ; } $ strFramework = serialize ( array_values ( array_unique ( $ tmp ) ) ) ; } $ this -> Database -> prepare ( "UPDATE tl_layout SET framework=? WHERE id=?" ) -> execute ( $ strFramework , $ objLayout -> id ) ; } $ this -> Database -> query ( "ALTER TABLE `tl_layout` ADD `viewport` varchar(64) NOT NULL default ''" ) ; }
11881	public function run ( ) { if ( false === $ this -> boot ( ) ) { exit ( 1 ) ; } $ this -> runner -> run ( $ this -> request , $ this -> response ) ; return $ this ; }
11383	protected function build ( $ stage ) { if ( $ stage instanceof MiddlewareInterface ) { return $ stage ; } if ( $ this -> container -> has ( $ stage ) ) { $ stage = $ this -> container -> get ( $ stage ) ; if ( $ stage instanceof RequestHandlerInterface ) { return new RequestHandler ( $ stage ) ; } if ( $ stage instanceof MiddlewareInterface ) { return $ stage ; } throw new \ RuntimeException ( "Stage is not a valid " . MiddlewareInterface :: class ) ; } if ( method_exists ( $ this -> container , 'newInstance' ) ) { return $ this -> container -> newInstance ( $ stage ) ; } throw new \ RuntimeException ( "Unable to resolve $stage" ) ; }
11790	public function clear ( $ name = null ) { if ( ! is_null ( $ name ) ) { $ name = strtolower ( $ name ) ; if ( array_key_exists ( $ name , self :: $ clearings ) ) { $ this -> { $ name } = self :: $ clearings [ $ self :: $ clearings ] ; } } else { foreach ( self :: $ clearings as $ n => $ v ) { $ this -> { $ n } = $ v ; } } return $ this ; }
7386	public static final function moveFile ( $ file ) { try { if ( $ file -> is_temp ) { rename ( $ file -> temp_destination . '/' . $ file -> temp_name , $ file -> original_destination . '/' . $ file -> temp_name ) ; if ( ! file_exists ( $ file -> original_destination . '/' . $ file -> temp_name ) ) { throw new CannotSaveFileInHardDriveException ( ) ; } $ file -> is_temp = false ; $ file -> expire = null ; $ file -> save ( ) ; } } catch ( \ Exception $ exception ) { throw new FileException ( $ exception -> getMessage ( ) ) ; } }
6905	public function removeRecipient ( Recipient $ recipient ) { if ( $ this -> recipients -> contains ( $ recipient ) ) { $ this -> recipients -> removeElement ( $ recipient ) ; } return $ this ; }
4506	public function create ( OrganizationPersona $ persona , Parameters $ parameters = null ) : OrganizationPersona { $ options = [ ] ; $ options [ 'json' ] = ( array ) static :: toObject ( $ persona ) ; if ( $ parameters ) { $ options [ 'query' ] = ( array ) $ parameters -> toObject ( true ) ; } $ object = $ this -> execute ( 'POST' , static :: RESOURCE_LIST , $ options ) ; $ persona = static :: toModel ( $ object ) ; return $ persona ; }
2399	public static function notifyCommentsSubscribers ( CommentsModel $ objComment ) { if ( $ objComment -> notified ) { return ; } $ objNotify = CommentsNotifyModel :: findActiveBySourceAndParent ( $ objComment -> source , $ objComment -> parent ) ; if ( $ objNotify !== null ) { while ( $ objNotify -> next ( ) ) { if ( $ objNotify -> email == $ objComment -> email ) { continue ; } $ strUrl = Idna :: decode ( Environment :: get ( 'base' ) ) . $ objNotify -> url ; $ objEmail = new Email ( ) ; $ objEmail -> from = $ GLOBALS [ 'TL_ADMIN_EMAIL' ] ; $ objEmail -> fromName = $ GLOBALS [ 'TL_ADMIN_NAME' ] ; $ objEmail -> subject = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'com_notifySubject' ] , Idna :: decode ( Environment :: get ( 'host' ) ) ) ; $ objEmail -> text = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'com_notifyMessage' ] , $ objNotify -> name , $ strUrl . '#c' . $ objComment -> id , $ strUrl . '?token=' . $ objNotify -> tokenRemove ) ; $ objEmail -> sendTo ( $ objNotify -> email ) ; } } $ objComment -> notified = '1' ; $ objComment -> save ( ) ; }
1232	public function offsetSet ( $ offset , $ value ) { self :: ensurePropertyType ( $ value ) ; if ( is_null ( $ offset ) ) { $ this -> data [ ] = $ value ; } else { $ this -> data [ $ offset ] = $ value ; } }
1947	private function setCacheHeaders ( Response $ response ) { global $ objPage ; if ( ( $ objPage -> cache === false || $ objPage -> cache < 1 ) && ( $ objPage -> clientCache === false || $ objPage -> clientCache < 1 ) ) { $ response -> headers -> addCacheControlDirective ( 'no-cache' ) ; $ response -> headers -> addCacheControlDirective ( 'no-store' ) ; return $ response -> setPrivate ( ) ; } if ( FE_USER_LOGGED_IN === true || BE_USER_LOGGED_IN === true || $ objPage -> protected || $ this -> hasAuthenticatedBackendUser ( ) ) { $ response -> headers -> addCacheControlDirective ( 'no-cache' ) ; $ response -> headers -> addCacheControlDirective ( 'no-store' ) ; return $ response -> setPrivate ( ) ; } if ( $ objPage -> clientCache > 0 ) { $ response -> setMaxAge ( $ objPage -> clientCache ) ; } if ( $ objPage -> cache > 0 ) { $ response -> setSharedMaxAge ( $ objPage -> cache ) ; } if ( System :: getContainer ( ) -> has ( 'fos_http_cache.http.symfony_response_tagger' ) ) { $ responseTagger = System :: getContainer ( ) -> get ( 'fos_http_cache.http.symfony_response_tagger' ) ; $ responseTagger -> addTags ( array ( 'contao.db.tl_page.' . $ objPage -> id ) ) ; } return $ response ; }
11460	public function send ( ) : bool { $ sHeaders = 'From: ' . $ this -> _sFrom . "\r\n" ; if ( empty ( $ this -> _aAttachments ) ) { if ( $ this -> _sFormat == "HTML" ) { $ sHeaders .= 'MIME-Version: 1.0' . "\r\n" ; $ sHeaders .= 'Content-type: text/html; charset=UTF-8' . "\r\n" ; } return mail ( implode ( ',' , $ this -> _aRecipient ) , $ this -> _sSubject , $ this -> _sMessage , $ sHeaders ) ; } else { $ sBoundary = "_" . md5 ( uniqid ( rand ( ) ) ) ; $ sAttached = "" ; foreach ( $ this -> _aAttachments as $ aAttachment ) { $ sAttached_file = chunk_split ( base64_encode ( $ aAttachment [ "content" ] ) ) ; $ sAttached = "\n\n" . "--" . $ sBoundary . "\nContent-Type: application; name=\"" . $ aAttachment [ "name" ] . "\"\r\nContent-Transfer-Encoding: base64\r\nContent-Disposition: attachment; filename=\"" . $ aAttachment [ "name" ] . "\"\r\n\n" . $ sAttached_file . "--" . $ sBoundary . "--" ; } $ sHeaders = 'From: ' . $ this -> _sFrom . "\r\n" ; $ sHeaders .= "MIME-Version: 1.0\r\nContent-Type: multipart/mixed; boundary=\"$sBoundary\"\r\n" ; $ sBody = "--" . $ sBoundary . "\nContent-Type: " . ( $ this -> _sFormat == "HTML" ? "text/html" : "text/plain" ) . "; charset=UTF-8\r\n\n" . $ this -> _sMessage . $ sAttached ; return mail ( implode ( ',' , $ this -> _aRecipient ) , $ this -> _sSubject , $ sBody , $ sHeaders ) ; } }
3592	protected function loadMetaAttributes ( ) { if ( ! array_key_exists ( 'metaAttributes' , $ this -> relations ) ) { $ this -> reloadMetaAttributes ( ) ; } $ attributes = $ this -> getRelation ( 'metaAttributes' ) ; if ( ! $ attributes instanceof AttributeBag ) { $ this -> setRelation ( 'metaAttributes' , ( new Attribute ) -> newBag ( $ attributes -> all ( ) ) ) ; } }
7000	public function url ( $ url = null ) { if ( $ url ) $ this -> url = trim ( $ url ) ; return $ this -> url ; }
6495	public function visitPage ( $ path , $ code = 200 ) { if ( ! $ this -> assertStatusCode ( $ path , $ code ) ) { throw new \ Exception ( sprintf ( 'The page "%s" is not accessible!' , $ path ) ) ; } self :: debug ( [ 'Visited page: %s' ] , [ $ path ] ) ; $ this -> visitPath ( $ path ) ; }
7669	function ServerVar ( $ varName ) { global $ HTTP_SERVER_VARS ; global $ HTTP_ENV_VARS ; if ( ! isset ( $ _SERVER ) ) { $ _SERVER = $ HTTP_SERVER_VARS ; if ( ! isset ( $ _SERVER [ "REMOTE_ADDR" ] ) ) $ _SERVER = $ HTTP_ENV_VARS ; } if ( isset ( $ _SERVER [ $ varName ] ) ) return $ _SERVER [ $ varName ] ; else return "" ; }
1998	public function getLocale ( ) : string { foreach ( $ this -> getAcceptedLocales ( ) as $ locale ) { if ( file_exists ( $ this -> translationsDir . '/messages.' . $ locale . '.xlf' ) ) { return $ locale ; } } return 'en' ; }
12023	function addAccessorMethods ( ) { foreach ( $ this -> operationDefinition -> getParameters ( ) as $ parameter ) { $ translatedParam = $ this -> apiGenerator -> translateParameter ( $ parameter -> getName ( ) ) ; $ methodGenerator = new MethodGenerator ( 'set' . ucfirst ( $ translatedParam ) ) ; $ body = sprintf ( '$this->parameters[\'%s\'] = $%s;' , $ parameter -> getName ( ) , $ translatedParam ) ; $ body .= "\n\n" ; $ body .= 'return $this;' ; $ tags = [ ] ; $ docBlockTest = "Set $translatedParam" ; $ description = trim ( $ parameter -> getDescription ( ) ) ; $ tags [ ] = new GenericTag ( 'return' , '$this' ) ; $ docBlock = new DocBlockGenerator ( $ docBlockTest , $ description , $ tags ) ; $ methodGenerator -> setDocBlock ( $ docBlock ) ; $ methodGenerator -> setBody ( $ body ) ; $ parameterGenerator = new ParameterGenerator ( $ translatedParam , $ parameter -> getType ( ) ) ; $ methodGenerator -> setParameter ( $ parameterGenerator ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; } $ methodGenerator = new MethodGenerator ( 'getParameters' ) ; $ body = 'return $this->parameters;' ; $ methodGenerator -> setBody ( $ body ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
5096	public function queryExists ( ) { foreach ( $ this -> selects as $ select ) { $ result = $ select -> queryExists ( ) ; if ( is_null ( $ result ) || $ result ) { return $ result ; } } return false ; }
4166	public function run ( $ command ) { $ process = new Process ( $ command , null , null , null , ini_get ( 'max_execution_time' ) ) ; $ process -> run ( function ( $ type , $ buffer ) { if ( Process :: ERR === $ type ) { $ this -> console -> warn ( trim ( $ buffer ) ) ; } else { $ this -> console -> info ( trim ( $ buffer ) ) ; } } ) ; if ( ! $ process -> isSuccessful ( ) ) { throw new ProcessFailedException ( $ process ) ; } return true ; }
6984	protected function extractInputFromRules ( $ data , array $ rules ) { $ keys = collect ( $ rules ) -> keys ( ) -> map ( function ( $ rule ) { return explode ( '.' , $ rule ) [ 0 ] ; } ) -> unique ( ) -> toArray ( ) ; if ( ! ( $ data instanceof Request ) ) { $ data = collect ( $ data ) ; } return $ data -> only ( $ keys ) ; }
1063	private function findConflictsWithinSelectionSet ( ValidationContext $ context , $ parentType , SelectionSetNode $ selectionSet ) { [ $ fieldMap , $ fragmentNames ] = $ this -> getFieldsAndFragmentNames ( $ context , $ parentType , $ selectionSet ) ; $ conflicts = [ ] ; $ this -> collectConflictsWithin ( $ context , $ conflicts , $ fieldMap ) ; $ fragmentNamesLength = count ( $ fragmentNames ) ; if ( $ fragmentNamesLength !== 0 ) { $ comparedFragments = [ ] ; for ( $ i = 0 ; $ i < $ fragmentNamesLength ; $ i ++ ) { $ this -> collectConflictsBetweenFieldsAndFragment ( $ context , $ conflicts , $ comparedFragments , false , $ fieldMap , $ fragmentNames [ $ i ] ) ; for ( $ j = $ i + 1 ; $ j < $ fragmentNamesLength ; $ j ++ ) { $ this -> collectConflictsBetweenFragments ( $ context , $ conflicts , false , $ fragmentNames [ $ i ] , $ fragmentNames [ $ j ] ) ; } } } return $ conflicts ; }
1449	protected function relationshipRules ( $ record , string $ field ) : array { return collect ( $ this -> rules ( $ record ) ) -> filter ( function ( $ v , $ key ) use ( $ field ) { return Str :: startsWith ( $ key , $ field ) ; } ) -> all ( ) ; }
751	protected function validateSlug ( $ slug ) { $ validator = Yii :: createObject ( array_merge ( [ 'class' => UniqueValidator :: className ( ) , ] , $ this -> uniqueValidator ) ) ; $ model = clone $ this -> owner ; $ model -> clearErrors ( ) ; $ model -> { $ this -> slugAttribute } = $ slug ; $ validator -> validateAttribute ( $ model , $ this -> slugAttribute ) ; return ! $ model -> hasErrors ( ) ; }
1739	public function generate ( ) { if ( TL_MODE == 'BE' ) { $ objTemplate = new BackendTemplate ( 'be_wildcard' ) ; $ objTemplate -> wildcard = '### ' . Utf8 :: strtoupper ( $ GLOBALS [ 'TL_LANG' ] [ 'FMD' ] [ 'login' ] [ 0 ] ) . ' ###' ; $ objTemplate -> title = $ this -> headline ; $ objTemplate -> id = $ this -> id ; $ objTemplate -> link = $ this -> name ; $ objTemplate -> href = 'contao/main.php?do=themes&amp;table=tl_module&amp;act=edit&amp;id=' . $ this -> id ; return $ objTemplate -> parse ( ) ; } if ( ! $ _POST && $ this -> redirectBack && ( $ strReferer = $ this -> getReferer ( ) ) != Environment :: get ( 'request' ) ) { $ _SESSION [ 'LAST_PAGE_VISITED' ] = $ strReferer ; } return parent :: generate ( ) ; }
6028	public function setDeployedFiles ( array $ deployedFiles ) { $ this -> deployedFiles = [ ] ; foreach ( $ deployedFiles as $ item ) { $ this -> addDeploymentFile ( $ item ) ; } return $ this ; }
5498	public function expectArguments ( $ method , $ args , $ message ) { $ args = $ this -> replaceWildcards ( $ args ) ; $ message .= Mock :: getExpectationLine ( ) ; $ this -> expected_args [ strtolower ( $ method ) ] = new ParametersExpectation ( $ args , $ message ) ; }
11950	private function buildAuthorizationHeader ( array $ params ) { foreach ( $ params as $ key => $ value ) { $ params [ $ key ] = $ key . '="' . rawurlencode ( $ value ) . '"' ; } if ( $ this -> realm ) { array_unshift ( $ params , 'realm="' . rawurlencode ( $ this -> realm ) . '"' ) ; } return [ 'Authorization' , 'OAuth ' . implode ( ', ' , $ params ) ] ; }
2315	protected function prepareImportantPart ( ) { $ importantPart = $ this -> getImportantPart ( ) ; if ( substr_count ( $ this -> resizeMode , '_' ) === 1 ) { $ importantPart = array ( 'x' => 0 , 'y' => 0 , 'width' => $ this -> fileObj -> viewWidth , 'height' => $ this -> fileObj -> viewHeight , ) ; $ mode = explode ( '_' , $ this -> resizeMode ) ; if ( $ mode [ 0 ] === 'left' ) { $ importantPart [ 'width' ] = 1 ; } elseif ( $ mode [ 0 ] === 'right' ) { $ importantPart [ 'x' ] = $ importantPart [ 'width' ] - 1 ; $ importantPart [ 'width' ] = 1 ; } if ( $ mode [ 1 ] === 'top' ) { $ importantPart [ 'height' ] = 1 ; } elseif ( $ mode [ 1 ] === 'bottom' ) { $ importantPart [ 'y' ] = $ importantPart [ 'height' ] - 1 ; $ importantPart [ 'height' ] = 1 ; } } if ( ! $ importantPart [ 'width' ] || ! $ importantPart [ 'height' ] ) { return null ; } return new ImportantPart ( new Point ( $ importantPart [ 'x' ] , $ importantPart [ 'y' ] ) , new Box ( $ importantPart [ 'width' ] , $ importantPart [ 'height' ] ) ) ; }
12188	public function getRelatedObject ( $ baseObject , $ baseRole , $ primaryRelation = null ) { $ companionRole = $ this -> companionRole ( $ baseRole ) ; $ companionType = $ this -> companionRoleType ( $ baseRole ) ; $ companionModel = $ companionType -> primaryModel ; if ( ! isset ( $ primaryRelation ) || is_array ( $ primaryRelation ) ) { if ( ! is_array ( $ primaryRelation ) ) { $ primaryRelation = [ ] ; } $ primaryRelation = $ this -> getPrimaryRelation ( $ baseObject , $ baseRole , $ primaryRelation ) ; } if ( ! empty ( $ primaryRelation ) ) { if ( $ companionRole === 'child' ) { return $ primaryRelation -> childObject ; } else { return $ primaryRelation -> parentObject ; } } return false ; }
595	private function deletePublishedAssets ( $ bundles ) { $ this -> stdout ( "Deleting source files...\n" ) ; if ( $ this -> getAssetManager ( ) -> linkAssets ) { $ this -> stdout ( "`AssetManager::linkAssets` option is enabled. Deleting of source files canceled.\n" , Console :: FG_YELLOW ) ; return ; } foreach ( $ bundles as $ bundle ) { if ( $ bundle -> sourcePath !== null ) { foreach ( $ bundle -> js as $ jsFile ) { @ unlink ( $ bundle -> basePath . DIRECTORY_SEPARATOR . $ jsFile ) ; } foreach ( $ bundle -> css as $ cssFile ) { @ unlink ( $ bundle -> basePath . DIRECTORY_SEPARATOR . $ cssFile ) ; } } } $ this -> stdout ( "Source files deleted.\n" , Console :: FG_GREEN ) ; }
10178	public function removeRow ( $ row ) { foreach ( $ this -> getCoordinates ( ) as $ coord ) { sscanf ( $ coord , '%[A-Z]%d' , $ c , $ r ) ; if ( $ r == $ row ) { $ this -> delete ( $ coord ) ; } } }
11781	public function fromEntityToDb ( $ document ) { $ unitOfWork = $ this -> documentManager -> getUnitOfWork ( ) ; $ persistenceBuilder = new PersistenceBuilder ( $ this -> documentManager , $ unitOfWork ) ; $ mapping = array ( 'targetDocument' => $ this -> documentClass , ) ; return $ persistenceBuilder -> prepareEmbeddedDocumentValue ( $ mapping , $ document , true ) ; }
1275	private function sendRequest ( $ request , $ endpoint , $ operation , $ wsdl ) { $ endpointurl = $ this -> compileEndpointUrl ( $ endpoint ) ; $ this -> response = $ this -> getRequest ( ) -> request ( $ this -> createAccess ( ) , $ request , $ endpointurl , $ operation , $ wsdl ) ; $ response = $ this -> response -> getResponse ( ) ; if ( null === $ response ) { throw new Exception ( 'Failure (0): Unknown error' , 0 ) ; } return $ this -> formatResponse ( $ response ) ; }
6323	public function getA ( StringType $ name ) { if ( ! $ this -> hasA ( $ name ) ) { throw new AttributesException ( "Attribute: {$name} does not exist" ) ; } return $ this -> attributes [ $ name ( ) ] ; }
9177	public function mapBoolean ( $ value ) { if ( isset ( $ this -> booleanMapping [ $ value ] ) ) { return $ this -> booleanMapping [ $ value ] ; } throw new \ Exception ( sprintf ( 'Can\'t convert %s to boolean' , $ value ) ) ; }
5396	public function paintSkip ( $ message ) { parent :: paintSkip ( $ message ) ; print $ this -> getIndent ( 1 ) ; print '<' . $ this -> namespace . 'skip>' ; print $ this -> toParsedXml ( $ message ) ; print '</' . $ this -> namespace . "skip>\n" ; }
11093	public static function linkRewrite ( $ str , $ allowUnicodeChars = false ) { if ( ! \ is_string ( $ str ) ) { return false ; } $ str = trim ( $ str ) ; if ( \ function_exists ( 'mb_strtolower' ) ) { $ str = mb_strtolower ( $ str , 'utf-8' ) ; } if ( ! $ allowUnicodeChars ) { $ str = self :: replaceAccentedChars ( $ str ) ; } if ( $ allowUnicodeChars ) { $ str = preg_replace ( '/[^a-zA-Z0-9\s\'\:\/\[\]\-\pL]/u' , '' , $ str ) ; } else { $ str = preg_replace ( '/[^a-zA-Z0-9\s\'\:\/\[\]\-]/' , '' , $ str ) ; } $ str = preg_replace ( '/[\s\'\:\/\[\]\-]+/' , ' ' , $ str ) ; $ str = str_replace ( [ ' ' , '/' ] , '-' , $ str ) ; if ( ! \ function_exists ( 'mb_strtolower' ) ) { $ str = strtolower ( $ str ) ; } return $ str ; }
4467	private function reload ( ) : void { $ this -> sha = ( string ) @ sha1_file ( $ this -> corePath ) ; if ( empty ( $ this -> sha ) ) { throw new RuntimeException ( 'Unable to locate qless-core file at path: ' . $ this -> corePath ) ; } $ res = $ this -> redis -> script ( 'exists' , $ this -> sha ) ; if ( $ res [ 0 ] !== 1 ) { $ this -> sha = $ this -> redis -> script ( 'load' , file_get_contents ( $ this -> corePath ) ) ; } }
6589	public function post ( $ url , $ data = null , $ method = "POST" ) { return $ this -> request ( [ CURLOPT_POST => true , CURLOPT_CUSTOMREQUEST => $ method ? : "POST" , CURLOPT_URL => "$url" , CURLOPT_POSTFIELDS => $ data ? : '' , ] ) ; }
988	public function activate ( ) { if ( ! $ this -> chargeId ) { throw new Exception ( 'Can not activate plan without a charge ID.' ) ; } $ this -> response = $ this -> api -> rest ( 'POST' , "/admin/{$this->plan->typeAsString(true)}/{$this->chargeId}/activate.json" ) -> body -> { $ this -> plan -> typeAsString ( ) } ; return $ this -> response ; }
6004	public function setCategories ( array $ categories ) { $ this -> categories = [ ] ; foreach ( $ categories as $ item ) { $ this -> addCategoryResponse ( $ item ) ; } return $ this ; }
11202	public function toArray ( ) { $ collection = $ this -> getIterator ( ) ; $ plainArray = [ ] ; foreach ( $ collection as $ prop => $ result ) { if ( is_object ( $ result ) && method_exists ( $ result , 'toArray' ) ) { $ plainArray [ ] = $ result -> toArray ( ) ; } else { $ plainArray [ ] = $ result ; } } return $ plainArray ; }
1127	public function isAncestorOf ( $ other ) { return ( $ this -> getLeft ( ) < $ other -> getLeft ( ) && $ this -> getRight ( ) > $ other -> getLeft ( ) && $ this -> inSameScope ( $ other ) ) ; }
12812	private static function isForeignKey ( string $ table , string $ column ) : bool { return array_key_exists ( $ column , self :: getForeignKeys ( $ table ) ) ; }
12566	public function sendVideo ( $ message , $ to = null ) { return $ this -> send ( self :: MSG_TYPE_VIDEO , $ message , $ to ) ; }
6287	private function buildReactRequest ( RequestInterface $ request ) { $ headers = [ ] ; foreach ( $ request -> getHeaders ( ) as $ name => $ value ) { $ headers [ $ name ] = ( is_array ( $ value ) ? $ value [ 0 ] : $ value ) ; } $ reactRequest = $ this -> client -> request ( $ request -> getMethod ( ) , ( string ) $ request -> getUri ( ) , $ headers , $ request -> getProtocolVersion ( ) ) ; return $ reactRequest ; }
11062	public static function isEncodingSupported ( $ encoding ) { $ encoding = strtolower ( $ encoding ) ; if ( isset ( static :: supportedEncodings ( ) [ $ encoding ] ) ) { return true ; } return false ; }
4978	public function filter ( $ value ) { return isset ( $ this -> map [ $ value ] ) ? $ this -> map [ $ value ] : $ value ; }
12266	public function renderCmsBlocks ( array $ blocks , $ username , array $ options = array ( ) ) { $ tmp = array ( ) ; foreach ( $ blocks as $ block ) { $ tmp [ ] = $ this -> renderCmsBlock ( $ block , $ username , $ options ) ; } return implode ( "\n" , $ tmp ) ; }
7209	public static function createFinalFromGross ( Amount $ gross ) : Amount { $ final = new Amount ( $ gross -> getCurrency ( ) , $ gross -> getBase ( ) , $ gross -> getBase ( ) , 0 , $ gross -> getBase ( ) , $ gross -> getTax ( ) , $ gross -> getTotal ( ) ) ; foreach ( $ gross -> getTaxAdjustments ( ) as $ t ) { $ final -> addTaxAdjustment ( $ t ) ; } return $ final ; }
7718	function meth_Conv_Prepare ( & $ Loc , $ StrConv ) { $ x = strtolower ( $ StrConv ) ; $ x = '+' . str_replace ( ' ' , '' , $ x ) . '+' ; if ( strpos ( $ x , '+esc+' ) !== false ) { $ this -> f_Misc_ConvSpe ( $ Loc ) ; $ Loc -> ConvStr = false ; $ Loc -> ConvEsc = true ; } if ( strpos ( $ x , '+wsp+' ) !== false ) { $ this -> f_Misc_ConvSpe ( $ Loc ) ; $ Loc -> ConvWS = true ; } if ( strpos ( $ x , '+js+' ) !== false ) { $ this -> f_Misc_ConvSpe ( $ Loc ) ; $ Loc -> ConvStr = false ; $ Loc -> ConvJS = true ; } if ( strpos ( $ x , '+url+' ) !== false ) { $ this -> f_Misc_ConvSpe ( $ Loc ) ; $ Loc -> ConvStr = false ; $ Loc -> ConvUrl = true ; } if ( strpos ( $ x , '+utf8+' ) !== false ) { $ this -> f_Misc_ConvSpe ( $ Loc ) ; $ Loc -> ConvStr = false ; $ Loc -> ConvUtf8 = true ; } if ( strpos ( $ x , '+no+' ) !== false ) $ Loc -> ConvStr = false ; if ( strpos ( $ x , '+yes+' ) !== false ) $ Loc -> ConvStr = true ; if ( strpos ( $ x , '+nobr+' ) !== false ) { $ Loc -> ConvStr = true ; $ Loc -> ConvBr = false ; } }
8156	public function addPath ( $ path , $ namespace = self :: MAIN_NAMESPACE ) { $ this -> cache = $ this -> errorCache = array ( ) ; $ checkPath = $ this -> isAbsolutePath ( $ path ) ? $ path : $ this -> rootPath . $ path ; if ( ! is_dir ( $ checkPath ) ) { throw new Twig_Error_Loader ( sprintf ( 'The "%s" directory does not exist ("%s").' , $ path , $ checkPath ) ) ; } $ this -> paths [ $ namespace ] [ ] = rtrim ( $ path , '/\\' ) ; }
8516	public function updateInboundShipment ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_UpdateInboundShipmentRequest ) ) { $ request = new FBAInboundServiceMWS_Model_UpdateInboundShipmentRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'UpdateInboundShipment' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_UpdateInboundShipmentResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
11678	protected function load ( $ locale , $ fileName ) { if ( $ this -> isFileLoaded ( $ locale , $ fileName ) === true ) { return true ; } $ startTime = microtime ( true ) ; $ file = $ this -> getPath ( ) . '/' . $ locale . '/' . $ fileName . '.php' ; if ( file_exists ( $ file ) === false ) { throw new FileNotFound ( $ this -> getPath ( ) , $ locale , $ fileName ) ; } $ translationKeys = include $ file ; if ( $ translationKeys === null || is_array ( $ translationKeys ) === false ) { throw new InvalidTranslationFile ( $ this -> getPath ( ) , $ locale , $ fileName ) ; } if ( array_key_exists ( $ locale , $ this -> translations ) === false ) { $ this -> translations [ $ locale ] = [ ] ; } $ this -> translations [ $ locale ] [ $ fileName ] = $ translationKeys ; $ this -> log ( 'Language loaded: ' . $ locale . '/' . $ fileName . ' (' . number_format ( microtime ( true ) - $ startTime , 2 , ',' , '.' ) . ')' ) ; return true ; }
6232	public function setPickupPoint ( $ pickup_point_id ) { $ service = new AdditionalService ( ) ; $ service -> setServiceCode ( 2106 ) ; $ service -> addSpecifier ( 'pickup_point_id' , $ pickup_point_id ) ; $ this -> addAdditionalService ( $ service ) ; }
8073	public function post ( $ endpoint , $ data , $ headers = [ ] ) { $ request = new Request ( 'POST' , $ endpoint , $ headers , $ data ) ; $ response = $ this -> guzzle -> send ( $ request ) ; return $ this -> handle ( $ response ) ; }
4914	private function addTraversable ( \ Traversable $ result ) { foreach ( $ result as $ item ) { break ; } if ( ! $ item instanceof EntityInterface ) { throw new \ InvalidArgumentException ( 'Traversable objects must be a non-empty collection of Entity instances.' ) ; } $ name = get_class ( $ item ) ; return $ this -> addArray ( [ 'name' => $ name , 'entities' => $ result , ] ) ; }
8248	public function checkPasswordPolicy ( Password $ password ) { $ result = true ; $ policy = $ this -> picoAuth -> getContainer ( ) -> get ( "PasswordPolicy" ) ; $ maxAllowedLen = $ this -> getPasswordEncoder ( ) -> getMaxAllowedLen ( ) ; if ( is_int ( $ maxAllowedLen ) && strlen ( $ password ) > $ maxAllowedLen ) { $ this -> session -> addFlash ( "error" , "Maximum length is {$maxAllowedLen}." ) ; $ result = false ; } if ( ! $ policy -> check ( $ password ) ) { $ errors = $ policy -> getErrors ( ) ; foreach ( $ errors as $ error ) { $ this -> session -> addFlash ( "error" , $ error ) ; } return false ; } return $ result ; }
2970	private function doSend ( MessageInterface $ message ) { $ content = $ this -> format ( $ message ) ; $ headers = $ this -> getHeaders ( ) ; $ files = $ this -> getFiles ( $ message ) ; if ( ! empty ( $ files ) ) { parse_str ( $ content , $ fields ) ; $ builder = new MultipartStreamBuilder ( ) ; foreach ( $ fields as $ name => $ value ) { if ( is_array ( $ value ) ) { foreach ( $ value as $ c ) { $ builder -> addResource ( $ name . '[]' , $ c ) ; } continue ; } $ builder -> addResource ( $ name , $ value ) ; } foreach ( $ files as $ key => $ items ) { foreach ( $ items as $ name => $ path ) { $ options = [ ] ; if ( ! is_numeric ( $ name ) ) { $ options [ 'filename' ] = $ name ; } $ value = fopen ( $ path , 'r' ) ; $ builder -> addResource ( $ key , $ value , $ options ) ; } } $ content = $ builder -> build ( ) ; $ headers [ 'Content-Type' ] = 'multipart/form-data; boundary="' . $ builder -> getBoundary ( ) . '"' ; } $ request = $ this -> getMessageFactory ( ) -> createRequest ( 'POST' , $ this -> getEndpoint ( ) , $ headers , $ content ) ; return $ this -> getHttpClient ( ) -> sendRequest ( $ request ) ; }
7224	public function exec ( $ keepAlive = false ) { $ this -> lastResult = curl_exec ( $ this -> curl ) ; $ this -> info = curl_getinfo ( $ this -> curl ) ; if ( ! $ keepAlive ) curl_close ( $ this -> curl ) ; return $ this -> lastResult !== false ; }
1570	public function getResource ( ) { $ resource = $ this -> parameter ( ResourceRegistrar :: PARAM_RESOURCE_ID ) ; return is_object ( $ resource ) ? $ resource : null ; }
6824	protected function getTaxAccountNumber ( float $ rate , string $ origin ) { foreach ( $ this -> accounts as $ account ) { if ( $ account -> getType ( ) !== AccountingTypes :: TYPE_TAX ) { continue ; } if ( 0 !== bccomp ( $ account -> getTax ( ) -> getRate ( ) , $ rate , 5 ) ) { continue ; } return $ account -> getNumber ( ) ; } throw new LogicException ( sprintf ( "No tax account number configured for tax rate '%s' (%s)" , $ rate , $ origin ) ) ; }
6223	public function getMenuPresence ( ) { return [ 'id' => 'simple-acl' , 'type' => MenuPresenceType :: GROUP , 'label' => 'Access Control' , 'children' => [ [ 'id' => 'simple-acl-users' , 'type' => MenuPresenceType :: ACTION , 'label' => 'Users' , 'permissions' => 'acl.users.show' , 'action' => $ this -> core -> prefixRoute ( 'acl.users.index' ) , 'parameters' => [ ] , ] , [ 'id' => 'simple-acl-create-user' , 'type' => MenuPresenceType :: ACTION , 'label' => 'New User' , 'permissions' => 'acl.users.create' , 'action' => $ this -> core -> prefixRoute ( 'acl.users.create' ) , 'parameters' => [ ] , ] , [ 'id' => 'simple-acl-roles' , 'type' => MenuPresenceType :: ACTION , 'label' => 'Roles' , 'permissions' => 'acl.roles.show' , 'action' => $ this -> core -> prefixRoute ( 'acl.roles.index' ) , 'parameters' => [ ] , ] , ] ] ; }
5719	public function cancel ( ) { Controller :: curr ( ) -> getResponse ( ) -> addHeader ( "X-Pjax" , "Content" ) ; return Controller :: curr ( ) -> redirect ( $ this -> getBackLink ( ) ) ; }
11712	protected function performAjaxValidation ( $ models ) { if ( \ Yii :: $ app -> request -> isAjax ) { if ( is_array ( $ models ) ) { $ result = [ ] ; foreach ( $ models as $ model ) { if ( $ model -> load ( \ Yii :: $ app -> request -> post ( ) ) ) { \ Yii :: $ app -> response -> format = Response :: FORMAT_JSON ; $ result = array_merge ( $ result , ActiveForm :: validate ( $ model ) ) ; } } echo json_encode ( $ result ) ; \ Yii :: $ app -> end ( ) ; } else { if ( $ models -> load ( \ Yii :: $ app -> request -> post ( ) ) ) { \ Yii :: $ app -> response -> format = Response :: FORMAT_JSON ; echo json_encode ( ActiveForm :: validate ( $ models ) ) ; \ Yii :: $ app -> end ( ) ; } } } }
4298	public function count ( $ label = null , $ flags = 0 ) { $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) ) ; if ( \ count ( $ args ) == 1 && \ is_int ( $ args [ 0 ] ) ) { $ label = null ; $ flags = $ args [ 0 ] ; } else { $ args = \ array_combine ( array ( 'label' , 'flags' ) , \ array_replace ( array ( null , 0 ) , $ args ) ) ; \ extract ( $ args ) ; } if ( isset ( $ label ) ) { $ dataLabel = ( string ) $ label ; } else { $ callerInfo = $ this -> utilities -> getCallerInfo ( ) ; $ meta = \ array_merge ( array ( 'file' => $ callerInfo [ 'file' ] , 'line' => $ callerInfo [ 'line' ] , ) , $ meta ) ; $ label = 'count' ; $ dataLabel = $ meta [ 'file' ] . ': ' . $ meta [ 'line' ] ; } if ( ! isset ( $ this -> data [ 'counts' ] [ $ dataLabel ] ) ) { $ this -> data [ 'counts' ] [ $ dataLabel ] = 0 ; } if ( ! ( $ flags & self :: COUNT_NO_INC ) ) { $ this -> data [ 'counts' ] [ $ dataLabel ] ++ ; } $ count = $ this -> data [ 'counts' ] [ $ dataLabel ] ; if ( ! ( $ flags & self :: COUNT_NO_OUT ) ) { $ this -> appendLog ( 'count' , array ( ( string ) $ label , $ count , ) , $ meta ) ; } return $ count ; }
4488	private function broadcastToPlatform ( $ message , string $ platform ) { if ( $ this -> debug ) { $ this -> logger && $ this -> logger -> notice ( "Message would have been sent to $platform" , [ 'Message' => $ message , ] ) ; return ; } foreach ( $ this -> sns -> getPaginator ( 'ListEndpointsByPlatformApplication' , [ 'PlatformApplicationArn' => $ this -> arns [ $ platform ] , ] ) as $ endpointsResult ) { foreach ( $ endpointsResult [ 'Endpoints' ] as $ endpoint ) { if ( $ endpoint [ 'Attributes' ] [ 'Enabled' ] == 'true' ) { try { $ this -> send ( $ message , $ endpoint [ 'EndpointArn' ] ) ; } catch ( \ Exception $ e ) { $ this -> logger && $ this -> logger -> error ( "Failed to push to {$endpoint['EndpointArn']}" , [ 'Message' => $ message , 'Exception' => $ e , 'Endpoint' => $ endpoint , ] ) ; } } else { $ this -> logger && $ this -> logger -> info ( "Disabled endpoint {$endpoint['EndpointArn']}" , [ 'Message' => $ message , 'Endpoint' => $ endpoint , ] ) ; } } } }
7605	public function setTranslator ( TranslatorInterface $ oTranslator = null , $ sTextDomain = null ) { $ this -> translator = $ oTranslator ; if ( null !== $ sTextDomain ) { $ this -> setTranslatorTextDomain ( $ sTextDomain ) ; } return $ this ; }
3628	protected static function getCURLCerts ( ) { $ url = 'https://curl.haxx.se/ca/cacert.pem' ; $ certs = @ file_get_contents ( $ url ) ; if ( ! $ certs ) { $ ch = curl_init ( ) ; curl_setopt ( $ ch , CURLOPT_URL , $ url ) ; curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , TRUE ) ; curl_setopt ( $ ch , CURLOPT_SSL_VERIFYPEER , TRUE ) ; curl_setopt ( $ ch , CURLOPT_SSL_VERIFYHOST , 2 ) ; $ response = curl_exec ( $ ch ) ; $ info = curl_getinfo ( $ ch ) ; curl_close ( $ ch ) ; if ( $ info [ 'http_code' ] == 200 ) { $ certs = $ response ; } } return $ certs ; }
4286	public function processLogEntry ( $ method , $ args = array ( ) , $ meta = array ( ) ) { if ( $ method === 'alert' ) { list ( $ method , $ args ) = $ this -> methodAlert ( $ args , $ meta ) ; } elseif ( $ method == 'assert' ) { \ array_unshift ( $ args , false ) ; } elseif ( \ in_array ( $ method , array ( 'count' , 'time' ) ) ) { $ method = 'log' ; } elseif ( \ in_array ( $ method , array ( 'profileEnd' , 'table' ) ) ) { $ method = 'log' ; if ( \ is_array ( $ args [ 0 ] ) ) { $ method = 'table' ; $ args = array ( $ this -> methodTable ( $ args [ 0 ] , $ meta [ 'columns' ] ) ) ; } elseif ( $ meta [ 'caption' ] ) { \ array_unshift ( $ args , $ meta [ 'caption' ] ) ; } } elseif ( $ method === 'trace' ) { $ method = 'table' ; $ args = array ( $ this -> methodTable ( $ args [ 0 ] , array ( 'function' , 'file' , 'line' ) ) ) ; } if ( ! \ in_array ( $ method , $ this -> consoleMethods ) ) { $ method = 'log' ; } foreach ( $ args as $ i => $ arg ) { $ args [ $ i ] = $ this -> dump ( $ arg ) ; } $ this -> json [ 'rows' ] [ ] = array ( $ args , isset ( $ meta [ 'file' ] ) ? $ meta [ 'file' ] . ': ' . $ meta [ 'line' ] : null , $ method === 'log' ? '' : $ method , ) ; }
1403	private function parse ( ) { if ( ! $ this -> response ) { return [ ] ; } $ body = json_decode ( ( string ) $ this -> response -> getBody ( ) , true ) ; return isset ( $ body [ 'errors' ] ) ? $ body [ 'errors' ] : [ ] ; }
6765	protected function handleUpdate ( SaleInterface $ sale ) { $ changed = false ; $ changed |= $ this -> updateNumber ( $ sale ) ; $ changed |= $ this -> updateKey ( $ sale ) ; $ changed |= $ this -> updateInformation ( $ sale , true ) ; if ( $ this -> persistenceHelper -> isChanged ( $ sale , 'vatNumber' ) ) { $ changed |= $ this -> pricingUpdater -> updateVatNumberSubject ( $ sale ) ; } if ( $ this -> persistenceHelper -> isChanged ( $ sale , 'customer' ) ) { $ changed |= $ this -> saleUpdater -> updatePaymentTerm ( $ sale ) ; } if ( $ this -> persistenceHelper -> isChanged ( $ sale , [ 'shipmentMethod' , 'customerGroup' ] ) ) { $ changed = $ this -> saleUpdater -> updateShipmentMethodAndAmount ( $ sale ) ; } if ( $ this -> isDiscountUpdateNeeded ( $ sale ) ) { $ changed |= $ this -> saleUpdater -> updateDiscounts ( $ sale , true ) ; } if ( $ this -> isTaxationUpdateNeeded ( $ sale ) ) { $ changed |= $ this -> saleUpdater -> updateTaxation ( $ sale , true ) ; } elseif ( $ this -> isShipmentTaxationUpdateNeeded ( $ sale ) ) { $ changed |= $ this -> saleUpdater -> updateShipmentTaxation ( $ sale , true ) ; } return $ changed ; }
3865	public function render ( $ blnNoNativeParsing , $ objCaller ) { $ event = new RenderItemListEvent ( $ this , $ this -> objTemplate , $ objCaller ) ; $ this -> getEventDispatcher ( ) -> dispatch ( MetaModelsEvents :: RENDER_ITEM_LIST , $ event ) ; $ this -> objTemplate -> noItemsMsg = $ this -> getNoItemsCaption ( ) ; $ this -> objTemplate -> details = $ this -> getCaptionText ( 'details' ) ; $ this -> prepare ( ) ; $ strOutputFormat = $ this -> getOutputFormat ( ) ; if ( $ this -> objItems -> getCount ( ) && ! $ blnNoNativeParsing ) { $ this -> objTemplate -> data = $ this -> objItems -> parseAll ( $ strOutputFormat , $ this -> objView ) ; } else { $ this -> objTemplate -> data = array ( ) ; } $ this -> setTitleAndDescription ( ) ; $ this -> objTemplate -> caller = $ objCaller ; $ this -> objTemplate -> items = $ this -> objItems ; $ this -> objTemplate -> filterParams = $ this -> arrParam ; return $ this -> objTemplate -> parse ( $ strOutputFormat ) ; }
3945	public function onLoadDataContainer ( $ tableName ) { static $ tableExists ; if ( null === $ tableExists ) { $ tableExists = \ System :: getContainer ( ) -> get ( 'database_connection' ) -> getSchemaManager ( ) -> tablesExist ( [ 'tl_metamodel' ] ) ; } if ( false === $ tableExists ) { return ; } $ this -> handleMetaModelTable ( $ tableName ) ; $ this -> handleNonMetaModelTable ( $ tableName ) ; }
1320	private function curlOptions ( ) { $ options = [ CURLOPT_CONNECTTIMEOUT => $ this -> connectionTimeout , CURLOPT_HEADER => true , CURLOPT_RETURNTRANSFER => true , CURLOPT_SSL_VERIFYHOST => 2 , CURLOPT_SSL_VERIFYPEER => true , CURLOPT_TIMEOUT => $ this -> timeout , CURLOPT_USERAGENT => $ this -> userAgent , ] ; if ( $ this -> useCAFile ( ) ) { $ options [ CURLOPT_CAINFO ] = __DIR__ . DIRECTORY_SEPARATOR . 'cacert.pem' ; } if ( $ this -> gzipEncoding ) { $ options [ CURLOPT_ENCODING ] = 'gzip' ; } if ( ! empty ( $ this -> proxy ) ) { $ options [ CURLOPT_PROXY ] = $ this -> proxy [ 'CURLOPT_PROXY' ] ; $ options [ CURLOPT_PROXYUSERPWD ] = $ this -> proxy [ 'CURLOPT_PROXYUSERPWD' ] ; $ options [ CURLOPT_PROXYPORT ] = $ this -> proxy [ 'CURLOPT_PROXYPORT' ] ; $ options [ CURLOPT_PROXYAUTH ] = CURLAUTH_BASIC ; $ options [ CURLOPT_PROXYTYPE ] = CURLPROXY_HTTP ; } return $ options ; }
654	protected function internalExecute ( $ rawSql ) { $ attempt = 0 ; while ( true ) { try { if ( ++ $ attempt === 1 && $ this -> _isolationLevel !== false && $ this -> db -> getTransaction ( ) === null ) { $ this -> db -> transaction ( function ( ) use ( $ rawSql ) { $ this -> internalExecute ( $ rawSql ) ; } , $ this -> _isolationLevel ) ; } else { $ this -> pdoStatement -> execute ( ) ; } break ; } catch ( \ Exception $ e ) { $ rawSql = $ rawSql ? : $ this -> getRawSql ( ) ; $ e = $ this -> db -> getSchema ( ) -> convertException ( $ e , $ rawSql ) ; if ( $ this -> _retryHandler === null || ! call_user_func ( $ this -> _retryHandler , $ e , $ attempt ) ) { throw $ e ; } } } }
1004	public function parseRequestParams ( $ method , array $ bodyParams , array $ queryParams ) { if ( $ method === 'GET' ) { $ result = OperationParams :: create ( $ queryParams , true ) ; } elseif ( $ method === 'POST' ) { if ( isset ( $ bodyParams [ 0 ] ) ) { $ result = [ ] ; foreach ( $ bodyParams as $ index => $ entry ) { $ op = OperationParams :: create ( $ entry ) ; $ result [ ] = $ op ; } } else { $ result = OperationParams :: create ( $ bodyParams ) ; } } else { throw new RequestError ( 'HTTP Method "' . $ method . '" is not supported' ) ; } return $ result ; }
8258	protected function finishAuthentication ( Request $ httpRequest ) { $ sessionCode = $ this -> session -> get ( "oauth2state" ) ; $ this -> session -> remove ( "oauth2state" ) ; if ( $ httpRequest -> query -> get ( "state" ) !== $ sessionCode ) { $ this -> onStateMismatch ( ) ; } if ( $ httpRequest -> query -> has ( "error" ) ) { $ this -> onOAuthError ( $ httpRequest -> query -> get ( "error" ) ) ; } if ( ! $ httpRequest -> query -> has ( "code" ) ) { $ this -> onOAuthError ( "no_code" ) ; } try { $ accessToken = $ this -> provider -> getAccessToken ( 'authorization_code' , [ 'code' => $ httpRequest -> query -> get ( "code" ) , ] ) ; $ resourceOwner = $ this -> provider -> getResourceOwner ( $ accessToken ) ; $ this -> saveLoginInfo ( $ resourceOwner ) ; } catch ( IdentityProviderException $ e ) { $ this -> onOauthResourceError ( $ e ) ; } }
7835	protected function getWorkflowsNamespace ( ) { $ relative = ltrim ( config ( 'workflow.path' ) , app_path ( ) ) ; $ chunks = array_map ( 'ucfirst' , explode ( '/' , $ relative ) ) ; return implode ( '\\' , $ chunks ) ; }
7086	public function setOptionLabelColumnForDefaultOptionsLoader ( $ columnNameOrClosure ) { if ( ! is_string ( $ columnNameOrClosure ) && ! ( $ columnNameOrClosure instanceof DbExpr ) && ! ( $ columnNameOrClosure instanceof \ Closure ) ) { throw new \ InvalidArgumentException ( '$columnNameOrClosure argument must be a string, DbExpr or a Closure' ) ; } $ this -> optionLabelColumnForDefaultOptionsLoader = $ columnNameOrClosure ; return $ this ; }
2784	private function indent ( $ output , $ asArray = false ) { $ lines = explode ( "\n" , $ output ) ; $ out = [ ] ; foreach ( $ lines as $ line ) { $ out [ ] = ' > ' . $ line ; } if ( $ asArray ) { return $ out ; } $ return = implode ( "\n" , $ out ) ; return $ return ; }
10770	protected function resolveViewName ( ) { $ viewName = Yii :: $ app -> request -> get ( $ this -> viewParam , $ this -> defaultView ) ; if ( ! is_string ( $ viewName ) || ! preg_match ( '~^\w(?:(?!\/\.{0,2}\/)[\w\/\-\.])*$~' , $ viewName ) ) { if ( YII_DEBUG ) { throw new NotFoundHttpException ( "The requested view \"$viewName\" must start with a word character, must not contain /../ or /./, can contain only word characters, forward slashes, dots and dashes." ) ; } else { throw new NotFoundHttpException ( Yii :: t ( 'yii' , 'The requested view "{name}" was not found.' , [ 'name' => $ viewName ] ) ) ; } } return empty ( $ this -> viewPrefix ) ? $ viewName : $ this -> viewPrefix . '/' . $ viewName ; }
12856	function performPayload ( iPayloadQueued $ processPayload ) { $ triesCount = 0 ; if ( $ processPayload instanceof FailedPayload ) { if ( $ processPayload -> getCountRetries ( ) > $ this -> getMaxTries ( ) ) throw new exPayloadMaxTriesExceed ( $ processPayload , sprintf ( 'Max Tries Exceeds After %s Tries.' , $ processPayload -> getCountRetries ( ) ) , null ) ; } $ payLoadData = $ processPayload -> getData ( ) ; try { if ( ob_get_level ( ) ) ob_end_clean ( ) ; ob_start ( ) ; $ this -> event ( ) -> trigger ( EventHeapOfWorker :: EVENT_PAYLOAD_RECEIVED , [ 'payload' => $ processPayload , 'data' => $ payLoadData , 'worker' => $ this ] ) ; ob_end_flush ( ) ; flush ( ) ; } catch ( \ LogicException $ e ) { throw $ e ; } catch ( \ Exception $ e ) { if ( ! $ processPayload instanceof FailedPayload ) $ failedPayload = new FailedPayload ( $ processPayload , $ triesCount ) ; else $ failedPayload = $ processPayload ; throw new exPayloadPerformFailed ( $ failedPayload , $ e ) ; } }
4805	public function getLowestFreeIndexNumber ( ) { $ query = $ this -> createQuery ( ) ; $ query -> statement ( 'SELECT index_number from ' . strtolower ( $ this -> objectType ) . ' WHERE deleted=0' ) ; $ index = 1 ; $ results = $ query -> execute ( true ) ; if ( false === is_array ( $ results ) || sizeof ( $ results ) < 1 ) { return $ index ; } $ indexes = array ( ) ; foreach ( $ results as $ result ) { $ indexes [ ] = ( integer ) $ result [ 'index_number' ] ; } for ( $ index = 1 ; $ index <= sizeof ( $ indexes ) + 1 ; $ index ++ ) { if ( false === in_array ( $ index , $ indexes ) ) { break ; } } return $ index ; }
2259	protected function createInitialVersion ( $ strTable , $ intId ) { @ trigger_error ( 'Using Controller::createInitialVersion() has been deprecated and will no longer work in Contao 5.0. Use Versions->initialize() instead.' , E_USER_DEPRECATED ) ; $ objVersions = new Versions ( $ strTable , $ intId ) ; $ objVersions -> initialize ( ) ; }
9584	public function getRouteForRequest ( Request $ request ) { $ method = $ request -> getMethod ( ) ; $ path = $ request -> getPathInfo ( ) ? : '/' ; $ result = $ this -> getDispatcher ( ) -> dispatch ( $ method , $ path ) ; if ( $ result [ 0 ] == \ FastRoute \ Dispatcher :: NOT_FOUND ) { throw new NotFoundHttpException ( "No route match for path $path" ) ; } else if ( $ result [ 0 ] == \ FastRoute \ Dispatcher :: METHOD_NOT_ALLOWED ) { throw new MethodNotAllowedHttpException ( $ result [ 1 ] , "Method $method not allowed for path $path" ) ; } else if ( $ result [ 0 ] !== \ FastRoute \ Dispatcher :: FOUND ) { throw new \ RuntimeException ( 'Unknown result from FastRoute: ' . $ result [ 0 ] ) ; } return $ this -> matchRoute ( $ result [ 1 ] , $ result [ 2 ] , $ request ) ; }
10646	public function execute ( ) { $ ch = curl_init ( ) ; curl_setopt ( $ ch , CURLOPT_URL , $ this -> getURI ( ) ) ; curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , true ) ; curl_setopt ( $ ch , CURLOPT_POST , true ) ; curl_setopt ( $ ch , CURLOPT_POSTFIELDS , $ this -> data ) ; $ response = curl_exec ( $ ch ) ; $ result = json_decode ( $ response ) ; curl_close ( $ ch ) ; if ( empty ( $ result ) || ! $ result -> success ) { throw new \ Exception ( "Pipedrive API error!" ) ; } return $ result ; }
6259	protected function _isAllowedRole ( $ userRoles , array $ allowedRoles ) { if ( in_array ( '*' , $ allowedRoles ) ) { return true ; } if ( is_string ( $ userRoles ) ) { $ userRoles = [ $ userRoles ] ; } foreach ( $ userRoles as $ userRole ) { if ( in_array ( $ userRole , $ allowedRoles ) ) { return true ; } } return false ; }
10245	function fromXML ( $ xmlElement ) { $ this -> contact = new ReportContact ( ) ; $ this -> contact -> fromXML ( $ xmlElement -> contact ) ; if ( isset ( $ xmlElement -> mailing_id ) ) $ this -> mailingId = $ xmlElement -> mailing_id ; if ( isset ( $ xmlElement -> timestamp ) ) $ this -> timestamp = $ xmlElement -> timestamp ; if ( isset ( $ xmlElement -> last_type ) ) $ this -> lastType = $ xmlElement -> last_type ; if ( isset ( $ xmlElement -> count ) ) $ this -> count = $ xmlElement -> count ; if ( isset ( $ xmlElement -> count_hard ) ) $ this -> countHard = $ xmlElement -> count_hard ; if ( isset ( $ xmlElement -> count_soft ) ) $ this -> countSoft = $ xmlElement -> count_soft ; }
8768	protected function registerApplicationAliases ( ) { foreach ( $ this -> config [ 'services' ] [ 'aliases' ] as $ key => $ alias ) { $ this -> alias ( $ key , $ alias ) ; if ( ! class_exists ( $ key ) ) { class_alias ( $ alias , $ key ) ; } } }
4934	public function erase ( EntityInterface $ entity ) { $ dependencies = $ this -> triggerEvent ( DependencyResultEvent :: DELETE , $ entity ) ; foreach ( $ dependencies as $ result ) { if ( $ result -> isDelete ( ) ) { foreach ( $ result -> getEntities ( ) as $ dependendEntity ) { $ this -> repositories -> remove ( $ dependendEntity ) ; } } } $ this -> repositories -> remove ( $ entity ) ; return $ dependencies ; }
1137	public function setDepthWithSubtree ( ) { $ self = $ this ; $ this -> getConnection ( ) -> transaction ( function ( ) use ( $ self ) { $ self -> reload ( ) ; $ self -> descendantsAndSelf ( ) -> select ( $ self -> getKeyName ( ) ) -> lockForUpdate ( ) -> get ( ) ; $ oldDepth = ! is_null ( $ self -> getDepth ( ) ) ? $ self -> getDepth ( ) : 0 ; $ newDepth = $ self -> getLevel ( ) ; $ self -> newNestedSetQuery ( ) -> where ( $ self -> getKeyName ( ) , '=' , $ self -> getKey ( ) ) -> update ( array ( $ self -> getDepthColumnName ( ) => $ newDepth ) ) ; $ self -> setAttribute ( $ self -> getDepthColumnName ( ) , $ newDepth ) ; $ diff = $ newDepth - $ oldDepth ; if ( ! $ self -> isLeaf ( ) && $ diff != 0 ) $ self -> descendants ( ) -> increment ( $ self -> getDepthColumnName ( ) , $ diff ) ; } ) ; return $ this ; }
1228	public function parse ( $ expression ) { $ this -> expression = $ expression ; $ this -> tokens = $ this -> lexer -> tokenize ( $ expression ) ; $ this -> tpos = - 1 ; $ this -> next ( ) ; $ result = $ this -> expr ( ) ; if ( $ this -> token [ 'type' ] === T :: T_EOF ) { return $ result ; } throw $ this -> syntax ( 'Did not reach the end of the token stream' ) ; }
3454	public static function fromAggregateRoot ( $ eventSourcedAggregateRoot ) : AggregateType { if ( ! \ is_object ( $ eventSourcedAggregateRoot ) ) { throw new Exception \ AggregateTypeException ( \ sprintf ( 'Aggregate root must be an object but type of %s given' , \ gettype ( $ eventSourcedAggregateRoot ) ) ) ; } if ( $ eventSourcedAggregateRoot instanceof AggregateTypeProvider ) { return $ eventSourcedAggregateRoot -> aggregateType ( ) ; } $ self = new static ( ) ; $ self -> aggregateType = \ get_class ( $ eventSourcedAggregateRoot ) ; return $ self ; }
11528	public function registerCustomHelpers ( ) { foreach ( glob ( app_path ( $ this -> namespace . '/*' ) ) as $ helper ) { $ helperName = last ( explode ( '/' , $ helper ) ) ; if ( ! in_array ( $ helperName , $ this -> customExclude ) ) { if ( in_array ( '*' , $ this -> customInclude ) || in_array ( $ helperName , $ this -> customInclude ) ) { require_once $ helper ; } } } }
8962	private static function extractArrayCriteria ( $ key , array $ criteria ) { if ( ! empty ( $ criteria [ $ key ] ) ) { return array ( $ criteria [ $ key ] ) ; } if ( ! empty ( $ criteria [ $ key . 's' ] ) ) { return $ criteria [ $ key . 's' ] ; } return array ( ) ; }
8949	function constructUrl ( Request $ appRequest , Nette \ Http \ Url $ refUrl ) { return $ this -> getRouter ( ) -> constructUrl ( $ appRequest , $ refUrl ) ; }
7236	private function phoneNumberCountry ( PhoneNumber $ phoneNumber = null ) { if ( $ phoneNumber ) { return $ this -> phoneNumberUtil -> getRegionCodeForNumber ( $ phoneNumber ) ; } return null ; }
2432	public function updateAfterRestore ( $ id , $ table , $ data ) { if ( $ table != 'tl_style' ) { return ; } $ this -> Database -> prepare ( "UPDATE tl_style_sheet SET tstamp=? WHERE id=?" ) -> execute ( time ( ) , $ data [ 'pid' ] ) ; $ this -> import ( 'Contao\StyleSheets' , 'StyleSheets' ) ; $ this -> StyleSheets -> updateStyleSheet ( $ data [ 'pid' ] ) ; }
12488	public static function write ( $ output ) { if ( self :: $ enabled ) { $ d = new \ DateTime ( ) ; $ f = new File ( self :: $ logFilePath , true ) ; $ f -> write ( $ d -> format ( 'd/m/Y H:i:s' ) . ' - ' . $ output . "\n" , true ) ; } }
2713	public function getValues ( ) { $ values = [ ] ; $ ratios = $ this -> pixelRatios -> toOptionArray ( ) ; foreach ( $ ratios as $ value ) { $ values [ $ value [ 'value' ] ] = $ value [ 'label' ] ; } return $ values ; }
2930	public function getValue ( $ key ) { $ allKeys = $ this -> getKeys ( [ $ key ] ) ; if ( array_key_exists ( $ key , $ allKeys ) ) { return $ allKeys [ $ key ] [ 'value' ] ; } throw new KeyNotFoundException ( 'Requested key not found in your file.' ) ; }
9483	public function toArray ( $ changedOnly = false , $ extraData = null ) { $ vars = get_object_vars ( $ this ) ; $ object = array ( ) ; if ( ! is_array ( $ this -> _changes ) ) { $ this -> _changes = array ( ) ; } if ( is_array ( $ extraData ) ) { $ vars = array_merge ( $ vars , $ extraData ) ; } foreach ( $ vars as $ k => $ v ) { if ( strpos ( $ k , '_' ) !== 0 && $ v !== null && ( ! $ changedOnly || array_key_exists ( $ k , $ this -> _changes ) || array_key_exists ( $ k , $ extraData ) ) ) { if ( is_array ( $ v ) ) { $ subV = array ( ) ; foreach ( $ v as $ sub ) { if ( is_a ( $ sub , 'Dlin\Zendesk\Entity\BaseEntity' ) ) { $ subV [ ] = $ sub -> toArray ( ) ; } else { $ subV [ ] = $ sub ; } } $ object [ $ k ] = $ subV ; } else if ( is_a ( $ v , 'Dlin\Zendesk\Entity\BaseEntity' ) ) { $ object [ $ k ] = $ v -> toArray ( ) ; } else { $ object [ $ k ] = $ v ; } } } return $ object ; }
12493	public static function groupBy ( $ field ) { if ( ! ( gettype ( $ field ) == "string" || $ field instanceof Key || $ field instanceof Raw ) ) { throw new ClusterpointException ( "\"->group()\" function: passed field selector is not in valid format." , 9002 ) ; } if ( $ field instanceof Key ) { $ field = self :: field ( "{$field}" ) ; } return "{$field}" ; }
2787	protected function execute ( InputInterface $ input , OutputInterface $ output ) { if ( PHP_SAPI !== 'phpdbg' && ! defined ( 'HHVM_VERSION' ) && ! extension_loaded ( 'xdebug' ) ) { $ output -> writeln ( '<error>You need to install and enable xdebug, or use phpdbg, ' . 'in order to allow for code coverage generation.</error>' ) ; return 1 ; } Performance :: upMemProfiler ( ) ; $ this -> validate ( $ input ) ; $ container = $ this -> container = new Container ( $ input -> getOptions ( ) ) ; $ this -> doConfiguration ( $ input ) ; if ( $ this -> isLoggingEnabled ( ) ) { $ this -> removeOldLogFiles ( ) ; } else { $ output -> writeln ( '<error>No log file is specified. Detailed results ' . 'will not be available.</error>' ) ; $ output -> write ( PHP_EOL ) ; } if ( $ input -> getOption ( 'incremental' ) ) { $ output -> writeln ( '<error>Incremental Analysis is an experimental feature and will very likely</error>' ) ; $ output -> writeln ( '<error>yield inaccurate results at this time.</error>' ) ; $ output -> write ( PHP_EOL ) ; } if ( $ this -> textLogFile ) { $ renderer = new Text ( $ output , true ) ; } else { $ renderer = new Text ( $ output ) ; } $ testSuiteRunner = new UnitTestRunner ( $ container -> getAdapter ( ) , $ container -> getAdapter ( ) -> getProcess ( $ container , true ) , $ container -> getTempDirectory ( ) . '/coverage.humbug.txt' ) ; $ testSuiteRunner -> addObserver ( new LoggingObserver ( $ renderer , $ output , new ProgressBarObserver ( $ input , $ output ) ) ) ; $ result = $ testSuiteRunner -> run ( $ container ) ; if ( ! $ result -> isSuccess ( ) ) { return 1 ; } $ output -> write ( PHP_EOL ) ; $ renderer -> renderStaticAnalysisStart ( ) ; $ output -> write ( PHP_EOL ) ; $ incrementalCache = null ; if ( $ input -> getOption ( 'incremental' ) ) { $ incrementalCache = new IncrementalCache ( $ container ) ; } $ mutationTestingRunner = $ this -> builder -> build ( $ container , $ renderer , $ input , $ output ) ; $ mutationTestingRunner -> run ( $ result -> getCoverage ( ) , $ this -> mutableIterator , $ incrementalCache ) ; if ( $ this -> isLoggingEnabled ( ) ) { $ output -> write ( PHP_EOL ) ; } if ( $ input -> getOption ( 'incremental' ) ) { $ incrementalCache -> write ( ) ; } }
10354	protected function getEventName ( ) { $ chunks = explode ( '\\' , get_class ( $ this ) ) ; $ name = $ chunks [ count ( $ chunks ) - 2 ] ; return strtolower ( $ name ) ; }
280	private function confirmLoad ( $ fixtures , $ except ) { $ this -> stdout ( "Fixtures namespace is: \n" , Console :: FG_YELLOW ) ; $ this -> stdout ( "\t" . $ this -> namespace . "\n\n" , Console :: FG_GREEN ) ; if ( count ( $ this -> globalFixtures ) ) { $ this -> stdout ( "Global fixtures will be used:\n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ this -> globalFixtures ) ; } if ( count ( $ fixtures ) ) { $ this -> stdout ( "\nFixtures below will be loaded:\n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ fixtures ) ; } if ( count ( $ except ) ) { $ this -> stdout ( "\nFixtures that will NOT be loaded: \n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ except ) ; } $ this -> stdout ( "\nBe aware that:\n" , Console :: BOLD ) ; $ this -> stdout ( "Applying leads to purging of certain data in the database!\n" , Console :: FG_RED ) ; return $ this -> confirm ( "\nLoad above fixtures?" ) ; }
12601	public static function write ( $ filename , $ buffer ) { $ fs = new Filesystem ( ) ; try { $ fs -> dumpFile ( $ filename , $ buffer ) ; } catch ( IOExceptionInterface $ e ) { throw new Exception ( $ e -> getMessage ( ) ) ; } return true ; }
11660	public static function readFromString ( $ string ) { $ xml = new \ DOMDocument ( ) ; $ xml -> loadXML ( $ string ) ; $ result = [ ] ; $ props = $ xml -> childNodes -> item ( $ xml -> childNodes -> length - 1 ) -> childNodes ; for ( $ i = 0 ; $ i < $ props -> length ; $ i ++ ) { $ entry = $ props -> item ( $ i ) ; if ( $ entry -> nodeName == "entry" ) $ result [ $ entry -> attributes -> getNamedItem ( "key" ) -> nodeValue ] = $ entry -> textContent ; } return $ result ; }
1532	protected function deserialize ( array $ document , $ record = null ) : ResourceObject { $ data = $ document [ 'data' ] ?? [ ] ; if ( ! is_array ( $ data ) || empty ( $ data ) ) { throw new \ InvalidArgumentException ( 'Expecting a JSON API document with a data member.' ) ; } return ResourceObject :: create ( $ data ) ; }
8436	public static function fetchArray ( array $ conditions , array $ orderBy = null , bool $ critical = false ) { $ entity = new static ( ) ; $ selectQuery = new Select ( $ entity -> getDatabaseName ( ) , $ critical ) ; $ selectQuery -> select ( $ entity -> getAllFieldsRealNames ( ) ) ; $ selectQuery -> from ( $ entity -> getTableName ( ) ) ; if ( count ( $ conditions ) > 0 ) { $ where = array ( ) ; foreach ( $ conditions as $ key => $ value ) { $ realName = constant ( get_called_class ( ) . '::FIELD_' . strtoupper ( Helper :: codifyName ( $ key ) ) ) ; $ where [ $ realName ] = ':where' . ucfirst ( $ key ) ; $ selectQuery -> bind ( 'where' . ucfirst ( $ key ) , $ value ) ; } $ selectQuery -> where ( $ where ) ; } if ( is_array ( $ orderBy ) && count ( $ orderBy ) > 0 ) { $ orders = array ( ) ; foreach ( $ orderBy as $ key => $ value ) { $ realName = constant ( get_called_class ( ) . '::FIELD_' . strtoupper ( Helper :: codifyName ( $ key ) ) ) ; $ orders [ $ realName ] = strtoupper ( ucfirst ( $ value ) ) ; } $ selectQuery -> orderBy ( $ orders ) ; } $ selectQuery -> limit ( 1 ) ; if ( $ selectQuery -> execute ( ) === false ) { return false ; } $ data = $ selectQuery -> fetch ( ) ; if ( is_array ( $ data ) === false ) { return false ; } return $ data ; }
3626	protected function getDefaultSerial ( $ serial_number ) { if ( empty ( $ serial_number ) ) { $ devices_serials = $ this -> getDevices ( ) ; if ( count ( $ devices_serials ) == 0 ) { $ devices_serials = $ this -> getDevices ( DEVICE_TYPE_PROTECT ) ; } $ serial_number = $ devices_serials [ 0 ] ; } return $ serial_number ; }
8987	public static function parseStatus ( $ statusLine ) : HttpStatus { list ( $ proto , $ code ) = sscanf ( $ statusLine , "%s %d %s" ) ; return new HttpStatus ( $ code , $ proto ) ; }
10445	protected function handleParam ( ) { if ( preg_match ( '/^@([0-9]+)=(.*)$/' , $ this -> getNextLine ( self :: LINE_TYPE_ANY ) , $ part ) ) { $ paramValue = trim ( $ part [ 2 ] , "'" ) ; return [ $ part [ 1 ] => $ paramValue ] ; } return null ; }
7244	public function load_options ( ) { $ options = get_option ( self :: OPTION_KEY , '' ) ; if ( ! is_array ( $ options ) ) { $ options = self :: $ default_options ; update_option ( self :: OPTION_KEY , $ options ) ; } else { foreach ( self :: $ default_options as $ key => $ value ) { if ( ! isset ( $ options [ $ key ] ) ) $ options [ $ key ] = $ value ; } } $ this -> options = $ options ; }
8382	public function fetch ( ) { if ( $ this -> statement == null || $ this -> getErrorState ( ) != '00000' ) { return false ; } return $ this -> statement -> fetch ( \ PDO :: FETCH_ASSOC ) ; }
8858	private function _absoluteSymlinkWithFallback ( string $ originDir , string $ targetDir ) : string { try { $ this -> _symlink ( $ originDir , $ targetDir ) ; $ method = AssetsInstallCommand :: METHOD_ABSOLUTE_SYMLINK ; } catch ( IOException $ e ) { $ method = $ this -> _hardCopy ( $ originDir , $ targetDir ) ; } return $ method ; }
6027	public function setUploaded ( $ uploaded ) { if ( $ uploaded instanceof DateTime ) { $ this -> uploaded = $ uploaded ; } else { try { $ this -> uploaded = new DateTime ( $ uploaded ) ; } catch ( \ Exception $ e ) { $ this -> uploaded = null ; } } return $ this ; }
5412	public function read ( ) { if ( $ this -> isError ( ) || ! $ this -> isOpen ( ) ) { return false ; } $ raw = @ fread ( $ this -> handle , $ this -> block_size ) ; if ( $ raw === false ) { $ this -> setError ( 'Cannot read from socket' ) ; $ this -> close ( ) ; } return $ raw ; }
10716	public function deleteMany ( ArrayAccess $ models ) { $ results = [ ] ; foreach ( $ models as $ model ) { $ results [ ] = $ this -> delete ( $ model ) ; } return $ this -> returnResults ( $ results ) ; }
11458	public function batchPageSummary ( $ timestamp , $ pageIndex ) { $ params = [ 'date' => $ timestamp , 'page_index' => $ pageIndex , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_PAGE_LIST , $ params ] ) ; }
9062	private function getTableSchema ( ) : ? Row { return $ this -> connection -> query ( " SELECT [tab.ENGINE], [col.COLLATION_NAME], [col.CHARACTER_SET_NAME] FROM [information_schema.TABLES] tab JOIN [information_schema.COLLATION_CHARACTER_SET_APPLICABILITY] col ON [tab.TABLE_COLLATION] = [col.COLLATION_NAME] WHERE [tab.TABLE_SCHEMA] = %s AND [tab.TABLE_NAME] = %s" , $ this -> database , $ this -> name ) -> fetch ( ) ; }
3566	public function setAttribute ( ) { return function ( $ next , $ value , $ args ) { $ key = $ args -> get ( 'key' ) ; if ( ! $ this -> hasColumn ( $ key ) && $ this -> allowsMeta ( $ key ) && ! $ this -> hasSetMutator ( $ key ) ) { return $ this -> setMeta ( $ key , $ value ) ; } return $ next ( $ value , $ args ) ; } ; }
7598	public function render ( $ sGlyphicon , array $ aGlyphiconAttributes = null ) { if ( ! is_scalar ( $ sGlyphicon ) ) { throw new InvalidArgumentException ( 'Glyphicon expects a scalar value, "' . gettype ( $ sGlyphicon ) . '" given' ) ; } if ( empty ( $ aGlyphiconAttributes ) ) { $ aGlyphiconAttributes = array ( 'class' => 'glyphicon' ) ; } else { if ( empty ( $ aGlyphiconAttributes [ 'class' ] ) ) { $ aGlyphiconAttributes [ 'class' ] = 'glyphicon' ; } elseif ( ! preg_match ( '/(\s|^)glyphicon(\s|$)/' , $ aGlyphiconAttributes [ 'class' ] ) ) { $ aGlyphiconAttributes [ 'class' ] .= ' glyphicon' ; } } if ( strpos ( 'glyphicon-' , $ sGlyphicon ) !== 0 ) { $ sGlyphicon = 'glyphicon-' . $ sGlyphicon ; } if ( ! preg_match ( '/(\s|^)' . preg_quote ( $ sGlyphicon , '/' ) . '(\s|$)/' , $ aGlyphiconAttributes [ 'class' ] ) ) { $ aGlyphiconAttributes [ 'class' ] .= ' ' . $ sGlyphicon ; } return sprintf ( static :: $ glyphiconFormat , $ this -> createAttributesString ( $ aGlyphiconAttributes ) ) ; }
5602	public function paintFail ( $ message ) { if ( ! $ this -> fail && ! $ this -> error ) { $ this -> fail = true ; $ this -> message = self :: escapeVal ( $ message ) ; $ this -> listener -> write ( '{status:"fail",message:"' . $ this -> message . '",group:"' . $ this -> group . '",case:"' . $ this -> case . '",method:"' . $ this -> method . '"}' ) ; } }
6296	private static function migrateConfig ( array $ config ) : array { if ( isset ( $ config [ 'class' ] ) ) { do_action ( 'inpsyde.assets.debug' , 'The asset config-format with "type" and "class" is deprecated.' , $ config ) ; $ config [ 'location' ] = $ config [ 'type' ] ?? Asset :: FRONTEND ; $ config [ 'type' ] = $ config [ 'class' ] ; unset ( $ config [ 'class' ] ) ; } return $ config ; }
1538	public function willSeeOne ( $ request ) : bool { if ( $ this -> route -> isRelationship ( ) ) { return false ; } if ( $ this -> route -> isResource ( ) ) { return true ; } return $ request -> isMethod ( 'POST' ) ; }
1915	protected function getQuestion ( ) { $ this -> generateCaptcha ( ) ; $ question = $ GLOBALS [ 'TL_LANG' ] [ 'SEC' ] [ 'question' . random_int ( 1 , 3 ) ] ; $ question = sprintf ( $ question , $ this -> arrCaptcha [ 'int1' ] , $ this -> arrCaptcha [ 'int2' ] ) ; $ strEncoded = '' ; $ arrCharacters = Utf8 :: str_split ( $ question ) ; foreach ( $ arrCharacters as $ strCharacter ) { $ strEncoded .= sprintf ( '&#%s;' , Utf8 :: ord ( $ strCharacter ) ) ; } return $ strEncoded ; }
3261	public static function placeOrder ( $ cart = null ) { try { if ( empty ( static :: $ gatewayKey ) ) throw new ShopException ( 'Payment gateway not selected.' ) ; if ( empty ( $ cart ) ) $ cart = Auth :: user ( ) -> cart ; $ order = $ cart -> placeOrder ( ) ; $ statusCode = $ order -> statusCode ; \ event ( new OrderPlaced ( $ order -> id ) ) ; static :: $ gateway -> setCallbacks ( $ order ) ; if ( static :: $ gateway -> onCharge ( $ order ) ) { $ order -> statusCode = static :: $ gateway -> getTransactionStatusCode ( ) ; $ order -> save ( ) ; $ order -> placeTransaction ( static :: $ gatewayKey , static :: $ gateway -> getTransactionId ( ) , static :: $ gateway -> getTransactionDetail ( ) , static :: $ gateway -> getTransactionToken ( ) ) ; if ( $ order -> isCompleted ) \ event ( new OrderCompleted ( $ order -> id ) ) ; } else { $ order -> statusCode = 'failed' ; $ order -> save ( ) ; } } catch ( ShopException $ e ) { static :: setException ( $ e ) ; if ( isset ( $ order ) ) { $ order -> statusCode = 'failed' ; $ order -> save ( ) ; $ order -> placeTransaction ( static :: $ gatewayKey , uniqid ( ) , static :: $ exception -> getMessage ( ) , $ order -> statusCode ) ; } } catch ( GatewayException $ e ) { static :: $ exception = $ e ; if ( isset ( $ order ) ) { $ order -> statusCode = 'failed' ; $ order -> save ( ) ; $ order -> placeTransaction ( static :: $ gatewayKey , uniqid ( ) , static :: $ exception -> getMessage ( ) , $ order -> statusCode ) ; } } if ( $ order ) { static :: checkStatusChange ( $ order , $ statusCode ) ; return $ order ; } else { return ; } }
8055	public static function get ( $ length = 8 , $ outputFormat = Code :: FORMAT_ALNUM ) { static :: throwUnlessAcceptable ( $ outputFormat , $ length ) ; $ number = rand ( 100 , 900 ) . str_replace ( '.' , '' , microtime ( true ) ) ; $ output = self :: convertBase ( $ number , self :: FORMAT_NUMBER , $ outputFormat ) ; if ( strlen ( $ output ) < $ length ) { $ output .= substr ( str_shuffle ( $ outputFormat . $ outputFormat ) , 0 , ( $ length - strlen ( $ output ) ) ) ; } if ( strlen ( $ output ) > $ length ) { $ output = substr ( $ output , 0 , $ length ) ; } return $ output ; }
3685	protected function optimizedFilter ( $ filterRule , $ children , $ operation ) { $ procedure = new FilterBuilderSql ( $ this -> getMetaModel ( ) -> getTableName ( ) , $ operation , $ this -> connection ) ; $ skipped = $ this -> buildNativeSqlProcedure ( $ procedure , $ children ) ; if ( ! $ procedure -> isEmpty ( ) ) { $ filterRule -> addChild ( $ this -> getMetaModel ( ) -> getEmptyFilter ( ) -> addFilterRule ( $ procedure -> build ( ) ) ) ; } return $ skipped ; }
10769	public function run ( ) { $ viewName = $ this -> resolveViewName ( ) ; $ this -> controller -> actionParams [ $ this -> viewParam ] = Yii :: $ app -> request -> get ( $ this -> viewParam ) ; $ controllerLayout = null ; if ( $ this -> layout !== null ) { $ controllerLayout = $ this -> controller -> layout ; $ this -> controller -> layout = $ this -> layout ; } try { $ output = $ this -> render ( $ viewName ) ; if ( $ controllerLayout ) { $ this -> controller -> layout = $ controllerLayout ; } } catch ( InvalidParamException $ e ) { if ( $ controllerLayout ) { $ this -> controller -> layout = $ controllerLayout ; } if ( YII_DEBUG ) { throw new NotFoundHttpException ( $ e -> getMessage ( ) ) ; } else { throw new NotFoundHttpException ( Yii :: t ( 'yii' , 'The requested view "{name}" was not found.' , [ 'name' => $ viewName ] ) ) ; } } return $ output ; }
6421	public static function ands ( callable ... $ predicates ) : callable { return function ( $ element ) use ( $ predicates ) { foreach ( $ predicates as $ predicate ) { if ( ! self :: call ( $ predicate , $ element ) ) { return false ; } } return true ; } ; }
7659	function AddrAppend ( $ type , $ addr ) { $ addr_str = $ type . ": " ; $ addr_str .= $ this -> AddrFormat ( $ addr [ 0 ] ) ; if ( count ( $ addr ) > 1 ) { for ( $ i = 1 ; $ i < count ( $ addr ) ; $ i ++ ) $ addr_str .= ", " . $ this -> AddrFormat ( $ addr [ $ i ] ) ; } $ addr_str .= $ this -> LE ; return $ addr_str ; }
8149	public function compileSource ( $ source , $ name = null ) { if ( ! $ source instanceof Twig_Source ) { @ trigger_error ( sprintf ( 'Passing a string as the $source argument of %s() is deprecated since version 1.27. Pass a Twig_Source instance instead.' , __METHOD__ ) , E_USER_DEPRECATED ) ; $ source = new Twig_Source ( $ source , $ name ) ; } try { return $ this -> compile ( $ this -> parse ( $ this -> tokenize ( $ source ) ) ) ; } catch ( Twig_Error $ e ) { $ e -> setSourceContext ( $ source ) ; throw $ e ; } catch ( Exception $ e ) { throw new Twig_Error_Syntax ( sprintf ( 'An exception has been thrown during the compilation of a template ("%s").' , $ e -> getMessage ( ) ) , - 1 , $ source , $ e ) ; } }
6582	public static function getSession ( ServerRequestInterface $ request ) : SessionDataHolder { $ session = $ request -> getAttribute ( static :: REQ_ATTR ) ; if ( ! $ session instanceof SessionDataHolder ) { throw new SessionMiddlewareException ( "No session object is available in the request attributes" ) ; } return $ session ; }
5092	public function assemble ( ) { $ command = 'CREATE ' . $ this -> getPartIfSet ( self :: PART_TEMP ) . 'TABLE ' . $ this -> getPartIfSet ( self :: PART_IF_NOT_EXIST ) . $ this -> parts [ self :: PART_DB ] . $ this -> parts [ self :: PART_NAME ] ; if ( $ this -> parts [ self :: PART_LIKE ] ) { return $ command . ' ' . $ this -> parts [ self :: PART_LIKE ] ; } if ( ! $ this -> columnsList -> isEmpty ( ) ) { $ command .= '(' ; $ columns = $ this -> columnsList -> assemble ( ) ; $ keys = $ this -> indexes -> assemble ( ) ; $ combined = array_merge ( $ columns , $ keys ) ; $ command .= implode ( ',' , $ combined ) ; $ command .= ') ' . $ this -> getPartIfSet ( self :: PART_ENGINE , 'ENGINE=' ) . $ this -> getPartIfSet ( self :: PART_CHARSET , 'CHARSET=' ) . $ this -> getPartIfSet ( self :: PART_CHARSET , 'AUTO_INCREMENT=' ) . $ this -> getPartIfSet ( self :: PART_COMMENT , 'COMMENT=' ) ; } if ( $ this -> parts [ self :: PART_AS ] ) { $ command .= " {$this->getAsExpression()}" ; } return $ command ; }
4548	public function getAll ( ) : Data { $ data = new Data ; foreach ( $ this -> statCollection as $ stat ) { $ datum = $ stat -> get ( ) ; $ data -> getCollection ( ) -> add ( $ datum ) ; } return $ data ; }
9796	public function hasHyperlink ( ) { if ( ! isset ( $ this -> parent ) ) { throw new Exception ( 'Cannot check for hyperlink when cell is not bound to a worksheet' ) ; } return $ this -> getWorksheet ( ) -> hyperlinkExists ( $ this -> getCoordinate ( ) ) ; }
5482	public function setField ( SelectorInterface $ selector , $ value , $ position = false ) { $ success = false ; $ _position = 0 ; for ( $ i = 0 , $ count = count ( $ this -> widgets ) ; $ i < $ count ; $ i ++ ) { if ( $ selector -> isMatch ( $ this -> widgets [ $ i ] ) ) { $ _position ++ ; if ( $ position === false or $ _position === ( int ) $ position ) { if ( $ this -> widgets [ $ i ] -> setValue ( $ value ) ) { $ success = true ; } } } } return $ success ; }
1871	public function generateAjax ( $ strFolder , $ strField , $ level , $ mount = false ) { if ( ! Environment :: get ( 'isAjaxRequest' ) ) { return '' ; } $ this -> strField = $ strField ; $ this -> loadDataContainer ( $ this -> strTable ) ; switch ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'dataContainer' ] ) { case 'File' : if ( Config :: get ( $ this -> strField ) != '' ) { $ this -> varValue = Config :: get ( $ this -> strField ) ; } break ; case 'Table' : $ this -> import ( Database :: class , 'Database' ) ; if ( ! $ this -> Database -> fieldExists ( $ this -> strField , $ this -> strTable ) ) { break ; } $ objField = $ this -> Database -> prepare ( "SELECT " . Database :: quoteIdentifier ( $ this -> strField ) . " FROM " . $ this -> strTable . " WHERE id=?" ) -> limit ( 1 ) -> execute ( $ this -> strId ) ; if ( $ objField -> numRows ) { $ this -> varValue = StringUtil :: deserialize ( $ objField -> { $ this -> strField } ) ; } break ; } $ this -> convertValuesToPaths ( ) ; if ( $ this -> extensions != '' ) { $ this -> arrValidFileTypes = StringUtil :: trimsplit ( ',' , $ this -> extensions ) ; } return $ this -> renderFiletree ( System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) . '/' . $ strFolder , ( $ level * 20 ) , $ mount , $ this -> isProtectedPath ( $ strFolder ) ) ; }
2746	public function isImageOptimizationPixelRatioEnabled ( ) { if ( $ this -> isImageOptimizationEnabled ( ) !== true ) { return false ; } return $ this -> _scopeConfig -> isSetFlag ( self :: XML_FASTLY_IMAGE_OPTIMIZATIONS_PIXEL_RATIO ) ; }
5607	public function paintGroupEnd ( $ group ) { $ this -> group = '' ; $ cc = '' ; if ( $ this -> cc ) { if ( extension_loaded ( 'xdebug' ) ) { $ arrfiles = xdebug_get_code_coverage ( ) ; xdebug_stop_code_coverage ( ) ; $ thisdir = dirname ( __FILE__ ) ; $ thisdirlen = strlen ( $ thisdir ) ; foreach ( $ arrfiles as $ index => $ file ) { if ( substr ( $ index , 0 , $ thisdirlen ) === $ thisdir ) { continue ; } $ lcnt = 0 ; $ ccnt = 0 ; foreach ( $ file as $ line ) { if ( $ line == - 2 ) { continue ; } $ lcnt ++ ; if ( $ line == 1 ) { $ ccnt ++ ; } } if ( $ lcnt > 0 ) { $ cc .= round ( ( $ ccnt / $ lcnt ) * 100 , 2 ) . '%' ; } else { $ cc .= '0.00%' ; } $ cc .= "\t" . $ index . "\n" ; } } } $ this -> listener -> write ( '{status:"coverage",message:"' . self :: escapeVal ( $ cc ) . '"}' ) ; }
1957	public function generate ( ) { if ( $ this -> vimeo == '' ) { return '' ; } if ( TL_MODE == 'BE' ) { $ return = '<p><a href="https://vimeo.com/' . $ this -> vimeo . '" target="_blank" rel="noreferrer noopener">vimeo.com/' . $ this -> vimeo . '</a></p>' ; if ( $ this -> headline != '' ) { $ return = '<' . $ this -> hl . '>' . $ this -> headline . '</' . $ this -> hl . '>' . $ return ; } return $ return ; } return parent :: generate ( ) ; }
5327	public function end ( string $ profile ) { Craft :: endProfile ( $ profile , Craft :: t ( 'twig-profiler' , self :: CATEGORY_PREFIX ) . TwigProfiler :: $ renderingTemplate ) ; }
2364	public static function generateAlias ( $ strString ) { $ strString = static :: decodeEntities ( $ strString ) ; $ strString = static :: restoreBasicEntities ( $ strString ) ; $ strString = static :: standardize ( strip_tags ( $ strString ) ) ; if ( strncmp ( $ strString , 'id-' , 3 ) === 0 && ! is_numeric ( $ strSubstr = substr ( $ strString , 3 ) ) ) { $ strString = $ strSubstr ; } return $ strString ; }
10779	private function addSessionCookie ( ResponseInterface $ response ) : ResponseInterface { $ params = session_get_cookie_params ( ) ; $ cookie = new SetCookie ( session_name ( ) , session_id ( ) , time ( ) + $ params [ "lifetime" ] , $ params [ "path" ] , $ params [ "domain" ] , $ params [ "secure" ] , $ params [ "httponly" ] ) ; return $ cookie -> addToResponse ( $ response ) ; }
5160	public function getAttachmentByField ( string $ field ) : array { if ( isset ( $ this -> attachment [ $ field ] ) ) { return $ this -> attachment [ $ field ] ; } return [ ] ; }
3189	public function getLastTimestamp ( $ tags ) { $ range = $ this -> getRange ( $ tags ) ; $ length = count ( $ range ) ; $ last = false ; if ( $ length ) { $ last = $ range [ $ length - 1 ] -> getTimestamp ( ) ; } return $ last ; }
2290	protected function addRecipient ( $ strEmail , $ arrNew ) { if ( ( $ objOld = NewsletterRecipientsModel :: findOldSubscriptionsByEmailAndPids ( $ strEmail , $ arrNew ) ) !== null ) { while ( $ objOld -> next ( ) ) { $ objOld -> delete ( ) ; } } $ time = time ( ) ; $ arrRelated = array ( ) ; foreach ( $ arrNew as $ id ) { $ objRecipient = new NewsletterRecipientsModel ( ) ; $ objRecipient -> pid = $ id ; $ objRecipient -> tstamp = $ time ; $ objRecipient -> email = $ strEmail ; $ objRecipient -> active = '' ; $ objRecipient -> addedOn = $ time ; $ objRecipient -> save ( ) ; if ( ( $ objBlacklist = NewsletterBlacklistModel :: findByHashAndPid ( md5 ( $ strEmail ) , $ id ) ) !== null ) { $ objBlacklist -> delete ( ) ; } $ arrRelated [ 'tl_newsletter_recipients' ] [ ] = $ objRecipient -> id ; } $ optIn = System :: getContainer ( ) -> get ( 'contao.opt-in' ) ; $ optInToken = $ optIn -> create ( 'nl' , $ strEmail , $ arrRelated ) ; $ objChannel = NewsletterChannelModel :: findByIds ( $ arrNew ) ; $ arrData = array ( ) ; $ arrData [ 'token' ] = $ optInToken -> getIdentifier ( ) ; $ arrData [ 'domain' ] = Idna :: decode ( Environment :: get ( 'host' ) ) ; $ arrData [ 'link' ] = Idna :: decode ( Environment :: get ( 'base' ) ) . Environment :: get ( 'request' ) . ( ( strpos ( Environment :: get ( 'request' ) , '?' ) !== false ) ? '&' : '?' ) . 'token=' . $ optInToken -> getIdentifier ( ) ; $ arrData [ 'channel' ] = $ arrData [ 'channels' ] = implode ( "\n" , $ objChannel -> fetchEach ( 'title' ) ) ; $ optInToken -> send ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'nl_subject' ] , Idna :: decode ( Environment :: get ( 'host' ) ) ) , StringUtil :: parseSimpleTokens ( $ this -> nl_subscribe , $ arrData ) ) ; if ( ( $ objTarget = $ this -> objModel -> getRelated ( 'jumpTo' ) ) instanceof PageModel ) { $ this -> redirect ( $ objTarget -> getFrontendUrl ( ) ) ; } System :: getContainer ( ) -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'nl_confirm' , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'nl_confirm' ] ) ; $ this -> reload ( ) ; }
7069	static function isValid ( $ unit , $ throw = false ) { if ( in_array ( $ unit , static :: getUnits ( ) , true ) ) { return true ; } if ( $ throw ) { throw new InvalidArgumentException ( "Invalid unit '$unit'." ) ; } return false ; }
349	public static function cssStyleToArray ( $ style ) { $ result = [ ] ; foreach ( explode ( ';' , $ style ) as $ property ) { $ property = explode ( ':' , $ property ) ; if ( count ( $ property ) > 1 ) { $ result [ trim ( $ property [ 0 ] ) ] = trim ( $ property [ 1 ] ) ; } } return $ result ; }
7720	static function f_Misc_UpdateArray ( & $ array , $ numerical , $ v , $ d ) { if ( ! is_array ( $ v ) ) { if ( is_null ( $ v ) ) { $ array = array ( ) ; return ; } else { $ v = array ( $ v => $ d ) ; } } foreach ( $ v as $ p => $ a ) { if ( $ numerical === true ) { if ( is_string ( $ p ) ) { $ i = array_search ( $ p , $ array , true ) ; if ( $ i === false ) { if ( ! is_null ( $ a ) ) $ array [ ] = $ p ; } else { if ( is_null ( $ a ) ) array_splice ( $ array , $ i , 1 ) ; } } else { $ i = array_search ( $ a , $ array , true ) ; if ( $ i == false ) $ array [ ] = $ a ; } } else { if ( is_null ( $ a ) ) { unset ( $ array [ $ p ] ) ; } elseif ( $ numerical === 'frm' ) { self :: f_Misc_FormatSave ( $ a , $ p ) ; } else { $ array [ $ p ] = $ a ; } } } }
5718	public function doPublishAndClose ( $ data , $ form ) { Controller :: curr ( ) -> getResponse ( ) -> addHeader ( "X-Pjax" , "Content" ) ; return $ this -> publish ( $ data , $ form , $ this -> owner , $ this -> getBackLink ( ) ) ; }
3684	protected function buildNativeSqlProcedure ( FilterBuilderSql $ procedure , $ children ) { $ skipped = array ( ) ; $ metaModel = $ this -> getMetaModel ( ) ; $ tableName = $ metaModel -> getTableName ( ) ; foreach ( $ children as $ child ) { if ( isset ( $ child [ 'property' ] ) && $ metaModel -> hasAttribute ( $ child [ 'property' ] ) ) { $ skipped [ ] = $ child ; continue ; } if ( ( 'AND' === $ child [ 'operation' ] ) || ( 'OR' === $ child [ 'operation' ] ) ) { if ( null === $ child [ 'children' ] ) { continue ; } $ subProcedure = new FilterBuilderSql ( $ tableName , $ child [ 'operation' ] , $ this -> connection ) ; $ subSkipped = $ this -> buildNativeSqlProcedure ( $ subProcedure , $ child [ 'children' ] ) ; if ( count ( $ subSkipped ) !== count ( $ child [ 'children' ] ) ) { $ procedure -> addSubProcedure ( $ subProcedure ) ; } if ( ! empty ( $ subSkipped ) ) { $ skipped += $ subSkipped ; } continue ; } $ procedure -> addChild ( $ child ) ; } return $ skipped ; }
568	private function formatTimestamp ( $ timestamp , $ format ) { if ( strncmp ( $ format , 'php:' , 4 ) === 0 ) { $ format = substr ( $ format , 4 ) ; } else { $ format = FormatConverter :: convertDateIcuToPhp ( $ format , 'date' ) ; } $ date = new DateTime ( ) ; $ date -> setTimestamp ( $ timestamp ) ; $ date -> setTimezone ( new \ DateTimeZone ( $ this -> timestampAttributeTimeZone ) ) ; return $ date -> format ( $ format ) ; }
9243	private function __setCookieAndLocale ( $ locale ) { if ( PHP_SAPI !== 'cli' ) { $ time = $ this -> __getCookieExpireTime ( ) ; I18n :: locale ( $ locale ) ; setcookie ( $ this -> __getCookieName ( ) , $ locale , $ time , '/' , $ this -> config ( 'Cookie.domain' ) ) ; } }
522	protected function createMigration ( $ class ) { $ this -> includeMigrationFile ( $ class ) ; $ migration = Yii :: createObject ( $ class ) ; if ( $ migration instanceof BaseObject && $ migration -> canSetProperty ( 'compact' ) ) { $ migration -> compact = $ this -> compact ; } return $ migration ; }
4296	public function assert ( $ assertion , $ msg = null ) { array ( $ msg ) ; $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args ) ; $ assertion = \ array_shift ( $ args ) ; if ( ! $ assertion ) { if ( ! $ args ) { $ callerInfo = $ this -> utilities -> getCallerInfo ( ) ; $ args [ ] = 'Assertion failed in ' . $ callerInfo [ 'file' ] . ' on line ' . $ callerInfo [ 'line' ] ; } $ this -> appendLog ( 'assert' , $ args , $ meta ) ; } }
6415	public static function get ( IteratorAggregate $ iterable , int $ position ) { return Iterators :: get ( Iterators :: from ( $ iterable -> getIterator ( ) ) , $ position ) ; }
8008	public static function forStringAndEncodings ( $ string , $ from_encoding , $ to_encoding , $ code = self :: CODE_FOR_STRING_AND_ENCODING_INFO , Exception $ previous = null ) { $ message = self :: DEFAULT_MESSAGE . sprintf ( self :: MESSAGE_EXTENSION_FOR_STRING_FORMAT , $ string ) . sprintf ( self :: MESSAGE_EXTENSION_FOR_ENCODING_INFO_FORMAT , $ from_encoding , $ to_encoding ) ; return new static ( $ message , $ code , $ previous ) ; }
5828	public function newRequest ( $ method , $ url , $ data = array ( ) , $ encoding = Request :: ENCODING_QUERY ) { $ class = $ this -> requestClass ; $ request = new $ class ( $ this ) ; $ request -> setMethod ( $ method ) ; $ request -> setUrl ( $ url ) ; $ request -> setData ( $ data ) ; $ request -> setEncoding ( $ encoding ) ; return $ request ; }
11633	private function saveLog ( $ operIdWriteOff , $ calcId ) { $ log = new ELogOper ( ) ; $ log -> setCalcId ( $ calcId ) ; $ log -> setOperId ( $ operIdWriteOff ) ; $ this -> daoLogOper -> create ( $ log ) ; }
12398	public function select ( $ select = null ) { $ this -> scope -> select = Parser :: select ( $ select ) ; return $ this ; }
9815	public function setWorksheet ( Worksheet $ value = null ) { if ( $ value !== null ) { $ this -> worksheet = $ value ; } return $ this ; }
9522	public function upsertDoc ( string $ collectionName , string $ docId , array $ docOrSubset ) : void { $ doc = $ this -> getDoc ( $ collectionName , $ docId ) ; if ( $ doc ) { $ this -> updateDoc ( $ collectionName , $ docId , $ docOrSubset ) ; } else { $ this -> addDoc ( $ collectionName , $ docId , $ docOrSubset ) ; } }
12523	public function update ( array $ arguments = null , array $ options = null ) : void { if ( $ arguments ) { $ keys = array_keys ( $ this -> arguments ) ; for ( $ index = 0 ; $ index < count ( $ keys ) ; $ index ++ ) { $ this -> arguments [ $ keys [ $ index ] ] = $ arguments [ $ index ] ; } } if ( $ options ) { foreach ( $ options as $ option => $ value ) { $ this -> options [ $ option ] = $ value ; } } }
8821	public function filter ( $ data = null , $ filter = false ) { if ( is_null ( $ data ) ) { return null ; } if ( is_array ( $ data ) ) { return array_map ( function ( $ value ) use ( $ filter ) { return $ this -> filter ( $ value , $ filter ) ; } , $ data ) ; } return ( $ filter == true ? $ this -> xssClean ( $ data ) : trim ( $ data ) ) ; }
1527	protected function doReplaceRelationship ( StoreInterface $ store , UpdateRelationship $ request ) { $ record = $ request -> getRecord ( ) ; $ name = Str :: classify ( $ field = $ request -> getRelationshipName ( ) ) ; if ( $ result = $ this -> invokeMany ( [ 'replacing' , "replacing{$name}" ] , $ record , $ request ) ) { return $ result ; } $ record = $ store -> replaceRelationship ( $ record , $ field , $ request -> all ( ) , $ request -> getParameters ( ) ) ; return $ this -> invokeMany ( [ "replaced{$name}" , "replaced" ] , $ record , $ request ) ? : $ record ; }
3110	public function removeCatValue ( $ assessmentSectionId , $ key ) { if ( isset ( $ this -> state [ self :: VAR_CAT ] ) && isset ( $ this -> state [ self :: VAR_CAT ] [ $ assessmentSectionId ] ) && isset ( $ this -> state [ self :: VAR_CAT ] [ $ assessmentSectionId ] [ $ key ] ) ) { unset ( $ this -> state [ self :: VAR_CAT ] [ $ assessmentSectionId ] [ $ key ] ) ; } return $ this ; }
10222	public function authenticationForm ( $ title , $ target ) { $ formFactory = $ this -> app -> make ( 'Label305\AujaLaravel\Factory\AuthenticationFormFactory' ) ; return $ formFactory -> create ( $ title , $ target ) ; }
8120	public function canSubmitReview ( $ record ) { if ( ! $ record -> canEdit ( ) || ! $ record -> hasMethod ( 'canBeReviewedBy' ) || ! $ record -> canBeReviewedBy ( Security :: getCurrentUser ( ) ) ) { return false ; } return true ; }
12838	static public function dir ( $ directory , $ date = false ) { if ( $ date ) { $ directory = rtrim ( $ directory , DIRECTORY_SEPARATOR ) . DIRECTORY_SEPARATOR . self :: getDateDirectory ( ) ; } if ( ! is_dir ( $ directory ) ) { $ umask = umask ( 0000 ) ; if ( @ mkdir ( $ directory , 0777 , true ) === false ) { throw new Exception ( sprintf ( 'Directory "%s" cannot be created.' , $ directory ) ) ; } umask ( $ umask ) ; } return $ directory ; }
9156	final public function getControllerSettings ( ) { $ rf = new \ ReflectionClass ( $ this ) ; $ this -> response = new Response ( ) ; $ this -> controllerClass = $ rf -> getShortName ( ) ; $ this -> controllerName = ucfirst ( str_replace ( 'Controller' , '' , $ this -> controllerClass ) ) ; $ this -> response -> setTitle ( $ this -> controllerName ) ; $ actions = $ rf -> getMethods ( \ ReflectionMethod :: IS_PUBLIC ) ; foreach ( $ actions as $ action ) { $ this -> parseAnnotations ( $ action ) ; } return $ this ; }
11246	public function getMigrations ( int $ steps ) : array { $ sql = "select migration from {$this->table} where batch >= 1 order by batch, migration desc limit ?" ; $ stmt = $ this -> pdo -> prepare ( $ sql ) ; $ stmt -> bindParam ( 1 , $ steps , PDO :: PARAM_INT ) ; $ stmt -> execute ( ) ; return $ stmt -> fetchAll ( PDO :: FETCH_COLUMN ) ; }
6937	private function has ( array & $ list , $ oid , StockUnitInterface $ unit ) { if ( ! isset ( $ list [ $ oid ] ) ) { return false ; } return false !== $ this -> find ( $ list , $ oid , $ unit ) ; }
4512	public function kernelView ( GetResponseForControllerResultEvent $ event ) { $ request = $ event -> getRequest ( ) ; if ( ! $ request -> query -> has ( 'locale' ) ) { return ; } $ controllerResult = $ event -> getControllerResult ( ) ; $ locale = $ request -> query -> get ( 'locale' ) ; if ( $ controllerResult instanceof Paginator || is_array ( $ controllerResult ) ) { foreach ( $ controllerResult as $ model ) { if ( $ model instanceof Localizable ) { $ this -> localeService -> localize ( $ model , $ locale ) ; } } } elseif ( $ controllerResult instanceof Localizable ) { $ this -> localeService -> localize ( $ controllerResult , $ locale ) ; } $ event -> setControllerResult ( $ controllerResult ) ; }
7644	protected function parseMetadataElement ( $ element = null ) { if ( ! is_null ( $ element ) && isset ( $ element -> Metadata ) && ! is_null ( $ element -> Metadata ) ) { return get_object_vars ( $ element -> Metadata ) ; } return array ( ) ; }
10708	public function getMany ( $ columns = [ '*' ] , $ paginated = false , $ perPage = null ) { $ results = $ paginated ? $ this -> getManyPaginated ( $ perPage , $ columns ) : $ this -> getQuery ( ) -> get ( $ columns ) ; return $ this -> returnResults ( $ results ) ; }
12108	public function changePageFromRequest ( $ id , $ request ) { $ this -> getPage ( $ id ) ; $ page = $ this -> createPageObject ( null , null , $ request ) ; $ this -> pages [ $ id ] = $ page ; $ this -> persist ( ) ; return $ page ; }
6814	private function getCurrencyFormatter ( ) { if ( $ this -> currencyFormatter ) { return $ this -> currencyFormatter ; } return $ this -> currencyFormatter = NumberFormatter :: create ( $ this -> locale , NumberFormatter :: CURRENCY ) ; }
4560	public function translate ( Translatable $ model ) { $ properties = $ this -> getProperties ( $ model ) ; foreach ( $ properties as $ property ) { $ get = 'get' . $ property -> getName ( ) ; $ set = 'set' . $ property -> getName ( ) ; $ values = [ ] ; foreach ( $ model -> getTranslations ( ) as $ translation ) { $ values [ $ translation -> getLocale ( ) ] = $ translation -> $ get ( ) ; } $ model -> $ set ( $ values ) ; } }
4972	private function flattenTree ( $ tree , & $ data , $ curId = '1' ) { $ data [ ] = new \ ArrayObject ( [ 'id' => $ tree -> getId ( ) , 'current' => $ curId , 'name' => $ tree -> getName ( ) , 'value' => $ tree -> getValue ( ) , 'priority' => $ tree -> getPriority ( ) , 'do' => 'nothing' , ] ) ; if ( $ tree -> hasChildren ( ) ) { foreach ( $ tree -> getChildren ( ) as $ i => $ child ) { $ this -> flattenTree ( $ child , $ data , $ curId . '-' . ( $ i + 1 ) ) ; } } }
2626	protected function _construct ( ) { $ this -> addColumn ( 'backend_name' , [ 'label' => __ ( 'Name' ) ] ) ; $ this -> _addAfter = false ; $ this -> _template = 'Fastly_Cdn::system/config/form/field/acl.phtml' ; parent :: _construct ( ) ; }
5891	public static function permissionType ( $ type ) { if ( $ type == TeamSpeak3 :: PERM_TYPE_SERVERGROUP ) { return "Server Group" ; } if ( $ type == TeamSpeak3 :: PERM_TYPE_CLIENT ) { return "Client" ; } if ( $ type == TeamSpeak3 :: PERM_TYPE_CHANNEL ) { return "Channel" ; } if ( $ type == TeamSpeak3 :: PERM_TYPE_CHANNELGROUP ) { return "Channel Group" ; } if ( $ type == TeamSpeak3 :: PERM_TYPE_CHANNELCLIENT ) { return "Channel Client" ; } return "Unknown" ; }
1746	public function addEnclosure ( $ strFile , $ strUrl = null , $ strMedia = 'enclosure' ) { if ( $ strFile == '' || ! file_exists ( System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) . '/' . $ strFile ) ) { return ; } if ( $ strUrl === null ) { $ strUrl = Environment :: get ( 'base' ) ; } $ objFile = new File ( $ strFile ) ; $ this -> arrData [ 'enclosure' ] [ ] = array ( 'media' => $ strMedia , 'url' => $ strUrl . System :: urlEncode ( $ strFile ) , 'length' => $ objFile -> size , 'type' => $ objFile -> mime ) ; }
9934	public function setValue ( $ pValue ) { if ( is_array ( $ pValue ) ) { $ grouping = - 1 ; foreach ( $ pValue as $ key => $ value ) { if ( ! in_array ( $ key , self :: $ dateTimeGroups ) ) { unset ( $ pValue [ $ key ] ) ; } else { $ grouping = max ( $ grouping , array_search ( $ key , self :: $ dateTimeGroups ) ) ; } } if ( count ( $ pValue ) == 0 ) { throw new PhpSpreadsheetException ( 'Invalid rule value for column AutoFilter Rule.' ) ; } $ this -> setGrouping ( self :: $ dateTimeGroups [ $ grouping ] ) ; } $ this -> value = $ pValue ; return $ this ; }
8909	public function serialize_row ( $ row ) { foreach ( $ this -> callback_parameters as $ column ) { $ row [ $ column ] = serialize ( $ row [ $ column ] ) ; } return $ row ; }
7860	private function registerCommands ( ) { foreach ( $ this -> commands as $ command ) { $ name = ucfirst ( last ( explode ( '.' , $ command ) ) ) ; $ this -> app -> singleton ( $ command , function ( $ app ) use ( $ name ) { return $ app [ "Cerbero\Workflow\Console\Commands\\{$name}WorkflowCommand" ] ; } ) ; } }
3251	public function scopeFindByUser ( $ query , $ userId ) { if ( empty ( $ userId ) ) return ; $ cart = $ query -> whereUser ( $ userId ) -> first ( ) ; if ( empty ( $ cart ) ) { $ cart = call_user_func ( Config :: get ( 'shop.cart' ) . '::create' , [ 'user_id' => $ userId ] ) ; } return $ cart ; }
179	protected function loadBundle ( $ name , $ config = [ ] , $ publish = true ) { if ( ! isset ( $ config [ 'class' ] ) ) { $ config [ 'class' ] = $ name ; } $ bundle = Yii :: createObject ( $ config ) ; if ( $ publish ) { $ bundle -> publish ( $ this ) ; } return $ bundle ; }
11445	public function getTransporter ( ) { if ( empty ( $ this -> transporter ) ) { $ transport_class = $ this -> getDefault ( 'transporter' ) ; if ( class_exists ( $ transport_class ) ) { $ this -> setTransporter ( new $ transport_class ) ; } else { throw new \ Exception ( sprintf ( 'Default transport class "%s" not found!' , $ transport_class ) ) ; } } return $ this -> transporter ; }
11840	public static function size ( $ inputImg ) { if ( is_string ( $ inputImg ) ) $ img = self :: imgCreate ( $ inputImg ) ; else $ img = $ inputImg ; $ imgW = imagesx ( $ img ) ; $ imgH = imagesy ( $ img ) ; if ( is_string ( $ inputImg ) ) imagedestroy ( $ img ) ; return array ( $ imgW , $ imgH ) ; }
3805	public function generate ( ) { $ GLOBALS [ 'TL_CSS' ] [ ] = 'bundles/metamodelscore/css/style.css' ; $ arrModule = $ GLOBALS [ 'BE_MOD' ] [ 'metamodels' ] [ 'metamodels' ] ; if ( \ Input :: get ( 'key' ) && isset ( $ arrModule [ \ Input :: get ( 'key' ) ] ) ) { Callbacks :: call ( $ arrModule [ \ Input :: get ( 'key' ) ] , $ this , $ arrModule ) ; } $ act = \ Input :: get ( 'act' ) ; if ( ! strlen ( $ act ) ) { $ act = 'showAll' ; } return $ this -> dataContainer -> getEnvironment ( ) -> getController ( ) -> handle ( new Action ( $ act ) ) ; }
8107	protected function getTemplateVariables ( $ recipient , $ config , $ pages ) { return [ 'Subject' => $ config -> ReviewSubject , 'PagesCount' => $ pages -> count ( ) , 'FromEmail' => $ config -> ReviewFrom , 'ToFirstName' => $ recipient -> FirstName , 'ToSurname' => $ recipient -> Surname , 'ToEmail' => $ recipient -> Email , ] ; }
3490	public function withCustomData ( string $ name , $ value ) : Payload { if ( $ value && ! is_array ( $ value ) && ! is_scalar ( $ value ) && ! $ value instanceof \ JsonSerializable ) { throw new \ InvalidArgumentException ( sprintf ( 'The custom data value should be a scalar or \JsonSerializable instance, but "%s" given.' , is_object ( $ value ) ? get_class ( $ value ) : gettype ( $ value ) ) ) ; } $ cloned = clone $ this ; $ cloned -> customData [ $ name ] = $ value ; return $ cloned ; }
9192	public function init ( ) { if ( $ this -> isInitialized ( ) ) return true ; $ sm = $ this -> getServiceManager ( ) ; $ defaultListeners = $ sm -> get ( 'yimaTheme.Manager.ListenerAggregate' ) ; if ( $ defaultListeners instanceof self ) $ defaultListeners -> manager = $ this ; $ sharedEvents = $ this -> getEventManager ( ) -> getSharedManager ( ) ; $ sharedEvents -> attachAggregate ( $ defaultListeners ) ; $ this -> isInitialized = true ; return $ this ; }
4911	protected function injectComponents ( array $ pages , $ routeMatch = null , $ router = null , $ request = null ) { if ( $ routeMatch ) { $ routeName = $ routeMatch -> getMatchedRouteName ( ) ; foreach ( $ pages as & $ page ) { if ( isset ( $ page [ 'active_on' ] ) && in_array ( $ routeName , ( array ) $ page [ 'active_on' ] ) ) { $ page [ 'active' ] = true ; } } } return parent :: injectComponents ( $ pages , $ routeMatch , $ router , $ request ) ; }
6641	public function init ( ) { $ this -> query = $ this -> controller -> query ; if ( $ this -> query ) { $ modelClass = Yii :: createObject ( $ this -> query -> modelClass ) ; $ this -> modelClass = $ modelClass ; $ this -> tableName = $ modelClass :: tableName ( ) ; } parent :: init ( ) ; }
11549	public function onExecuteAction ( ExecuteActionEvent $ event ) { $ request = $ event -> getRequest ( ) ; $ authenticate = $ request -> getConfig ( ) -> getObject ( 'authenticate' ) ; if ( $ authenticate ) { $ this -> execute ( $ event , $ authenticate ) ; } }
5703	public function bindGridField ( Form $ form , GridFieldDetailForm_ItemRequest $ request ) { $ this -> setForm ( $ form ) ; $ this -> gridFieldRequest = $ request ; return $ this ; }
8096	public function destroy ( ) { if ( ! is_null ( $ this -> getValue ( ) ) ) { if ( ! headers_sent ( ) ) { return setcookie ( $ this -> name , '' , time ( ) - 3600 , $ this -> path , $ this -> host ) ; } else { return false ; } } else { return true ; } }
6947	private function getOutstandingExpiredDueQueryBuilder ( ) { $ qb = $ this -> createQueryBuilder ( 'o' ) ; $ ex = $ qb -> expr ( ) ; $ qb -> join ( 'o.paymentTerm' , 't' ) -> where ( $ ex -> andX ( $ ex -> eq ( 'o.sample' , ':not_sample' ) , $ ex -> lt ( 'o.paidTotal' , 'o.grandTotal' ) , $ ex -> notIn ( 'o.invoiceState' , ':canceled_or_refunded' ) , $ qb -> expr ( ) -> lte ( 'o.outstandingDate' , ':today' ) , $ this -> getDueClauses ( ) ) ) -> addOrderBy ( 'o.outstandingDate' , 'ASC' ) -> setParameter ( 'not_sample' , false ) -> setParameter ( 'today' , ( new \ DateTime ( ) ) -> setTime ( 23 , 59 , 59 ) , Type :: DATETIME ) -> setParameter ( 'canceled_or_refunded' , [ InvoiceStates :: STATE_CANCELED , InvoiceStates :: STATE_CREDITED ] ) ; $ this -> setDueParameters ( $ qb ) ; return $ qb ; }
1815	public function tableImportWizard ( ) { return ' <a href="' . $ this -> addToUrl ( 'key=table' ) . '" title="' . Contao \ StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tw_import' ] [ 1 ] ) . '" onclick="Backend.getScrollOffset()">' . Contao \ Image :: getHtml ( 'tablewizard.svg' , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tw_import' ] [ 0 ] ) . '</a> ' . Contao \ Image :: getHtml ( 'demagnify.svg' , '' , 'title="' . Contao \ StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tw_shrink' ] ) . '" style="cursor:pointer" onclick="Backend.tableWizardResize(0.9)"' ) . Contao \ Image :: getHtml ( 'magnify.svg' , '' , 'title="' . Contao \ StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tw_expand' ] ) . '" style="cursor:pointer" onclick="Backend.tableWizardResize(1.1)"' ) ; }
5662	private function mergeAttribute ( $ attributes , $ raw ) { $ parts = explode ( '=' , $ raw ) ; list ( $ name , $ value ) = count ( $ parts ) === 1 ? array ( $ parts [ 0 ] , $ parts [ 0 ] ) : $ parts ; $ attributes [ trim ( $ name ) ] = html_entity_decode ( $ this -> dequote ( trim ( $ value ) ) , ENT_QUOTES ) ; return $ attributes ; }
895	private function findComparisonEnd ( Tokens $ tokens , $ index ) { ++ $ index ; $ count = \ count ( $ tokens ) ; while ( $ index < $ count ) { $ token = $ tokens [ $ index ] ; if ( $ token -> isGivenKind ( [ T_WHITESPACE , T_COMMENT , T_DOC_COMMENT ] ) ) { ++ $ index ; continue ; } if ( $ this -> isOfLowerPrecedence ( $ token ) ) { break ; } $ block = Tokens :: detectBlockType ( $ token ) ; if ( null === $ block ) { ++ $ index ; continue ; } if ( ! $ block [ 'isStart' ] ) { break ; } $ index = $ tokens -> findBlockEnd ( $ block [ 'type' ] , $ index ) + 1 ; } $ prev = $ tokens -> getPrevMeaningfulToken ( $ index ) ; return $ tokens [ $ prev ] -> isGivenKind ( T_CLOSE_TAG ) ? $ tokens -> getPrevMeaningfulToken ( $ prev ) : $ prev ; }
7652	public function url_stat ( $ path , $ flags ) { $ stat = array ( ) ; $ stat [ 'dev' ] = 0 ; $ stat [ 'ino' ] = 0 ; $ stat [ 'mode' ] = 0 ; $ stat [ 'nlink' ] = 0 ; $ stat [ 'uid' ] = 0 ; $ stat [ 'gid' ] = 0 ; $ stat [ 'rdev' ] = 0 ; $ stat [ 'size' ] = 0 ; $ stat [ 'atime' ] = 0 ; $ stat [ 'mtime' ] = 0 ; $ stat [ 'ctime' ] = 0 ; $ stat [ 'blksize' ] = 0 ; $ stat [ 'blocks' ] = 0 ; $ info = null ; try { $ info = $ this -> getStorageClient ( $ path ) -> getBlobInstance ( $ this -> getContainerName ( $ path ) , $ this -> getFileName ( $ path ) ) ; $ stat [ 'size' ] = $ info -> Size ; $ lastmodified = strtotime ( $ info -> LastModified ) ; $ stat [ 'mtime' ] = $ lastmodified ; $ stat [ 'ctime' ] = $ lastmodified ; $ stat [ 'mode' ] = 0100000 ; return array_values ( $ stat ) + $ stat ; } catch ( BlobException $ ex ) { return false ; } }
1015	public function setValidationRules ( $ validationRules ) { if ( ! is_callable ( $ validationRules ) && ! is_array ( $ validationRules ) && $ validationRules !== null ) { throw new InvariantViolation ( 'Server config expects array of validation rules or callable returning such array, but got ' . Utils :: printSafe ( $ validationRules ) ) ; } $ this -> validationRules = $ validationRules ; return $ this ; }
379	public function renderCallStackItem ( $ file , $ line , $ class , $ method , $ args , $ index ) { $ lines = [ ] ; $ begin = $ end = 0 ; if ( $ file !== null && $ line !== null ) { $ line -- ; $ lines = @ file ( $ file ) ; if ( $ line < 0 || $ lines === false || ( $ lineCount = count ( $ lines ) ) < $ line ) { return '' ; } $ half = ( int ) ( ( $ index === 1 ? $ this -> maxSourceLines : $ this -> maxTraceSourceLines ) / 2 ) ; $ begin = $ line - $ half > 0 ? $ line - $ half : 0 ; $ end = $ line + $ half < $ lineCount ? $ line + $ half : $ lineCount - 1 ; } return $ this -> renderFile ( $ this -> callStackItemView , [ 'file' => $ file , 'line' => $ line , 'class' => $ class , 'method' => $ method , 'index' => $ index , 'lines' => $ lines , 'begin' => $ begin , 'end' => $ end , 'args' => $ args , ] ) ; }
9149	public function markAsUnread ( $ uid ) { if ( ! $ object = $ this -> model -> find ( $ uid ) ) { abort ( 404 ) ; } $ this -> authorize ( 'update' , $ object ) ; if ( ! is_null ( $ object -> read_at ) ) { $ object -> forceFill ( [ 'read_at' => null ] ) -> save ( ) ; } \ Cache :: tags ( 'response' ) -> flush ( ) ; return $ this -> successJsonResponse ( ) ; }
12036	public function addTranslateResponseToExceptionMethod ( ) { $ body = 'return $this->api->translateResponseToException($response);' ; $ docBlock = new DocBlockGenerator ( 'Determine whether the response is an error. Override this method to have a per-operation decision, otherwise the function from the API class will be used.' , null ) ; $ methodGenerator = $ this -> createMethodGenerator ( 'translateResponseToException' , $ body , $ docBlock , [ [ 'response' , 'Amp\Artax\Response' ] ] , [ 'null' , '\ArtaxServiceBuilder\BadResponseException' ] ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
6883	static public function getTypes ( ) { return [ static :: MANUAL , static :: CART_REMIND , static :: ORDER_ACCEPTED , static :: QUOTE_REMIND , static :: PAYMENT_CAPTURED , static :: PAYMENT_EXPIRED , static :: SHIPMENT_SHIPPED , static :: SHIPMENT_PARTIAL , static :: RETURN_PENDING , static :: RETURN_RECEIVED , ] ; }
8426	public function getAllInactiveQuery ( Production $ production ) : Query { $ qb = $ this -> createQueryBuilder ( 'p' ) ; return $ qb -> join ( 'p.groups' , 'g' ) -> andWhere ( $ qb -> expr ( ) -> eq ( 'g' , ':group' ) ) -> andWhere ( $ qb -> expr ( ) -> isNull ( 'p.parent' ) ) -> andWhere ( $ qb -> expr ( ) -> orX ( $ qb -> expr ( ) -> eq ( 'p.active' , ':active' ) , $ qb -> expr ( ) -> lt ( 'p.expiry' , ':now' ) ) ) -> setParameter ( 'group' , $ production ) -> setParameter ( 'active' , false ) -> setParameter ( 'now' , new \ DateTime ( ) ) -> addOrderBy ( 'p.updated' , 'DESC' ) -> getQuery ( ) ; }
1878	public function deleteAll ( ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notDeletable' ] ) { throw new InternalServerErrorException ( 'Table "' . $ this -> strTable . '" is not deletable.' ) ; } $ objSession = System :: getContainer ( ) -> get ( 'session' ) ; $ session = $ objSession -> all ( ) ; $ ids = $ session [ 'CURRENT' ] [ 'IDS' ] ; if ( ! empty ( $ ids ) && \ is_array ( $ ids ) ) { $ ids = $ this -> eliminateNestedPaths ( $ ids ) ; foreach ( $ ids as $ id ) { $ this -> delete ( $ id ) ; } } $ this -> redirect ( $ this -> getReferer ( ) ) ; }
1839	protected static function find ( array $ arrOptions ) { if ( static :: $ strTable == '' ) { return null ; } if ( $ arrOptions [ 'return' ] == 'Model' ) { $ arrColumn = ( array ) $ arrOptions [ 'column' ] ; if ( \ count ( $ arrColumn ) == 1 ) { $ arrColumn [ 0 ] = preg_replace ( '/^' . preg_quote ( static :: getTable ( ) , '/' ) . '\./' , '' , $ arrColumn [ 0 ] ) ; if ( $ arrColumn [ 0 ] == static :: $ strPk || \ in_array ( $ arrColumn [ 0 ] , static :: getUniqueFields ( ) ) ) { $ varKey = \ is_array ( $ arrOptions [ 'value' ] ) ? $ arrOptions [ 'value' ] [ 0 ] : $ arrOptions [ 'value' ] ; $ objModel = Registry :: getInstance ( ) -> fetch ( static :: $ strTable , $ varKey , $ arrColumn [ 0 ] ) ; if ( $ objModel !== null ) { return $ objModel ; } } } } $ arrOptions [ 'table' ] = static :: $ strTable ; $ strQuery = static :: buildFindQuery ( $ arrOptions ) ; $ objStatement = Database :: getInstance ( ) -> prepare ( $ strQuery ) ; if ( ! isset ( $ arrOptions [ 'limit' ] ) ) { $ arrOptions [ 'limit' ] = 0 ; } if ( ! isset ( $ arrOptions [ 'offset' ] ) ) { $ arrOptions [ 'offset' ] = 0 ; } if ( $ arrOptions [ 'limit' ] > 0 || $ arrOptions [ 'offset' ] > 0 ) { $ objStatement -> limit ( $ arrOptions [ 'limit' ] , $ arrOptions [ 'offset' ] ) ; } $ objStatement = static :: preFind ( $ objStatement ) ; $ objResult = $ objStatement -> execute ( $ arrOptions [ 'value' ] ) ; if ( $ objResult -> numRows < 1 ) { return $ arrOptions [ 'return' ] == 'Array' ? array ( ) : null ; } $ objResult = static :: postFind ( $ objResult ) ; if ( $ arrOptions [ 'return' ] == 'Model' ) { $ objModel = Registry :: getInstance ( ) -> fetch ( static :: $ strTable , $ objResult -> { static :: $ strPk } ) ; if ( $ objModel !== null ) { return $ objModel -> mergeRow ( $ objResult -> row ( ) ) ; } return static :: createModelFromDbResult ( $ objResult ) ; } elseif ( $ arrOptions [ 'return' ] == 'Array' ) { return static :: createCollectionFromDbResult ( $ objResult , static :: $ strTable ) -> getModels ( ) ; } else { return static :: createCollectionFromDbResult ( $ objResult , static :: $ strTable ) ; } }
12561	public function send ( $ msgType , $ message , $ to = null ) { $ message = ( new MessageBuilder ( ) ) -> msgType ( $ msgType ) -> message ( $ message ) -> to ( $ to ) -> build ( ) ; $ api = is_array ( $ to ) ? self :: API_SEND_BY_OPENID : self :: API_SEND_BY_GROUP ; return $ this -> post ( $ api , $ message ) ; }
4873	public function init ( ) { $ this -> setName ( 'buttons' ) ; if ( ! isset ( $ this -> options [ 'render_summary' ] ) ) { $ this -> options [ 'render_summary' ] = false ; } $ this -> setAttribute ( 'class' , 'text-right' ) ; $ this -> add ( array ( 'type' => 'Core/Spinner-Submit' , 'name' => 'submit' , 'options' => array ( 'label' => 'Save' , ) , 'attributes' => array ( 'id' => 'submit' , 'type' => 'submit' , 'value' => 'Save' , 'class' => 'sf-submit btn btn-primary btn-xs' ) , ) ) ; $ this -> add ( array ( 'type' => 'Button' , 'name' => 'cancel' , 'options' => array ( 'label' => 'Cancel' , ) , 'attributes' => array ( 'id' => 'cancel' , 'type' => 'reset' , 'value' => 'Cancel' , 'class' => 'sf-cancel btn btn-default btn-xs' ) , ) ) ; }
4328	public static function parseAttribString ( $ str , $ dataDecode = true ) { $ attribs = array ( ) ; $ regexAttribs = '/\b([\w\-]+)\b(?: \s*=\s*(["\'])(.*?)\\2 | \s*=\s*(\S+) )?/xs' ; \ preg_match_all ( $ regexAttribs , $ str , $ matches ) ; $ keys = \ array_map ( 'strtolower' , $ matches [ 1 ] ) ; $ values = \ array_replace ( $ matches [ 3 ] , \ array_filter ( $ matches [ 4 ] , 'strlen' ) ) ; foreach ( $ keys as $ i => $ k ) { $ attribs [ $ k ] = $ values [ $ i ] ; if ( \ in_array ( $ k , self :: $ htmlBoolAttr ) ) { $ attribs [ $ k ] = true ; } } \ ksort ( $ attribs ) ; foreach ( $ attribs as $ k => $ v ) { if ( \ is_string ( $ v ) ) { $ attribs [ $ k ] = \ htmlspecialchars_decode ( $ v ) ; } $ isDataAttrib = \ strpos ( $ k , 'data-' ) === 0 ; if ( $ isDataAttrib && $ dataDecode ) { $ val = $ attribs [ $ k ] ; $ attribs [ $ k ] = \ json_decode ( $ attribs [ $ k ] , true ) ; if ( $ attribs [ $ k ] === null && $ val !== 'null' ) { $ attribs [ $ k ] = \ json_decode ( '"' . $ val . '"' , true ) ; } } } return $ attribs ; }
9663	public static function registerWriter ( $ writerType , $ writerClass ) { if ( ! is_a ( $ writerClass , Writer \ IWriter :: class , true ) ) { throw new Writer \ Exception ( 'Registered writers must implement ' . Writer \ IWriter :: class ) ; } self :: $ writers [ $ writerType ] = $ writerClass ; }
1432	public function allow ( string ... $ params ) : self { $ this -> all = false ; foreach ( $ params as $ param ) { $ this -> allowed -> put ( $ param , $ param ) ; } return $ this ; }
10748	protected function sendCreated ( Response $ response , string $ type , array $ ids , array $ extra = [ ] ) : Response { return $ this -> sendVerb ( 'created' , $ response , $ type , $ ids , $ extra ) -> withStatus ( 201 , "Created" ) ; }
8204	protected function reserveJob ( $ tube ) { try { return $ this -> getPheanstalk ( ) -> reserveFromTube ( $ tube , 0 ) ; } catch ( ServerException $ e ) { if ( $ this -> isNotFoundException ( $ e ) ) { return ; } throw $ e ; } }
11872	protected function _setDataKey ( $ key ) { if ( ! is_null ( $ key ) && ! is_string ( $ key ) && ! ( $ key instanceof Stringable ) ) { throw $ this -> _createInvalidArgumentException ( $ this -> __ ( 'Data key must be a string or stringable' ) , 0 , null , $ key ) ; } $ this -> dataKey = $ key ; return $ this ; }
2600	public function peek ( ) { if ( isset ( $ this -> tokens [ $ this -> position + $ this -> peek ] ) ) { return $ this -> tokens [ $ this -> position + $ this -> peek ++ ] ; } else { return null ; } }
4890	public function renderPage ( PageInterface $ page , $ vars = array ( ) ) { return $ this -> render ( $ this -> getPageManager ( ) -> getTemplate ( $ page ) , $ vars + array ( 'page' => $ page , 'id' => $ page -> getId ( ) , ) ) ; }
