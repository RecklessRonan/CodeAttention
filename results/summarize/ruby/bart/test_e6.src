881	def dump_scraped_objects ( task_name ) counts = Hash . new ( 0 ) @store . pipelined do send ( task_name ) . each do | object | counts [ object . _type ] += 1 dump_scraped_object ( object ) end end counts end
661	def process_request ( data , client ) validated = @validated . include? ( client ) parser = @validating [ client . object_id ] if validated parser . process data else result = parser . signal ( data ) case result when :validated @validated . each do | old | old . write "\x02update\x03" end @validated << client if @validated . length > 1 client . write "\x02wait\x03" else client . write "\x02ready\x03" end @logger . verbose { "Client <0x#{client.object_id.to_s(16)}> connection was validated" } when :close_connection client . close @logger . warn "Client <0x#{client.object_id.to_s(16)}> connection was closed due to bad credentials" end end end
147	def write io_path_or_writer if io_path_or_writer . is_a? Writer io_path_or_writer . write self else writer ( io_path_or_writer ) . write ( self ) end end
806	def write_data ( bytes ) bytes = bytes . pack ( 'c*' ) if bytes . respond_to? ( :pack ) size = bytes . respond_to? ( :bytesize ) ? bytes . bytesize : bytes . size mem_buf = FFI :: MemoryPointer . new ( :char , size ) mem_buf . put_bytes ( 0 , bytes ) bytes_written = Ftdi . ftdi_write_data ( ctx , mem_buf , size ) check_result ( bytes_written ) bytes_written end
1376	def get_height ( img ) new_height = ( img . height / ( img . width . to_f / self . width . to_f ) ) . ceil end
51	def remove_blank_values ( hash ) hash . delete_if { | _ , value | value . respond_to? ( :empty? ) ? value . empty? : ! value } end
345	def send_data ( data , options = { } ) response . write data if data filename = options [ :filename ] content_disposition = options [ :inline ] ? 'inline' . dup : 'attachment' . dup content_disposition << "; filename=#{::File.basename(options[:filename])}" if filename cont_type = ( options [ :mime ] ||= filename && Rack :: Mime . mime_type ( :: File . extname ( filename ) ) ) response [ 'content-type' . freeze ] = cont_type if cont_type response [ 'content-disposition' . freeze ] = content_disposition true end
1153	def can_hold_child? ( storable ) Specimen === storable and storable . specimen_class == specimen_class and specimen_types . include? ( storable . specimen_type ) end
1004	def declare_queue ( channel , exchange , name , key , options = { } ) channel . queue ( name , options ) do | queue | unless default_exchange? ( exchange . name ) queue . bind ( exchange , { :routing_key => key } ) end log . debug ( "Queue #{queue.name.inspect} bound to #{exchange.name.inspect}" ) end end
43	def version_has_service ( version , service ) return service_config . include? ( version ) && service_config [ version ] . include? ( service ) end
195	def sync_folder_items ( opts ) opts = opts . clone req = build_soap! do | type , builder | if ( type == :header ) else builder . nbuild . SyncFolderItems { builder . nbuild . parent . default_namespace = @default_ns builder . item_shape! ( opts [ :item_shape ] ) builder . sync_folder_id! ( opts [ :sync_folder_id ] ) if opts [ :sync_folder_id ] builder . sync_state! ( opts [ :sync_state ] ) if opts [ :sync_state ] builder . ignore! ( opts [ :ignore ] ) if opts [ :ignore ] builder . max_changes_returned! ( opts [ :max_changes_returned ] ) builder . sync_scope! ( opts [ :sync_scope ] ) if opts [ :sync_scope ] } end end do_soap_request ( req , response_class : EwsResponse ) end
478	def ft_del_all @model . all . each { | record | ft_del ( record : record ) } ft_optimize rescue Exception => e Rails . logger . error e if defined? Rails return e . message end
1107	def make_controlled_value ( value_hash ) cv = ControlledValue . new ( value_hash [ :value ] , value_hash [ :parent ] ) cv . identifier = value_hash [ :identifier ] cv . public_id = value_hash [ :public_id ] cv end
1053	def process ( object , options = { } ) return nil if object . nil? or object . empty? object = object . encode ( 'UTF-8' , 'binary' , invalid : :replace , undef : :replace , replace : '' ) object += " " if object =~ / / return object if filter . empty? and pivot . empty? filtered = object . split ( ';' ) . values_at ( * filter . flatten . uniq ) pivot_each_column ( object . split ( ';' ) ) do | column , match | filtered << column if match end if ! filtered . last . nil? and filtered . last . empty? filtered . compact . join ( ';' ) + " " else filtered . compact . join ( ';' ) end end
360	def active_admin_settings_page ( options = { } , & block ) options . assert_valid_keys ( * ActiveadminSettingsCached :: Options :: VALID_OPTIONS ) options = ActiveadminSettingsCached :: Options . options_for ( options ) coercion = ActiveadminSettingsCached :: Coercions . new ( options [ :template_object ] . defaults , options [ :template_object ] . display ) content title : options [ :title ] do render partial : options [ :template ] , locals : { settings_model : options [ :template_object ] } end page_action :update , method : :post do settings_params = params . require ( :settings ) . permit! coercion . cast_params ( settings_params ) do | name , value | options [ :template_object ] . save ( name , value ) end flash [ :success ] = t ( 'activeadmin_settings_cached.settings.update.success' . freeze ) Rails . version . to_i >= 5 ? redirect_back ( fallback_location : admin_root_path ) : redirect_to ( :back ) options [ :after_save ] . call if options [ :after_save ] . respond_to? ( :call ) end instance_eval ( & block ) if block_given? end
634	def colour ( fore , back ) style = CharacterStyle . new style . foreground = fore style . background = back root . colours << fore root . colours << back if block_given? apply ( style ) { | node | yield node } else apply ( style ) end end
506	def scheduled response = get 'scheduled' response . map { | item | Hashie :: Mash . new ( item ) } end
1072	def enter if client . room != self client . room . leave if client . room client . connect ( url ) begin client . room = self data = api ( 'room.register' , :section => nil ) self . attributes = { 'section' => data [ 'section' ] } rescue Exception client . room = nil raise end end true end
622	def paragraph ( style = nil ) node = ParagraphNode . new ( self , style ) yield node if block_given? self . store ( node ) end
362	def write_func_declaration type : , c_name : , args : [ ] , static : true write_func_prototype type , c_name , args , static : static @code << ";" new_line end
1309	def connection @options [ :path ] = API_REST + @options [ :path ] @options [ :headers ] = HEADERS . merge ( { 'X-Megam-Date' => Time . now . strftime ( "%Y-%m-%d %H:%M" ) } ) . merge ( @options [ :headers ] ) text . info ( "HTTP Request Data:" ) text . msg ( "> HTTP #{@options[:scheme]}://#{@options[:host]}" ) @options . each do | key , value | text . msg ( "> #{key}: #{value}" ) end text . info ( "End HTTP Request Data." ) http = Net :: HTTP . new ( @options [ :host ] , @options [ :port ] ) http end
27	def validate_hash_arg ( arg , parent , key , arg_type ) arg_type = handle_xsi_type ( arg , parent , key , arg_type ) validate_arguments ( arg , arg_type [ :fields ] , arg_type [ :ns ] ) end
1335	def write_hash ( name , val ) raise "RedisAssist: tried to store a #{val.class.name} as Hash" unless val . is_a? ( Hash ) hashes [ name ] = val end
321	def bot_config { :consumer_key => ENV [ "chatterbot_consumer_key" ] , :consumer_secret => ENV [ "chatterbot_consumer_secret" ] , :access_token => ENV [ "chatterbot_access_token" ] , :access_token_secret => ENV [ "chatterbot_access_secret" ] || ENV [ "chatterbot_access_token_secret" ] } . delete_if { | k , v | v . nil? } . merge ( slurp_file ( config_file ) || { } ) end
168	def vanity_simple_format ( text , options = { } ) open = "<p #{options.map { |k,v| "#{k}=\"#{CGI.escapeHTML v}\"" }.join(" ")}>" text = open + text . gsub ( / \r \n / , "\n" ) . gsub ( / \n \n / , "</p>\n\n#{open}" ) . gsub ( / \n \n \n / , '\1<br />' ) + "</p>" end
58	def method_missing ( name , * args , & block ) restricted_functions = [ :dst? , :getgm , :getlocal , :getutc , :gmt , :gmtime , :gmtoff , :isdst , :localtime , :utc ] if restricted_functions . include? name raise NoMethodError , 'undefined method %s for %s' % [ name , self ] end result = @time . send ( name , * args , & block ) if result . is_a? Time return self . class . new ( @api , result , @timezone . identifier ) else return result end end
1132	def load data = api ( 'user.get_prefs' ) self . attributes = data [ 'result' ] . inject ( { } ) do | result , ( preference , value , * ) | result [ preference ] = value result end super end
697	def upload_file ( uploadURL , uploadFile , progressUrl , config = { } ) raise :: IOError , "#{uploadFile} not found." unless File . exists? ( uploadFile ) chunkSize = ( config [ :chunksize ] || 10485760 ) progressBarFormat = ( config [ :progressbar_format ] || "%e <%B> %p%% %t" ) progressBarLength = ( config [ :progressbar_length ] || 120 ) uploadFileHandle = File . new ( uploadFile , "rb" ) fileName = File . basename ( uploadFileHandle ) progressBarTitle = "Uploading: " + uploadFile . to_s if config [ :progressbar_enable ] == true && uploadFileHandle . size . to_i > chunkSize progressbar = ProgressBar . create ( :title => progressBarTitle , :starting_at => 0 , :total => uploadFileHandle . size . to_i , :length => progressBarLength , :format => progressBarFormat ) else @logger . info progressBarTitle end clnt = HTTPClient . new clnt . ssl_config . verify_mode = ( OpenSSL :: SSL :: VERIFY_NONE ) clnt . ssl_config . verify_callback = proc { | ok , ctx | ; true } ; until uploadFileHandle . eof? rangeStart = uploadFileHandle . pos rangeStop = uploadFileHandle . pos . to_i + chunkSize fileContent = uploadFileHandle . read ( chunkSize ) if rangeStop . to_i > uploadFileHandle . size . to_i contentRange = "bytes #{rangeStart.to_s}-#{uploadFileHandle.size.to_s}/#{uploadFileHandle.size.to_s}" rangeLen = uploadFileHandle . size . to_i - rangeStart . to_i else contentRange = "bytes #{rangeStart.to_s}-#{rangeStop.to_s}/#{uploadFileHandle.size.to_s}" rangeLen = rangeStop . to_i - rangeStart . to_i end extheader = { 'x-vcloud-authorization' => @auth_key , 'Content-Range' => contentRange , 'Content-Length' => rangeLen . to_s } begin uploadRequest = "#{@host_url}#{uploadURL}" connection = clnt . request ( 'PUT' , uploadRequest , nil , fileContent , extheader ) if config [ :progressbar_enable ] == true && uploadFileHandle . size . to_i > chunkSize params = { 'method' => :get , 'command' => progressUrl } response , headers = send_request ( params ) response . css ( "Files File [name='#{fileName}']" ) . each do | file | progressbar . progress = file [ :bytesTransferred ] . to_i end end rescue retryTime = ( config [ :retry_time ] || 5 ) @logger . warn "Range #{contentRange} failed to upload, retrying the chunk in #{retryTime.to_s} seconds, to stop the action press CTRL+C." sleep retryTime . to_i retry end end uploadFileHandle . close end
602	def all_write! will_change! permissions . keys . each do | perm | permissions [ perm ] . write! true end end
379	def load_captcha ( options ) if options [ :raw64 ] options [ :raw64 ] elsif options [ :raw ] Base64 . encode64 ( options [ :raw ] ) elsif options [ :file ] Base64 . encode64 ( options [ :file ] . read ) elsif options [ :path ] Base64 . encode64 ( File . open ( options [ :path ] , 'rb' ) . read ) elsif options [ :url ] Base64 . encode64 ( TwoCaptcha :: HTTP . open_url ( options [ :url ] ) ) else fail TwoCaptcha :: ArgumentError , 'Illegal image format' end rescue raise TwoCaptcha :: InvalidCaptcha end
1079	def add_child_type ( type ) case type when CaTissue :: StorageType then add_storage_type ( type ) when CaTissue :: SpecimenArrayType then add_specimen_array_type ( type ) when String then add_specimen_class ( type ) else raise ArgumentError . new ( "Storage type child not supported - #{type}" ) end self end
1097	def render_opml ( list ) document = Nokogiri :: XML ( list . load_list ) feeds . each do | feed_url | node = "<outline xmlUrl='#{feed_url}' />\n" document . xpath ( "//outline[@text='Subscriptions']" ) . last . add_child node end formatted_no_decl = Nokogiri :: XML :: Node :: SaveOptions :: FORMAT + Nokogiri :: XML :: Node :: SaveOptions :: NO_DECLARATION document . to_xml ( encoding : 'utf-8' , save_with : formatted_no_decl ) end
390	def redis_mock ( replies = { } ) begin pid = fork do trap ( "TERM" ) { exit } RedisMock . start do | command , * args | ( replies [ command . to_sym ] || lambda { | * _ | "+OK" } ) . call ( * args ) end end sleep 1 yield ensure if pid Process . kill ( "TERM" , pid ) Process . wait ( pid ) end end end
642	def right_border_width = ( width ) size = width . nil? ? 0 : width if size > 0 @borders [ RIGHT ] = size . to_i else @borders [ RIGHT ] = nil end end
613	def add ( font ) if font . instance_of? ( Font ) @fonts . push ( font ) if @fonts . index ( font ) . nil? end self end
1299	def find_excluded ( excluded ) result = [ ] Array ( excluded ) . each do | exclude | if exclude . include? ( ':' ) find_labeled ( exclude ) . each { | x | result << x } next end res = Client . get_server ( exclude ) result << res [ 'id' ] if res end result end
210	def get_time_zones ( full = false , ids = nil ) req = build_soap! do | type , builder | unless type == :header builder . get_server_time_zones! ( full : full , ids : ids ) end end result = do_soap_request req , response_class : EwsSoapResponse if result . success? zones = [ ] result . response_messages . each do | message | elements = message [ :get_server_time_zones_response_message ] [ :elems ] [ :time_zone_definitions ] [ :elems ] elements . each do | definition | data = { id : definition [ :time_zone_definition ] [ :attribs ] [ :id ] , name : definition [ :time_zone_definition ] [ :attribs ] [ :name ] } zones << OpenStruct . new ( data ) end end zones else raise EwsError , "Could not get time zones" end end
1119	def fan_of data = api ( 'user.get_fan_of' ) data [ 'fanof' ] . map { | id | User . new ( client , :_id => id ) } end
693	def login params = { 'method' => :post , 'command' => '/sessions' } response , headers = send_request ( params ) if ! headers . has_key? ( :x_vcloud_authorization ) raise "Unable to authenticate: missing x_vcloud_authorization header" end extensibility_link = response . css ( "Link[rel='down:extensibility']" ) @extensibility = extensibility_link . first [ 'href' ] unless extensibility_link . empty? @auth_key = headers [ :x_vcloud_authorization ] end
315	def direct_messages ( opts = { } , & block ) return unless require_login debug "check for DMs since #{since_id_dm}" @current_tweet = nil client . direct_messages_received ( since_id : since_id_dm , count : 200 ) . each { | s | update_since_id_dm ( s ) debug s . text if has_safelist? && ! on_safelist? ( s . sender ) debug "skipping because user not on safelist" elsif block_given? && ! on_blocklist? ( s . sender ) && ! skip_me? ( s ) @current_tweet = s yield s end } @current_tweet = nil rescue Twitter :: Error :: Forbidden => e puts "sorry, looks like we're not allowed to check DMs for this account" end
216	def resolve_names ( opts ) opts = opts . clone fcd = opts . has_key? ( :full_contact_data ) ? opts [ :full_contact_data ] : true req = build_soap! do | type , builder | if ( type == :header ) else builder . nbuild . ResolveNames { | x | x . parent [ 'ReturnFullContactData' ] = fcd . to_s x . parent [ 'SearchScope' ] = opts [ :search_scope ] if opts [ :search_scope ] x . parent . default_namespace = @default_ns x . UnresolvedEntry ( opts [ :name ] ) } end end do_soap_request ( req ) end
70	def should_log_payloads ( level , is_fault ) return level <= Logger :: INFO if is_fault return level <= Logger :: DEBUG end
540	def user_tips ( user_id , options = { } ) response = connection . get do | req | req . url "users/#{user_id}/tips" , options end tips = return_error_or_body ( response , response . body . response . tips ) tips = Foursquare2 . filter ( tips , options [ :query ] ) if options . has_key? :query tips end
966	def validate_format ( field , value , setting ) result = value . nil? || setting . match ( value ) . nil? add_message ( field , "#{field.to_s} does not appear to be in the proper format." ) if result return ! result end
1092	def role_id = ( value ) value_i = value . to_i @role_id = value_i . zero? ? nil : value_i value_s = @role_id . to_s if @role_id setRoleId ( value_s ) end
1307	def PARSE ( parser ) if ! :: Integer . equal? ( parser ) and ! parser . respond_to? ( :parse ) raise TypeError , 'wrong object for parser' end -> v { if :: Integer . equal? parser :: Kernel . Integer v else parser . parse ( case v when String v when -> _ { v . respond_to? :to_str } v . to_str when -> _ { v . respond_to? :read } v . read else raise TypeError , 'wrong object for parsing source' end ) end } end
656	def add ( colour ) if colour . instance_of? ( Colour ) @colours . push ( colour ) if @colours . index ( colour ) . nil? end self end
600	def delete ( id ) id = id . id if id . is_a? ( Parse :: Pointer ) if id . present? && permissions . has_key? ( id ) will_change! permissions . delete ( id ) end end
722	def tableize ( rows , & block ) rows = rows . map ( & block ) if block widths = max_length_of_each_column ( rows ) rows . map do | row | row . zip ( widths ) . map { | value , width | value . ljust ( width ) } . join ( " " ) end end
923	def generate_migration ( tables ) return if tables . empty? && @db_tables . empty? result . clear add_line "Sequel.migration do" indent do generate_migration_body ( tables ) end add_line "end\n" result . join ( "\n" ) end
94	def normalize_output_field ( field_data , field_def ) return case field_data when Array normalize_array_field ( field_data , field_def ) when Hash normalize_hash_field ( field_data , field_def ) else normalize_item ( field_data , field_def ) end end
21	def check_extra_fields ( args_hash , known_fields ) extra_fields = args_hash . keys - known_fields - IGNORED_HASH_KEYS unless extra_fields . empty? raise AdsCommon :: Errors :: UnexpectedParametersError . new ( extra_fields ) end end
843	def load! ( args = { } ) @config_file = args [ :config_file ] if args [ :config_file ] @environment = args [ :environment ] if args [ :environment ] new_data = { } begin new_data = JSON . parse ( File . read ( @config_file ) , symbolize_names : true ) rescue => e EventHub . logger . warn ( "Exception while loading configuration file: #{e}" ) EventHub . logger . info ( 'Using default configuration values' ) end deep_merge! ( @config_data , default_configuration ) new_data = new_data [ @environment . to_sym ] deep_merge! ( @config_data , new_data ) end
286	def get ( options = { } , & block ) response = http . get_uri ( options , & block ) handle_response ( response ) end
639	def to_rtf text = StringIO . new temp = StringIO . new offset = 0 text << "\\trowd\\tgraph#{parent.cell_margin}" self . each do | entry | widths = entry . border_widths colour = entry . shading_colour text << "\n" text << "\\clbrdrt\\brdrw#{widths[0]}\\brdrs" if widths [ 0 ] != 0 text << "\\clbrdrl\\brdrw#{widths[3]}\\brdrs" if widths [ 3 ] != 0 text << "\\clbrdrb\\brdrw#{widths[2]}\\brdrs" if widths [ 2 ] != 0 text << "\\clbrdrr\\brdrw#{widths[1]}\\brdrs" if widths [ 1 ] != 0 text << "\\clcbpat#{root.colours.index(colour)}" if colour != nil text << "\\cellx#{entry.width + offset}" temp << "\n#{entry.to_rtf}" offset += entry . width end text << "#{temp.string}\n\\row" text . string end
368	def fit ( xs , ys , tran_x : -> ( x ) { x } , tran_y : -> ( y ) { y } ) eps = ( 10 ** - 10 ) n = 0 sum_x = 0.0 sum_x2 = 0.0 sum_y = 0.0 sum_y2 = 0.0 sum_xy = 0.0 xs . zip ( ys ) . each do | x , y | n += 1 sum_x += tran_x . ( x ) sum_y += tran_y . ( y ) sum_x2 += tran_x . ( x ) ** 2 sum_y2 += tran_y . ( y ) ** 2 sum_xy += tran_x . ( x ) * tran_y . ( y ) end txy = n * sum_xy - sum_x * sum_y tx = n * sum_x2 - sum_x ** 2 ty = n * sum_y2 - sum_y ** 2 is_linear = tran_x . ( Math :: E ) * tran_y . ( Math :: E ) == Math :: E ** 2 if tx . abs < eps raise ArgumentError , "No variation in data #{xs}" elsif ty . abs < eps && is_linear slope = 0 intercept = sum_y / n residual_sq = 1 else slope = txy / tx intercept = ( sum_y - slope * sum_x ) / n residual_sq = ( txy ** 2 ) / ( tx * ty ) end [ slope , intercept , residual_sq ] end
251	def call ( file = nil , destination : nil , ** call_options ) options = { } options = options . merge ( source : file ) if file options = options . merge ( destination : destination ) if destination branch ( options ) . call! ( ** call_options ) end
270	def visit_page ( url ) url = sanitize_url ( url ) get_page ( url ) do | page | @history << page . url begin @every_page_blocks . each { | page_block | page_block . call ( page ) } yield page if block_given? rescue Actions :: Paused => action raise ( action ) rescue Actions :: SkipPage return nil rescue Actions :: Action end page . each_url do | next_url | begin @every_link_blocks . each do | link_block | link_block . call ( page . url , next_url ) end rescue Actions :: Paused => action raise ( action ) rescue Actions :: SkipLink next rescue Actions :: Action end if ( @max_depth . nil? || @max_depth > @levels [ url ] ) enqueue ( next_url , @levels [ url ] + 1 ) end end end end
820	def dump_points ( cur_path = [ ] ) points = [ self . exterior_ring . dump_points ] self . interior_rings . each do | ring | points . push ( ring . dump_points ) end cur_path . concat ( points ) end
1258	def common_array ( ary ) return ary unless ary . is_a? Array count = ary . count return ary if count . zero? return ary . flatten . uniq if count == 1 common = ary [ 0 ] & ary [ 1 ] return common if count == 2 ( count - 2 ) . times { | x | common &= ary [ x + 2 ] } if count > 2 common end
739	def process_media ( part ) file = temp_file ( part ) if part . part_type? =~ / \/ / || part . part_type? == 'application/smil' type , content = transform_text_part ( part ) else if part . part_type? == 'application/octet-stream' type = type_from_filename ( filename? ( part ) ) else type = part . part_type? end content = part . body . decoded end return type , nil if content . nil? || content . empty? log ( "#{self.class} writing file #{file}" , :info ) File . open ( file , 'wb' ) { | f | f . write ( content ) } return type , file end
703	def edit_vm_network ( vmId , network , config = { } ) params = { 'method' => :get , 'command' => "/vApp/vm-#{vmId}/networkConnectionSection" } netconfig_response , headers = send_request ( params ) if config [ :primary_index ] node = netconfig_response . css ( 'PrimaryNetworkConnectionIndex' ) . first node . content = config [ :primary_index ] end picked_network = netconfig_response . css ( "NetworkConnection" ) . select do | net | net . attribute ( 'network' ) . text == network [ :name ] end . first raise WrongItemIDError , "Network named #{network[:name]} not found." unless picked_network if config [ :ip_allocation_mode ] node = picked_network . css ( 'IpAddressAllocationMode' ) . first node . content = config [ :ip_allocation_mode ] end if config [ :network_index ] node = picked_network . css ( 'NetworkConnectionIndex' ) . first node . content = config [ :network_index ] end if config [ :is_connected ] node = picked_network . css ( 'IsConnected' ) . first node . content = config [ :is_connected ] end if config [ :ip ] node = picked_network . css ( 'IpAddress' ) . first node . content = config [ :ip ] end params = { 'method' => :put , 'command' => "/vApp/vm-#{vmId}/networkConnectionSection" } response , headers = send_request ( params , netconfig_response . to_xml , "application/vnd.vmware.vcloud.networkConnectionSection+xml" ) task_id = headers [ :location ] . gsub ( / \/ \/ / , "" ) task_id end
125	def propagate ( id , _ ) start = Time . now modified = [ ] total = 0 network = @wallets . acq ( id , & :network ) @wallets . acq ( id , & :txns ) . select { | t | t . amount . negative? } . each do | t | total += 1 if t . bnf == id @log . error ( "Paying itself in #{id}? #{t}" ) next end @wallets . acq ( t . bnf , exclusive : true ) do | target | unless target . exists? @log . debug ( "#{t.amount * -1} from #{id} to #{t.bnf}: wallet is absent" ) next end unless target . network == network @log . debug ( "#{t.amount * -1} to #{t.bnf}: network mismatch, '#{target.network}'!='#{network}'" ) next end next if target . includes_positive? ( t . id , id ) unless target . prefix? ( t . prefix ) @log . debug ( "#{t.amount * -1} from #{id} to #{t.bnf}: wrong prefix \"#{t.prefix}\" in \"#{t}\"" ) next end target . add ( t . inverse ( id ) ) @log . info ( "#{t.amount * -1} arrived to #{t.bnf}: #{t.details}" ) modified << t . bnf end end modified . uniq! @log . debug ( "Wallet #{id} propagated successfully, #{total} txns \in #{Age.new(start, limit: 20 + total * 0.005)}, #{modified.count} wallets affected" ) modified . each do | w | @wallets . acq ( w , & :refurbish ) end modified end
1140	def log_time Mako . logger . info 'Generating...' start_time = Time . now . to_f yield generation_time = Time . now . to_f - start_time Mako . logger . info "done in #{generation_time} seconds" end
172	def get_user_configuration ( opts ) opts = opts . clone [ :user_config_name , :user_config_props ] . each do | k | validate_param ( opts , k , true ) end req = build_soap! do | type , builder | if ( type == :header ) else builder . nbuild . GetUserConfiguration { | x | x . parent . default_namespace = @default_ns builder . user_configuration_name! ( opts [ :user_config_name ] ) builder . user_configuration_properties! ( opts [ :user_config_props ] ) } end end do_soap_request ( req , response_class : EwsSoapAvailabilityResponse ) end
1327	def check_script ( path ) binary = path . split ( ' ' ) [ 0 ] raise "#{path} does not exist" unless File . exist? binary raise "#{path} is not executable" unless File . executable? binary path end
768	def set_log ( stream = Pancake . configuration . log_stream , log_level = Pancake . configuration . log_level , delimiter = Pancake . configuration . log_delimiter , auto_flush = Pancake . configuration . log_auto_flush ) @buffer = [ ] @delimiter = delimiter @auto_flush = auto_flush if Levels [ log_level ] @level = Levels [ log_level ] else @level = log_level end @log = stream @log . sync = true @mutex = ( @@mutex [ @log ] ||= Mutex . new ) end
1208	def date_range ( col , start_date , end_date , args , block ) operation = " Date.strptime(\"#{start_date}\", \"#{date_format}\") " + "<= Date.strptime(\"[value]\", \"#{date_format}\") && " + " Date.strptime(\"[value]\", \"#{date_format}\") " + "<= Date.strptime(\"#{end_date}\", \"#{date_format}\")" pivot [ "#{start_date}-#{end_date}" ] = { col : col , operation : operation } end
998	def js ( code ) XhrProxy . context = self @__page ||= Harmony :: Page . new ( XHR_MOCK_SCRIPT + rewrite_script_paths ( @response . body . to_s ) ) Harmony :: Page :: Window :: BASE_RUNTIME . wait @__page . execute_js ( code ) end
343	def register ( extention , handler = nil , & block ) handler ||= block raise 'Handler or block required.' unless handler @render_library [ extention . to_s ] = handler handler end
760	def use ( middleware , * _args , & block ) stack ( middleware ) . use ( middleware , * _args , & block ) end
852	def sales_restriction_type = ( type ) composite = product . sales_restrictions . first if composite . nil? composite = ONIX :: SalesRestriction . new product . sales_restrictions << composite end composite . sales_restriction_type = type end
872	def exact_path return nil if has_double_star || exact_parts . any? { | part | part . nil? } result = ChefFS :: PathUtils :: join ( * exact_parts ) is_absolute ? ChefFS :: PathUtils :: join ( '' , result ) : result end
617	def insert ( text , offset ) if ! @text . nil? @text = @text [ 0 , offset ] + text . to_s + @text [ offset , @text . length ] else @text = text . to_s end end
949	def toggle ( outlet , status ) current_status = status ( outlet ) toggle_relay ( outlet ) if current_status != status status end
333	def class_name ( classname ) classname = sym_to_str ( classname ) classname . split ( '.' ) . map { | m | inflector . camelize ( m ) } . join ( '::' ) end
1312	def obfuscated_link_to ( path , image , label , args = { } ) _html = %{<form action="#{path}" method="get" class="obfuscated_link">} _html << %{ <fieldset><input alt="#{label}" src="#{image}" type="image" /></fieldset>} args . each { | k , v | _html << %{ <div><input id="#{k.to_s}" name="#{k}" type="hidden" value="#{v}" /></div>} } _html << %{</form>} _html end
802	def usb_open_desc ( vendor , product , description , serial ) raise ArgumentError . new ( 'vendor should be Fixnum' ) unless vendor . kind_of? ( Fixnum ) raise ArgumentError . new ( 'product should be Fixnum' ) unless product . kind_of? ( Fixnum ) check_result ( Ftdi . ftdi_usb_open_desc ( ctx , vendor , product , description , serial ) ) end
264	def [] ( url ) url = URI ( url ) key = [ url . scheme , url . host , url . port ] paths = @credentials [ key ] return nil unless paths ordered_paths = paths . keys . sort_by { | path_key | - path_key . length } path_dirs = URI . expand_path ( url . path ) . split ( '/' ) ordered_paths . each do | path | return paths [ path ] if path_dirs [ 0 , path . length ] == path end return nil end
339	def find_central_directory ( io ) eocd_offset = - 22 loop do io . seek ( eocd_offset , IO :: SEEK_END ) if IOExtensions . read_exactly ( io , 4 ) == EOCD_SIGNATURE then io . seek ( 16 , IO :: SEEK_CUR ) if IOExtensions . read_exactly ( io , 2 ) . unpack ( 'v' ) [ 0 ] == ( eocd_offset + 22 ) . abs then break end end eocd_offset -= 1 end io . seek ( eocd_offset + 16 , IO :: SEEK_END ) return IOExtensions . read_exactly ( io , 4 ) . unpack ( 'V' ) [ 0 ] rescue Errno :: EINVAL raise Zip :: UnzipError , 'unable to locate end-of-central-directory record' end
585	def format_value ( key , val , data_type = nil ) data_type ||= self . fields [ key ] val = format_operation ( key , val , data_type ) case data_type when :object val = val . with_indifferent_access if val . is_a? ( Hash ) when :array val = val . to_a if val . is_a? ( Parse :: CollectionProxy ) val = [ val ] unless val . is_a? ( Array ) val . compact! val = Parse :: CollectionProxy . new val , delegate : self , key : key when :geopoint val = Parse :: GeoPoint . new ( val ) unless val . blank? when :file val = Parse :: File . new ( val ) unless val . blank? when :bytes val = Parse :: Bytes . new ( val ) unless val . blank? when :integer if val . nil? || val . respond_to? ( :to_i ) == false val = nil else val = val . to_i end when :boolean if val . nil? val = nil else val = val ? true : false end when :string val = val . to_s unless val . blank? when :float val = val . to_f unless val . blank? when :acl val = ACL . typecast ( val , self ) when :date if val . respond_to? ( :parse_date ) && val . is_a? ( Parse :: Date ) == false val = val . parse_date elsif val . is_a? ( Hash ) val = Parse :: Date . parse ( val [ "iso" ] || val [ :iso ] ) elsif val . is_a? ( String ) val = Parse :: Date . parse val end when :timezone val = Parse :: TimeZone . new ( val ) if val . present? else if data_type . respond_to? ( :typecast ) val = data_type . typecast ( val ) else warn "Property :#{key}: :#{data_type} has no valid data type" val = val end end val end
1355	def pick ( number , * cards ) ordered = cards . flatten . map do | card | i = card_preference . map { | preference | card . type == preference } . index ( true ) { card : card , index : i } end ordered . sort_by { | h | h [ :index ] || 99 } . first ( number ) . map { | h | h [ :card ] } end
1023	def trigger ( command , * args ) command = command . to_sym if command if Event . command? ( command ) event = Event . new ( self , command , args ) handlers = @event_handlers [ event . name ] || [ ] handlers . each do | handler | success = handler . run ( event ) handlers . delete ( handler ) if success && handler . once end end true end
812	def to_g_polygon_api2 ( polygon_options = { } , options = { } ) klass = if options [ :short_class ] 'GPolygon' else 'google.maps.Polygon' end poly_opts = if polygon_options [ :polygon_options ] Geos :: Helper . camelize_keys ( polygon_options [ :polygon_options ] ) end args = [ ( polygon_options [ :stroke_color ] ? "'#{Geos::Helper.escape_javascript(polygon_options[:stroke_color])}'" : 'null' ) , ( polygon_options [ :stroke_weight ] || 'null' ) , ( polygon_options [ :stroke_opacity ] || 'null' ) , ( polygon_options [ :fill_color ] ? "'#{Geos::Helper.escape_javascript(polygon_options[:fill_color])}'" : 'null' ) , ( polygon_options [ :fill_opacity ] || 'null' ) , ( poly_opts ? poly_opts . to_json : 'null' ) ] . join ( ', ' ) "new #{klass}([#{self.to_g_lat_lng_api2(options).join(', ')}], #{args})" end
718	def call! ( env ) @env = env . dup status , @headers , response = @app . call ( @env ) if should_clean? @headers . delete ( 'Content-Length' ) response = Rack :: Response . new ( tidy_markup ( response . respond_to? ( :body ) ? response . body : response ) , status , @headers ) response . finish response . to_a else [ status , @headers , response ] end end
174	def item_shape! ( item_shape ) @nbuild [ NS_EWS_MESSAGES ] . ItemShape { @nbuild . parent . default_namespace = @default_ns base_shape! ( item_shape [ :base_shape ] ) mime_content! ( item_shape [ :include_mime_content ] ) if item_shape . has_key? ( :include_mime_content ) body_type! ( item_shape [ :body_type ] ) if item_shape [ :body_type ] if ( item_shape [ :additional_properties ] ) additional_properties! ( item_shape [ :additional_properties ] ) end } end
1006	def home path = if ( env [ 'HOME' ] || env [ 'USERPROFILE' ] ) env [ 'HOME' ] || env [ 'USERPROFILE' ] elsif ( env [ 'HOMEDRIVE' ] && env [ 'HOMEPATH' ] ) "#{env['HOMEDRIVE']}#{env['HOMEPATH']}" else begin File . expand_path ( '~' ) rescue if File :: ALT_SEPARATOR 'C:/' else '/' end end end return Pathname . new ( path ) end
970	def mech ( & block ) m = Mechanize . new do | m | m . cert_store = OpenSSL :: X509 :: Store . new m . cert_store . add_file mitca_path m . user_agent_alias = 'Linux Firefox' yield m if block m end m end
201	def validate_created_item ( response ) msg = response . response_messages [ 0 ] if ( msg . status == 'Success' ) msg . items . empty? ? true : parse_created_item ( msg . items . first ) else raise EwsCreateItemError , "#{msg.code}: #{msg.message_text}" end end
229	def incoming_references ( client = nil , query = { } ) return false unless client query = is_a? ( Contentful :: Entry ) ? query . merge ( links_to_entry : id ) : query . merge ( links_to_asset : id ) client . entries ( query ) end
507	def drafts response = get 'drafts' response . map { | item | Hashie :: Mash . new ( item ) } end
590	def payload msg = { data : { alert : alert , badge : badge || "Increment" } } msg [ :data ] [ :sound ] = sound if sound . present? msg [ :data ] [ :title ] = title if title . present? msg [ :data ] . merge! @data if @data . is_a? ( Hash ) if @expiration_time . present? msg [ :expiration_time ] = @expiration_time . respond_to? ( :iso8601 ) ? @expiration_time . iso8601 ( 3 ) : @expiration_time end if @push_time . present? msg [ :push_time ] = @push_time . respond_to? ( :iso8601 ) ? @push_time . iso8601 ( 3 ) : @push_time end if @expiration_interval . is_a? ( Numeric ) msg [ :expiration_interval ] = @expiration_interval . to_i end if query . where . present? q = @query . dup if @channels . is_a? ( Array ) && @channels . empty? == false q . where :channels . in => @channels end msg [ :where ] = q . compile_where unless q . where . empty? elsif @channels . is_a? ( Array ) && @channels . empty? == false msg [ :channels ] = @channels end msg end
439	def tabs ( name , locator ) define_method ( name ) do adapter . tab_control ( locator ) . value end define_method ( "#{name}=" ) do | which | adapter . tab_control ( locator ) . selected_tab = which end define_method ( "#{name}_items" ) do adapter . tab_control ( locator ) . items end define_method ( "#{name}_view" ) do adapter . tab_control ( locator ) end end
691	def create_internal_network_node ( network_config ) builder = Nokogiri :: XML :: Builder . new do | xml | xml . Configuration { xml . IpScopes { xml . IpScope { xml . IsInherited ( network_config [ :is_inherited ] || "false" ) xml . Gateway network_config [ :gateway ] xml . Netmask network_config [ :netmask ] xml . Dns1 network_config [ :dns1 ] if network_config [ :dns1 ] xml . Dns2 network_config [ :dns2 ] if network_config [ :dns2 ] xml . DnsSuffix network_config [ :dns_suffix ] if network_config [ :dns_suffix ] xml . IsEnabled ( network_config [ :is_enabled ] || true ) xml . IpRanges { xml . IpRange { xml . StartAddress network_config [ :start_address ] xml . EndAddress network_config [ :end_address ] } } } } xml . FenceMode 'isolated' xml . RetainNetInfoAcrossDeployments ( network_config [ :retain_info ] || false ) } end builder . doc end
1379	def draw_line ( pixels ) pix_line = "" pixels . each do | pixel | pix_line = pix_line + " " . colorize ( :background => find_color ( pixel ) ) end puts pix_line end
1164	def place ( top , left , angle ) api ( 'sticker.place' , :placement => [ :sticker_id => id , :top => top , :left => left , :angle => angle ] , :is_dj => client . user . dj? , :roomid => room . id , :section => room . section ) true end
332	def reset! registered_keys . each { | key | ClassConstants . new ( key ) . deconstantize } @registered_keys = [ ] container . _container . clear end
1042	def output o = if @output . nil? './lib/steamd' else @output end raise 'output must be a directory' unless File . directory? ( o ) File . expand_path ( o ) end
346	def build_feedback_edge_set ( edges , fixed_edges ) edges = edges . dup acyclic_edges = fixed_edges . dup feedback_edge_set = [ ] while edges . present? edge = edges . shift if detect_cycle ( edge , acyclic_edges ) feedback_edge_set << edge else acyclic_edges << edge end end feedback_edge_set end
750	def get_transfer ( type ) type = type [ 0 ] . upcase + type [ 1 .. - 1 ] try_require ( type ) Transfer . const_get ( type ) . new ( @options , @files ) end
254	def active? ( url ) url = URI ( url ) key = key_for ( url ) return @sessions . has_key? ( key ) end
1300	def send_sms_confirmation! return false if _TC_sms_blocked return true if sms_confirmed? return false if _TC_phone_number . blank? format_phone_number confirmation_code = TwilioContactable . confirmation_code ( self , :sms ) message = ( self . class . respond_to? ( :confirmation_message ) ? self . class : TwilioContactable ) . confirmation_message ( confirmation_code ) if message . to_s . size > 160 raise ArgumentError , "SMS Confirmation Message is too long. Limit it to 160 characters of unescaped text." end response = TwilioContactable :: Gateway . deliver_sms ( message , _TC_formatted_phone_number ) if response . success? update_twilio_contactable_sms_confirmation confirmation_code end response end
1306	def INJECT ( adjuster1 , adjuster2 , * adjusters ) adjusters = [ adjuster1 , adjuster2 , * adjusters ] unless adjusters . all? { | f | adjustable? f } raise TypeError , 'wrong object for adjuster' end -> v { adjusters . reduce ( v ) { | ret , adjuster | adjuster . call ret } } end
342	def show begin @datatable = EffectiveDatatables . find ( params [ :id ] ) @datatable . view = view_context EffectiveDatatables . authorize! ( self , :index , @datatable . collection_class ) render json : @datatable . to_json rescue => e EffectiveDatatables . authorized? ( self , :index , @datatable . try ( :collection_class ) ) render json : error_json ( e ) ExceptionNotifier . notify_exception ( e ) if defined? ( ExceptionNotifier ) raise e if Rails . env . development? end end
1213	def awesome_string ( string ) lexers = :: Rouge :: Guessers :: Source . new ( string ) . filter ( R_LEXERS ) if ! lexers . empty? format_syntax_string ( string , lexers . first ) elsif string =~ / \r \n \z / format_multiline_string ( string ) else format_plain_string ( string ) end end
355	def fixed_attributes if model_class presence_validators = model_class . validators . detect { | x | x . kind_of? ( ActiveRecord :: Validations :: PresenceValidator ) } end fixed_attributes = manager_ref fixed_attributes += presence_validators . attributes if presence_validators . present? fixed_attributes end
946	def file? ( method ) @files ||= { } @files [ method ] ||= begin file = @object . send ( method ) if @object && @object . respond_to? ( method ) file && :: Formula . file . any? { | method | file . respond_to? ( method ) } end end
508	def lists response = get 'lists' response . map { | item | Hashie :: Mash . new ( item ) } end
570	def search_venues_by_tip ( options = { } ) tips = search_tips ( options ) venues = [ ] tips . each do | tip | venues << tip [ 'venue' ] end venues end
945	def input ( method , options = { } ) options [ :as ] ||= as ( method ) options [ :input ] ||= { } return hidden_field method , options [ :input ] if options [ :as ] == :hidden klass = [ :: Formula . input_class , options [ :as ] ] klass << :: Formula . input_error_class if :: Formula . input_error_class . present? and error? ( method ) self . block ( method , options ) do @template . content_tag ( :: Formula . input_tag , :class => klass ) do case options [ :as ] when :text then text_area method , :: Formula . area_options . merge ( options [ :input ] || { } ) when :file then file_field method , :: Formula . file_options . merge ( options [ :input ] || { } ) when :string then text_field method , :: Formula . field_options . merge ( options [ :input ] || { } ) when :password then password_field method , :: Formula . field_options . merge ( options [ :input ] || { } ) when :url then url_field method , :: Formula . field_options . merge ( options [ :input ] || { } ) when :email then email_field method , :: Formula . field_options . merge ( options [ :input ] || { } ) when :phone then phone_field method , :: Formula . field_options . merge ( options [ :input ] || { } ) when :number then number_field method , :: Formula . field_options . merge ( options [ :input ] || { } ) when :boolean then check_box method , :: Formula . box_options . merge ( options [ :input ] || { } ) when :country then country_select method , :: Formula . select_options . merge ( options [ :input ] || { } ) when :date then date_select method , :: Formula . select_options . merge ( options [ :input ] || { } ) , options [ :input ] . delete ( :html ) || { } when :time then time_select method , :: Formula . select_options . merge ( options [ :input ] || { } ) , options [ :input ] . delete ( :html ) || { } when :datetime then datetime_select method , :: Formula . select_options . merge ( options [ :input ] || { } ) , options [ :input ] . delete ( :html ) || { } when :select then select method , options [ :choices ] , :: Formula . select_options . merge ( options [ :input ] || { } ) , options [ :input ] . delete ( :html ) || { } end end end end
218	def create_item ( attributes , to_ews_create_opts = { } ) template = Viewpoint :: EWS :: Template :: CalendarItem . new attributes template . saved_item_folder_id = { id : self . id , change_key : self . change_key } rm = ews . create_item ( template . to_ews_create ( to_ews_create_opts ) ) . response_messages . first if rm && rm . success? CalendarItem . new ews , rm . items . first [ :calendar_item ] [ :elems ] . first else raise EwsCreateItemError , "Could not create item in folder. #{rm.code}: #{rm.message_text}" unless rm end end
631	def strike style = CharacterStyle . new style . strike = true if block_given? apply ( style ) { | node | yield node } else apply ( style ) end end
857	def measurement_set ( type , value , unit ) measure = measurement ( type ) if measure . nil? measure = ONIX :: Measure . new measure . measure_type_code = type product . measurements << measure end measure . measurement = value measure . measure_unit_code = unit . to_s end
34	def load ( filename ) begin new_config = YAML :: load_file ( filename ) if new_config . kind_of? ( Hash ) @config = new_config else raise AdsCommon :: Errors :: Error , "Incorrect configuration file: '%s'" % filename end rescue TypeError => e raise AdsCommon :: Errors :: Error , "Error parsing configuration file: '%s' (%s)" % [ filename , e ] end return nil end
975	def no_body ( status ) res . status = :: Rack :: Utils . status_code ( status ) res . write :: Rack :: Utils :: HTTP_STATUS_CODES [ res . status ] res [ 'Content-Type' ] = 'text/plain' end
794	def check ( name , * options_or_check , & block ) raise ArgumentError ( "Too many arguments to #{self.class.name}#check" ) if options_or_check . size > 2 check = nil options = { :async => true } unless options_or_check . empty? if options_or_check [ 0 ] . is_a? ( Hash ) options = options . merge ( options_or_check [ 0 ] ) else check = options_or_check [ 0 ] end if options_or_check [ 1 ] . is_a? ( Hash ) options = options . merge ( options_or_check [ 1 ] ) end end unless check if block check = block else check = lookup_check ( name , options ) end end @filters << Filter . new ( name , check , options [ :async ] ) end
32	def implode_parent ( data_type ) result = [ ] if data_type [ :base ] parent_type = @registry . get_type_signature ( data_type [ :base ] ) result += implode_parent ( parent_type ) end data_type [ :fields ] . each do | field | result . reject! { | parent_field | parent_field [ :name ] . eql? ( field [ :name ] ) } field [ :ns ] = data_type [ :ns ] if data_type [ :ns ] result << field end return result end
591	def send ( message = nil ) @alert = message if message . is_a? ( String ) @data = message if message . is_a? ( Hash ) client . push ( payload . as_json ) end
302	def exclude ( * args ) e = flatten_list_of_strings ( args ) if e . nil? || e . empty? bot . exclude = [ ] else bot . exclude += e end end
45	def do_require ( version , service ) filename = [ api_path , version . to_s , service . to_s . snakecase ] . join ( '/' ) require filename return filename end
66	def do_logging ( action , request , response ) logger = get_logger ( ) return unless should_log_summary ( logger . level , response . soap_fault? ) response_hash = response . hash soap_headers = { } begin soap_headers = response_hash [ :envelope ] [ :header ] [ :response_header ] rescue NoMethodError end summary_message = ( 'ID: %s, URL: %s, Service: %s, Action: %s, Response ' + 'time: %sms, Request ID: %s' ) % [ @header_handler . identifier , request . url , self . class . to_s . split ( "::" ) . last , action , soap_headers [ :response_time ] , soap_headers [ :request_id ] ] if soap_headers [ :operations ] summary_message += ', Operations: %s' % soap_headers [ :operations ] end summary_message += ', Is fault: %s' % response . soap_fault? request_message = nil response_message = nil if should_log_payloads ( logger . level , response . soap_fault? ) request_message = 'Outgoing request: %s %s' % [ format_headers ( request . headers ) , sanitize_request ( request . body ) ] response_message = 'Incoming response: %s %s' % [ format_headers ( response . http . headers ) , response . http . body ] end if response . soap_fault? summary_message += ', Fault message: %s' % format_fault ( response_hash [ :envelope ] [ :body ] [ :fault ] [ :faultstring ] ) logger . warn ( summary_message ) logger . info ( request_message ) unless request_message . nil? logger . info ( response_message ) unless response_message . nil? else logger . info ( summary_message ) logger . debug ( request_message ) unless request_message . nil? logger . debug ( response_message ) unless response_message . nil? end end
792	def run status = Status . new ( name ) runner = ( async ? AsyncRunner : SyncRunner ) . new do t = Time . now begin @check . call ( status ) rescue Exception => e status . fail ( "#{name} error: #{e.inspect}" ) end status . time = Time . now - t end runner . filter_status = status runner end
1076	def snag assert_current_song sh = digest ( rand ) api ( 'snag.add' , :djid => room . current_dj . id , :songid => id , :roomid => room . id , :section => room . section , :site => 'queue' , :location => 'board' , :in_queue => 'false' , :blocked => 'false' , :vh => digest ( [ client . user . id , room . current_dj . id , id , room . id , 'queue' , 'board' , 'false' , 'false' , sh ] * '/' ) , :sh => sh , :fh => digest ( rand ) ) true end
1086	def enums raise StreamNotParsed , 'you must parse first' if @tree . nil? enums = statements . select do | node | node . is_a? ( EnumStatement ) end enums . map ( & :to_hash ) end
1069	def process ( line , values = true ) return "" if @header_cols . empty? && @insert_cols . empty? header_patterns = { } @row_cols = unstring ( line ) . split ( ';' ) if @header_cols [ 0 ] == '*' @header_cols [ 0 ] = @row_cols else @header_cols . each_with_index do | h , i | if h =~ / \( \d / if col = eval ( h ) last_eval = $1 unless @header_cols . index ( last_eval ) || @header_cols . index ( col ) if values @header_cols [ i ] = ( h =~ / \( \d / ) ? last_eval : col header_patterns [ i + 1 ] = h if h =~ / \( \d / else @header_cols [ i ] = col if h =~ / \( \d / end end end else @header_cols [ i ] = h end end end insert_header_cols header_patterns . each { | i , h | @header_cols . insert ( i , h ) } to_s end
903	def in_chain? ( other ) return false unless other . is_a? Listable chain_head . equal? other . chain_head end
559	def add_checkin ( options = { } ) response = connection . post do | req | req . url "checkins/add" , options end return_error_or_body ( response , response . body . response . checkin ) end
1202	def equal ( value , args , block ) filter << value . to_i unless filter . index ( value . to_i ) end
859	def price_set ( type , num ) p = price_get ( type ) if p . nil? supply = find_or_create_supply_detail p = ONIX :: Price . new p . price_type_code = type supply . prices << p end p . price_amount = num end
1305	def WHEN ( condition , adjuster ) unless Validation . conditionable? condition raise TypeError , 'wrong object for condition' end unless Validation . adjustable? adjuster raise TypeError , 'wrong object for adjuster' end -> v { _valid? ( condition , v ) ? adjuster . call ( v ) : v } end
189	def dispatch_item_id! ( iid ) type = iid . keys . first item = iid [ type ] case type when :item_id item_id! ( item ) when :occurrence_item_id occurrence_item_id! ( item ) when :recurring_master_item_id recurring_master_item_id! ( item ) else raise EwsBadArgumentError , "Bad ItemId type. #{type}" end end
325	def replies ( * args , & block ) return unless require_login debug "check for replies since #{since_id_reply}" opts = { :since_id => since_id_reply , :count => 200 } results = client . mentions_timeline ( opts ) @current_tweet = nil results . each { | s | update_since_id_reply ( s ) if block_given? && valid_tweet? ( s ) @current_tweet = s yield s end } @current_tweet = nil end
250	def apply ( operations ) operations . inject ( self ) do | builder , ( name , argument ) | if argument == true || argument == nil builder . send ( name ) elsif argument . is_a? ( Array ) builder . send ( name , * argument ) else builder . send ( name , argument ) end end end
1145	def publish_to_http ( params ) api = params . delete ( :api ) message_id = params [ :msgid ] http = EventMachine :: HttpRequest . new ( "http://turntable.fm/api/#{api}" ) . get ( :query => params ) if http . response_header . status == 200 success , data = JSON . parse ( http . response ) data = { 'result' => data } unless data . is_a? ( Hash ) message = data . merge ( 'success' => success ) else message = { 'success' => false , 'error' => http . error } end message . merge! ( 'msgid' => message_id ) event = Faye :: WebSocket :: API :: Event . new ( 'message' , :data => "~m~#{Time.now.to_i}~m~#{JSON.generate(message)}" ) on_message ( event ) end
1170	def decrement_derived_quantity ( child ) return unless specimen_type == child . specimen_type and child . initial_quantity if available_quantity . nil? then raise Jinx :: ValidationError . new ( "Derived specimen has an initial quantity #{child.initial_quantity} but the parent is missing an available quantity" ) elsif ( available_quantity - child . initial_quantity ) . abs < 0.00000001 then self . available_quantity = 0.0 elsif child . initial_quantity <= available_quantity then self . available_quantity -= child . initial_quantity else raise Jinx :: ValidationError . new ( "Derived specimen initial quantity #{child.initial_quantity} exceeds parent available quantity #{available_quantity}" ) end end
745	def msg_tmp_dir @dir_count += 1 dir = File . expand_path ( File . join ( @media_dir , "#{@dir_count}" ) ) FileUtils . mkdir_p ( dir ) dir end
557	def checkin ( checkin_id , options = { } ) response = connection . get do | req | req . url "checkins/#{checkin_id}" , options end return_error_or_body ( response , response . body . response . checkin ) end
487	def in_dir ( dir , & block ) original_dir = Dir . pwd begin Dir . chdir ( dir ) block . call ensure Dir . chdir ( original_dir ) end end
648	def to_integer ( array , signed = false ) from = nil to = nil data = [ ] if array . size == 2 data . concat ( get_endian == BIG_ENDIAN ? array . reverse : array ) from = 'C2' to = signed ? 's' : 'S' else data . concat ( get_endian == BIG_ENDIAN ? array [ 0 , 4 ] . reverse : array ) from = 'C4' to = signed ? 'l' : 'L' end data . pack ( from ) . unpack ( to ) [ 0 ] end
119	def sub ( amount , invoice , pvt , details = '-' , time : Time . now ) raise 'The amount has to be of type Amount' unless amount . is_a? ( Amount ) raise "The amount can't be negative: #{amount}" if amount . negative? raise 'The pvt has to be of type Key' unless pvt . is_a? ( Key ) prefix , target = invoice . split ( '@' ) tid = max + 1 raise 'Too many transactions already, can\'t add more' if max > 0xffff txn = Txn . new ( tid , time , amount * - 1 , prefix , Id . new ( target ) , details ) txn = txn . signed ( pvt , id ) raise "Invalid private key for the wallet #{id}" unless Signature . new ( network ) . valid? ( key , id , txn ) add ( txn ) txn end
1340	def last ( limit = 1 , offset = 0 ) from = offset to = from + limit - 1 members = redis . zrange ( index_key_for ( :id ) , ( to * - 1 ) + - 1 , ( from * - 1 ) + - 1 ) . reverse find ( limit > 1 ? members : members . first ) end
1336	def update_columns ( attrs ) redis . multi do attrs . each do | attr , value | if self . class . fields . has_key? ( attr ) write_attribute ( attr , value ) redis . hset ( key_for ( :attributes ) , attr , self . class . transform ( :to , attr , value ) ) unless new_record? end if self . class . lists . has_key? ( attr ) write_list ( attr , value ) unless new_record? redis . del ( key_for ( attr ) ) redis . rpush ( key_for ( attr ) , value ) unless value . empty? end end if self . class . hashes . has_key? ( attr ) write_hash ( attr , value ) unless new_record? hash_as_args = hash_to_redis ( value ) redis . hmset ( key_for ( attr ) , * hash_as_args ) end end end end end
1091	def log ( level , message , quiet : false , & block ) if ! quiet && ( LEVELS . index ( level ) >= LEVELS . index ( Logger . level ) ) synchronize do message = message . to_s . colorize ( COLORS [ level ] ) if level message . split ( "\n" ) . each do | line | STDERR . puts " " * Logger . indent + @prefix + line end end with_indent ( & block ) if block elsif block block . ( ) end end
124	def max negative = txns . select { | t | t . amount . negative? } negative . empty? ? 0 : negative . max_by ( & :id ) . id end
665	def get_device ( vendor_id , product_id , serial_number = nil , options = { } ) raise ArgumentError , 'vendor_id must be provided' if vendor_id . to_i == 0 raise ArgumentError , 'product_id must be provided' if product_id . to_i == 0 if serial_number . is_a? ( Hash ) options = serial_number serial_number = nil end klass = ( options || { } ) . delete ( :as ) || 'HIDAPI::Device' klass = Object . const_get ( klass ) unless klass == :no_mapping list = enumerate ( vendor_id , product_id , as : :no_mapping ) return nil unless list && list . count > 0 if serial_number . to_s == '' if klass != :no_mapping return klass . new ( list . first ) else return list . first end end list . each do | dev | if dev . serial_number == serial_number if klass != :no_mapping return klass . new ( dev ) else return dev end end end nil end
684	def clone_vapp ( vdc_id , source_vapp_id , name , deploy = "true" , poweron = "false" , linked = "false" , delete_source = "false" ) params = { "method" => :post , "command" => "/vdc/#{vdc_id}/action/cloneVApp" } builder = Nokogiri :: XML :: Builder . new do | xml | xml . CloneVAppParams ( "xmlns" => "http://www.vmware.com/vcloud/v1.5" , "name" => name , "deploy" => deploy , "linkedClone" => linked , "powerOn" => poweron ) { xml . Source "href" => "#{@api_url}/vApp/vapp-#{source_vapp_id}" xml . IsSourceDelete delete_source } end response , headers = send_request ( params , builder . to_xml , "application/vnd.vmware.vcloud.cloneVAppParams+xml" ) vapp_id = headers [ :location ] . gsub ( / \/ \/ \- / , "" ) task = response . css ( "VApp Task[operationName='vdcCopyVapp']" ) . first task_id = task [ "href" ] . gsub ( / \/ \/ / , "" ) { :vapp_id => vapp_id , :task_id => task_id } end
511	def suppressionlist ( page = 1 , page_size = 1000 , order_field = "email" , order_direction = "asc" ) options = { :query => { :page => page , :pagesize => page_size , :orderfield => order_field , :orderdirection => order_direction } } response = get 'suppressionlist' , options Hashie :: Mash . new ( response ) end
528	def slice_hash ( hash , * keys ) return { } if keys . length . zero? new_hash = { } hash . each do | key , value | new_hash [ key ] = value if keys . include? key end new_hash end
242	def set_ext_params ( ext_key , ext_params ) raise ArgumentError unless ext_params . is_a? ( Hash ) @extensions [ ext_key ] = ext_params end
1234	def init_sum_scheme ( sum_scheme ) return if sum_scheme . nil? re = / \w \d \w / sum_scheme . scan ( re ) . each do | part | if part . compact . size == 2 @sum_row_title = part [ 0 ] @sum_row = part [ 1 ] . to_i else @sum_col_title = part [ 2 ] end end end
247	def destination_format format = File . extname ( destination ) [ 1 .. - 1 ] if destination format ||= self . format format ||= File . extname ( source_path ) [ 1 .. - 1 ] if source_path format || DEFAULT_FORMAT end
178	def folder_id! ( fid , change_key = nil ) attribs = { 'Id' => fid } attribs [ 'ChangeKey' ] = change_key if change_key @nbuild [ NS_EWS_TYPES ] . FolderId ( attribs ) end
934	def extract_version ( value ) value = value . to_s . split ( '|' ) [ 0 ] if value . to_s . include? '|' regexp_to_match = / \d / if ( not regexp_to_match . match ( value ) . nil? ) version = regexp_to_match . match ( value ) [ 0 ] else version = '' end version end
1147	def add_defaults_local super self . capacity ||= Capacity . new . add_defaults self . row_label ||= capacity . rows && capacity . rows > 0 ? 'Row' : 'Unused' self . column_label ||= capacity . columns && capacity . columns > 0 ? 'Column' : 'Unused' end
688	def merge_network_config ( vapp_networks , new_network , config ) net_configuration = new_network . css ( 'Configuration' ) . first fence_mode = new_network . css ( 'FenceMode' ) . first fence_mode . content = config [ :fence_mode ] || 'isolated' network_features = Nokogiri :: XML :: Node . new "Features" , net_configuration firewall_service = Nokogiri :: XML :: Node . new "FirewallService" , network_features firewall_enabled = Nokogiri :: XML :: Node . new "IsEnabled" , firewall_service firewall_enabled . content = config [ :firewall_enabled ] || "false" firewall_service . add_child ( firewall_enabled ) network_features . add_child ( firewall_service ) net_configuration . add_child ( network_features ) if config [ :parent_network ] parent_network = Nokogiri :: XML :: Node . new "ParentNetwork" , net_configuration parent_network [ "href" ] = "#{@api_url}/network/#{config[:parent_network][:id]}" parent_network [ "name" ] = config [ :parent_network ] [ :name ] parent_network [ "type" ] = "application/vnd.vmware.vcloud.network+xml" new_network . css ( 'IpScopes' ) . first . add_next_sibling ( parent_network ) end vapp_networks . to_xml . gsub ( "<PLACEHOLDER/>" , new_network . css ( 'Configuration' ) . to_xml ) end
986	def hash_to_query ( h ) h = Hash [ h . map { | k , v | [ k , "\"#{v}\"" ] } ] Rack :: Utils . unescape Rack :: Utils . build_query ( h ) end
241	def coerce ( value , configuration ) return value if type . nil? return value if value . nil? options = { } options [ :coercion_class ] = KNOWN_TYPES [ items . type ] unless items . nil? KNOWN_TYPES [ type ] . new ( value , options ) . coerce ( configuration ) end
130	def to_s @threads . map do | t | [ "#{t.name}: status=#{t.status}; alive=#{t.alive?}" , 'Vars: ' + t . thread_variables . map { | v | "#{v}=\"#{t.thread_variable_get(v)}\"" } . join ( '; ' ) , t . backtrace . nil? ? 'NO BACKTRACE' : " #{t.backtrace.join("\n ")}" ] . join ( "\n" ) end end
973	def bind raise ModelNotSetError . new ( "You must set the model before binding it." ) unless @model fields do | field | view_obj = self . view . viewWithTag ( field . tag ) @model . send ( "#{field.name}=" . to_sym , view_obj . text ) if view_obj . respond_to? ( :text ) end end
1216	def init_collection ( column_filter ) column_filter . split ( '+' ) . each do | f | category , filter = f . split ( ':' ) collection [ category ] = { entries : [ ] , filter : ColumnFilter . new ( filter ) } end end
567	def search_specials ( options = { } ) response = connection . get do | req | req . url "specials/search" , options end return_error_or_body ( response , response . body . response . specials . items ) end
737	def subject unless @subject subject = mail . subject . strip rescue "" ignores = config [ 'ignore' ] [ 'text/plain' ] if ignores && ignores . detect { | s | s == subject } @subject = "" else @subject = transform_text ( 'text/plain' , subject ) . last end end @subject end
551	def add_tip ( options = { } ) response = connection . post do | req | req . url "tips/add" , options end return_error_or_body ( response , response . body . response . tip ) end
258	def doc unless body . empty? doc_class = if html? Nokogiri :: HTML :: Document elsif rss? || atom? || xml? || xsl? Nokogiri :: XML :: Document end if doc_class begin @doc ||= doc_class . parse ( body , @url . to_s , content_charset ) rescue end end end end
1257	def filestring ( file , size = 8192 ) return unless file return file unless file . is_a? ( String ) && File . file? ( file ) && File . size ( file ) <= size File . read ( file ) end
1015	def execute scripts = Dir . glob ( File . join ( @script_dir , @script_file ) ) scripts . each do | script | list [ script ] = [ ] if show_methods list [ script ] = retrieve_methods ( script ) end end list end
465	def single_use_pipeline ( caller_reference , return_url , options = { } ) cbui SingleUse . new ( options . merge ( :caller_reference => caller_reference , :return_url => return_url ) ) end
492	def subscribers ( date = "" , page = 1 , page_size = 1000 , order_field = "email" , order_direction = "asc" , include_tracking_preference = false ) options = { :query => { :date => date , :page => page , :pagesize => page_size , :orderfield => order_field , :orderdirection => order_direction , :includetrackingpreference => include_tracking_preference } } response = get "active" , options Hashie :: Mash . new ( response ) end
754	def save_to_assets_library ( jpeg_data , & block ) assets_library . writeImageDataToSavedPhotosAlbum ( jpeg_data , metadata : nil , completionBlock : -> ( asset_url , error ) { error ? error_callback . call ( error ) : block . call ( asset_url ) } ) end
300	def blocklist ( * args ) list = flatten_list_of_strings ( args ) if list . nil? || list . empty? bot . blocklist = [ ] else bot . blocklist += list end end
482	def ft_sugadd ( record : , attribute : , score : 1 ) key = "#{@model.to_s}:#{attribute}" string = record . send ( attribute ) REDI_SEARCH . call ( 'FT.SUGADD' , key , string , score ) rescue Exception => e Rails . logger . error e if defined? Rails return e . message end
606	def parse_result! ( h ) @result = { } return unless h . is_a? ( Hash ) @code = h [ CODE ] @error = h [ ERROR ] if h [ RESULTS ] . is_a? ( Array ) @result = h [ RESULTS ] @count = h [ COUNT ] || @result . count else @result = h @count = 1 end end
1033	def entry_summary ( entry ) ! entry . content || entry . content . empty? ? entry . summary : entry . content end
988	def create ( clone_from_version_id ) request = Net :: HTTP :: Post . new ( URI . join ( @base_uri . to_s , "cloudlets/api/v2/policies/#{@policy_id}/versions?includeRules=false&matchRuleFormat=1.0&cloneVersion=#{clone_from_version_id}" ) . to_s , { 'Content-Type' => 'application/json' } ) response = @http_host . request ( request ) response . body end
1082	def load! return if loaded? Treetop . load ( "#{Steamd.grammar_dir}/shared.treetop" ) Dir . glob ( "#{Steamd.grammar_dir}/*.treetop" ) do | file | Treetop . load ( file ) end @parser = SteamdParser . new true end
653	def header ( type = HeaderNode :: UNIVERSAL ) index = 0 if type == HeaderNode :: LEFT_PAGE index = 1 elsif type == HeaderNode :: RIGHT_PAGE index = 2 elsif type == HeaderNode :: FIRST_PAGE index = 3 end @headers [ index ] end
502	def active ( date = "" , page = 1 , page_size = 1000 , order_field = "email" , order_direction = "asc" , include_tracking_preference = false ) paged_result_by_date ( "active" , date , page , page_size , order_field , order_direction , include_tracking_preference ) end
1254	def random_data_url url0s = Array . new file = File . open ( STATUS_FILE_PATH ) file . each { | line | if line . start_with? "url0" url0s << line . split ( "=" ) . last end } return url0s [ rand ( url0s . length ) ] end
544	def user_mayorships ( user_id , options = { } ) response = connection . get do | req | req . url "users/#{user_id}/mayorships" , options end return_error_or_body ( response , response . body . response . mayorships ) end
445	def put ( from , to , overwrite = false , raise = true ) ls_items = ls to , false if ! overwrite && ! ls_items . empty? raise Client :: RuntimeError , "File [#{to}] already exist" end from = '"' + from + '"' if from . include? ' ' to = '"' + to + '"' if to . include? ' ' exec 'put ' + from + ' ' + to true rescue Client :: RuntimeError => e raise e if raise false end
545	def user_lists ( user_id , options = { } ) response = connection . get do | req | req . url "users/#{user_id}/lists" , options end return_error_or_body ( response , response . body . response . lists ) end
1037	def set_map_lat_lon ( latitude , longitude , zoom_level , animated = false ) coordinate = LocationCoordinate . new ( latitude , longitude ) set_center_coordinates ( coordinate , zoom_level , animated ) end
549	def search_tips ( options = { } ) response = connection . get do | req | req . url "tips/search" , options end return_error_or_body ( response , response . body . response . tips ) end
1298	def remove_nonreporting_servers ( keeptime = nil ) list_nonreporting_servers . each do | server | next if keeptime && Time . parse ( server [ :last_reported_at ] ) >= Time . now - ChronicDuration . parse ( keeptime ) Notifier . msg ( server [ :name ] , 'Removing Stale, Non-Reporting Server' ) Client . delete_server ( server [ :id ] ) end end
1001	def respect_query_limit now = Time . now . to_f three_requests_ago = request_times [ - 3 ] request_times << now return unless three_requests_ago time_for_last_3_requeests = now - three_requests_ago enough_time_has_passed = time_for_last_3_requeests >= 1.0 unless enough_time_has_passed sleep_time = 1 - time_for_last_3_requeests STDERR . puts "sleeping #{sleep_time}" sleep ( sleep_time ) end end
548	def tip ( tip_id , options = { } ) response = connection . get do | req | req . url "tips/#{tip_id}" , options end return_error_or_body ( response , response . body . response . tip ) end
879	def export_to_file ( filename , options = { } ) content_string = export_to_string ( default_options ( filename ) . merge ( :filename => filename ) ) File . open ( filename , "w" ) { | f | f . write ( content_string ) } nil end
1224	def column_collect ( & block ) result = [ ] 0 . upto ( ncols - 1 ) { | i | result << block . call ( self [ nil , i ] ) } result end
558	def recent_checkins ( options = { } ) response = connection . get do | req | req . url "checkins/recent" , options end return_error_or_body ( response , response . body . response . recent ) end
1281	def post ( opts ) opts = @helper . ensure_open_struct ( opts ) date = @helper . get_date_stamp slug = if opts . slug . nil? || opts . slug . empty? opts . title else opts . slug end slug = @helper . get_slug_for ( slug ) head , ext = @helper . get_layout ( opts . layout ) head . sub! ( / \s / , "title: #{opts.title}" ) head . sub! ( / \s / , "date: #{date}" ) ext ||= @ext path = File . join ( POSTS_FOLDER , "#{date}-#{slug}.#{ext}" ) f = File . open ( path , "w" ) f . write ( head ) f . close @helper . open_in_editor ( path ) path end
1384	def send ( type , payload , opts = { } , & block ) res = http_send type , Oj . dump ( { "rid" => uuid , "data" => payload } ) block . call ( res ) if block res end
1262	def unregister_observer ( observer_class , observer_id ) @observer_mutex . synchronize do log "EventListener: un-registering observer #{observer_class} #{observer_id}" if ( consumer = @observers . delete ( observer_key_for ( observer_class , observer_id ) ) ) consumer . cancel end end end
306	def token ( s ) bot . deprecated "Setting access_token outside of your config file is deprecated!" , Kernel . caller . first bot . config [ :access_token ] = s end
1245	def match_characteristics ( other ) chr = characteristics ochr = other . characteristics chr and ochr and chr . tissue_side == ochr . tissue_side and chr . tissue_site == ochr . tissue_site end
1160	def parse ( argv ) OptionParser . new do | options | usage_and_help options assign_text_file options assign_weights_file options assign_output_file options begin options . parse argv rescue OptionParser :: ParseError => error STDERR . puts error . message , "\n" , options exit ( - 1 ) end end end
746	def filename? ( part ) name = part . filename if ( name . nil? || name . empty? ) if part . content_id && ( matched = / / . match ( part . content_id ) ) name = matched [ 1 ] else name = "#{Time.now.to_f}.#{self.default_ext(part.part_type?)}" end end name = ( name =~ / \. / ? name : "#{name}.#{self.default_ext(part.part_type?)}" ) . strip if name . size > 255 ext = File . extname ( name ) base = File . basename ( name , ext ) name = "#{base[0, 255 - ext.size]}#{ext}" end name end
307	def flatten_list_of_strings ( args ) args . collect do | b | if b . is_a? ( String ) b . split ( "," ) . collect { | s | s . strip } else b end end . flatten end
1003	def declare_exchange ( channel , name , type , options = { } ) exchange = if default_exchange? ( name ) channel . default_exchange else channel . send ( type , name , options ) end log . debug ( "Exchange #{exchange.name.inspect} declared" ) exchange end
397	def psubscribe ( pattern , proc = nil , & block ) if cb = proc || block @psub_callbacks [ pattern ] << cb end @psubs << pattern raw_send_command ( :psubscribe , [ pattern ] ) return pubsub_deferrable ( pattern ) end
112	def class_for_path ( path ) path . split ( '::' ) . inject ( Kernel ) do | scope , const_name | scope . const_get ( const_name ) end end
1077	def add ( options = { } ) assert_valid_keys ( options , :playlist , :index ) options = { :playlist => playlist . id , :index => 0 } . merge ( options ) song = dup song . attributes = { :playlist => options [ :playlist ] } playlist , index = song . playlist , options [ :index ] api ( 'playlist.add' , :playlist_name => playlist . id , :song_dict => { :fileid => id } , :index => index ) playlist . songs . insert ( index , song ) if playlist . loaded? true end
204	def search_by_subject ( match_str , exclude_str = nil ) items do | obj | match = { :contains => { :containment_mode => 'Substring' , :containment_comparison => 'IgnoreCase' , :field_uRI => { :field_uRI => 'item:Subject' } , :constant => { :value => match_str } } } unless exclude_str . nil? excl = { :not => { :contains => { :containment_mode => 'Substring' , :containment_comparison => 'IgnoreCase' , :field_uRI => { :field_uRI => 'item:Subject' } , :constant => { :value => exclude_str } } } } match [ :and ] = [ { :contains => match . delete ( :contains ) } , excl ] end obj . restriction = match end end
781	def update_user ( options = { } ) user = User . new ( options ) user . validate! response = oauth_access_token . put ( "/v1/users/#{user.id}" , body : user_hash ( user . to_hash ) ) User . new ( response . parsed ) end
67	def format_headers ( headers ) return headers . map do | k , v | v = REDACTED_STR if k == 'Authorization' [ k , v ] . join ( ': ' ) end . join ( ', ' ) end
1196	def write buffer = create_zip ( @entries , @ignore_entries ) puts "\nwrite file #{@output_file}" File . open ( @output_file , "wb" ) { | f | f . write buffer . string } end
587	def twin h = self . as_json h . delete ( Parse :: Model :: OBJECT_ID ) h . delete ( :objectId ) h . delete ( :id ) self . class . new h end
1263	def observer_queue @observer_queue ||= client . create_queue ( [ name , 'listener' , Socket . gethostname , Process . pid ] . join ( '.' ) , models_exchange , queue_options : { exclusive : true } , subscribe_options : { manual_ack : true } ) end
159	def destroy! return false if destroyed? || new_record? @client . connection . delete ( url || path ) do | req | yield req if block_given? end @destroyed = true end
463	def multi_use_pipeline ( caller_reference , return_url , options = { } ) cbui MultiUse . new ( options . merge ( :caller_reference => caller_reference , :return_url => return_url ) ) end
14	def instance_action_module @instance_action_module ||= Module . new do def client ( & block ) self . class . client ( & block ) end end . tap { | mod | include ( mod ) } end
1175	def copy_annotation_proxy_owner_to_template ( obj , template ) prop = obj . class . proxy_property return unless prop and prop . java_property? rdr , wtr = prop . java_accessors pxy = obj . send ( rdr ) logger . debug { "Setting #{obj.qp} template #{template.qp} proxy owner to #{pxy}..." } template . send ( wtr , pxy ) end
1243	def region = ( args ) case args when Hash self . setRegion ( CoordinateRegion . new ( args [ :region ] ) . api , animated : args [ :animated ] ) else self . setRegion ( CoordinateRegion . new ( args ) . api , animated : false ) end end
576	def venue_menus ( venue_id , options = { } ) response = connection . get do | req | req . url "venues/#{venue_id}/menu" , options end return_error_or_body ( response , response . body . response ) end
1282	def draft ( opts ) opts = @helper . ensure_open_struct ( opts ) FileUtils . mkdir_p ( DRAFTS_FOLDER ) slug = if opts . slug . nil? || opts . slug . empty? opts . title else opts . slug end slug = @helper . get_slug_for ( slug ) head , ext = @helper . get_layout ( opts . layout ) head . sub! ( / \s / , "title: #{opts.title}" ) head . sub! ( / \s / , "date: #{@helper.get_date_stamp}" ) ext ||= @ext path = File . join ( DRAFTS_FOLDER , "#{slug}.#{ext}" ) f = File . open ( path , "w" ) f . write ( head ) f . close @helper . open_in_editor ( path ) path end
1277	def create_queue ( queue_name , exchange_name , options = { } ) queue_options = options [ :queue_options ] || { durable : true } routing_keys = options [ :routing_keys ] || [ ] log "Isimud::BunnyClient: create_queue #{queue_name}: queue_options=#{queue_options.inspect}" queue = find_queue ( queue_name , queue_options ) bind_routing_keys ( queue , exchange_name , routing_keys ) if routing_keys . any? queue end
1365	def set_pagination_info ( page_no , page_size , record_count ) @current_page = page_no @per_page = page_size @total_count = record_count @total_pages = ( record_count / page_size . to_f ) . ceil extend PaginationMethods self end
710	def acquire_ticket_vm ( vmId ) params = { 'method' => :post , 'command' => "/vApp/vm-#{vmId}/screen/action/acquireTicket" } response , headers = send_request ( params ) screen_ticket = response . css ( "ScreenTicket" ) . text result = { } if screen_ticket =~ / \/ \/ \/ \/ \? \? / result = { host : $1 , moid : $2 , token : $3 } result [ :token ] = URI . unescape result [ :token ] end result end
9	def _follow_redirection ( new_args , & block ) url = headers [ :location ] unless url raise exception_with_response end unless url . start_with? ( 'http' ) url = URI . parse ( request . url ) . merge ( url ) . to_s end new_args [ :url ] = url new_args [ :password ] = request . password new_args [ :user ] = request . user new_args [ :headers ] = request . headers new_args [ :max_redirects ] = request . max_redirects - 1 new_args [ :cookies ] = cookie_jar new_req = Request . new ( new_args ) new_req . redirection_history = history + [ self ] new_req . execute ( & block ) end
341	def view = ( view ) @view = ( view . respond_to? ( :view_context ) ? view . view_context : view ) raise 'expected view to respond to params' unless @view . respond_to? ( :params ) load_cookie! assert_cookie! load_attributes! initialize_filters if respond_to? ( :initialize_filters ) load_filters! load_state! initialize_bulk_actions if respond_to? ( :initialize_bulk_actions ) initialize_datatable if respond_to? ( :initialize_datatable ) load_columns! initialize_charts if respond_to? ( :initialize_charts ) initialize_collection if respond_to? ( :initialize_collection ) load_collection! load_resource! apply_belongs_to_attributes! load_resource_search! validate_datatable! save_cookie! end
711	def get_network ( networkId ) response = get_base_network ( networkId ) name = response . css ( 'OrgVdcNetwork' ) . attribute ( 'name' ) . text description = response . css ( "Description" ) . first description = description . text unless description . nil? gateway = response . css ( 'Gateway' ) gateway = gateway . text unless gateway . nil? netmask = response . css ( 'Netmask' ) netmask = netmask . text unless netmask . nil? fence_mode = response . css ( 'FenceMode' ) fence_mode = fence_mode . text unless fence_mode . nil? start_address = response . css ( 'StartAddress' ) start_address = start_address . text unless start_address . nil? end_address = response . css ( 'EndAddress' ) end_address = end_address . text unless end_address . nil? { :id => networkId , :name => name , :description => description , :gateway => gateway , :netmask => netmask , :fence_mode => fence_mode , :start_address => start_address , :end_address => end_address } end
1014	def populate galena = CaTissue :: Institution . new ( :name => 'Galena University' ) addr = CaTissue :: Address . new ( :city => 'Galena' , :state => 'Illinois' , :country => 'United States' , :zipCode => '37544' , :street => '411 Basin St' , :phoneNumber => '311-555-5555' ) dept = CaTissue :: Department . new ( :name => 'Pathology' ) crg = CaTissue :: CancerResearchGroup . new ( :name => 'Don Thomas Cancer Center' ) coord = CaTissue :: User . new ( :email_address => 'corey.nator@galena.edu' , :last_name => 'Nator' , :first_name => 'Corey' , :address => addr . copy , :institution => galena , :department => dept , :cancer_research_group => crg ) @hospital = CaTissue :: Site . new ( :site_type => CaTissue :: Site :: SiteType :: COLLECTION , :name => 'Galena Hospital' , :address => addr . copy , :coordinator => coord ) @tissue_bank = CaTissue :: Site . new ( :site_type => CaTissue :: Site :: SiteType :: REPOSITORY , :name => 'Galena Tissue Bank' , :address => addr . copy , :coordinator => coord ) pi = CaTissue :: User . new ( :email_address => 'vesta.gator@galena.edu' , :last_name => 'Gator' , :first_name => 'Vesta' , :address => addr . copy , :institution => galena , :department => dept , :cancer_research_group => crg ) @surgeon = CaTissue :: User . new ( :email_address => 'serge.on@galena.edu' , :first_name => 'Serge' , :last_name => 'On' , :address => addr . copy , :institution => galena , :department => dept , :cancer_research_group => crg ) @protocol = CaTissue :: CollectionProtocol . new ( :title => 'Galena Migration' , :principal_investigator => pi , :sites => [ @tissue_bank ] ) cpe = CaTissue :: CollectionProtocolEvent . new ( :collection_protocol => @protocol , :event_point => 1.0 ) CaTissue :: TissueSpecimenRequirement . new ( :collection_event => cpe , :specimen_type => 'Fixed Tissue' ) @freezer_type = CaTissue :: StorageType . new ( :name => 'Galena Freezer' , :columns => 10 , :rows => 1 , :column_label => 'Rack' ) rack_type = CaTissue :: StorageType . new ( :name => 'Galena Rack' , :columns => 10 , :rows => 10 ) @box_type = CaTissue :: StorageType . new ( :name => 'Galena Box' , :columns => 10 , :rows => 10 ) @freezer_type << rack_type rack_type << @box_type @box_type << 'Tissue' @box = @box_type . new_container ( :name => 'Galena Box 1' ) end
30	def prefix_key_with_namespace ( key , ns_index = nil ) namespace = ( ns_index . nil? ) ? DEFAULT_NAMESPACE : ( "ns%d" % ns_index ) return prefix_key ( key , namespace ) end
922	def audit ( audit_data ) request = create_request ( audit_data ) http = create_http_transport send_request_to_server ( http , request ) end
1195	def runebooks ( summoners , optional = { } ) return { } if summoners . empty? region = optional [ :region ] || @sightstone . region ids = summoners . collect { | summoner | if summoner . is_a? Summoner summoner . id else summoner end } uri = "https://prod.api.pvp.net/api/lol/#{region}/v1.3/summoner/#{ids.join(',')}/runes" response = _get_api_response ( uri ) _parse_response ( response ) { | resp | data = JSON . parse ( resp ) books = { } data . each do | key , raw_book | books [ key ] = RuneBook . new ( raw_book ) end if block_given? yield books else return books end } end
1156	def init_sum_scheme ( sum_scheme ) row_scheme , col_scheme = sum_scheme . split ( ',' ) unless sum_scheme . nil? unless row_scheme . nil? @sum_row_title , @sum_row = row_scheme . split ( ':' ) unless row_scheme . empty? end @sum_row . nil? ? @sum_row = 0 : @sum_row = @sum_row . to_i @sum_row_title = 'Total' if @sum_row_title . nil? col_scheme . nil? ? @sum_col_title = 'Total' : @sum_col_title = col_scheme @sum_col = 0 end
1238	def messages data = api ( 'pm.history' , :receiverid => id ) data [ 'history' ] . map { | attrs | Message . new ( client , attrs ) } end
513	def templates response = get 'templates' response . map { | item | Hashie :: Mash . new ( item ) } end
1056	def add_to_existing_container ( storable ) if storage_type . nil? then raise Jinx :: ValidationError . new ( "Cannot add #{storable.qp} to #{qp} with missing storage type" ) end scs = subcontainers . sort { | sc1 , sc2 | sc1 . position . coordinate <=> sc2 . position . coordinate } logger . debug { "Looking for a #{self} subcontainer from among #{scs.pp_s} to place #{storable.qp}..." } unless scs . empty? sc = scs . detect do | sc | if identifier and sc . identifier == identifier then raise Jinx :: ValidationError . new ( "#{self} has a circular containment reference to subcontainer #{sc}" ) end sc . add_to_existing_container ( storable ) if StorageContainer === sc end if sc then logger . debug { "#{self} subcontainer #{sc} stored #{storable.qp}." } self elsif can_hold_child? ( storable ) then logger . debug { "#{self} can hold #{storable.qp}." } add_local ( storable ) else logger . debug { "Neither #{self} of type #{storage_type.name} nor its subcontainers can hold #{storable.qp}." } nil end end
664	def enumerate ( vendor_id = 0 , product_id = 0 , options = { } ) raise HIDAPI :: HidApiError , 'not initialized' unless @context if vendor_id . is_a? ( Hash ) || ( vendor_id . is_a? ( String ) && options . empty? ) options = vendor_id vendor_id = 0 product_id = 0 end if product_id . is_a? ( Hash ) || ( product_id . is_a? ( String ) && options . empty? ) options = product_id product_id = 0 end if options . is_a? ( String ) || options . is_a? ( Symbol ) options = { as : options } end unless options . nil? || options . is_a? ( Hash ) raise ArgumentError , 'options hash is invalid' end klass = ( options || { } ) . delete ( :as ) || 'HIDAPI::Device' klass = Object . const_get ( klass ) unless klass == :no_mapping filters = { bClass : HID_CLASS } unless vendor_id . nil? || vendor_id . to_i == 0 filters [ :idVendor ] = vendor_id . to_i end unless product_id . nil? || product_id . to_i == 0 filters [ :idProduct ] = product_id . to_i end list = @context . devices ( filters ) if klass != :no_mapping list . to_a . map { | dev | klass . new ( dev ) } else list . to_a end end
1332	def read_hash ( name ) opts = self . class . persisted_attrs [ name ] if ! hashes [ name ] && opts [ :default ] opts [ :default ] else self . send ( "#{name}=" , hashes [ name ] . value ) if hashes [ name ] . is_a? ( Redis :: Future ) hashes [ name ] end end
402	def search_enum ( args , page_size : 100 , additional_headers : { } ) Enumerator . new do | yielder | ( 0 .. Float :: INFINITY ) . step ( page_size ) . each do | index | search_params = args . merge ( start : index . to_i , count : page_size ) results = search ( search_params , additional_headers ) . to_h . fetch ( 'results' , [ ] ) results . each do | result | yielder << result end if results . count < page_size break end end end end
912	def shift return nil if empty? if list_head . last? @_chain . tap { @_chain = nil } else old_head = list_head @_chain = list_head . next old_head . delete end end
473	def redi_search_schema ( schema ) @schema = schema . to_a . flatten @fields = schema . keys @model = self . name . constantize @index_name = @model . to_s @score = 1 end
123	def age list = txns list . empty? ? 0 : ( Time . now - list . min_by ( & :date ) . date ) / ( 60 * 60 ) end
1378	def find_closest_term_color ( pixel_values ) color = "" lil_dist = 195075 @@palette . each do | col_name , col_values | dist = find_distance ( col_values , pixel_values ) if dist < lil_dist lil_dist = dist color = col_name end end color end
146	def worksheet idx case idx when Integer @worksheets [ idx ] when String @worksheets . find do | sheet | sheet . name == idx end end end
1048	def generate make_output_directory files . each do | file | File . write ( "#{@output}/#{File.basename(file, '.*')}.rb" , Steamd :: Generator :: Ruby . new ( file ) . run ) end end
955	def eq ( query_string , options = { :case_sensitive => false } ) do_comparison ( query_string , options ) do | comparator , item | comparator == item end end
1292	def msg ( message , subtitle = message , title = 'NewRelic Management' ) terminal_notification ( message , subtitle ) return if Config . silent osx_notification ( message , subtitle , title ) if OS . x? end
1380	def tree @tree and return @tree @tree = [ ] file_set = version_files while child = file_set . shift tree << child if child . type == "dir" file_set . unshift ( github . where ( child . path ) . contents ) . flatten! end end @tree end
54	def validate ( ) if ! @select . to_s . strip . empty? and @from . to_s . strip . empty? raise 'FROM clause is required with SELECT' end if ! @from . to_s . strip . empty? and @select . to_s . strip . empty? raise 'SELECT clause is required with FROM' end if ! @offset . nil? and @limit . nil? raise 'LIMIT clause is required with OFFSET' end unless @limit . is_a? Integer or @limit . nil? raise 'LIMIT must be an integer' end unless @offset . is_a? Integer or @offset . nil? raise 'OFFSET must be an integer' end end
721	def progress ( message , & block ) spinner = %w[ / \\ | ] . cycle print "\e[90m#{message}... \e[0m" result = observing_thread ( block , 0.5 , 0.1 ) do print "\r\e[90m#{message}... #{spinner.next} \e[0m" end puts "\r\e[90m#{message}... OK\e[0m" result rescue StandardError puts "\r\e[90m#{message}...\e[0m \e[31mFAILED\e[0m" raise end
1083	def parse ( io ) io . rewind raise NotLoadedError , 'load before parsing (#load!)' if @parser . nil? data = strip_comments_and_obsolete_tags! ( io ) @tree = @parser . parse ( data ) raise_parser_error! if @tree . nil? true end
213	def update_folder ( folder_changes ) req = build_soap! do | type , builder | if ( type == :header ) else builder . nbuild . UpdateFolder { builder . nbuild . parent . default_namespace = @default_ns builder . nbuild . FolderChanges { folder_changes . each do | fc | builder [ NS_EWS_TYPES ] . FolderChange { builder . dispatch_folder_id! ( fc ) builder [ NS_EWS_TYPES ] . Updates { } } end } } end end do_soap_request ( req ) end
227	def push_subscribe_folder ( folder , evtypes , url , status_frequency = nil , watermark = nil ) status_frequency ||= 30 psr = { :subscribe_to_all_folders => false , :folder_ids => [ { :id => folder [ :id ] , :change_key => folder [ :change_key ] } ] , :event_types => evtypes , :status_frequency => status_frequency , :uRL => url . to_s } psr [ :watermark ] = watermark if watermark subscribe ( [ { push_subscription_request : psr } ] ) end
1128	def run ( event ) if conditions_match? ( event . data ) event . results . each do | args | begin @block . call ( * args ) rescue StandardError => ex logger . error ( ( [ ex . message ] + ex . backtrace ) * "\n" ) end end true else false end end
1030	def breadcrumbs ( root_depth : 0 , last_page_title : nil , nav_class : 'breadcrumbs' , div_class : 'scrollable' ) return if m . parent_at_depth ( root_depth ) . nil? h . content_tag :nav , class : nav_class do h . concat h . content_tag ( :div , breadcrumbs_ul ( breadcrumbs_list ( root_depth , last_page_title ) ) , class : div_class ) end end
413	def complete ( execution_target , source_commandline = ENV . fetch ( 'COMP_LINE' ) , cursor_position = ENV . fetch ( 'COMP_POINT' ) . to_i ) commandline_processor = CommandlineProcessor . process_commandline ( source_commandline , cursor_position , @switches_definition ) if commandline_processor . completing_an_option? complete_option ( commandline_processor , execution_target ) elsif commandline_processor . parsing_error? return else complete_value ( commandline_processor , execution_target ) end end
33	def time_to_xml_hash ( time ) return { :hour => time . hour , :minute => time . min , :second => time . sec , :date => { :year => time . year , :month => time . month , :day => time . day } } end
214	def empty_folder ( opts ) validate_version ( VERSION_2010_SP1 ) ef_opts = { } [ :delete_type , :delete_sub_folders ] . each do | k | ef_opts [ camel_case ( k ) ] = validate_param ( opts , k , true ) end fids = validate_param opts , :folder_ids , true req = build_soap! do | type , builder | if ( type == :header ) else builder . nbuild . EmptyFolder ( ef_opts ) { | x | builder . nbuild . parent . default_namespace = @default_ns builder . folder_ids! ( fids ) } end end do_soap_request ( req ) end
1223	def [] ( * range ) r , c = range r ||= 0 .. ( nrows - 1 ) c ||= 0 .. ( ncols - 1 ) row_selection = rows . values_at ( * r ) col_selection = [ ] if rows_are_arrays? ( row_selection ) row_selection . each do | row | values = row . values_at ( * c ) col_selection << ( values . respond_to? ( :to_ary ) ? values : [ values ] ) end else col_selection << row_selection [ * c ] end SpreadSheet . new ( * col_selection , row_labels : row_labels . values_at ( * r ) , col_labels : col_labels . values_at ( * c ) ) end
81	def check_for_errors ( response ) if response . code != 200 report_body = response . body check_for_xml_error ( report_body , response . code ) raise AdwordsApi :: Errors :: ReportError . new ( response . code , 'HTTP code: %d, body: %s' % [ response . code , response . body ] ) end return nil end
40	def extract_soap_operations ( full_soap_xml ) doc = Nokogiri :: XML ( full_soap_xml ) operations = doc . css ( 'wsdl|operations' ) operations . attr ( 'xmlns:xsi' , 'http://www.w3.org/2001/XMLSchema-instance' ) operations . each do | element | check_xsi_type ( element ) end return operations . to_s end
645	def border_widths widths = [ ] @borders . each { | entry | widths . push ( entry . nil? ? 0 : entry ) } widths end
609	def login! ( passwd = nil ) self . password = passwd || self . password response = client . login ( username . to_s , password . to_s ) apply_attributes! response . result self . session_token . present? end
224	def camel_case ( input ) input . to_s . split ( / / ) . map { | i | i . sub ( / / ) { | s | s . upcase } } . join end
904	def before return to_enum ( __callee__ ) unless block_given? return if chain_head? item = prev loop do yield item item = item . prev end end
1063	def meta_tag ( attr_name , options = { } ) key = normalize_meta_tag_name ( attr_name ) cached_meta_tags [ key ] ||= self . meta_tags . detect { | t | t . name == key } cached_meta_tags [ key ] ||= self . meta_tags . build ( :name => key ) if options [ :build ] cached_meta_tags [ key ] end
1008	def weekdays_int int = 0 WEEKDAY_KEYS . each . with_index do | day , index | int += 2 ** index if @weekdays [ day ] end int end
1106	def delete ( cv ) @executor . transact do | dbh | sth = dbh . prepare ( DELETE_STMT ) delete_recursive ( cv , sth ) sth . finish end end
139	def protect! password = '' @protected = true password = password . to_s if password . size == 0 @password_hash = 0 else @password_hash = Excel :: Password . password_hash password end end
1065	def add_annotation ( name , opts = { } ) mod_sym = name . camelize . to_sym pkg = opts [ :package ] ||= name . underscore svc = opts [ :service ] ||= name . underscore grp = opts [ :group ] ||= pkg pxy_nm = opts [ :proxy_name ] || "#{self.name.demodulize}RecordEntry" self . annotation_proxy_class_name = pxy_nm @ann_spec_hash ||= { } @ann_spec_hash [ mod_sym ] = opts logger . info ( "Added #{qp} annotation #{name} with module #{mod_sym}, package #{pkg}, service #{svc} and group #{grp}." ) end
1225	def rename ( opts = { } ) if opts [ :rows ] opts [ :rows ] = opts [ :rows ] [ 0 , nrows ] opts [ :rows ] += row_labels [ opts [ :rows ] . size , nrows ] end if opts [ :cols ] opts [ :cols ] = opts [ :cols ] [ 0 , ncols ] opts [ :cols ] += col_labels [ opts [ :cols ] . size , ncols ] end @row_labels = opts [ :rows ] if opts [ :rows ] @col_labels = opts [ :cols ] if opts [ :cols ] end
1321	def run logger . info ( "#{self.class.to_s} is starting." ) count_options = self . class . legacy_find_options . dup count_options . delete ( :order ) count_options . delete ( :group ) count_options . delete ( :limit ) count_options . delete ( :offset ) @num_of_records = self . class . legacy_model . count ( count_options ) if self . class . legacy_find_options [ :limit ] && ( @num_of_records > self . class . legacy_find_options [ :limit ] ) run_in_batches @num_of_records else run_normal end logger . info ( "#{self.class.to_s} migrated all #{@num_of_records} records successfully." ) end
1344	def mapped_key ( map , key ) load_keymap ( map . to_s ) @maps [ map . to_s ] [ handle_composite ( key ) ] end
1395	def find ( * args ) scope = args . slice! ( 0 ) options = args . slice! ( 0 ) || { } @resource_class . find ( scope , options ) end
135	def iterate ( log , farm : Farm :: Empty . new , threads : 1 ) raise 'Log can\'t be nil' if log . nil? raise 'Farm can\'t be nil' if farm . nil? Hands . exec ( threads , all ) do | r , idx | Thread . current . name = "remotes-#{idx}@#{r[:host]}:#{r[:port]}" start = Time . now best = farm . best [ 0 ] node = RemoteNode . new ( host : r [ :host ] , port : r [ :port ] , score : best . nil? ? Score :: ZERO : best , idx : idx , master : master? ( r [ :host ] , r [ :port ] ) , log : log , network : @network ) begin yield node raise 'Took too long to execute' if ( Time . now - start ) . round > @timeout unerror ( r [ :host ] , r [ :port ] ) if node . touched rescue StandardError => e error ( r [ :host ] , r [ :port ] ) if e . is_a? ( RemoteNode :: CantAssert ) || e . is_a? ( Fetch :: Error ) log . debug ( "#{Rainbow(node).red}: \"#{e.message.strip}\" in #{Age.new(start)}" ) else log . info ( "#{Rainbow(node).red}: \"#{e.message.strip}\" in #{Age.new(start)}" ) log . debug ( Backtrace . new ( e ) . to_s ) end remove ( r [ :host ] , r [ :port ] ) if r [ :errors ] > TOLERANCE end end end
91	def extract_header_data ( response ) header_type = get_full_type_signature ( :SoapResponseHeader ) headers = response . header [ :response_header ] . dup process_attributes ( headers , false ) headers = normalize_fields ( headers , header_type [ :fields ] ) return headers end
114	def exists? ( id , body ) DirItems . new ( @dir ) . fetch . each do | f | next unless f . start_with? ( "#{id}-" ) return true if safe_read ( File . join ( @dir , f ) ) == body end false end
853	def on_order supply = find_or_create_supply_detail composite = supply . stock . first if composite . nil? composite = ONIX :: Stock . new supply . stock << composite end composite . on_order end
52	def values ( ) values_array = @values . map do | key , value | raise 'Missing value in StatementBuilder.' if value . nil? raise 'Misconfigured value in StatementBuilder.' unless value . is_a? Hash raise 'Value cannot be nil on StatementBuilder.' if value [ :value ] . nil? raise 'Missing value type for %s.' % key if value [ :xsi_type ] . nil? unless VALUE_TYPES . values . include? ( value [ :xsi_type ] ) raise 'Unknown value type for %s.' % key end if value [ :xsi_type ] == 'SetValue' if value [ :value ] . map { | v | v . class } . to_set . size > 1 raise 'Cannot pass more than one type in set variable, %s.' % key end end if value [ :xsi_type ] == 'DateTimeValue' unless value [ :value ] [ :time_zone_id ] raise 'Missing timezone on DateTimeValue variable, %s.' % key end end { :key => key . to_s ( ) , :value => value } end return values_array end
430	def button ( name , locator ) define_method ( "#{name}" ) do | & block | adapter . button ( locator ) . click & block end define_method ( "#{name}_value" ) do adapter . button ( locator ) . value end define_method ( "#{name}_view" ) do adapter . button ( locator ) . view end end
105	def validate_service_request ( version , service ) unless api_config . has_version ( version ) raise AdsCommon :: Errors :: Error , "Version '%s' not recognized" % version . to_s end unless api_config . version_has_service ( version , service ) raise AdsCommon :: Errors :: Error , "Version '%s' does not contain service '%s'" % [ version . to_s , service . to_s ] end end
361	def or ( value = nil , & block ) return Failure ( block . call ( @value ) ) if failure? && block_given? return Failure ( value ) if failure? return self end
120	def add ( txn ) raise 'The txn has to be of type Txn' unless txn . is_a? ( Txn ) raise "Wallet #{id} can't pay itself: #{txn}" if txn . bnf == id raise "The amount can't be zero in #{id}: #{txn}" if txn . amount . zero? if txn . amount . negative? && includes_negative? ( txn . id ) raise "Negative transaction with the same ID #{txn.id} already exists in #{id}" end if txn . amount . positive? && includes_positive? ( txn . id , txn . bnf ) raise "Positive transaction with the same ID #{txn.id} and BNF #{txn.bnf} already exists in #{id}" end raise "The tax payment already exists in #{id}: #{txn}" if Tax . new ( self ) . exists? ( txn . details ) File . open ( path , 'a' ) { | f | f . print "#{txn}\n" } @txns . flush end
866	def default_app_directories StatDirectory . from_list ( [ %w( Controllers app/controllers ) , %w( Helpers app/helpers ) , %w( Models app/models ) , %w( Mailers app/mailers ) , %w( Javascripts app/assets/javascripts ) , %w( Libraries lib ) , %w( APIs app/apis ) ] , @root ) end
211	def copy_folder ( to_folder_id , * sources ) req = build_soap! do | type , builder | if ( type == :header ) else builder . nbuild . CopyFolder { builder . nbuild . parent . default_namespace = @default_ns builder . to_folder_id! ( to_folder_id ) builder . folder_ids! ( sources . flatten ) } end end do_soap_request ( req ) end
1212	def join_as_series ( options = { } ) if defined? ( I18n ) default_delimiter = I18n . translate ( :' ' , :locale => options [ :locale ] ) default_final_delimiter = I18n . translate ( :' ' , :locale => options [ :locale ] ) default_conjunction = I18n . translate ( :' ' , :locale => options [ :locale ] ) else default_delimiter = ', ' default_final_delimiter = '' default_conjunction = ' and ' end delimiter = options [ :delimiter ] || default_delimiter final_delimiter = options [ :final_delimiter ] || default_final_delimiter conjunction = options [ :conjunction ] || default_conjunction sz = self . size if sz > 0 r = self [ 0 ] if sz > 1 if sz > 2 for i in 1 .. ( sz - 2 ) r += delimiter + self [ i ] end r += final_delimiter end r += conjunction + self [ sz - 1 ] end end return r end
394	def subscribe ( channel , proc = nil , & block ) if cb = proc || block @sub_callbacks [ channel ] << cb end @subs << channel raw_send_command ( :subscribe , [ channel ] ) return pubsub_deferrable ( channel ) end
790	def load_environment ( env = RACK_ENV ) require File . join ( root_path , 'config' , 'environments' , 'default.rb' ) env_file = File . join ( root_path , "config" , "environments" , "#{env}.rb" ) if File . exist? ( env_file ) require env_file else debug_msg = "Environment file: #{env_file} couldn't be found, using only the default environment config instead." unless env == 'development' end unless Object . const_defined? ( :LOGGER ) Object . const_set ( :LOGGER , Logger . new ( $stdout ) ) end LOGGER . debug ( debug_msg ) if debug_msg end
744	def add_file ( type , file ) media [ type ] = [ ] unless media [ type ] media [ type ] << file end
1230	def coerce ( value ) return SpreadSheet . new ( [ value ] ) if value . is_a? ( Numeric ) return SpreadSheet . new ( value ) if value . is_a? ( Array ) end
359	def record_identity ( record ) identity = record . try ( :[] , :id ) || record . try ( :[] , "id" ) || record . try ( :id ) raise "Cannot obtain identity of the #{record}" if identity . blank? { :id => identity } end
984	def labelable_values ( var ) return var . values if var . is_string_var var . values . find_all { | val | val . value . to_s =~ / \- \d / } end
1149	def cp ( froms , to , as : nil , quiet : false ) as ||= @user output = "" synchronize do [ froms ] . flatten . each do | from | if from . is_a? ( String ) to += "/" if to [ - 1 ] != "/" && from . is_a? ( Array ) command = [ "rsync" , "-e" , ssh_command , "-r" ] command += [ * from , "#{as}@#{@address}:#{to}" ] log . trace command . shelljoin , quiet : quiet IO . popen ( command , in : :close , err : %i( child out ) ) do | io | until io . eof? begin output << io . read_nonblock ( 100 ) rescue IO :: WaitReadable IO . select ( [ io ] ) retry end end io . close if ! $? . success? log . fatal "exit status #{$?.exitstatus}: #{command}" , quiet : quiet log . fatal output , quiet : quiet fail "failed to copy files" end end elsif from . respond_to? ( :read ) cmd = "echo #{Base64.strict_encode64(from.read).shellescape} | base64 -d > #{to.shellescape}" sh cmd , quiet : quiet else fail "Don't know how to copy a #{from.class}: #{from}" end end end true end
997	def request ( info , data = "" ) context . instance_eval do xhr ( info [ "method" ] . downcase , info [ "url" ] , data ) @response . body . to_s end end
1162	def leagues ( summoner , optional = { } ) region = optional [ :region ] || @sightstone . region id = if summoner . is_a? Summoner summoner . id else summoner end uri = "https://prod.api.pvp.net/api/lol/#{region}/v2.3/league/by-summoner/#{id}" response = _get_api_response ( uri ) _parse_response ( response ) { | resp | data = JSON . parse ( resp ) leagues = [ ] data . each do | league | leagues << League . new ( league ) end if block_given? yield leagues else return leagues end } end
289	def sign ( tx_template ) return tx_template if @xpubs_by_signer . empty? @xpubs_by_signer . each do | signer_conn , xpubs | tx_template = signer_conn . singleton_batch_request ( '/sign-transaction' , transactions : [ tx_template ] , xpubs : xpubs , ) { | item | Transaction :: Template . new ( item ) } end tx_template end
630	def superscript style = CharacterStyle . new style . superscript = true if block_given? apply ( style ) { | node | yield node } else apply ( style ) end end
985	def update_ttl new_ttl = nil new_ttl = self . _default_expire if new_ttl . nil? new_ttl = - 1 if ! new_ttl . to_i . is_a? ( Fixnum ) || new_ttl . to_i < 0 Ohm . redis . expire ( self . key , new_ttl ) Ohm . redis . expire ( "#{self.key}:_indices" , new_ttl ) end
1240	def boot ( reason = '' ) api ( 'room.boot_user' , :roomid => room . id , :section => room . section , :target_userid => id , :reason => reason ) true end
807	def read_data_chunksize p = FFI :: MemoryPointer . new ( :uint , 1 ) check_result ( Ftdi . ftdi_read_data_get_chunksize ( ctx , p ) ) p . read_uint end
1067	def import_annotation ( name , opts ) logger . debug { "Importing #{qp} annotation #{name}..." } class_eval ( "module #{name}; end" ) mod = const_get ( name ) mod . extend ( Annotation :: Importer ) mod . initialize_annotation ( self , opts ) { | pxy | create_proxy_attribute ( mod , pxy ) } mod end
12	def callback_call setup_phase log :info , 'Callback phase initiated.' @env [ 'omniauth.origin' ] = session . delete ( 'omniauth.origin' ) @env [ 'omniauth.origin' ] = nil if env [ 'omniauth.origin' ] == '' @env [ 'omniauth.params' ] = session . delete ( 'omniauth.params' ) || { } OmniAuth . config . before_callback_phase . call ( @env ) if OmniAuth . config . before_callback_phase callback_phase end
1249	def translations :: I18n . load_path = default_locales_path :: I18n . backend . instance_eval do init_translations unless initialized? translations end end
1287	def daemon ENV [ 'TZ' ] = 'UTC' if OS . windows? && ! ENV [ 'TZ' ] scheduler = Rufus :: Scheduler . new Notifier . msg ( 'Daemonizing Process' ) alerts_interval = Config . alert_management_interval scheduler . every alerts_interval , overlap : false do Manager . manage_alerts end if Config . cleanup cleanup_interval = Config . cleanup_interval cleanup_age = Config . cleanup_age scheduler . every cleanup_interval , overlap : false do Manager . remove_nonreporting_servers ( cleanup_age ) end end scheduler . join end
1187	def load ( options = { } ) assert_valid_keys ( options , :minimal ) options = { :minimal => false } . merge ( options ) data = api ( 'playlist.all' , options ) self . attributes = data super ( ) end
187	def contacts_view! ( con_view ) attribs = { } con_view . each_pair { | k , v | attribs [ camel_case ( k ) ] = v . to_s } @nbuild [ NS_EWS_MESSAGES ] . ContactsView ( attribs ) end
1326	def parse_config ( conffile = nil ) conffile ||= Dir . glob ( [ "/etc/foreman_hooks-host_rename/settings.yaml" , "#{confdir}/settings.yaml" ] ) [ 0 ] raise "Could not locate the configuration file" if conffile . nil? config = { hook_user : 'foreman' , database_path : '/var/tmp/foreman_hooks-host_rename.db' , log_path : '/var/tmp/foreman_hooks-host_rename.log' , log_level : 'warn' , rename_hook_command : '/bin/true' , } . merge ( symbolize ( YAML . load ( File . read ( conffile ) ) ) ) config . each do | k , v | instance_variable_set ( "@#{k}" , v ) end document = Kwalify :: Yaml . load_file ( conffile ) schema = Kwalify :: Yaml . load_file ( "#{confdir}/schema.yaml" ) validator = Kwalify :: Validator . new ( schema ) errors = validator . validate ( document ) if errors && ! errors . empty? puts "WARNING: The following errors were found in #{conffile}:" for e in errors puts "[#{e.path}] #{e.message}" end raise "Errors in the configuration file" end check_script @rename_hook_command end
263	def for_host ( host ) if @dirty . include? ( host ) values = [ ] cookies_for_host ( host ) . each do | name , value | values << "#{name}=#{value}" end @cookies [ host ] = values . join ( '; ' ) @dirty . delete ( host ) end return @cookies [ host ] end
1339	def nethash interval = 500 , start = 0 , stop = false suffixe = stop ? "/#{stop}" : '' JSON . parse ( call_blockchain_api ( "nethash/#{interval}/#{start}#{suffixe}?format=json" ) ) end
1302	def validate ( value , format , raise_error = false ) unless FORMATS . key? ( format ) raise FormatError , "Invalid data format: #{format}" end result = value =~ FORMATS [ format ] ? true : false if raise_error && ! result raise ValidationError , "Invalid value \"#{value}\" for #{format}" end result end
422	def find ( file , paths ) if ( Pathname . new ( file ) . absolute? ) return unless ( timestamp = mtime ( file ) ) @logger . debug ( "Found #{file}" ) [ file , timestamp ] else paths . each do | path | fullpath = File . expand_path ( ( File . join ( path , file ) ) ) next unless ( timestamp = mtime ( fullpath ) ) @logger . debug ( "Found #{file} in #{fullpath}" ) return ( [ fullpath , timestamp ] ) end return ( nil ) end end
1239	def stalk become_fan unless client . user . fan_of . include? ( self ) client . rooms . with_friends . detect do | room | room . listener ( id ) end end
849	def subtitle = ( str ) composite = product . titles . first if composite . nil? composite = ONIX :: Title . new composite . title_type = 1 product . titles << composite end composite . subtitle = str end
930	def selenium_driver ( browser , browser_options ) target , options = browser_caps ( browser , browser_options ) create_selenium_driver ( target , options ) end
918	def each_item return to_enum ( __method__ ) { count } unless block_given? return if empty? item = list_head loop do yield item item = item . next end end
682	def compose_vapp_from_vm ( vdc , vapp_name , vapp_description , vm_list = { } , network_config = { } ) builder = Nokogiri :: XML :: Builder . new do | xml | xml . ComposeVAppParams ( "xmlns" => "http://www.vmware.com/vcloud/v1.5" , "xmlns:ovf" => "http://schemas.dmtf.org/ovf/envelope/1" , "name" => vapp_name ) { xml . Description vapp_description xml . InstantiationParams { xml . NetworkConfigSection { xml [ 'ovf' ] . Info "Configuration parameters for logical networks" xml . NetworkConfig ( "networkName" => network_config [ :name ] ) { xml . Configuration { xml . IpScopes { xml . IpScope { xml . IsInherited ( network_config [ :is_inherited ] || "false" ) xml . Gateway network_config [ :gateway ] xml . Netmask network_config [ :netmask ] xml . Dns1 network_config [ :dns1 ] if network_config [ :dns1 ] xml . Dns2 network_config [ :dns2 ] if network_config [ :dns2 ] xml . DnsSuffix network_config [ :dns_suffix ] if network_config [ :dns_suffix ] xml . IpRanges { xml . IpRange { xml . StartAddress network_config [ :start_address ] xml . EndAddress network_config [ :end_address ] } } } } xml . ParentNetwork ( "href" => "#{@api_url}/network/#{network_config[:parent_network]}" ) xml . FenceMode network_config [ :fence_mode ] xml . Features { xml . FirewallService { xml . IsEnabled ( network_config [ :enable_firewall ] || "false" ) } if network_config . has_key? :nat_type xml . NatService { xml . IsEnabled "true" xml . NatType network_config [ :nat_type ] xml . Policy ( network_config [ :nat_policy_type ] || "allowTraffic" ) } end } } } } } vm_list . each do | vm_name , vm_id | xml . SourcedItem { xml . Source ( "href" => "#{@api_url}/vAppTemplate/vm-#{vm_id}" , "name" => vm_name ) xml . InstantiationParams { xml . NetworkConnectionSection ( "xmlns:ovf" => "http://schemas.dmtf.org/ovf/envelope/1" , "type" => "application/vnd.vmware.vcloud.networkConnectionSection+xml" , "href" => "#{@api_url}/vAppTemplate/vm-#{vm_id}/networkConnectionSection/" ) { xml [ 'ovf' ] . Info "Network config for sourced item" xml . PrimaryNetworkConnectionIndex "0" xml . NetworkConnection ( "network" => network_config [ :name ] ) { xml . NetworkConnectionIndex "0" xml . IsConnected "true" xml . IpAddressAllocationMode ( network_config [ :ip_allocation_mode ] || "POOL" ) } } } xml . NetworkAssignment ( "containerNetwork" => network_config [ :name ] , "innerNetwork" => network_config [ :name ] ) } end xml . AllEULAsAccepted "true" } end params = { "method" => :post , "command" => "/vdc/#{vdc}/action/composeVApp" } response , headers = send_request ( params , builder . to_xml , "application/vnd.vmware.vcloud.composeVAppParams+xml" ) vapp_id = headers [ :location ] . gsub ( / \/ \/ \- / , "" ) task = response . css ( "VApp Task[operationName='vdcComposeVapp']" ) . first task_id = task [ "href" ] . gsub ( / \/ \/ / , "" ) { :vapp_id => vapp_id , :task_id => task_id } end
635	def table ( rows , columns , * widths ) node = TableNode . new ( self , rows , columns , * widths ) yield node if block_given? store ( node ) node end
860	def other_text_set ( type , value ) text = other_text ( type ) if text . nil? text = ONIX :: OtherText . new text . text_type_code = type product . text << text end text . text = value . to_s end
1362	def optional_args_block_call ( block , args ) if RUBY_VERSION >= "1.9.0" if block . arity == 0 block . call else block . call ( * args ) end else block . call ( * args ) end end
318	def max_id_from ( s ) if ! s . respond_to? ( :max ) if s . respond_to? ( :id ) return s . id else return s end end sorted = s . max { | a , b | a . id . to_i <=> b . id . to_i } sorted && sorted . id end
578	def update_setting ( setting , value , options = { } ) response = connection . post do | req | req . url "settings/#{setting}/set" , { :value => value } . merge ( options ) end return_error_or_body ( response , response . body . response ) end
1375	def post_with_signature ( opts ) path = opts . fetch ( :path ) payload = opts . fetch ( :payload ) secret = opts . fetch ( :secret ) post path , { payload : payload } , generate_secret_header ( secret , URI . encode_www_form ( payload : payload ) ) end
1049	def reset! self . api_key = DEFAULT_API_KEY self . api_secret = DEFAULT_API_SECRET self . adapter = DEFAULT_ADAPTER self . endpoint = DEFAULT_ENDPOINT self . user_agent = DEFAULT_USER_AGENT self . format = DEFAULT_FORMAT self . max = DEFAULT_MAX self . related_entities = DEFAULT_RELATED_ENTITIES self . show_metadata = DEFAULT_SHOW_METADATA self . enable_categorizer = DEFAULT_ENABLE_CATEGORIZER self . unique = DEFAULT_UNIQUE self end
983	def change_column ( table_name , column_name , type , options = { } ) change_column_sql = "ALTER TABLE #{quote_table_name(table_name)} " << "ADD #{quote_column_name(column_name)} #{type_to_sql(type, options[:limit])}" add_column_options! ( change_column_sql , options ) execute ( change_column_sql ) end
767	def assign_tp_self_caches ( tp_ins ) unless tp_self_caches . find { | tp_cache | tp_cache . object_id . equal? tp_ins . self . object_id } tp_self_caches . push tp_ins . self end end
1029	def tree ( root_depth : 1 , sitemap : false , nav_class : 'tree' ) return if m . parent_at_depth ( root_depth ) . nil? @sitemap = sitemap h . content_tag :nav , class : nav_class do h . concat render_tree_master_ul ( m . parent_at_depth ( root_depth ) ) end end
525	def update ( new_email_address , name ) options = { :query => { :email => @email_address } , :body => { :EmailAddress => new_email_address , :Name => name } . to_json } put '/admins.json' , options @email_address = new_email_address end
73	def download_report_as_stream_with_awql ( report_query , format , cid = nil , & block ) return get_report_response_with_awql ( report_query , format , cid , & block ) end
237	def fields_with_locales remapped_fields = { } locales . each do | locale | fields ( locale ) . each do | name , value | remapped_fields [ name ] ||= { } remapped_fields [ name ] [ locale . to_sym ] = value end end remapped_fields end
1236	def original_pivot_sequence_heading ( heading . sort - col_filter . pivot . keys << col_filter . pivot . keys ) . flatten end
929	def watir_browser ( browser , browser_options ) target , options = browser_caps ( browser , browser_options ) create_watir_browser ( target , options ) end
156	def create_many! ( client , attributes_array , association = Association . new ( :class => self ) ) response = client . connection . post ( "#{association.generate_path}/create_many" ) do | req | req . body = { resource_name => attributes_array } yield req if block_given? end JobStatus . new_from_response ( client , response ) end
534	def page_venues ( page_id , options = { } ) response = connection . get do | req | req . url "pages/#{page_id}/venues" , options end venues = return_error_or_body ( response , response . body . response . venues ) venues = Foursquare2 . filter ( venues , options [ :query ] ) if options . has_key? :query venues end
592	def distinct ( field ) if field . nil? == false && field . respond_to? ( :to_s ) old_count_value = @count @count = nil compile_query = compile compile_query [ :distinct ] = Query . format_field ( field ) . to_sym @count = old_count_value return client . aggregate_objects ( @table , compile_query . as_json , _opts ) . result else raise ArgumentError , "Invalid field name passed to `distinct`." end end
69	def should_log_summary ( level , is_fault ) return level <= Logger :: WARN if is_fault return level <= Logger :: INFO end
901	def option ( opt ) opt = opt . to_sym options . each do | op | if op . short === opt or op . long === opt return op . value end end end
1084	def imports raise StreamNotParsed , 'you must parse first' if @tree . nil? imports = statements . select do | node | node . is_a? ( ImportStatement ) end imports . map ( & :to_hash ) end
386	def prettify ( xml ) result = '' formatter = REXML :: Formatters :: Pretty . new indent formatter . compact = compact doc = REXML :: Document . new xml formatter . write doc , result result end
890	def resolve_foreign_keys ( object , map ) object . foreign_keys . each do | property | value = object [ property ] if value if map . key? ( value ) object [ property ] = map [ value ] else raise Errors :: MissingDatabaseIdError , "couldn't resolve foreign key: #{property} #{value}" end end end end
593	def fetch! ( compiled_query ) response = client . find_objects ( @table , compiled_query . as_json , _opts ) if response . error? puts "[ParseQuery] #{response.error}" end response end
671	def read_timeout ( milliseconds ) raise DeviceNotOpen unless open? mutex . synchronize do if input_reports . count > 0 data = input_reports . delete_at ( 0 ) HIDAPI . debug "read data from device #{path}: #{data.inspect}" return data end if shutdown_thread HIDAPI . debug "read thread for device #{path} is not running" return nil end end return '' if milliseconds == 0 if milliseconds < 0 until shutdown_thread mutex . synchronize do if input_reports . count > 0 data = input_reports . delete_at ( 0 ) HIDAPI . debug "read data from device #{path}: #{data.inspect}" return data end end sleep 0.001 end HIDAPI . debug "read thread ended while waiting on device #{path}" nil else stop_at = Time . now + ( milliseconds * 0.001 ) while Time . now < stop_at mutex . synchronize do if input_reports . count > 0 data = input_reports . delete_at ( 0 ) HIDAPI . debug "read data from device #{path}: #{data.inspect}" return data end end sleep 0.001 end '' end end
537	def user_requests ( options = { } ) response = connection . get do | req | req . url "users/requests" , options end return_error_or_body ( response , response . body . response . requests ) end
782	def find_user_by_email ( email ) response = oauth_access_token . get ( '/v1/users' , params : { email : email } ) user = response . parsed . first if user user = User . new ( user ) end user end
1028	def wait ( & block ) fiber = Fiber . current allow_resume = true block . call do | * args | fiber . resume ( * args ) if allow_resume end begin Fiber . yield rescue FiberError => ex allow_resume = false raise Error , 'Turntabler APIs cannot be called from root fiber; use Turntabler.run { ... } instead' end end
455	def create_scanner ( start_row = nil , end_row = nil , * columns , & block ) columns = ( columns . length > 0 ) ? columns : column_families . keys sid = call :scannerOpenWithStop , start_row . to_s , end_row . to_s , columns Scanner . new @client , sid , & block end
960	def ne ( query_string , options = { :case_sensitive => false } ) do_comparison ( query_string , options ) do | comparator , item | comparator != item end end
471	def save return false unless valid? self . last_result_set = if persisted? self . class . requestor . update ( self ) else self . class . requestor . create ( self ) end if last_result_set . has_errors? fill_errors false else self . errors . clear if self . errors mark_as_persisted! if updated = last_result_set . first self . attributes = updated . attributes self . links . attributes = updated . links . attributes self . relationships . attributes = updated . relationships . attributes clear_changes_information end true end end
100	def check_array_collapse ( data , field_def ) result = data if ! field_def [ :min_occurs ] . nil? && ( field_def [ :max_occurs ] == :unbounded || ( ! field_def [ :max_occurs ] . nil? && field_def [ :max_occurs ] > 1 ) ) && ! ( field_def [ :type ] =~ / / ) result = arrayize ( result ) end return result end
675	def delta ( other_audit ) return self . change_log if other_audit . nil? { } . tap do | d | ( self . change_log . keys - other_audit . change_log . keys ) . each do | k | d [ k ] = [ nil , self . change_log [ k ] ] end ( other_audit . change_log . keys - self . change_log . keys ) . each do | k | d [ k ] = [ other_audit . change_log [ k ] , nil ] end self . change_log . keys . each do | k | if self . change_log [ k ] != other_audit . change_log [ k ] d [ k ] = [ other_audit . change_log [ k ] , self . change_log [ k ] ] end end end end
981	def _execute ( sql , name = nil ) if self . class . select? ( sql ) result = @connection . execute_query ( sql ) result . map! do | r | new_hash = { } r . each_pair do | k , v | new_hash . merge! ( { k . downcase => v } ) end new_hash end if self . class . lowercase_schema_reflection result elsif self . class . insert? ( sql ) ( @connection . execute_insert ( sql ) || last_insert_id ( _table_name_from_insert ( sql ) ) ) . to_i else @connection . execute_update ( sql ) end end
566	def special ( special_id , options = { } ) response = connection . get do | req | req . url "specials/#{special_id}" , options end return_error_or_body ( response , response . body . response . special ) end
588	def save unless saved? || @contents . nil? || @name . nil? response = client . create_file ( @name , @contents , @mime_type ) unless response . error? result = response . result @name = result [ FIELD_NAME ] || File . basename ( result [ FIELD_URL ] ) @url = result [ FIELD_URL ] end end saved? end
358	def records_identities ( records ) records = [ records ] unless records . respond_to? ( :map ) records . map { | record | record_identity ( record ) } end
829	def verify_required! @key_metadata . required_properties . each do | key_name | next if @source . key? ( @key_metadata . get ( key_name ) . source_key ) raise RequiredAttribute , "#{@parent} requires `#{key_name}`" end end
317	def get_api_key green "****************************************" green "****************************************" green "**** API SETUP TIME! ****" green "****************************************" green "****************************************" puts "\n\nWelcome to Chatterbot. Let's walk through the steps to get a bot running.\n\n" puts "Hey, looks like you need to get an API key from Twitter before you can get started.\n\n" app_already_exists = ask_yes_no ( "Have you already set up an app with Twitter?" ) if app_already_exists puts "Terrific! Let's get your bot running!\n\n" else puts "OK, I can help with that!\n\n" send_to_app_creation end print "\n\nPaste the 'Consumer Key' here: " STDOUT . flush config [ :consumer_key ] = STDIN . readline . chomp . strip print "Paste the 'Consumer Secret' here: " STDOUT . flush config [ :consumer_secret ] = STDIN . readline . chomp . strip puts "\n\nNow it's time to authorize your bot!\n\n" if ! app_already_exists && ask_yes_no ( "Do you want to authorize a bot using the account that created the app?" ) puts "OK, on the app page, you can click the 'Create my access token' button to proceed.\n\n" print "Paste the 'Access Token' here: " STDOUT . flush config [ :access_token ] = STDIN . readline . chomp . strip print "\n\nPaste the 'Access Token Secret' here: " STDOUT . flush config [ :access_token_secret ] = STDIN . readline . chomp . strip reset_client @screen_name = client . user . screen_name rescue nil else reset_client end rescue Interrupt => e exit end
437	def tree_view ( name , locator ) define_method ( "#{name}" ) do adapter . tree_view ( locator ) . value end define_method ( "#{name}=" ) do | which_item | adapter . tree_view ( locator ) . select which_item end define_method ( "#{name}_items" ) do adapter . tree_view ( locator ) . items end define_method ( "expand_#{name}_item" ) do | which_item | adapter . tree_view ( locator ) . expand which_item end define_method ( "collapse_#{name}_item" ) do | which_item | adapter . tree_view ( locator ) . collapse which_item end define_method ( "#{name}_view" ) do adapter . tree_view ( locator ) . view end end
39	def get_job_results ( batch_job_url ) @api . utils_reporter . batch_job_utils_used ( ) xml_response = AdsCommon :: Http . get_response ( batch_job_url , @api . config ) begin return sanitize_result ( get_nori ( ) . parse ( xml_response . body ) [ :mutate_response ] [ :rval ] ) rescue return nil end end
885	def load_scraped_object ( properties ) type = properties [ '_type' ] || properties [ :_type ] if type type . camelize . constantize . new ( properties ) else raise Errors :: MissingObjectTypeError , "missing _type: #{JSON.dump(properties)}" end end
344	def requested_method params [ '_method' . freeze ] = ( params [ '_method' . freeze ] || request . request_method . downcase ) . to_sym self . class . _pl_params2method ( params , request . env ) end
448	def get ( from , to = nil , overwrite = false , raise = true ) tempfile = Tempfile . new to ||= tempfile . path tempfile . unlink if ! overwrite && File . exist? ( to ) raise Client :: RuntimeError , "File [#{to}] already exist locally" end from = '"' + from + '"' if from . include? ' ' exec 'get ' + from + ' ' + to to rescue Client :: RuntimeError => e raise e if raise false end
846	def each ( & block ) @reader . each do | node | if @reader . node_type == 1 && @reader . name == "Product" str = @reader . outer_xml if str . nil? yield @product_klass . new else yield @product_klass . from_xml ( str ) end end end end
1214	def meta = val val = JSON . parse ( val ) if val . is_a? ( String ) write_store_attribute ( :data , :meta , val ) end
74	def get_stream_helper_with_awql ( report_query , format , cid = nil ) return AdwordsApi :: ReportStream . set_up_with_awql ( self , report_query , format , cid ) end
363	def range ( start , limit , ratio : 8 ) check_greater ( start , 0 ) check_greater ( limit , start ) check_greater ( ratio , 2 ) items = [ ] count = start items << count ( limit / ratio ) . times do count *= ratio break if count >= limit items << count end items << limit if start != limit items end
681	def create_vapp_from_template ( vdc , vapp_name , vapp_description , vapp_templateid , poweron = false ) builder = Nokogiri :: XML :: Builder . new do | xml | xml . InstantiateVAppTemplateParams ( "xmlns" => "http://www.vmware.com/vcloud/v1.5" , "xmlns:xsi" => "http://www.w3.org/2001/XMLSchema-instance" , "xmlns:ovf" => "http://schemas.dmtf.org/ovf/envelope/1" , "name" => vapp_name , "deploy" => "true" , "powerOn" => poweron ) { xml . Description vapp_description xml . Source ( "href" => "#{@api_url}/vAppTemplate/#{vapp_templateid}" ) } end params = { "method" => :post , "command" => "/vdc/#{vdc}/action/instantiateVAppTemplate" } response , headers = send_request ( params , builder . to_xml , "application/vnd.vmware.vcloud.instantiateVAppTemplateParams+xml" ) vapp_id = headers [ :location ] . gsub ( / \/ \/ \- / , "" ) task = response . css ( "VApp Task[operationName='vdcInstantiateVapp']" ) . first task_id = task [ "href" ] . gsub ( / \/ \/ / , "" ) { :vapp_id => vapp_id , :task_id => task_id } end
1313	def required_field_helper ( model , element , html ) if model && ! model . errors . empty? && element . is_required return content_tag ( :div , html , :class => 'fieldWithErrors' ) else return html end end
732	def load_formatter_files ( local_path : LOCAL_FORMATTER_PATH ) paths = Rescuetime . configuration . formatter_paths << local_path paths . each do | path | Dir [ File . expand_path ( path , __FILE__ ) ] . each { | file | require file } end end
1252	def download_files if ! File . exists? ( STATUS_FILE_PATH ) or File . mtime ( STATUS_FILE_PATH ) < Time . now - STATUS_DOWNLOAD_INTERVAL download_to_file STATUS_URL , STATUS_FILE_PATH end if ! File . exists? ( DATA_FILE_PATH ) or File . mtime ( DATA_FILE_PATH ) < Time . now - DATA_DOWNLOAD_INTERVAL download_to_file random_data_url , DATA_FILE_PATH end end
249	def handle_destination destination_existed = File . exist? ( destination ) yield rescue File . delete ( destination ) if File . exist? ( destination ) && ! destination_existed raise end
1311	def crud_links ( model , instance_name , actions , args = { } ) _html = "" _options = args . keys . empty? ? '' : ", #{args.map{|k,v| ":#{k} => #{v}"}}" if use_crud_icons if actions . include? ( :show ) _html << eval ( "link_to image_tag('/images/icons/view.png', :class => 'crud_icon'), model, :title => 'View'#{_options}" ) end if actions . include? ( :edit ) _html << eval ( "link_to image_tag('/images/icons/edit.png', :class => 'crud_icon'), edit_#{instance_name}_path(model), :title => 'Edit'#{_options}" ) end if actions . include? ( :delete ) _html << eval ( "link_to image_tag('/images/icons/delete.png', :class => 'crud_icon'), model, :confirm => 'Are you sure? This action cannot be undone.', :method => :delete, :title => 'Delete'#{_options}" ) end else if actions . include? ( :show ) _html << eval ( "link_to 'View', model, :title => 'View', :class => 'crud_link'#{_options}" ) end if actions . include? ( :edit ) _html << eval ( "link_to 'Edit', edit_#{instance_name}_path(model), :title => 'Edit', :class => 'crud_link'#{_options}" ) end if actions . include? ( :delete ) _html << eval ( "link_to 'Delete', model, :confirm => 'Are you sure? This action cannot be undone.', :method => :delete, :title => 'Delete', :class => 'crud_link'#{_options}" ) end end _html end
1197	def collect ( opts ) raise Jinx :: ValidationError . new ( "#{self} is already collected" ) if received? specimen_event_parameters . merge! ( extract_event_parameters ( opts ) ) end
1255	def cachier! ( var = nil ) if var && instance_variable_get ( "@#{var}" ) remove_instance_variable ( "@#{var}" ) else instance_variables . each { | x | remove_instance_variable ( x ) } end end
874	def set ( x , y , r , g , b ) check_coords ( x , y ) self [ x , y ] = Color . new ( r , g , b ) end
1295	def generate ( string ) x = [ ] @fst . _generate ( string ) { | a | x << a . join } x end
795	def lookup_check ( name , options ) check_class_name = "#{name.to_s.gsub(/(^|_)([a-z])/){|m| m.sub('_', '').upcase}}Check" check = nil if IsItWorking . const_defined? ( check_class_name ) check_class = IsItWorking . const_get ( check_class_name ) check = check_class . new ( options ) else raise ArgumentError . new ( "Check not defined #{check_class_name}" ) end check end
276	def every_xml_doc every_page do | page | if ( block_given? && page . xml? ) if ( doc = page . doc ) yield doc end end end end
1203	def equal_type ( type , value , args , block ) filter_size_before = filter . size equal ( value , args , block ) types << type if filter_size_before < filter . size end
1177	def write_to_file File . open ( outfile , 'w' ) do | out | out . puts header . to_s out . puts create_sum_row if @sum_row_pos == 'TOP' rows . each do | key , row | line = [ ] << row [ :key ] header . clear_header_cols . each_with_index do | col , index | next if index < row [ :key ] . size line << row [ :cols ] [ col ] end out . puts line . flatten . join ( ';' ) end out . puts create_sum_row if @sum_row_pos == 'EOF' end end
632	def font ( font , size = nil ) style = CharacterStyle . new style . font = font style . font_size = size root . fonts << font if block_given? apply ( style ) { | node | yield node } else apply ( style ) end end
166	def render ( path_or_options , locals = { } ) if path_or_options . respond_to? ( :keys ) render_erb ( path_or_options [ :file ] || path_or_options [ :partial ] , path_or_options [ :locals ] ) else render_erb ( path_or_options , locals ) end end
824	def validate_ipv6_addr ( value ) ipaddr = IPAddr . new ( value ) unless ipaddr . ipv6? raise ValidationError , "IP address '#{value}' is not IPv6" end ipaddr rescue ArgumentError => e raise ValidationError , "invalid IPv6 address '#{value}' - #{e.message}" end
1141	def execute result = eval ( operation ) if outfile if result . is_a? ( SpreadSheet ) result . write ( outfile ) else puts puts "Warning: Result is no spread sheet and not written to file!" puts " To view the result use -p flag" unless print end end if print puts puts "Operation" puts "---------" operation . split ( ';' ) . each { | o | puts o } puts puts "Result" puts "------" if result . nil? || result . empty? puts result . inspect else puts result end puts end end
305	def secret ( s ) bot . deprecated "Setting access_token_secret outside of your config file is deprecated!" , Kernel . caller . first bot . config [ :access_token_secret ] = s end
837	def []= ( key , value ) case value when String string ( key , equal_to : value . to_s ) else any ( key , equal_to : value . to_s ) end end
844	def keywords ( limit = 20 ) @keywords ||= { } @keywords [ limit ] ||= begin list = [ ] count = 0 _stopwords = Vidibus :: Words . stopwords ( * locales ) for word in sort clean = word . permalink . gsub ( '-' , '' ) unless _stopwords . include? ( clean ) list << word count += 1 break if count >= limit end end list end end
1356	def discard ordered = player . hand . map do | card | i = card_preference . map { | preference | card . type == preference } . index ( true ) { card : card , index : i } end ordered . sort_by { | h | h [ :index ] || 99 } . last . try ( :fetch , :card ) end
1024	def reset_keepalive ( interval = 10 ) if ! @keepalive_timer || @keepalive_interval != interval @keepalive_interval = interval @keepalive_timer . cancel if @keepalive_timer @keepalive_timer = EM :: Synchrony . add_periodic_timer ( interval ) do Turntabler . run { user . update ( :status => user . status ) } end end end
932	def extract_values_from ( browser_string ) browser = extract_browser ( browser_string ) . to_sym version = extract_version ( browser_string ) platform = extract_platform ( browser_string ) device = extract_device ( browser_string ) return browser , version , platform , device end
1377	def create_color_string ( 0 ... img . height ) . map do | y | ( 0 ... img . width ) . map do | x | pix = self . img [ x , y ] pix_vals = [ r ( pix ) , g ( pix ) , b ( pix ) ] find_closest_term_color ( pix_vals ) end end . join end
352	def assign_full_row_version_attr ( full_row_version_attr , attributes , data ) if attributes [ full_row_version_attr ] && data [ full_row_version_attr ] data [ full_row_version_attr ] = attributes [ full_row_version_attr ] if attributes [ full_row_version_attr ] > data [ full_row_version_attr ] elsif attributes [ full_row_version_attr ] && ! data [ full_row_version_attr ] data [ full_row_version_attr ] = attributes [ full_row_version_attr ] end end
3	def stringify_headers headers headers . inject ( { } ) do | result , ( key , value ) | if key . is_a? Symbol key = key . to_s . split ( / / ) . map ( & :capitalize ) . join ( '-' ) end if 'CONTENT-TYPE' == key . upcase result [ key ] = maybe_convert_extension ( value . to_s ) elsif 'ACCEPT' == key . upcase if value . is_a? Array target_values = value else target_values = value . to_s . split ',' end result [ key ] = target_values . map { | ext | maybe_convert_extension ( ext . to_s . strip ) } . join ( ', ' ) else result [ key ] = value . to_s end result end end
605	def batch_responses return [ @result ] unless @batch_response @result . map do | r | next r unless r . is_a? ( Hash ) hash = r [ SUCCESS ] || r [ ERROR ] Parse :: Response . new hash end end
162	def apply! ( ticket = nil ) path = "#{self.path}/apply" if ticket path = "#{ticket.path}/#{path}" end response = @client . connection . get ( path ) SilentMash . new ( response . body . fetch ( "result" , { } ) ) end
1066	def load_local_annotations return Array :: EMPTY_ARRAY if @ann_spec_hash . nil? initialize_annotation_holder @ann_spec_hash . map { | name , opts | import_annotation ( name , opts ) } end
584	def << ( * list ) if list . count > 0 notify_will_change! list . flatten . each { | e | collection . push ( e ) } end end
713	def get_tasks_list ( id ) params = { 'method' => :get , 'command' => "/tasksList/#{id}" } response , headers = send_request ( params ) tasks = [ ] response . css ( 'Task' ) . each do | task | id = task [ 'href' ] . gsub ( / \/ \/ / , "" ) operation = task [ 'operationName' ] status = task [ 'status' ] error = nil error = task . css ( 'Error' ) . first [ 'message' ] if task [ 'status' ] == 'error' start_time = task [ 'startTime' ] end_time = task [ 'endTime' ] user_canceled = task [ 'cancelRequested' ] == 'true' tasks << { :id => id , :operation => operation , :status => status , :error => error , :start_time => start_time , :end_time => end_time , :user_canceled => user_canceled } end tasks end
569	def trending_venues ( ll , options = { } ) options [ :ll ] = ll response = connection . get do | req | req . url "venues/trending" , options end return_error_or_body ( response , response . body . response ) end
831	def response response = Net :: HTTP . get_response ( @uri ) if response . is_a? Net :: HTTPRedirection response = Net :: HTTP . get_response ( URI . parse ( response [ 'location' ] ) ) end fail ResponseError , response . code unless response . is_a? Net :: HTTPSuccess response end
104	def save_oauth2_token ( token ) raise AdsCommon :: Errors :: Error , "Can't save nil token" if token . nil? AdsCommon :: Utils . save_oauth2_token ( File . join ( ENV [ 'HOME' ] , api_config . default_config_filename ) , token ) end
1237	def process ( object , options = { } ) object = unstring ( object ) return object unless has_filter? filtered = ! filter . flatten . uniq . index ( options [ :row ] ) . nil? pattern . each do | p | filtered = ( filtered or ! ( object =~ Regexp . new ( p ) ) . nil? ) end filtered = ( filtered or match_boolean_filter? ( object . split ( ';' ) ) ) filtered ? object : nil end
990	def update ( options = { } , existing_rules = [ ] ) request = Net :: HTTP :: Put . new ( URI . join ( @base_uri . to_s , "cloudlets/api/v2/policies/#{@policy_id}/versions/#{@version_id}?omitRules=false&matchRuleFormat=1.0" ) . to_s , { 'Content-Type' => 'application/json' } ) rules = generate_path_rules ( options ) + generate_cookie_rules ( options ) + existing_rules if rules . empty? puts "No rules to apply, please check syntax" return end request . body = { matchRules : rules } . to_json response = @http_host . request ( request ) response . body end
365	def fit_logarithmic ( xs , ys ) fit ( xs , ys , tran_x : -> ( x ) { Math . log ( x ) } ) end
1011	def weekdays_field ( attribute , options = { } ) db_field = options [ :db_field ] || attribute . to_s + '_bit_array' self . composed_of ( attribute , :class_name => "::Timely::WeekDays" , :mapping => [ [ db_field , 'weekdays_int' ] ] , :converter => Proc . new { | field | :: Timely :: WeekDays . new ( field ) } ) end
290	def sign_batch ( tx_templates ) if @xpubs_by_signer . empty? successes = tx_templates . each_with_index . reduce ( { } ) do | memo , ( t , i ) | memo [ i ] = t memo end BatchResponse . new ( successes : successes ) end orig_index = ( 0 ... tx_templates . size ) . to_a errors = { } @xpubs_by_signer . each do | signer_conn , xpubs | next_tx_templates = [ ] next_orig_index = [ ] batch = signer_conn . batch_request ( '/sign-transaction' , transactions : tx_templates , xpubs : xpubs , ) { | item | Transaction :: Template . new ( item ) } batch . successes . each do | i , template | next_tx_templates << template next_orig_index << orig_index [ i ] end batch . errors . each do | i , err | errors [ orig_index [ i ] ] = err end tx_templates = next_tx_templates orig_index = next_orig_index break if tx_templates . empty? end successes = tx_templates . each_with_index . reduce ( { } ) do | memo , ( t , i ) | memo [ orig_index [ i ] ] = t memo end BatchResponse . new ( successes : successes , errors : errors , ) end
969	def submissions page = @client . get_nokogiri @url @submissions ||= page . css ( '.gradeTable tbody tr' ) . map { | tr | begin Stellar :: Homework :: Submission . new tr , self rescue ArgumentError nil end } . reject ( & :nil? ) end
861	def website_set ( type , value ) site = website ( type ) if site . nil? site = ONIX :: Website . new site . website_role = type product . websites << site end site . website_link = value . to_s end
1038	def zoom_level region = self . region center_pixel = region . center . to_pixel_space top_left_pixel = ( region . center - ( region . span / 2 ) ) . to_pixel_space scaled_map_width = ( center_pixel . x - top_left_pixel . x ) * 2 map_size_in_pixels = MapSize . new ( self . bounds . size ) zoom_scale = scaled_map_width / map_size_in_pixels . width zoom_exponent = log ( zoom_scale ) / log ( 2 ) 20 - zoom_exponent end
35	def process_hash_keys ( hash ) return hash . inject ( { } ) do | result , pair | key , value = pair result [ key . to_sym ] = value . is_a? ( Hash ) ? process_hash_keys ( value ) : value result end end
811	def to_g_polyline_api2 ( polyline_options = { } , options = { } ) klass = if options [ :short_class ] 'GPolyline' else 'google.maps.Polyline' end poly_opts = if polyline_options [ :polyline_options ] Geos :: Helper . camelize_keys ( polyline_options [ :polyline_options ] ) end args = [ ( polyline_options [ :color ] ? "'#{Geos::Helper.escape_javascript(polyline_options[:color])}'" : 'null' ) , ( polyline_options [ :weight ] || 'null' ) , ( polyline_options [ :opacity ] || 'null' ) , ( poly_opts ? poly_opts . to_json : 'null' ) ] . join ( ', ' ) "new #{klass}([#{self.to_g_lat_lng(options).join(', ')}], #{args})" end
113	def to_json { threads : @threads . to_json , pipeline : @pipeline . size , best : best . map ( & :to_mnemo ) . join ( ', ' ) , farmer : @farmer . class . name } end
1012	def calculate_audit_for ( param ) objects = [ { attributes : self . attributes , whodunnit : self . paper_trail . originator } , self . versions . map { | e | { attributes : YAML . load ( e . object ) , whodunnit : e . paper_trail_originator } if e . object } . compact ] . flatten objects = objects . select { | e | e [ :attributes ] [ "updated_at" ] } . sort_by { | e | e [ :attributes ] [ "updated_at" ] } result = [ ] if ( objects . count > 0 && ! objects . first [ :attributes ] [ param . to_s ] . nil? ) result << PaperTrailAudit :: Change . new ( { old_value : nil , new_value : objects . first [ :attributes ] [ param . to_s ] , time : objects . first [ :attributes ] [ "updated_at" ] , whodunnit : objects . first [ :whodunnit ] } ) end objects . each_cons ( 2 ) do | a , b | if a [ :attributes ] [ param . to_s ] != b [ :attributes ] [ param . to_s ] result << PaperTrailAudit :: Change . new ( { old_value : a [ :attributes ] [ param . to_s ] , new_value : b [ :attributes ] [ param . to_s ] , time : b [ :attributes ] [ "updated_at" ] , whodunnit : b [ :whodunnit ] } ) end end result end
408	def to_s ( format = 'dd/mm/yyyy' ) SUPPORTED_FIELDS . collect do | k , v | next unless current = instance_variable_get ( "@#{k}" ) field = v . keys . first case current . class . to_s when "Time" , "Date" , "DateTime" "#{field}#{DateFormat.new(format).format(current)}" when "Float" "#{field}#{'%.2f'%current}" when "String" current . split ( "\n" ) . collect { | x | "#{field}#{x}" } else "#{field}#{current}" end end . concat ( @splits . collect { | s | s . to_s } ) . flatten . compact . join ( "\n" ) end
1101	def create_annotation_service ( mod , name ) @integrator = Annotation :: Integrator . new ( mod ) Annotation :: AnnotationService . new ( @database , name , @integrator ) end
1204	def range ( start_value , end_value , args , block ) filter << ( start_value . to_i .. end_value . to_i ) . to_a end
660	def to_rtf ( indent = 0 ) prefix = indent > 0 ? ' ' * indent : '' text = StringIO . new text << "#{prefix}{\\info" text << "\n#{prefix}{\\title #{@title}}" unless @title . nil? text << "\n#{prefix}{\\author #{@author}}" unless @author . nil? text << "\n#{prefix}{\\company #{@company}}" unless @company . nil? text << "\n#{prefix}{\\doccomm #{@comments}}" unless @comments . nil? unless @created . nil? text << "\n#{prefix}{\\createim\\yr#{@created.year}" text << "\\mo#{@created.month}\\dy#{@created.day}" text << "\\hr#{@created.hour}\\min#{@created.min}}" end text << "\n#{prefix}}" text . string end
633	def foreground ( colour ) style = CharacterStyle . new style . foreground = colour root . colours << colour if block_given? apply ( style ) { | node | yield node } else apply ( style ) end end
926	def alter_tables ( current_table_names , tables ) each_table ( current_table_names , tables ) do | table_name , table , last_table | hsh = table . dup hsh [ :columns ] = hsh [ :columns ] . map { | c | Schema :: DbColumn . build_from_hash ( c ) } operations = Schema :: AlterTableOperations . build ( @db_tables [ table_name ] , hsh , :immutable_columns => @immutable_columns ) unless operations . empty? all_operations = if @separate_alter_table_statements operations . map { | o | [ o ] } else [ operations ] end all_operations . each_with_index do | o , i | alter_table_statement table_name , o add_blank_line unless last_table && i + 1 == all_operations . size end end end end
726	def parse_response ( body ) report = CSV . new ( body , headers : true , header_converters : :symbol , converters : :all ) format = @format . to_s . downcase report_formatter = formatters . find ( format ) report_formatter . format report end
720	def evaluate name , receiver , args , call = nil , context = nil matcher = Support :: Matcher . new self , name , receiver , args matcher . match . new ( receiver , call , context ) . send name , * args end
891	def resolve_foreign_objects ( object , map ) object . foreign_objects . each do | property | value = object [ property ] if value . present? foreign_object = ForeignObject . new ( value ) resolve_foreign_keys ( foreign_object , map ) document = connection . find ( foreign_object . to_h ) if document object [ "#{property}_id" ] = document [ '_id' ] else raise Errors :: MissingDatabaseIdError , "couldn't resolve foreign object: #{property} #{value}" end end end end
1370	def ever_follow follow = [ ] self . follow_history . each do | h | follow << h . split ( '_' ) [ 0 ] . constantize . find ( h . split ( '_' ) [ 1 ] ) end follow end
662	def log ( error , context , trace = nil ) msg = String . new if error . respond_to? ( :backtrace ) msg << "unhandled exception: #{error.message} (#{context})" backtrace = error . backtrace msg << "\n#{backtrace.join("\n")}" if backtrace msg << "\n#{trace.join("\n")}" if trace else msg << "unhandled exception: #{args}" end @logger . error msg end
309	def home_timeline ( * args , & block ) return unless require_login debug "check for home_timeline tweets since #{since_id_home_timeline}" opts = { :since_id => since_id_home_timeline , :count => 200 } results = client . home_timeline ( opts ) @current_tweet = nil results . each { | s | update_since_id_home_timeline ( s ) if block_given? && valid_tweet? ( s ) @current_tweet = s yield s end } @current_tweet = nil end
1345	def processor_count @processor_count ||= begin os_name = RbConfig :: CONFIG [ "target_os" ] if os_name =~ / / require 'win32ole' result = WIN32OLE . connect ( "winmgmts://" ) . ExecQuery ( "select NumberOfLogicalProcessors from Win32_Processor" ) result . to_enum . collect ( & :NumberOfLogicalProcessors ) . reduce ( :+ ) elsif File . readable? ( "/proc/cpuinfo" ) IO . read ( "/proc/cpuinfo" ) . scan ( / / ) . size elsif File . executable? ( "/usr/bin/hwprefs" ) IO . popen ( "/usr/bin/hwprefs thread_count" ) . read . to_i elsif File . executable? ( "/usr/sbin/psrinfo" ) IO . popen ( "/usr/sbin/psrinfo" ) . read . scan ( / / ) . size elsif File . executable? ( "/usr/sbin/ioscan" ) IO . popen ( "/usr/sbin/ioscan -kC processor" ) do | out | out . read . scan ( / / ) . size end elsif File . executable? ( "/usr/sbin/pmcycles" ) IO . popen ( "/usr/sbin/pmcycles -m" ) . read . count ( "\n" ) elsif File . executable? ( "/usr/sbin/lsdev" ) IO . popen ( "/usr/sbin/lsdev -Cc processor -S 1" ) . read . count ( "\n" ) elsif File . executable? ( "/usr/sbin/sysconf" ) and os_name =~ / /i IO . popen ( "/usr/sbin/sysconf NPROC_ONLN" ) . read . to_i elsif File . executable? ( "/usr/sbin/sysctl" ) IO . popen ( "/usr/sbin/sysctl -n hw.ncpu" ) . read . to_i elsif File . executable? ( "/sbin/sysctl" ) IO . popen ( "/sbin/sysctl -n hw.ncpu" ) . read . to_i else $stderr . puts "Unknown platform: " + RbConfig :: CONFIG [ "target_os" ] $stderr . puts "Assuming 1 processor." 1 end end end
676	def render_audits ( audited_model ) return '' unless audited_model . respond_to? ( :audits ) audits = ( audited_model . audits || [ ] ) . dup . sort { | a , b | b . created_at <=> a . created_at } res = '' audits . each_with_index do | audit , index | older_audit = audits [ index + 1 ] res += content_tag ( :div , :class => 'audit' ) do content_tag ( :div , audit . action , :class => "action #{audit.action}" ) + content_tag ( :div , audit . username , :class => "user" ) + content_tag ( :div , l ( audit . created_at ) , :class => "timestamp" ) + content_tag ( :div , :class => 'changes' ) do changes = if older_audit . present? audit . delta ( older_audit ) . sort { | x , y | audited_model . class . human_attribute_name ( x . first ) <=> audited_model . class . human_attribute_name ( y . first ) } . collect do | k , v | next if k . to_s == 'created_at' || k . to_s == 'updated_at' "\n" + audited_model . class . human_attribute_name ( k ) + ":" + content_tag ( :span , v . last , :class => 'current' ) + content_tag ( :span , v . first , :class => 'previous' ) end else audit . change_log . sort { | x , y | audited_model . class . human_attribute_name ( x . first ) <=> audited_model . class . human_attribute_name ( y . first ) } . reject { | k , v | v . blank? } . collect { | k , v | "\n#{audited_model.class.human_attribute_name(k)}: #{v}" } end raw changes . join end end end raw res end
1064	def init_col_filter ( columns , source ) if columns . nil? File . open ( source , 'r' ) . each do | line | line = unstring ( line ) next if line . empty? line += ' ' if line =~ / / size = line . split ( ';' ) . size columns = "0-#{size-1}" break end end ColumnFilter . new ( columns ) . filter . flatten end
356	def fixed_dependencies fixed_attrs = fixed_attributes filtered_dependency_attributes . each_with_object ( Set . new ) do | ( key , value ) , fixed_deps | fixed_deps . merge ( value ) if fixed_attrs . include? ( key ) end . reject ( & :saved? ) end
627	def italic style = CharacterStyle . new style . italic = true if block_given? apply ( style ) { | node | yield node } else apply ( style ) end end
869	def set ( index , r , g , b ) check_index ( index ) self [ index ] = Color . new ( r , g , b ) end
1250	def load_properties file = default_properties_file props = file && File . exists? ( file ) ? load_properties_file ( file ) : { } path = props [ :classpath ] || props [ :path ] || infer_classpath Java . expand_to_class_path ( path ) if path unless props . has_key? ( :host ) or props . has_key? ( :port ) then url = remote_service_url if url then host , port = url . split ( ':' ) props [ :host ] = host props [ :port ] = port end end unless props . has_key? ( :database ) then props . merge ( infer_database_properties ) end props end
472	def destroy self . last_result_set = self . class . requestor . destroy ( self ) if last_result_set . has_errors? fill_errors false else self . attributes . clear true end end
646	def get_file_type type = nil read = [ ] open_file do | file | read_source ( file , read , 2 ) if read [ 0 , 2 ] == [ 255 , 216 ] type = JPEG else read_source ( file , read , 6 ) if read [ 0 , 8 ] == [ 137 , 80 , 78 , 71 , 13 , 10 , 26 , 10 ] type = PNG else if read [ 0 , 2 ] == [ 66 , 77 ] size = to_integer ( read [ 2 , 4 ] ) type = BITMAP if size == File . size ( @source ) end end end end type end
992	def convert ( valueToConvert , firstUnit , secondUnit ) finalValue = valueToConvert . round ( 10 ) firstUnitResultant = getInDictionary ( firstUnit ) if firstUnitResultant . nil? raise NotImplementedError . new ( "#{firstUnit} isn't recognized by InoxConverter" ) end finalValue *= firstUnitResultant . round ( 10 ) secondUnitResultant = getInDictionary ( secondUnit ) if secondUnitResultant . nil? raise NotImplementedError . new ( "#{secondUnit} isn't recognized by InoxConverter" ) end finalValue /= secondUnitResultant . round ( 10 ) return finalValue . round ( 10 ) end
906	def valid? return false if raw_payload . nil? || raw_payload . empty? return false if raw_authentication . nil? || raw_authentication . empty? return false unless json_valid? Authentication . valid? ( raw_authentication , json_payload ) end
707	def get_vm ( vmId ) params = { 'method' => :get , 'command' => "/vApp/vm-#{vmId}" } response , headers = send_request ( params ) vm_name = response . css ( 'Vm' ) . attribute ( "name" ) vm_name = vm_name . text unless vm_name . nil? status = convert_vapp_status ( response . css ( 'Vm' ) . attribute ( "status" ) . text ) os_desc = response . css ( 'ovf|OperatingSystemSection ovf|Description' ) . first . text networks = { } response . css ( 'NetworkConnection' ) . each do | network | ip = network . css ( 'IpAddress' ) . first ip = ip . text if ip external_ip = network . css ( 'ExternalIpAddress' ) . first external_ip = external_ip . text if external_ip key = "#{network['network']}_#{network.css('NetworkConnectionIndex').first.text}" networks [ key ] = { :index => network . css ( 'NetworkConnectionIndex' ) . first . text , :ip => ip , :external_ip => external_ip , :is_connected => network . css ( 'IsConnected' ) . first . text , :mac_address => network . css ( 'MACAddress' ) . first . text , :ip_allocation_mode => network . css ( 'IpAddressAllocationMode' ) . first . text } end admin_password = response . css ( 'GuestCustomizationSection AdminPassword' ) . first admin_password = admin_password . text if admin_password guest_customizations = { :enabled => response . css ( 'GuestCustomizationSection Enabled' ) . first . text , :admin_passwd_enabled => response . css ( 'GuestCustomizationSection AdminPasswordEnabled' ) . first . text , :admin_passwd_auto => response . css ( 'GuestCustomizationSection AdminPasswordAuto' ) . first . text , :admin_passwd => admin_password , :reset_passwd_required => response . css ( 'GuestCustomizationSection ResetPasswordRequired' ) . first . text , :computer_name => response . css ( 'GuestCustomizationSection ComputerName' ) . first . text } { :id => vmId , :vm_name => vm_name , :os_desc => os_desc , :networks => networks , :guest_customizations => guest_customizations , :status => status } end
779	def options VALID_CONFIG_OPTIONS . inject ( { } ) do | option , key | option . merge! ( key => send ( key ) ) end end
372	def require ( paths , & block ) if @reloader @reloader . require_dependencies ( paths , & block ) else Unreloader . expand_directory_paths ( paths ) . each { | f | super ( f ) } end end
1201	def create_filter ( values ) values . scan ( / \/ \/ /i ) . flatten . each do | value | send ( value ) end unless values . nil? end
610	def logout return true if self . session_token . blank? client . logout session_token self . session_token = nil true rescue => e false end
56	def method_missing ( name , * args , & block ) result = @date . send ( name , * args , & block ) return self . class . new ( @api , result ) if result . is_a? Date return result end
677	def _output_paths ( file ) input_file_dir = File . dirname ( file ) file_name = _output_filename ( file ) file_name = "#{file_name}.html" if _append_html_ext_to_output_path? ( file_name ) input_file_dir = input_file_dir . gsub ( Regexp . new ( "#{options[:input]}(\/){0,1}" ) , '' ) if options [ :input ] if options [ :output ] Array ( options [ :output ] ) . map do | output_dir | File . join ( output_dir , input_file_dir , file_name ) end else if input_file_dir == '' [ file_name ] else [ File . join ( input_file_dir , file_name ) ] end end end
956	def gt ( query_string , options = { :case_sensitive => false } ) do_comparison ( query_string , options ) do | comparator , item | comparator < item end end
1002	def insert_schemas ( obj ) if obj . is_a? ( Array ) obj . map! { | method | insert_schemas ( method ) } elsif obj . is_a? ( Hash ) @current_method = obj [ 'method' ] if obj . include? ( 'method' ) obj . each { | k , v | obj [ k ] = insert_schemas ( v ) } if obj . include? ( 'body' ) if obj [ 'body' ] . fetch ( 'application/x-www-form-urlencoded' , { } ) . include? ( 'formParameters' ) if insert_json_schema? ( obj ) insert_json_schema ( obj , generate_json_schema ( obj ) ) end end end end obj end
982	def primary_keys ( table ) if self . class . lowercase_schema_reflection @connection . primary_keys ( table ) . map do | key | key . downcase end else @connection . primary_keys ( table ) end end
1087	def pull_to_start ( name ) loop do res = pull raise NotFoundError if res . event_type == :end_document next if res . start_element? && res [ 0 ] == name . to_s end end
709	def poweroff_vm ( vmId ) builder = Nokogiri :: XML :: Builder . new do | xml | xml . UndeployVAppParams ( "xmlns" => "http://www.vmware.com/vcloud/v1.5" ) { xml . UndeployPowerAction 'powerOff' } end params = { 'method' => :post , 'command' => "/vApp/vm-#{vmId}/action/undeploy" } response , headers = send_request ( params , builder . to_xml , "application/vnd.vmware.vcloud.undeployVAppParams+xml" ) task_id = headers [ :location ] . gsub ( / \/ \/ / , "" ) task_id end
734	def to_hash converter = lambda { | obj | obj . respond_to? ( :to_hash ) ? obj . to_hash : obj } self . class . rules . keys . inject ( { } ) do | hash , name | value = send ( name ) hash [ name . to_sym ] = Array === value ? value . map ( & converter ) : converter [ value ] hash end end
804	def baudrate = ( new_baudrate ) raise ArgumentError . new ( 'baudrate should be Fixnum' ) unless new_baudrate . kind_of? ( Fixnum ) check_result ( Ftdi . ftdi_set_baudrate ( ctx , new_baudrate ) ) end
184	def time_zone_definition! ( zone ) attributes = { 'Id' => zone [ :id ] } attributes [ 'Name' ] = zone [ :name ] if zone [ :name ] nbuild [ NS_EWS_TYPES ] . TimeZoneDefinition ( attributes ) end
554	def campaign ( campaign_id , options = { } ) response = connection . get do | req | req . url "campaigns/#{campaign_id}" , options end return_error_or_body ( response , response . body . response . campaign ) end
886	def deduplicate ( objects ) losers_to_winners = build_losers_to_winners_map ( objects ) losers_to_winners . each_key do | key | objects . delete ( key ) end objects . each do | id , object | object . foreign_keys . each do | property | value = object [ property ] if value && losers_to_winners . key? ( value ) object [ property ] = losers_to_winners [ value ] end end end objects end
1134	def teams ( summoner , optional = { } ) region = optional [ :region ] || @sightstone . region id = if summoner . is_a? Summoner summoner . id else summoner end uri = "https://prod.api.pvp.net/api/lol/#{region}/v2.2/team/by-summoner/#{id}" response = _get_api_response ( uri ) _parse_response ( response ) { | resp | data = JSON . parse ( resp ) teams = [ ] data . each do | team | teams << Team . new ( team ) end if block_given? yield teams else return teams end } end
1367	def follower_of? ( model ) 0 < self . followees . by_model ( model ) . limit ( 1 ) . count * model . followers . by_model ( self ) . limit ( 1 ) . count end
281	def each_redirect ( & block ) return enum_for ( __method__ ) unless block if ( locations = @response . get_fields ( 'Location' ) ) locations . each ( & block ) else each_meta_redirect ( & block ) end end
1264	def as_json ( options = { } ) session_id = parameters . delete ( :session_id ) || Thread . current [ :keas_session_id ] data = { type : type , action : action , user_id : user_id , occurred_at : occurred_at , eventful_type : eventful_type , eventful_id : eventful_id , session_id : session_id } unless options [ :omit_parameters ] data [ :parameters ] = parameters data [ :attributes ] = attributes end data end
451	def connect Thread . start do begin PTY . spawn ( @executable + ' ' + params ) do | output , input , pid | @pid = pid output . sync = true input . sync = true Thread . start do while ( line = @read1 . readline ) input . puts line end end loop do output . expect ( / \\ / ) { | text | handle_response text } end end rescue Errno :: EIO => e unless @shutdown_in_progress if @connection_established raise StandardError , "Unexpected error: [#{e.message}]" else raise Client :: ConnectionError , 'Cannot connect to SMB server' end end end end end
1178	def to_number ( value ) value = convert_to_en ( value ) return value . to_i unless value =~ / \. / return value . to_f if value =~ / \. / end
1158	def resolve ( dep_hashes , repos ) logger . info 'resolving dependencies' session = MavenRepositorySystemSession . new local_repo = LocalRepository . new ( local_repository_path ) local_manager = @system . newLocalRepositoryManager ( local_repo ) session . setLocalRepositoryManager ( local_manager ) collect_req = CollectRequest . new dep_hashes . each do | hash | dep = Dependency . new new_artifact ( hash ) , 'compile' collect_req . addDependency dep logger . debug 'requested {}' , dep end repos . each do | uri | repo = RemoteRepository . new ( uri . object_id . to_s , 'default' , uri ) collect_req . addRepository repo logger . info 'added repository {}' , repo . getUrl enabled = [ ] enabled << 'releases' if repo . getPolicy ( false ) . isEnabled enabled << 'snapshots' if repo . getPolicy ( true ) . isEnabled logger . debug '{}' , enabled . join ( '+' ) end node = @system . collectDependencies ( session , collect_req ) . getRoot dependency_req = DependencyRequest . new ( node , nil ) @system . resolveDependencies ( session , dependency_req ) nlg = PreorderNodeListGenerator . new node . accept nlg if logger . isDebugEnabled total_size = 0 nlg . getArtifacts ( false ) . each do | artifact | file = artifact . file size = File . stat ( artifact . file . absolute_path ) . size total_size += size logger . debug ( "Using %0.2f %s" % [ size / MiB_PER_BYTE , artifact ] ) end logger . debug ( ' -----' ) logger . debug ( " %0.2f MiB total" % [ total_size / MiB_PER_BYTE ] ) else nlg . getArtifacts ( false ) . each do | artifact | logger . info 'Using {}' , artifact end end nlg . getFiles . map { | e | e . to_s } end
235	def do_build_resource ( response ) logger . debug ( response : response ) if logger configuration [ :resource_builder ] . new ( response . object , configuration . merge ( endpoint : response . request . endpoint ) , ( response . request . query || { } ) . fetch ( :locale , nil ) == '*' , 0 ) . run end
154	def save_associations self . class . associations . each do | association_data | association_name = association_data [ :name ] next unless send ( "#{association_name}_used?" ) && association = send ( association_name ) inline_creation = association_data [ :inline ] == :create && new_record? changed = association . is_a? ( Collection ) || association . changed? if association . respond_to? ( :save ) && changed && ! inline_creation && association . save send ( "#{association_name}=" , association ) end if ( association_data [ :inline ] == true || inline_creation ) && changed attributes [ association_name ] = association . to_param end end end
572	def venue_links ( venue_id , options = { } ) response = connection . get do | req | req . url "venues/#{venue_id}/links" , options end return_error_or_body ( response , response . body . response . links ) end
940	def update_self_and_descendants_depth if depth? scope_class . each_with_level ( self_and_descendants ) do | node , level | node . with ( :safe => true ) . set ( :depth , level ) unless node . depth == level end self . reload end self end
283	def each_url return enum_for ( __method__ ) unless block_given? each_link do | link | if ( url = to_absolute ( link ) ) yield url end end end
367	def fit_exponential ( xs , ys ) a , b , rr = fit ( xs , ys , tran_y : -> ( y ) { Math . log ( y ) } ) [ Math . exp ( a ) , Math . exp ( b ) , rr ] end
462	def edit_token_pipeline ( caller_reference , return_url , options = { } ) cbui EditToken . new ( options . merge ( :caller_reference => caller_reference , :return_url => return_url ) ) end
185	def restriction! ( restriction ) @nbuild [ NS_EWS_MESSAGES ] . Restriction { restriction . each_pair do | k , v | self . send normalize_type ( k ) , v end } end
863	def befriend! new_friend run_callbacks :befriend do friendships . create! friend_id : new_friend . id , friend_type : new_friend . class . name end end
623	def list ( kind = :bullets ) node = ListNode . new ( self ) yield node . list ( kind ) self . store ( node ) end
788	def privacy ( id , privacy = false ) drop = Drop . find ( id ) drop . update ( :private => privacy ) end
553	def event ( event_id , options = { } ) response = connection . get do | req | req . url "events/#{event_id}" , options end return_error_or_body ( response , response . body . response . event ) end
292	def set_basic_auth ( client , secret ) FHIR . logger . info 'Configuring the client to use HTTP Basic authentication.' token = Base64 . encode64 ( "#{client}:#{secret}" ) value = "Basic #{token}" @security_headers = { 'Authorization' => value } @use_oauth2_auth = false @use_basic_auth = true @client = RestClient @client . proxy = proxy unless proxy . nil? @client end
83	def report_definition_to_xml ( report_definition ) check_report_definition_hash ( report_definition ) add_report_definition_hash_order ( report_definition ) begin return Gyoku . xml ( { :report_definition => report_definition } ) rescue ArgumentError => e if e . message . include? ( "order!" ) unknown_fields = e . message . slice ( e . message . index ( '[' ) , e . message . length ) raise AdwordsApi :: Errors :: InvalidReportDefinitionError , "Unknown report definition field(s): %s" % unknown_fields end raise e end end
479	def ft_del record : doc_id = record . to_global_id REDI_SEARCH . call ( 'FT.DEL' , @index_name , doc_id ) rescue Exception => e Rails . logger . error e if defined? Rails return e . message end
1123	def update_profile ( attributes = { } ) assert_valid_keys ( attributes , :name , :twitter_id , :facebook_url , :website , :about , :top_artists , :hangout ) { :twitter_id => :twitter , :facebook_url => :facebook , :top_artists => :topartists } . each do | from , to | attributes [ to ] = attributes . delete ( from ) if attributes [ from ] end api ( 'user.modify_profile' , attributes ) self . attributes = attributes true end
845	def next_tempfile p = nil Tempfile . open ( "onix" ) do | tf | p = tf . path tf . close! end p end
110	def init_config ( ) provided_logger = @config . read ( 'library.logger' ) self . logger = ( provided_logger . nil? ) ? create_default_logger ( ) : provided_logger provided_adapter = @config . read ( 'connection.adapter' ) @config . set ( 'connection.adapter' , :httpclient ) if provided_adapter . nil? symbolize_config_value ( 'authentication.method' ) end
568	def list ( list_id , options = { } ) response = connection . get do | req | req . url "lists/#{list_id}" , options end return_error_or_body ( response , response . body . response . list ) end
421	def find_files_for_reload paths = [ './' , * $LOAD_PATH ] . uniq [ $0 , * $LOADED_FEATURES ] . uniq . map do | file | next if file =~ / \. / yield ( find ( file , paths ) ) end end
169	def experiment ( name ) id = name . to_s . downcase . gsub ( / \W / , "_" ) . to_sym Vanity . logger . warn ( "Deprecated: Please call experiment method with experiment identifier (a Ruby symbol)" ) unless id == name experiments [ id . to_sym ] or raise NoExperimentError , "No experiment #{id}" end
753	def captureOutput ( output , didFinishProcessingPhotoSampleBuffer : photo_sample_buffer , previewPhotoSampleBuffer : preview_photo_sample_buffer , resolvedSettings : resolved_settings , bracketSettings : bracket_settings , error : error ) if error error_callback . call ( error ) else jpeg_data = AVCapturePhotoOutput . jpegPhotoDataRepresentation ( forJPEGSampleBuffer : photo_sample_buffer , previewPhotoSampleBuffer : preview_photo_sample_buffer ) @capture_callback . call ( jpeg_data ) end end
1124	def update_laptop ( name ) assert_valid_values ( name , * %w( mac pc linux chrome iphone cake intel android ) ) api ( 'user.modify' , :laptop => name ) self . attributes = { 'laptop' => name } true end
60	def get_soap_xml ( action_name , args ) registry = get_service_registry ( ) validator = ParametersValidator . new ( registry ) args = validator . validate_args ( action_name , args ) return handle_soap_request ( action_name . to_sym , true , args , validator . extra_namespaces ) end
1044	def disable if enabled? Cratus :: LDAP . replace_attribute ( dn , Cratus . config . user_account_control_attribute , [ '514' ] ) refresh else true end end
369	def fit_at ( type , slope : nil , intercept : nil , n : nil ) raise ArgumentError , "Incorrect input size: #{n}" unless n > 0 case type when :logarithmic , :log intercept + slope * Math . log ( n ) when :linear intercept + slope * n when :power intercept * ( n ** slope ) when :exponential , :exp intercept * ( slope ** n ) else raise ArgumentError , "Unknown fit type: #{type}" end end
420	def handle_exceptions ( response ) begin yield rescue => error message = "Exception: #{error}" message << "\n#{error.backtrace.join("\n")}" if ( error . respond_to? ( :backtrace ) ) Server . logger . error ( message ) return if response . isCommitted response . reset response . setStatus ( 500 ) end end
1057	def add_to_new_subcontainer ( storable ) scs = subcontainers . sort { | sc1 , sc2 | sc1 . position . coordinate <=> sc2 . position . coordinate } logger . debug { "Looking for a #{self} subcontainer #{scs} to place a new #{storable.qp} container..." } unless scs . empty? sc = scs . detect { | sc | sc . add_to_new_subcontainer ( storable ) if StorageContainer === sc } if sc then logger . debug { "#{self} subcontainer #{sc} stored #{storable.qp}." } self elsif not full? then logger . debug { "Creating a subcontainer in #{self} of type #{storage_type} to hold #{storable.qp}..." } create_subcontainer_for ( storable ) end end
1026	def on_session_ended url = @connection . url room = @room @connection = nil @room = nil if @reconnect reconnect_from ( Exception ) do room ? room . enter : connect ( url ) trigger ( :reconnected ) end end end
1192	def summoner ( name_or_id , optional = { } ) region = optional [ :region ] || @sightstone . region uri = if name_or_id . is_a? Integer "https://prod.api.pvp.net/api/lol/#{region}/v1.3/summoner/#{name_or_id}" else "https://prod.api.pvp.net/api/lol/#{region}/v1.3/summoner/by-name/#{URI::encode(name_or_id)}" end response = _get_api_response ( uri ) _parse_response ( response ) { | resp | data = JSON . parse ( resp ) s = Summoner . new ( data . values [ 0 ] ) if block_given? yield s else return s end } end
207	def unsubscribe return true if @subscription_id . nil? resp = ews . unsubscribe ( @subscription_id ) rmsg = resp . response_messages . first if rmsg . success? @subscription_id , @watermark = nil , nil true else raise EwsSubscriptionError , "Could not unsubscribe: #{rmsg.code}: #{rmsg.message_text}" end end
770	def paths_for ( name , opts = { } ) result = [ ] dirs_and_glob_for ( name , opts ) . each do | path , glob | next if glob . nil? paths = Dir [ File . join ( path , glob ) ] paths = paths . reverse if opts [ :invert ] paths . each do | full_path | result << [ path , full_path . gsub ( path , "" ) ] end end result end
1172	def update_user_address ( user , address ) logger . debug { "Work around caTissue prohibition of #{user} address #{address} update by creating a new address record for a dummy user..." } address . identifier = nil perform ( :create , address ) { create_object ( address ) } logger . debug { "Worked around caTissue address update bug by swizzling the #{user} address #{address} identifier." } perform ( :update , user ) { update_object ( user ) } user end
1113	def read ( filename , as : user , on : hosts , quiet : false ) log . info "read: #{filename}" , quiet : quiet do hash_map ( hosts ) do | host | host . read filename , as : as end end end
474	def ft_search_count ( args ) ft_search ( args ) . first rescue Exception => e Rails . logger . error e if defined? Rails return e . message end
1364	def select ( fields ) if ( fields == [ ] ) || ( fields . nil? ) fields = [ :_id ] end clone . tap { | q | q . options [ :fields ] = fields } end
1279	def channel if ( channel = Thread . current [ CHANNEL_KEY ] ) . try ( :open? ) channel else new_channel = connection . channel new_channel . confirm_select new_channel . prefetch ( Isimud . prefetch_count ) if Isimud . prefetch_count Thread . current [ CHANNEL_KEY ] = new_channel end end
1150	def write ( string , to , as : nil , quiet : false ) cp StringIO . new ( string ) , to , as : as , quiet : quiet end
1043	def recent ( summoner , optional = { } ) region = optional [ :region ] || @sightstone . region id = if summoner . is_a? Summoner summoner . id else summoner end uri = "https://prod.api.pvp.net/api/lol/#{region}/v1.3/game/by-summoner/#{id}/recent" response = _get_api_response ( uri ) _parse_response ( response ) { | resp | data = JSON . parse ( resp ) history = MatchHistory . new ( data ) if block_given? yield history else return history end } end
476	def ft_add record : fields = [ ] @fields . each { | field | fields . push ( field , record . send ( field ) ) } REDI_SEARCH . call ( 'FT.ADD' , @index_name , record . to_global_id . to_s , @score , 'REPLACE' , 'FIELDS' , fields ) rescue Exception => e Rails . logger . error e if defined? Rails return e . message end
41	def sanitize_result ( results ) if results . is_a? ( Array ) ret = [ ] results . each do | result | ret << sanitize_result ( result ) end return ret end if results . is_a? ( Hash ) ret = { } results . each do | k , v | v = sanitize_result ( v ) if v . is_a? ( Hash ) ret [ k ] = v unless k . to_s . start_with? ( '@' ) end return ret end return results end
426	def current_user ( options ) access_token = options . fetch ( :access_token ) subdomain = options . fetch ( :subdomain ) user_url = URL . new ( options . merge ( params : { access_token : access_token , } , path : "/api/v1/profiles/me" , ) ) . to_s response = RestClient . get ( user_url , accept : :json , ) build_profile ( access_token , subdomain , JSON . parse ( response ) [ "profiles" ] . first ) end
1316	def tag_for_label_with_inline_help ( label_text , field_id , help_text ) _html = "" _html << %{<label for="#{field_id}">#{label_text}} _html << %{<img src="/images/icons/help_icon.png" onclick="$('#{field_id}_help').toggle();" class='inline_icon' />} _html << %{</label><br />} _html << %{<div class="inline_help" id="#{field_id}_help" style="display: none;">} _html << %{<p>#{help_text}</p>} _html << %{</div>} _html end
38	def put_incremental_operations ( operations , batch_job_url , total_content_length = 0 , is_last_request = false ) @api . utils_reporter . batch_job_utils_used ( ) headers = DEFAULT_HEADERS soap_operations = generate_soap_operations ( operations ) request_body = soap_operations . join is_first_request = ( total_content_length == 0 ) if is_first_request request_body = ( UPLOAD_XML_PREFIX % [ @version ] ) + request_body end if is_last_request request_body += UPLOAD_XML_SUFFIX end request_body = add_padding ( request_body ) content_length = request_body . bytesize headers [ 'Content-Length' ] = content_length lower_bound = total_content_length upper_bound = total_content_length + content_length - 1 total_bytes = is_last_request ? upper_bound + 1 : '*' content_range = "bytes %d-%d/%s" % [ lower_bound , upper_bound , total_bytes ] headers [ 'Content-Range' ] = content_range log_request ( batch_job_url , headers , request_body ) begin AdsCommon :: Http . put_response ( batch_job_url , request_body , @api . config , headers ) rescue ArgumentError end total_content_length += content_length return total_content_length end
1373	def announce ( key , port , opts = { } , & block ) payload = [ key , port ] link . send 'announce' , payload , opts , & block if config . auto_announce periodically ( config . auto_announce_interval ) do link . send 'announce' , payload , opts , & block end end end
316	def get_oauth_verifier green "****************************************" green "****************************************" green "**** BOT AUTH TIME! ****" green "****************************************" green "****************************************" puts "You need to authorize your bot with Twitter.\n\nPlease login to Twitter under the bot's account. When you're ready, hit Enter.\n\nYour browser will open with the following URL, where you can authorize the bot.\n\n" url = request_token . authorize_url puts url puts "\nIf that doesn't work, you can open the URL in your browser manually." puts "\n\nHit enter to start.\n\n" STDIN . readline . chomp Launchy . open ( url ) sleep ( 2 ) puts "Paste your PIN and hit enter when you have completed authorization.\n\n" print "> " STDIN . readline . chomp . strip rescue Interrupt => e exit end
663	def ready load_promise = load_applications load_promise . then do if @running @logger . verbose "All gazelles running" @loaded = true bind_application_ports unless @delay_port_binding else @logger . warn "A shutdown event occured while loading" perform_shutdown end end @load_complete . resolve ( load_promise ) end
401	def batch_search ( searches , additional_headers = { } ) url_friendly_searches = searches . each_with_index . map do | search , index | { index => search } end searches_query = { search : url_friendly_searches } request_url = "#{base_url}/batch_search.json?#{Rack::Utils.build_nested_query(searches_query)}" get_json ( request_url , additional_headers ) end
18	def run_with_temporary_flag ( flag_name , flag_value , block ) previous = @credential_handler . instance_variable_get ( flag_name ) @credential_handler . instance_variable_set ( flag_name , flag_value ) begin return block . call ensure @credential_handler . instance_variable_set ( flag_name , previous ) end end
167	def method_missing ( method , * args , & block ) %w( url_for flash ) . include? ( method . to_s ) ? ProxyEmpty . new : super end
993	def wrap ( num_lines ) cleaned = gsub ( / \s / , ' ' ) . strip chars_per_line = cleaned . size / num_lines . to_f lines = [ ] cleaned . split . each do | word | if lines . empty? lines << word else if ( lines [ - 1 ] . size + 1 + word . size ) <= chars_per_line || lines . size >= num_lines lines [ - 1 ] << ' ' unless lines [ - 1 ] . empty? lines [ - 1 ] << word else lines << word end end end Caption . new ( lines . join ( "\n" ) ) end
243	def process_xml ( xml ) doc = REXML :: Document . new xml if root = REXML :: XPath . first ( doc , 'xmlns:cartridge_basiclti_link' ) @title = get_node_text ( root , 'blti:title' ) @description = get_node_text ( root , 'blti:description' ) @launch_url = get_node_text ( root , 'blti:launch_url' ) @secure_launch_url = get_node_text ( root , 'blti:secure_launch_url' ) @icon = get_node_text ( root , 'blti:icon' ) @secure_icon = get_node_text ( root , 'blti:secure_icon' ) @cartridge_bundle = get_node_att ( root , 'xmlns:cartridge_bundle' , 'identifierref' ) @cartridge_icon = get_node_att ( root , 'xmlns:cartridge_icon' , 'identifierref' ) if vendor = REXML :: XPath . first ( root , 'blti:vendor' ) @vendor_code = get_node_text ( vendor , 'lticp:code' ) @vendor_description = get_node_text ( vendor , 'lticp:description' ) @vendor_name = get_node_text ( vendor , 'lticp:name' ) @vendor_url = get_node_text ( vendor , 'lticp:url' ) @vendor_contact_email = get_node_text ( vendor , '//lticp:contact/lticp:email' ) @vendor_contact_name = get_node_text ( vendor , '//lticp:contact/lticp:name' ) end if custom = REXML :: XPath . first ( root , 'blti:custom' , LTI_NAMESPACES ) set_properties ( @custom_params , custom ) end REXML :: XPath . each ( root , 'blti:extensions' , LTI_NAMESPACES ) do | vendor_ext_node | platform = vendor_ext_node . attributes [ 'platform' ] properties = { } set_properties ( properties , vendor_ext_node ) REXML :: XPath . each ( vendor_ext_node , 'lticm:options' , LTI_NAMESPACES ) do | options_node | opt_name = options_node . attributes [ 'name' ] options = { } set_properties ( options , options_node ) properties [ opt_name ] = options end self . set_ext_params ( platform , properties ) end end end
994	def consume_api @dados = RestClient :: Request . execute ( method : :get , url : 'https://finance.yahoo.com/webservice/v1/symbols/allcurrencies/quote' ) hash_local = Hash . new @hash_local = Hash . from_xml ( @dados ) end
1227	def rows_from_params ( opts ) col_count = opts [ :cols ] row_count = opts [ :rows ] size = row_count * col_count if row_count && col_count rows = [ ] if values = opts [ :values ] if size values += [ NotAvailable ] * ( size - values . size ) elsif col_count values += [ NotAvailable ] * ( ( col_count - values . size ) % col_count ) elsif row_count values += [ NotAvailable ] * ( ( row_count - values . size ) % row_count ) col_count = values . size / row_count else col_count = Math . sqrt ( values . size ) . ceil values += [ NotAvailable ] * ( ( col_count - values . size ) % col_count ) end values . each_slice ( col_count ) { | row | rows << row } elsif opts [ :file ] File . foreach ( opts [ :file ] ) do | line | next if line . chomp . empty? values = line . split ( SEMICOLON ) rescue str2utf8 ( line ) . split ( SEMICOLON ) rows << values . collect { | v | v . strip . empty? ? NotAvailable : str2num ( v . chomp , opts [ :ds ] ) } end end rows end
907	def run validate_settings Lock . create ( self ) do schedule = find_schedule unless schedule logger . info "No backup needed - exiting" return end logger . info "Starting #{schedule} backup to #{settings.remote_server}" timestamp = Time . now . strftime ( 'backup_%Y-%m-%d-T%H-%M-%S' ) current_path = File . join ( settings . remote_path , 'current' ) progress_path = File . join ( settings . remote_path , 'incomplete' ) complete_path = File . join ( schedule_path ( schedule ) , timestamp ) login = "#{settings.remote_user}@#{settings.remote_server}" rsync_path = "#{login}:#{progress_path}" execute_ssh "mkdir --verbose --parents #{schedule_path schedule}" Rsync . execute ( logger , settings . local_path , rsync_path , { exclude_file : settings . exclude_file , link_dest : current_path , max_upload_speed : settings . max_upload_speed , max_download_speed : settings . max_download_speed } ) logger . info "Do the backup shuffle" execute_ssh [ "mv --verbose #{progress_path} #{complete_path}" , "rm --verbose --force #{current_path}" , "ln --verbose --symbolic #{complete_path} #{current_path}" , ] delete_old_backups schedule logger . info "#{schedule} backup done" end rescue Exception => exception logger . error exception . message logger . error exception . backtrace end
1127	def weighted ( type , group ) if @weights [ type ] . has_key? ( group ) selector = WeightedSelect :: Selector . new @weights [ type ] [ group ] selector . select end end
1385	def jquids_includes ( options = { } ) Jquids . format = options [ :format ] if options . has_key? ( :format ) html_out = "" if options . has_key? ( :style ) html_out << stylesheet_link_tag ( jq_ui_stylesheet ( options [ :style ] ) ) + "\n" unless options [ :style ] == nil or options [ :style ] == :none or options [ :style ] == false else html_out << stylesheet_link_tag ( jq_ui_stylesheet ) + "\n" end jq_vrs = options . has_key? ( :jQuery ) ? options [ :jQuery ] : Jquids :: JQVersions . last ui_vrs = options . has_key? ( :jQueryUI ) ? options [ :jQueryUI ] : Jquids :: UIVersions . last trtp_vrs = options . has_key? ( :TRTimepicker ) ? options [ :TRTimepicker ] : :none unless trtp_vrs == :none or trtp_vrs == false or trtp_vrs == nil html_out << "<style type=\"text/css\">.ui-timepicker-div .ui-widget-header{margin-bottom:8px;}.ui-timepicker-div dl{text-align:left;}.ui-timepicker-div dl dt{height:25px;}.ui-timepicker-div dl dd{margin:-25px 0 10px 65px;}.ui-timepicker-div td{font-size:90%;}</style>\n" end html_out << javascript_include_tag ( jq_ui_javascripts ( jq_vrs , ui_vrs , trtp_vrs ) ) + "\n" options [ :datepicker_options ] ||= { } options [ :datepicker_options ] [ :showOtherMonths ] = true if options [ :datepicker_options ] [ :showOtherMonths ] . nil? options [ :datepicker_options ] [ :selectOtherMonths ] = true if options [ :datepicker_options ] [ :selectOtherMonths ] . nil? options [ :datepicker_options ] [ :changeMonth ] = true if options [ :datepicker_options ] [ :changeMonth ] . nil? options [ :datepicker_options ] [ :changeYear ] = true if options [ :datepicker_options ] [ :changeYear ] . nil? options [ :datepicker_options ] [ :dateFormat ] = Jquids . format [ :js_date ] Jquids . jquids_process_options ( options ) datepicker_options = if options [ :datepicker_options ] . respond_to? ( :to_json ) options . delete ( :datepicker_options ) . to_json else begin JSON . unparse ( options . delete ( :datepicker_options ) ) rescue "" end end html_out << '<script type="text/javascript">$.datepicker.setDefaults(' + datepicker_options + ');' unless trtp_vrs == :none or trtp_vrs == false or trtp_vrs == nil options [ :timepicker_options ] ||= { } options [ :timepicker_options ] [ :ampm ] = Jquids . format [ :ampm ] options [ :timepicker_options ] [ :timeFormat ] = Jquids . format [ :tr_js_time ] timepicker_options = if options [ :timepicker_options ] . respond_to? ( :to_json ) options . delete ( :timepicker_options ) . to_json else begin JSON . unparse ( options . delete ( :timepicker_options ) ) rescue "" end end html_out << '$.timepicker.setDefaults(' + timepicker_options + ');' end html_out << '$(document).ready(function(){$(".jquids_dp").each(function(){var s=$(this).attr("data-jquipicker");$(this).attr("data-jquipicker")?$(this).datepicker(JSON.parse(s)):$(this).datepicker()});$(".jquids_tp").each(function(){var s=$(this).attr("data-jquipicker");$(this).attr("data-jquipicker")?$(this).timepicker(JSON.parse(s)):$(this).timepicker()});$(".jquids_dtp").each(function(){var s=$(this).attr("data-jquipicker");$(this).attr("data-jquipicker")?$(this).datetimepicker(JSON.parse(s)):$(this).datetimepicker()})});</script>' if html_out . respond_to? ( :html_safe ) return html_out . html_safe else return html_out end end
1054	def add ( storable , * coordinate ) return add_local ( storable , * coordinate ) unless coordinate . empty? add_to_existing_container ( storable ) or add_to_new_subcontainer ( storable ) or out_of_bounds ( storable ) self end
953	def contain ( query_string , options = { :case_sensitive => false } ) do_comparison ( query_string ) do | comparator , item | if options [ :case_sensitive ] item =~ Regexp . new ( comparator , Regexp :: MULTILINE ) else item =~ Regexp . new ( comparator , Regexp :: IGNORECASE | Regexp :: MULTILINE ) end end end
354	def filtered_dependency_attributes filtered_attributes = dependency_attributes if attributes_blacklist . present? filtered_attributes = filtered_attributes . reject { | key , _value | attributes_blacklist . include? ( key ) } end if attributes_whitelist . present? filtered_attributes = filtered_attributes . select { | key , _value | attributes_whitelist . include? ( key ) } end filtered_attributes end
350	def assign_attributes ( attributes ) attributes . each do | k , v | next if %i( resource_timestamps resource_timestamps_max resource_timestamp ) . include? ( k ) next if %i( resource_counters resource_counters_max resource_counter ) . include? ( k ) if data [ :resource_timestamp ] && attributes [ :resource_timestamp ] assign_only_newest ( :resource_timestamp , :resource_timestamps , attributes , data , k , v ) elsif data [ :resource_counter ] && attributes [ :resource_counter ] assign_only_newest ( :resource_counter , :resource_counters , attributes , data , k , v ) else public_send ( "#{k}=" , v ) end end if attributes [ :resource_timestamp ] assign_full_row_version_attr ( :resource_timestamp , attributes , data ) elsif attributes [ :resource_counter ] assign_full_row_version_attr ( :resource_counter , attributes , data ) end self end
225	def iso8601_duration_to_seconds ( input ) return nil if input . nil? || input . empty? match_data = DURATION_RE . match ( input ) raise ( StringFormatException , "Invalid duration given" ) if match_data . nil? duration = 0 duration += match_data [ :weeks ] . to_i * 604800 duration += match_data [ :days ] . to_i * 86400 duration += match_data [ :hours ] . to_i * 3600 duration += match_data [ :minutes ] . to_i * 60 duration += match_data [ :seconds ] . to_i end
320	def global_config tmp = { } global_config_files . each { | f | tmp . merge! ( slurp_file ( f ) || { } ) } tmp end
1360	def timer ( & block ) start_time = Time . now yield ( start_time ) time_elapsed = Time . now - start_time end
668	def open_path ( path , options = { } ) dev = get_device_by_path ( path , options ) dev . open if dev end
1368	def follow ( * models ) models . each do | model | unless model == self or self . follower_of? ( model ) or model . followee_of? ( self ) or self . cannot_follow . include? ( model . class . name ) or model . cannot_followed . include? ( self . class . name ) model . followers . create! ( :f_type => self . class . name , :f_id => self . id . to_s ) model . followed_history << self . class . name + '_' + self . id . to_s model . save self . followees . create! ( :f_type => model . class . name , :f_id => model . id . to_s ) self . follow_history << model . class . name + '_' + model . id . to_s self . save end end end
182	def start_time_zone! ( zone ) attributes = { } attributes [ 'Id' ] = zone [ :id ] if zone [ :id ] attributes [ 'Name' ] = zone [ :name ] if zone [ :name ] nbuild [ NS_EWS_TYPES ] . StartTimeZone ( attributes ) end
927	def alter_table_statement ( table_name , operations ) add_line "alter_table #{table_name.inspect} do" indent do operations . compact . each { | op | add_line op } end add_line "end" end
967	def set_auto_date_field ( field_name ) unless self . class . protect_remote_timestamps? method = "#{field_name}=" self . send ( method , Time . now ) if self . respond_to? ( method ) end end
822	def raw_exchange_rates req = Net :: HTTP :: Post . new ( @uri , 'Content-Type' => 'application/json' ) req . body = { lang : :en } . to_json response = Net :: HTTP . start ( @uri . hostname , @uri . port ) do | http | http . request ( req ) end fail ResponseError , response . code unless response . is_a? Net :: HTTPSuccess response = JSON . parse ( response . body ) unless response [ 'd' ] && response [ 'd' ] . size >= 6 fail ResponseError , "Unknown JSON #{response}" end response rescue JSON :: ParserError raise ResponseError , "Unknown JSON: #{response.body}" end
171	def run unless @executables . empty? @config . executables = @executables end jobs = @jobs . flat_map do | job | BenchmarkDriver :: JobParser . parse ( { type : @config . runner_type , prelude : @prelude , loop_count : @loop_count , } . merge! ( job ) ) end BenchmarkDriver :: Runner . run ( jobs , config : @config ) end
1393	def to_hash index_hash = Hash . new index_hash [ "json_claz" ] = self . class . name index_hash [ "creationDate" ] = creationDate index_hash [ "admin" ] = admin index_hash [ "type" ] = type index_hash [ "password" ] = password index_hash [ "name" ] = name index_hahs [ "mail" ] = mail index_hash [ "displayName" ] = displayName index_hash [ "lastModified" ] = lastModified index_hash [ "active" ] = active index_hash [ "some_msg" ] = some_msg index_hash end
351	def assign_only_newest ( full_row_version_attr , partial_row_version_attr , attributes , data , k , v ) specific_attr_timestamp = attributes [ partial_row_version_attr ] . try ( :[] , k ) specific_data_timestamp = data [ partial_row_version_attr ] . try ( :[] , k ) assign = if ! specific_attr_timestamp true elsif specific_attr_timestamp && ! specific_data_timestamp if data . key? ( k ) if attributes [ full_row_version_attr ] >= data [ full_row_version_attr ] true end else true end true elsif specific_attr_timestamp > specific_data_timestamp true end if assign public_send ( "#{k}=" , v ) ( data [ partial_row_version_attr ] ||= { } ) [ k ] = specific_attr_timestamp if specific_attr_timestamp end end
628	def underline style = CharacterStyle . new style . underline = true if block_given? apply ( style ) { | node | yield node } else apply ( style ) end end
690	def create_fake_network_node ( vapp_networks , network_name ) parent_section = vapp_networks . css ( 'NetworkConfigSection' ) . first new_network = Nokogiri :: XML :: Node . new "NetworkConfig" , parent_section new_network [ 'networkName' ] = network_name placeholder = Nokogiri :: XML :: Node . new "PLACEHOLDER" , new_network new_network . add_child placeholder parent_section . add_child ( new_network ) vapp_networks end
1333	def write_attribute ( name , val ) if attributes . is_a? ( Redis :: Future ) value = attributes . value self . attributes = value ? Hash [ * self . class . fields . keys . zip ( value ) . flatten ] : { } end attributes [ name ] = self . class . transform ( :to , name , val ) end
962	def mine page = @client . get_nokogiri '/atstellar' class_links = page . css ( 'a[href*="/S/course/"]' ) . map { | link | Stellar :: Course . from_link link , @client } . reject ( & :nil? ) end
415	def classes ( delimiter ) git = @dangerfile . git affected_files = git . modified_files + git . added_files affected_files . select { | file | files_extension . reduce ( false ) { | state , el | state || file . end_with? ( el ) } } . map { | file | file . split ( '.' ) . first . split ( delimiter ) [ 1 ] } end
597	def post ( uri , body = nil , headers = { } ) request :post , uri , body : body , headers : headers end
248	def create_tempfile tempfile = Tempfile . new ( [ "image_processing" , ".#{destination_format}" ] , binmode : true ) yield tempfile tempfile . open tempfile rescue tempfile . close! if tempfile raise end
31	def get_full_type_signature ( type_name ) result = ( type_name . nil? ) ? nil : @registry . get_type_signature ( type_name ) result [ :fields ] = implode_parent ( result ) if result and result [ :base ] return result end
774	def classify ( value ) raise ArgumentError , "value: #{value} must be in data array" unless @data . include? ( value ) bounds [ 1 .. - 1 ] . index { | bound | value <= bound } end
911	def option_parser params = [ "-#{@short}" , "--#{@long}" , nil , @options [ :type ] ] if ! @description . nil? and ! @description . empty? params [ 2 ] = @description end if ! [ TrueClass , FalseClass ] . include? ( @options [ :type ] ) params [ 1 ] += " #{@options[:key]}" end return params end
268	def get_page ( url ) url = URI ( url ) prepare_request ( url ) do | session , path , headers | new_page = Page . new ( url , session . get ( path , headers ) ) @cookies . from_page ( new_page ) yield new_page if block_given? return new_page end end
15	def soap_header_handler ( auth_handler , version , header_ns , default_ns ) auth_method = @config . read ( 'authentication.method' , :OAUTH2 ) handler_class = case auth_method when :OAUTH2 , :OAUTH2_SERVICE_ACCOUNT AdsCommon :: SavonHeaders :: OAuthHeaderHandler else raise AdsCommon :: Errors :: AuthError , "Unknown auth method: %s" % auth_method end return handler_class . new ( @credential_handler , auth_handler , header_ns , default_ns , version ) end
1151	def read ( filename , as : nil , quiet : false ) Base64 . decode64 sh ( "cat #{filename.shellescape} | base64" , as : as , quiet : quiet ) end
116	def push ( id , body ) mods = @entrance . push ( id , body ) return mods if @remotes . all . empty? mods . each do | m | next if @seen . include? ( m ) @mutex . synchronize { @seen << m } @modified . push ( m ) @log . debug ( "Spread-push scheduled for #{m}, queue size is #{@modified.size}" ) end mods end
1179	def prepare_sum_row ( pattern ) return if pattern . nil? || pattern . empty? @sum_row_pos , sum_row_pattern = pattern . split ( / /i ) @sum_row_pos . upcase! @sum_row = Hash . new @sum_row_patterns = split_by_comma_regex ( sum_row_pattern ) end
96	def normalize_hash_field ( field , field_def ) process_attributes ( field , true ) field_type = field_def [ :type ] field_def = get_full_type_signature ( field_type ) xsi_type_override = determine_xsi_type_override ( field , field_def ) unless xsi_type_override . nil? field_def = get_full_type_signature ( xsi_type_override ) return ( field_def . nil? ) ? field : normalize_fields ( field , field_def [ :fields ] ) end result = field choice_type_override = determine_choice_type_override ( field , field_def ) unless choice_type_override . nil? field_key = field . keys . first field_data = field [ field_key ] field_def = get_full_type_signature ( choice_type_override ) if ! field_def . nil? and field_data . kind_of? ( Hash ) field_data = normalize_fields ( field_data , field_def [ :fields ] ) end result = { field_key => field_data } else unless field_def . nil? result = normalize_fields ( field , field_def [ :fields ] ) end end if check_key_value_struct ( result ) result = convert_key_value_to_hash ( result ) end return result end
76	def get_report_response_with_awql ( report_query , format , cid , & block ) data = '__rdquery=%s&__fmt=%s' % [ CGI . escape ( report_query ) , CGI . escape ( format ) ] return make_adhoc_request ( data , cid , & block ) end
758	def full_feature ( value = true ) return unless value @config . formulize @config . event = ( @config . event + [ :call , :return ] ) . uniq @config . import_return_to_call = true @config . show_additional_attrs = [ :path , :lineno ] if value == 10 @config . include_instance_var = true @config . include_local_var = true end end
815	def to_g_marker_api3 ( marker_options = { } , options = { } ) options = { :escape => [ ] , :lat_lng_options => { } } . merge ( options ) opts = Geos :: Helper . camelize_keys ( marker_options ) opts [ :position ] = self . centroid . to_g_lat_lng ( options [ :lat_lng_options ] ) json = Geos :: Helper . escape_json ( opts , Geos :: GoogleMaps :: Api3Constants :: UNESCAPED_MARKER_OPTIONS - options [ :escape ] ) "new google.maps.Marker(#{json})" end
954	def in ( set ) @collection = @collection . collect do | item | item if set . include? ( item . send ( @field_name . to_sym ) ) end . compact end
425	def authorization_code_url ( options ) URL . new ( options . merge ( path : "/api/v1/oauth2/authorize" , params : { response_type : "code" , approve : "true" , client_id : client_id , } , ) ) . to_s end
761	def attribute_lookup ( assoc ) group_data = @map [ assoc . group . to_sym ] return nil unless group_data attribute = group_data [ assoc . type . to_sym ] return attribute end
1346	def physical_processor_count @physical_processor_count ||= begin ppc = case RbConfig :: CONFIG [ "target_os" ] when / / IO . popen ( "/usr/sbin/sysctl -n hw.physicalcpu" ) . read . to_i when / / cores = { } phy = 0 IO . read ( "/proc/cpuinfo" ) . scan ( / / ) do | ln | if ln . start_with? ( "physical" ) phy = ln [ / \d / ] elsif ln . start_with? ( "core" ) cid = phy + ":" + ln [ / \d / ] cores [ cid ] = true if not cores [ cid ] end end cores . count when / / require 'win32ole' result_set = WIN32OLE . connect ( "winmgmts://" ) . ExecQuery ( "select NumberOfCores from Win32_Processor" ) result_set . to_enum . collect ( & :NumberOfCores ) . reduce ( :+ ) else processor_count end ppc > 0 ? ppc : processor_count end end
683	def add_vm_to_vapp ( vapp , vm , network_config = { } ) builder = Nokogiri :: XML :: Builder . new do | xml | xml . RecomposeVAppParams ( "xmlns" => "http://www.vmware.com/vcloud/v1.5" , "xmlns:ovf" => "http://schemas.dmtf.org/ovf/envelope/1" , "name" => vapp [ :name ] ) { xml . SourcedItem { xml . Source ( "href" => "#{@api_url}/vAppTemplate/vm-#{vm[:template_id]}" , "name" => vm [ :vm_name ] ) xml . InstantiationParams { xml . NetworkConnectionSection ( "xmlns:ovf" => "http://schemas.dmtf.org/ovf/envelope/1" , "type" => "application/vnd.vmware.vcloud.networkConnectionSection+xml" , "href" => "#{@api_url}/vAppTemplate/vm-#{vm[:template_id]}/networkConnectionSection/" ) { xml [ 'ovf' ] . Info "Network config for sourced item" xml . PrimaryNetworkConnectionIndex "0" xml . NetworkConnection ( "network" => network_config [ :name ] ) { xml . NetworkConnectionIndex "0" xml . IsConnected "true" xml . IpAddressAllocationMode ( network_config [ :ip_allocation_mode ] || "POOL" ) } } } xml . NetworkAssignment ( "containerNetwork" => network_config [ :name ] , "innerNetwork" => network_config [ :name ] ) } xml . AllEULAsAccepted "true" } end params = { "method" => :post , "command" => "/vApp/vapp-#{vapp[:id]}/action/recomposeVApp" } response , headers = send_request ( params , builder . to_xml , "application/vnd.vmware.vcloud.recomposeVAppParams+xml" ) task = response . css ( "Task[operationName='vdcRecomposeVapp']" ) . first task_id = task [ "href" ] . gsub ( / \/ \/ / , "" ) task_id end
498	def update_custom_field ( custom_field_key , field_name , visible_in_preference_center ) custom_field_key = CGI . escape ( custom_field_key ) options = { :body => { :FieldName => field_name , :VisibleInPreferenceCenter => visible_in_preference_center } . to_json } response = put "customfields/#{custom_field_key}" , options response . parsed_response end
1115	def ping ( on : hosts , quiet : false ) log . info "ping" , quiet : quiet do hash_map ( hosts ) do | host | host . ping end end end
1323	def extract_search_text ( * attributes ) Array ( attributes ) . map { | meth | Nokogiri :: HTML ( self . send ( meth ) ) . xpath ( "//text()" ) . map { | node | text = node . text ; text . try ( :strip! ) ; text } . join ( " " ) } . reject ( & :blank? ) . join ( "\n" ) end
785	def list_roles response = oauth_access_token . get ( '/v1/roles' ) response . parsed . collect { | parsed_role | Role . new ( parsed_role ) } end
1331	def read_list ( name ) opts = self . class . persisted_attrs [ name ] if ! lists [ name ] && opts [ :default ] opts [ :default ] else send ( "#{name}=" , lists [ name ] . value ) if lists [ name ] . is_a? ( Redis :: Future ) lists [ name ] end end
5	def [] ( suburl , & new_block ) case when block_given? then self . class . new ( concat_urls ( url , suburl ) , options , & new_block ) when block then self . class . new ( concat_urls ( url , suburl ) , options , & block ) else self . class . new ( concat_urls ( url , suburl ) , options ) end end
486	def run normalize_count = 0 if generate_gitattributes? output_options = { :prefix => '# DO NOT EDIT: File is auto-generated' , :normalize => true } new_gitattributes = generate_gitattributes! new_content = new_gitattributes . as_file_contents ( output_options ) old_content = File . exist? ( @attributes . attributes_file ) ? IO . read ( @attributes . attributes_file ) : nil if new_content != old_content @attributes = new_gitattributes if check_only? puts 'Non-normalized .gitattributes file' else puts 'Fixing: .gitattributes' @attributes . write ( output_options ) end normalize_count += 1 end end files = { } collect_file_attributes ( files ) files . each_pair do | filename , config | full_filename = "#{@base_directory}/#{filename}" original_bin_content = File . binread ( full_filename ) encoding = config [ :encoding ] . nil? ? 'utf-8' : config [ :encoding ] . gsub ( / / , 'utf-' ) content = File . read ( full_filename , :encoding => "bom|#{encoding}" ) content = config [ :dos ] ? clean_dos_whitespace ( filename , content , config [ :eofnl ] , config [ :allow_empty ] ) : clean_whitespace ( filename , content , config [ :eofnl ] , config [ :allow_empty ] ) if config [ :nodupnl ] while content . gsub! ( / \n \n \n / , "\n\n" ) end end if content . bytes != original_bin_content . bytes normalize_count += 1 if check_only? puts "Non-normalized whitespace in #{filename}" else puts "Fixing: #{filename}" File . open ( full_filename , 'wb' ) do | out | out . write content end end end end normalize_count end
1176	def create_table_data processed_header = false File . open ( infile ) . each_with_index do | line , index | line = line . chomp next if line . empty? line = unstring ( line ) . chomp header . process line , processed_header unless processed_header processed_header = true next end next if row_filter . process ( line , row : index ) . nil? @columns = line . split ( ';' ) create_row ( create_key , line ) end end
1117	def update ( attributes = { } ) assert_valid_keys ( attributes , :name , :status , :laptop_name , :twitter_id , :facebook_url , :website , :about , :top_artists , :hangout ) status = attributes . delete ( :status ) update_status ( status ) if status laptop_name = attributes . delete ( :laptop_name ) update_laptop ( laptop_name ) if laptop_name update_profile ( attributes ) if attributes . any? true end
581	def venue_photos ( venue_id , options = { :group => 'venue' } ) response = connection . get do | req | req . url "venues/#{venue_id}/photos" , options end return_error_or_body ( response , response . body . response . photos ) end
400	def raw_send_command ( sym , args ) if @connected @connection . send_command ( sym , args ) else callback do @connection . send_command ( sym , args ) end end return nil end
948	def check ( obj ) if name == 'Boolean' obj == true || obj == false else obj . kind_of? constant end end
640	def border_width = ( width ) size = width . nil? ? 0 : width if size > 0 @borders [ TOP ] = @borders [ RIGHT ] = @borders [ BOTTOM ] = @borders [ LEFT ] = size . to_i else @borders = [ nil , nil , nil , nil ] end end
409	def verify_digests! references . each do | reference | node = referenced_node ( reference . uri ) canoned = node . canonicalize ( C14N , reference . namespaces ) digest = reference . digest_method . digest ( canoned ) if digest != reference . decoded_digest_value raise SignatureError . new ( "Reference validation error: Digest mismatch for #{reference.uri}" ) end end end
892	def run ( args , overrides = { } ) rest = opts . parse! ( args ) @options = OpenStruct . new ( options . to_h . merge ( overrides ) ) if options . actions . empty? options . actions = %w( scrape import ) end if options . tasks . empty? options . tasks = @processor_class . tasks end processor = @processor_class . new ( options . output_dir , pipelined : options . pipelined , cache_dir : options . cache_dir , expires_in : options . expires_in , value_max_bytes : options . value_max_bytes , memcached_username : options . memcached_username , memcached_password : options . memcached_password , database_url : options . database_url , validate : options . validate , level : options . level , faraday_options : options . faraday_options , options : Hash [ * rest ] ) options . actions . each do | action | unless action == 'scrape' || processor . respond_to? ( action ) abort %(`#{action}` is not a #{opts.program_name} action. See `#{opts.program_name} --help` for a list of available actions.) end end if %w( DEBUG INFO ) . include? ( options . level ) puts "processor: #{@processor_class}" puts "actions: #{options.actions.join(', ')}" puts "tasks: #{options.tasks.join(', ')}" end if options . level == 'DEBUG' %w( output_dir pipelined cache_dir expires_in value_max_bytes memcached_username memcached_password database_url validate level ) . each do | option | puts "#{option}: #{options[option]}" end unless rest . empty? puts "options: #{rest.join(' ')}" end end exit if options . dry_run report = { plan : { processor : @processor_class , options : Marshal . load ( Marshal . dump ( options ) ) . to_h , arguments : rest , } , start : Time . now . utc , } if options . actions . delete ( 'scrape' ) processor . store . clear report [ :scrape ] = { } options . tasks . each do | task_name | report [ :scrape ] [ task_name ] = processor . dump_scraped_objects ( task_name ) end end options . actions . each do | action | processor . send ( action ) if processor . report . key? ( action . to_sym ) report . update ( action . to_sym => processor . report [ action . to_sym ] ) end end if %w( DEBUG INFO ) . include? ( options . level ) report [ :end ] = Time . now . utc report [ :time ] = report [ :end ] - report [ :start ] puts JSON . dump ( report ) end end
370	def export ( * symbols ) symbols = symbols . first if symbols . first . is_a? ( Array ) __exported_symbols . concat ( symbols ) end
868	def []= ( index , color ) if index . respond_to? ( :to_a ) index . to_a . each do | i | check_index ( i ) ws2811_led_set ( @channel , i , color . to_i ) end else check_index ( index ) ws2811_led_set ( @channel , index , color . to_i ) end end
308	def favorite ( id = @current_tweet ) return if require_login == false id = id_from_tweet ( id ) if debug_mode? debug "I'm in debug mode, otherwise I would favorite tweet id: #{id}" return end client . favorite id end
2	def process_url_params ( url , headers ) url_params = nil headers . delete_if do | key , value | if key . to_s . downcase == 'params' && ( value . is_a? ( Hash ) || value . is_a? ( RestClient :: ParamsArray ) ) if url_params raise ArgumentError . new ( "Multiple 'params' options passed" ) end url_params = value true else false end end if url_params && ! url_params . empty? query_string = RestClient :: Utils . encode_query_string ( url_params ) if url . include? ( '?' ) url + '&' + query_string else url + '?' + query_string end else url end end
941	def destroy_descendants return if right . nil? || left . nil? || skip_before_destroy if acts_as_nested_set_options [ :dependent ] == :destroy descendants . each do | model | model . skip_before_destroy = true model . destroy end else c = nested_set_scope . where ( left_field_name . to_sym . gt => left , right_field_name . to_sym . lt => right ) scope_class . where ( c . selector ) . delete_all end diff = right - left + 1 scope_class . with ( :safe => true ) . where ( nested_set_scope . where ( left_field_name . to_sym . gt => right ) . selector ) . inc ( left_field_name , - diff ) scope_class . with ( :safe => true ) . where ( nested_set_scope . where ( right_field_name . to_sym . gt => right ) . selector ) . inc ( right_field_name , - diff ) self . skip_before_destroy = true end
388	def acquire df = EM :: DefaultDeferrable . new @redis . lock_acquire ( [ @key ] , [ @token , @timeout ] ) . callback { | success | if ( success ) EM :: Hiredis . logger . debug "#{to_s} acquired" EM . cancel_timer ( @expire_timer ) if @expire_timer @expire_timer = EM . add_timer ( @timeout - 1 ) { EM :: Hiredis . logger . debug "#{to_s} Expires in 1s" @onexpire . call if @onexpire } df . succeed else EM :: Hiredis . logger . debug "#{to_s} failed to acquire" df . fail ( "Lock is not available" ) end } . errback { | e | EM :: Hiredis . logger . error "#{to_s} Error acquiring lock #{e}" df . fail ( e ) } df end
816	def to_g_polyline_api3 ( polyline_options = { } , options = { } ) options = { :escape => [ ] , :lat_lng_options => { } } . merge ( options ) opts = Geos :: Helper . camelize_keys ( polyline_options ) opts [ :path ] = "[#{self.to_g_lat_lng_api3(options[:lat_lng_options]).join(', ')}]" json = Geos :: Helper . escape_json ( opts , Geos :: GoogleMaps :: Api3Constants :: UNESCAPED_POLY_OPTIONS - options [ :escape ] ) "new google.maps.Polyline(#{json})" end
800	def perform_http_request request = Net :: HTTP :: Get . new ( @uri . request_uri , @headers ) request . basic_auth ( @username , @password ) if @username || @password http = instantiate_http http . start do http . request ( request ) end end
583	def add ( * items ) notify_will_change! if items . count > 0 items . each do | item | collection . push item end @collection end
959	def lte ( query_string , options = { :case_sensitive => false } ) do_comparison ( query_string , options ) do | comparator , item | comparator >= item end end
873	def []= ( x , y , color ) check_coords ( x , y ) @pixels [ x ] [ y ] = color @hat [ map_coords ( x , y ) ] = color end
287	def put ( options = { } , & block ) response = http . put_uri ( options . merge ( :body => serialize ) , & block ) handle_response ( response ) self end
382	def search ( options , & block ) instrument "search.github_ldap" , options . dup do | payload | result = if options [ :base ] @connection . search ( options , & block ) else search_domains . each_with_object ( [ ] ) do | base , result | rs = @connection . search ( options . merge ( :base => base ) , & block ) result . concat Array ( rs ) unless rs == false end end return [ ] if result == false Array ( result ) end end
1099	def to_date ( value ) if value . nil? or value . strip . empty? nil else Date . strptime ( value , date_format ) end end
772	def build_association ( value ) association = @form . create_association ( group : @group . to_s , type : @type . to_s , value : value ) association . persisted = @source . persisted? return association end
491	def history options = { :query => { :email => @email_address } } response = cs_get "/subscribers/#{@list_id}/history.json" , options response . map { | item | Hashie :: Mash . new ( item ) } end
37	def initialize_url ( batch_job_url ) headers = DEFAULT_HEADERS headers [ 'Content-Length' ] = 0 headers [ 'x-goog-resumable' ] = 'start' response = AdsCommon :: Http . post_response ( batch_job_url , '' , @api . config , headers ) return response . headers [ 'Location' ] end
799	def instantiate_http http_class = nil if @proxy && @proxy [ :host ] http_class = Net :: HTTP :: Proxy ( @proxy [ :host ] , @proxy [ :port ] , @proxy [ :username ] , @proxy [ :password ] ) else http_class = Net :: HTTP end http = http_class . new ( @uri . host , @uri . port ) if @uri . scheme == 'https' http . use_ssl = true http . verify_mode = OpenSSL :: SSL :: VERIFY_PEER end http . open_timeout = @open_timeout http . read_timeout = @read_timeout return http end
692	def generate_network_section ( vAppId , network , config , type ) params = { 'method' => :get , 'command' => "/vApp/vapp-#{vAppId}/networkConfigSection" } vapp_networks , headers = send_request ( params ) create_fake_network_node ( vapp_networks , network [ :name ] ) if type . to_sym == :internal new_network = create_internal_network_node ( config ) else new_network = get_base_network ( network [ :id ] ) end merge_network_config ( vapp_networks , new_network , config ) end
1369	def unfollow ( * models ) models . each do | model | unless model == self or ! self . follower_of? ( model ) or ! model . followee_of? ( self ) or self . cannot_follow . include? ( model . class . name ) or model . cannot_followed . include? ( self . class . name ) model . followers . by_model ( self ) . first . destroy self . followees . by_model ( model ) . first . destroy end end end
1337	def filter_authorized! ( method , objects , user = current_user ) object_array = Array ( objects ) object_array . select do | object | policy = policy_for ( object ) policy . can? ( method , user ) end end
453	def valid? @transitions . each do | key , val | @alphabet . each do | a | return false unless @transitions [ key ] . has_key? a . to_s end end return true end
279	def initialize_filters ( options = { } ) @schemes = [ ] if options [ :schemes ] self . schemes = options [ :schemes ] else @schemes << 'http' begin require 'net/https' @schemes << 'https' rescue Gem :: LoadError => e raise ( e ) rescue :: LoadError warn "Warning: cannot load 'net/https', https support disabled" end end @host_rules = Rules . new ( accept : options [ :hosts ] , reject : options [ :ignore_hosts ] ) @port_rules = Rules . new ( accept : options [ :ports ] , reject : options [ :ignore_ports ] ) @link_rules = Rules . new ( accept : options [ :links ] , reject : options [ :ignore_links ] ) @url_rules = Rules . new ( accept : options [ :urls ] , reject : options [ :ignore_urls ] ) @ext_rules = Rules . new ( accept : options [ :exts ] , reject : options [ :ignore_exts ] ) if options [ :host ] visit_hosts_like ( options [ :host ] ) end end
864	def unfriend friend run_callbacks :unfriend do friendships . where ( friend_type : friend . class . name ) . where ( friend_id : friend . id ) . first . destroy end end
1382	def process_timeout ( timeout ) unless timeout == nil raise TypeError , "'timeout' must be nil or a Numeric" unless timeout . is_a? ( Numeric ) raise ArgumentError , "'timeout' must not be negative" if timeout . negative? end timeout = nil if timeout == Float :: INFINITY timeout end
1218	def require_aether * deps @mini_aether_require_spec ||= MiniAether :: Spec . new @mini_aether_require_resolver ||= MiniAether :: Resolver . new spec = @mini_aether_require_spec resolver = @mini_aether_require_resolver if deps . last . kind_of? ( Hash ) hash = deps . pop [ hash [ :source ] , hash [ :sources ] ] . flatten . compact . each do | source | spec . source ( source ) end end deps . each { | coords | spec . jar ( coords ) } resolver . require ( spec . dependencies , spec . sources ) nil end
177	def distinguished_folder_id! ( dfid , change_key = nil , act_as = nil ) attribs = { 'Id' => dfid . to_s } attribs [ 'ChangeKey' ] = change_key if change_key @nbuild [ NS_EWS_TYPES ] . DistinguishedFolderId ( attribs ) { if ! act_as . nil? mailbox! ( { :email_address => act_as } ) end } end
870	def [] ( index ) if index . respond_to? ( :to_a ) index . to_a . map do | i | check_index ( i ) Color . from_i ( ws2811_led_get ( @channel , i ) ) end else check_index ( index ) Color . from_i ( ws2811_led_get ( @channel , index ) ) end end
314	def direct_message ( txt , user = nil ) return unless require_login if user . nil? user = current_user end client . create_direct_message ( user , txt ) end
1269	def nr_api @conn ||= Faraday :: Connection . new ( 'https://api.newrelic.com' , conn_opts ) do | client | client . use Faraday :: Response :: RaiseError client . use FaradayMiddleware :: EncodeJson client . use FaradayMiddleware :: ParseJson , content_type : / \b / client . response :logger if Config . environment . to_s . casecmp ( 'development' ) . zero? client . adapter Faraday . default_adapter end end
1110	def as ( user , quiet : false ) let :@user => user do log . info "as #{user}" , quiet : quiet do yield end end end
1211	def create_annotation ( hook , annotation ) if hook . nil? then raise ArgumentError . new ( "Annotated caTissue object is missing" ) end if annotation . nil? then raise ArgumentError . new ( "Annotation caTissue object is missing" ) end unless hook . identifier then raise AnnotationError . new ( "Annotation writer does not support annotation of a caTissue object without an identifier: #{hook}" ) end hook . class . ensure_annotations_loaded annotation . hook = hook annotation . create end
842	def parse_options ( argv = ARGV ) @config_file = File . join ( Dir . getwd , 'config' , "#{@name}.json" ) OptionParser . new do | opts | note = 'Define environment' opts . on ( '-e' , '--environment ENVIRONMENT' , note ) do | environment | @environment = environment end opts . on ( '-d' , '--detached' , 'Run processor detached as a daemon' ) do @detached = true end note = 'Define configuration file' opts . on ( '-c' , '--config CONFIG' , note ) do | config | @config_file = config end end . parse! ( argv ) true rescue OptionParser :: InvalidOption => e EventHub . logger . warn ( "Argument Parsing: #{e}" ) false rescue OptionParser :: MissingArgument => e EventHub . logger . warn ( "Argument Parsing: #{e}" ) false end
773	def block_it? ( tp ) if @cond . track_params return true if negative_check ( tp ) if positives_check ( tp ) return ! tp . binding . eval ( 'local_variables' ) . any? do | v | tp . binding . local_variable_get ( v ) . object_id == @cond . track_params end end else return true if negative_check ( tp ) return false if positives_check ( tp ) end true end
433	def label ( name , locator ) define_method ( "#{name}" ) do adapter . label ( locator ) . value end define_method ( "#{name}_view" ) do adapter . label ( locator ) . view end end
1389	def gd ( date = self ) j_date = jd ( date ) g_date = HijriUmmAlqura . jd_to_gd ( j_date ) return g_date end
931	def browser_caps ( browser , browser_options ) target = ( browser . to_sym if ENV [ 'BROWSER' ] . nil? or ENV [ 'browser' ] . empty? ) || ( ENV [ 'BROWSER' ] . to_sym ) browser , version , platform , device = extract_values_from ( target ) options = { } options . merge! browser_options caps = capabilities ( browser , version , platform , device ) options [ :url ] = url if url if options . include? :url browser = :remote options [ :desired_capabilities ] = caps end options [ :http_client ] = http_client if persistent_http or options . delete ( :persistent_http ) return browser , options end
1284	def terminal_size rows , cols = 25 , 80 buf = [ 0 , 0 , 0 , 0 ] . pack ( "SSSS" ) if $stdout . ioctl ( TIOCGWINSZ , buf ) >= 0 then rows , cols , row_pixels , col_pixels = buf . unpack ( "SSSS" ) end return [ rows , cols ] end
1085	def classes raise StreamNotParsed , 'you must parse first' if @tree . nil? classes = statements . select do | node | node . is_a? ( ClassStatement ) end classes . map ( & :to_hash ) end
1229	def same_column_size? ( rows ) offset = opts [ :c ] ? 1 : 0 return true if rows . size == 1 + offset ( 0 + offset ) . upto ( rows . size - 2 ) do | i | return false unless rows [ i ] . size == rows [ i + 1 ] . size end true end
143	def formatted copy = dup Helpers . rcompact ( @formats ) if copy . length < @formats . size copy . concat Array . new ( @formats . size - copy . length ) end copy end
896	def delete ( pkg ) iterator = case pkg when Package pkg [ :sigmd5 ] ? each_match ( :sigmd5 , pkg [ :sigmd5 ] ) : each_match ( :label , pkg [ :label ] ) when String each_match ( :label , pkg ) when Dependency each_match ( :label , pkg . name ) . set_iterator_version ( pkg . version ) else raise TypeError , 'illegal argument type' end iterator . each do | header | ret = RPM :: C . rpmtsAddEraseElement ( @ptr , header . ptr , iterator . offset ) raise "Error while adding erase/#{pkg} to transaction" if ret != 0 end end
1157	def attributes ( & block ) raise ArgumentError , "You should provide block" unless block_given? attributes = Morf :: AttributesParser . parse ( & block ) self . class_variable_set ( :@@attributes , attributes ) end
236	def resolve ( client , query = { } ) id_and_query = [ ( id unless link_type == 'Space' ) ] . compact + [ query ] client . public_send ( Contentful :: Support . snakify ( link_type ) . to_sym , * id_and_query ) end
217	def convert_id ( opts ) opts = opts . clone [ :id , :format , :destination_format , :mailbox ] . each do | k | validate_param ( opts , k , true ) end req = build_soap! do | type , builder | if ( type == :header ) else builder . nbuild . ConvertId { | x | builder . nbuild . parent . default_namespace = @default_ns x . parent [ 'DestinationFormat' ] = opts [ :destination_format ] . to_s . camel_case x . SourceIds { | x | x [ NS_EWS_TYPES ] . AlternateId { | x | x . parent [ 'Format' ] = opts [ :format ] . to_s . camel_case x . parent [ 'Id' ] = opts [ :id ] x . parent [ 'Mailbox' ] = opts [ :mailbox ] } } } end end do_soap_request ( req , response_class : EwsResponse ) end
599	def delete ( uri , body = nil , headers = { } ) request :delete , uri , body : body , headers : headers end
1268	def resolve_links ( text ) html = Nokogiri :: HTML . fragment ( text ) html . css ( "a[href]" ) . each do | link | href = URI ( link [ "href" ] ) next unless href . relative? && markup_for_file ( nil , href . path ) == :markdown link . replace "{file:#{href} #{link.inner_html}}" end super ( html . to_s ) end
136	def mark_as_unread ( user ) if previous_post . nil? read_state = postable . user_read_states . find_by ( user_id : user . id ) read_state . destroy if read_state else postable . user_read_states . touch! ( user . id , previous_post , overwrite_newer : true ) end end
851	def imprint = ( str ) composite = product . imprints . first if composite . nil? composite = ONIX :: Imprint . new product . imprints << composite end composite . imprint_name = str end
49	def yield_objects ( offset , instance , & block ) to_yield = [ :soap , :wsdl , :http , :wsse ] yield * ( to_yield [ offset , block . arity ] . map { | obj_name | instance . send ( obj_name ) } ) end
86	def headers ( url , cid ) override = ( cid . nil? ) ? nil : { :client_customer_id => cid } credentials = @credential_handler . credentials ( override ) headers = { 'Content-Type' => 'application/x-www-form-urlencoded' , 'Authorization' => @auth_handler . auth_string ( credentials ) , 'User-Agent' => @credential_handler . generate_user_agent ( ) , 'clientCustomerId' => credentials [ :client_customer_id ] . to_s , 'developerToken' => credentials [ :developer_token ] } skip_report_header = @config . read ( 'library.skip_report_header' ) unless skip_report_header . nil? headers [ 'skipReportHeader' ] = skip_report_header . to_s end skip_report_summary = @config . read ( 'library.skip_report_summary' ) unless skip_report_summary . nil? headers [ 'skipReportSummary' ] = skip_report_summary . to_s end skip_column_header = @config . read ( 'library.skip_column_header' ) unless skip_column_header . nil? headers [ 'skipColumnHeader' ] = skip_column_header . to_s end include_zero_impressions = @config . read ( 'library.include_zero_impressions' ) unless include_zero_impressions . nil? headers [ 'includeZeroImpressions' ] = include_zero_impressions . to_s end use_raw_enum_values = @config . read ( 'library.use_raw_enum_values' ) unless use_raw_enum_values . nil? headers [ 'useRawEnumValues' ] = use_raw_enum_values . to_s end return headers end
1013	def result rows = File . readlines ( file ) result = Result . new unless rows . empty? row_number = 0 row_number += 1 while rows [ row_number ] . chomp . empty? result . cols = rows [ row_number ] . chomp . split ( ';' ) result . col_count = result . cols . size row_number += 1 row_number += 1 while rows [ row_number ] . chomp . empty? result . row_count = rows . size - 1 result . sample_row = rows [ row_number ] . chomp end result end
1165	def find request_uris . map do | request | if request [ :body ] . nil? request [ :uri ] else html = Nokogiri :: HTML ( request [ :body ] ) potential_feed_uris = html . xpath ( XPATHS . detect { | path | ! html . xpath ( path ) . empty? } ) if potential_feed_uris . empty? Mako . errors . add_error "Could not find feed for #{request[:uri]}" next end uri_string = potential_feed_uris . first . value feed_uri = URI . parse ( uri_string ) feed_uri . absolutize! ( request [ :uri ] ) end end . compact end
127	def add raise 'Block must be given to start()' unless block_given? latch = Concurrent :: CountDownLatch . new ( 1 ) thread = Thread . start do Thread . current . name = @title VerboseThread . new ( @log ) . run do latch . count_down yield end end latch . wait Thread . current . thread_variable_set ( :kids , ( Thread . current . thread_variable_get ( :kids ) || [ ] ) + [ thread ] ) @threads << thread end
148	def _side_load ( name , klass , resources ) associations = klass . associated_with ( name ) associations . each do | association | association . side_load ( resources , @included [ name ] ) end resources . each do | resource | loaded_associations = resource . loaded_associations loaded_associations . each do | association | loaded = resource . send ( association [ :name ] ) next unless loaded _side_load ( name , association [ :class ] , to_array ( loaded ) ) end end end
297	def subnet ( subprefix ) unless ( ( @prefix . to_i ) .. 32 ) . include? subprefix raise ArgumentError , "New prefix must be between #@prefix and 32" end Array . new ( 2 ** ( subprefix - @prefix . to_i ) ) do | i | self . class . parse_u32 ( network_u32 + ( i * ( 2 ** ( 32 - subprefix ) ) ) , subprefix ) end end
1078	def move ( to_index ) api ( 'playlist.reorder' , :playlist_name => playlist . id , :index_from => index , :index_to => to_index ) playlist . songs . insert ( to_index , playlist . songs . delete ( self ) ) true end
865	def handle_timecop_offset if session [ TimecopConsole :: SESSION_KEY_NAME ] . present? Rails . logger . debug "[timecop-console] Time traveling to #{session[TimecopConsole::SESSION_KEY_NAME].to_s}" Timecop . travel ( session [ TimecopConsole :: SESSION_KEY_NAME ] ) else Timecop . return end yield if session [ TimecopConsole :: SESSION_KEY_NAME ] . present? adjusted_time = Time . now + 3 Rails . logger . debug "[timecop-console] Resetting session to: #{adjusted_time}" session [ TimecopConsole :: SESSION_KEY_NAME ] = adjusted_time end end
164	def version ( * versions , & block ) condition = lambda { | env | versions . include? ( env [ "HTTP_X_API_VERSION" ] ) } with_conditions ( condition , & block ) end
446	def write ( content , to , overwrite = false , raise = true ) tempfile = Tempfile . new tempfile . write content tempfile . close put tempfile . path , to , overwrite , raise end
53	def generate_value_object ( value ) typeKeyValue = VALUE_TYPES . find { | key , val | value . is_a? key } dateTypes = [ AdManagerApi :: AdManagerDate , AdManagerApi :: AdManagerDateTime ] if dateTypes . include? ( value . class ) value = value . to_h end return value if typeKeyValue . nil? return { :xsi_type => typeKeyValue . last , :value => value } end
374	def record_split_class ( main_file , * files ) if @reloader files = Unreloader . expand_paths ( files ) files . each do | file | record_dependency ( file , main_file ) end @reloader . skip_reload ( files ) end end
796	def render ( statuses , elapsed_time ) fail = statuses . all? { | s | s . success? } headers = { "Content-Type" => "text/plain; charset=utf8" , "Cache-Control" => "no-cache" , "Date" => Time . now . httpdate , } messages = [ ] statuses . each do | status | status . messages . each do | m | messages << "#{m.ok? ? 'OK: ' : 'FAIL:'} #{status.name} - #{m.message} (#{status.time ? sprintf('%0.000f', status.time * 1000) : '?'}ms)" end end info = [ ] info << "Host: #{@hostname}" unless @hostname . size == 0 info << "PID: #{$$}" info << "Timestamp: #{Time.now.iso8601}" info << "Elapsed Time: #{(elapsed_time * 1000).round}ms" code = ( fail ? 200 : 500 ) [ code , headers , [ info . join ( "\n" ) , "\n\n" , messages . join ( "\n" ) ] ] end
618	def to_rtf rtf = ( @text . nil? ? '' : @text . gsub ( "{" , "\\{" ) . gsub ( "}" , "\\}" ) . gsub ( "\\" , "\\\\" ) ) f = lambda { | n | n < 128 ? n . chr : "\\u#{n}\\'3f" } if RUBY_VERSION > "1.9.0" return rtf . encode ( "UTF-16LE" , :undef => :replace ) . each_codepoint . map ( & f ) . join ( '' ) else return rtf . unpack ( 'U*' ) . map ( & f ) . join ( '' ) end end
181	def get_server_time_zones! ( get_time_zone_options ) nbuild [ NS_EWS_MESSAGES ] . GetServerTimeZones ( 'ReturnFullTimeZoneData' => get_time_zone_options [ :full ] ) do if get_time_zone_options [ :ids ] && get_time_zone_options [ :ids ] . any? nbuild [ NS_EWS_MESSAGES ] . Ids do get_time_zone_options [ :ids ] . each do | id | nbuild [ NS_EWS_TYPES ] . Id id end end end end end
299	def bot return @bot unless @bot . nil? @bot_command = nil params = { } opts = OptionParser . new opts . banner = "Usage: #{File.basename($0)} [options]" opts . separator "" opts . separator "Specific options:" opts . on ( '-c' , '--config [ARG]' , "Specify a config file to use" ) { | c | ENV [ "chatterbot_config" ] = c } opts . on ( '-t' , '--test' , "Run the bot without actually sending any tweets" ) { params [ :debug_mode ] = true } opts . on ( '-v' , '--verbose' , "verbose output to stdout" ) { params [ :verbose ] = true } opts . on ( '--dry-run' , "Run the bot in test mode, and also don't update the database" ) { params [ :debug_mode ] = true ; params [ :no_update ] = true } opts . on ( '-r' , '--reset' , "Reset your bot to ignore old tweets" ) { @bot_command = :reset_since_id_counters } opts . on ( '--profile [ARG]' , "get/set your bot's profile text" ) { | p | @bot_command = :profile_text @bot_command_args = [ p ] } opts . on ( '--website [ARG]' , "get/set your bot's profile URL" ) { | u | @bot_command = :profile_website @bot_command_args = [ u ] } opts . on_tail ( "-h" , "--help" , "Show this message" ) do puts opts exit end opts . parse! ( ARGV ) @bot = Chatterbot :: Bot . new ( params ) if @bot_command != nil @bot . skip_run = true result = @bot . send ( @bot_command , * @bot_command_args ) puts result end @bot end
1353	def render ( template_name , view_handler , locals , & content ) self . erb_source . render ( template_name , render_locals ( view_handler , locals ) , & content ) end
296	def supernet ( new_prefix ) raise ArgumentError , "New prefix must be smaller than existing prefix" if new_prefix >= @prefix . to_i return self . class . new ( "0.0.0.0/0" ) if new_prefix < 1 return self . class . new ( @address + "/#{new_prefix}" ) . network end
44	def endpoint ( version , service ) base = get_wsdl_base ( version ) if ! subdir_config ( ) . nil? base = base . to_s + subdir_config ( ) [ [ version , service ] ] . to_s end return base . to_s + version . to_s + '/' + service . to_s end
48	def process ( offset = 0 , instance = self , & block ) block . arity > 0 ? yield_objects ( offset , instance , & block ) : evaluate ( instance , & block ) end
348	def traverse_dependecies ( traversed_nodes , starting_node , current_node , edges , dependencies , escalation ) dependencies . each do | node_edge | node = node_edge . first traversed_nodes << node if traversed_nodes . include? ( starting_node ) if escalation == :exception raise "Cycle from #{current_node} to #{node}, starting from #{starting_node} passing #{traversed_nodes}" else return true end end return true if traverse_dependecies ( traversed_nodes , starting_node , node , edges , node_edges ( edges , node ) , escalation ) end false end
161	def update_many! ( client , ids_or_attributes , attributes = { } ) association = attributes . delete ( :association ) || Association . new ( :class => self ) response = client . connection . put ( "#{association.generate_path}/update_many" ) do | req | if attributes == { } req . body = { resource_name => ids_or_attributes } else req . params = { :ids => ids_or_attributes . join ( ',' ) } req . body = { singular_resource_name => attributes } end yield req if block_given? end JobStatus . new_from_response ( client , response ) end
828	def delete_attribute ( key_name ) key_name_sym = key_name . to_sym meta = ensure_metadata_exists ( key_name_sym ) @cache . delete ( key_name ) @writethrough . delete ( key_name ) @source . delete ( meta . source_key ) nil end
128	def kill if @threads . empty? @log . debug ( "Thread pool \"#{@title}\" terminated with no threads" ) return end @log . debug ( "Stopping \"#{@title}\" thread pool with #{@threads.count} threads: \#{@threads.map { |t| "#{t.name}/#{t.status}" }.join(', ')}..." ) start = Time . new begin join ( 0.1 ) ensure @threads . each do | t | ( t . thread_variable_get ( :kids ) || [ ] ) . each ( & :kill ) t . kill sleep ( 0.001 ) while t . alive? Thread . current . thread_variable_set ( :kids , ( Thread . current . thread_variable_get ( :kids ) || [ ] ) - [ t ] ) end @log . debug ( "Thread pool \"#{@title}\" terminated all threads in #{Age.new(start)}, \it was alive for #{Age.new(@start)}: #{@threads.map { |t| "#{t.name}/#{t.status}" }.join(', ')}" ) @threads . clear end end
1005	def disconnect channels . each do | chan | chan . close end connections . each do | conn | conn . disconnect end end
209	def get_folder ( opts = { } ) args = get_folder_args ( opts ) resp = ews . get_folder ( args ) get_folder_parser ( resp ) end
323	def retweet ( id = @current_tweet ) return if require_login == false || id . nil? id = id_from_tweet ( id ) if debug_mode? debug "I'm in debug mode, otherwise I would retweet with tweet id: #{id}" return end client . retweet id end
495	def administrators response = get ( '/admins.json' ) response . map { | item | Hashie :: Mash . new ( item ) } end
443	def update email , card_or_token = nil attributes = self . class . attributes - [ :token , :created_at ] options = self . class . parse_options_for_request ( attributes , email : email , card : card_or_token ) response = self . class . put ( URI . parse ( PinPayment . api_url ) . tap { | uri | uri . path = "/1/customers/#{token}" } , options ) self . email = response [ 'email' ] self . card = response [ 'card' ] self end
275	def every_html_doc every_page do | page | if ( block_given? && page . html? ) if ( doc = page . doc ) yield doc end end end end
920	def register ( target , * mods , & block ) options = mods . last . is_a? ( Hash ) ? mods . pop : { } mods << Module . new ( & block ) if block target = DuckPuncher . lookup_constant target Ducks . list [ target ] = Set . new [ ] unless Ducks . list . key? ( target ) mods = Array ( mods ) . each do | mod | duck = UniqueDuck . new Duck . new ( target , mod , options ) Ducks . list [ target ] << duck end [ target , * mods ] end
762	def translate_association ( assoc ) attribute = attribute_lookup ( assoc ) return unless attribute if assoc . marked_for_destruction? assoc = @form . create_association end add_association_to_attribute_map ( attribute , assoc ) end
1248	def save ( translations , file ) file = :: Rails . root . join ( file ) FileUtils . mkdir_p File . dirname ( file ) variable_to_assign = config . fetch ( :variable , 'Ember.I18n.translations' ) File . open ( file , 'w+' ) do | f | f << variable_to_assign f << ' = ' f << JSON . pretty_generate ( translations ) . html_safe f << ';' end end
1103	def name = ( value ) value = Name . parse ( value ) if String === value value = Name . new ( nil , nil ) if value . nil? unless Name === value then raise ArgumentError . new ( "Name argument type invalid; expected <#{Name}>, found <#{value.class}>" ) end self . first_name = value . first self . last_name = value . last self . middle_name = value . middle if respond_to? ( :middle_name ) end
1200	def pivot_each_column ( values = [ ] ) pivot . each do | column , parameters | value = values [ parameters [ :col ] . to_i ] value = value . strip . gsub ( / / , "" ) unless value . nil? match = false begin match = eval ( parameters [ :operation ] . gsub ( '[value]' , value ) ) rescue Exception => e end yield column , match end end
313	def reply ( txt , source , params = { } ) debug txt params = { :in_reply_to_status_id => source . id } . merge ( params ) tweet txt , params , source end
16	def report_utils ( version = nil ) version = api_config . default_version if version . nil? if ! api_config . versions . include? ( version ) raise AdsCommon :: Errors :: Error , "Unknown version '%s'" % version end return AdwordsApi :: ReportUtils . new ( self , version ) end
1173	def add_position_to_specimen_template ( specimen , template ) pos = specimen . position pas = pos . class . nondomain_attributes ss = pos . snapshot vh = ss ? pas . to_compact_hash { | pas | ss [ pas ] } : pos . value_hash ( pas ) vh [ :specimen ] = template vh [ :storage_container ] = pos . storage_container . copy template . position = pos . class . new ( vh ) logger . debug { "Work around #{specimen} update anomaly by copying position #{template.position.qp} to update template #{template.qp} as #{template.position.qp} with values #{vh.qp}..." } end
467	def get_account_activity ( start_date , end_date , options = { } ) submit GetAccountActivity . new ( options . merge ( :start_date => start_date , :end_date => end_date ) ) end
131	def legacy ( wallet , hours : 24 ) raise 'You can\'t add legacy to a non-empty patch' unless @id . nil? wallet . txns . each do | txn | @txns << txn if txn . amount . negative? && txn . date < Time . now - hours * 60 * 60 end end
1280	def publish ( exchange , routing_key , payload , options = { } ) log "Isimud::BunnyClient#publish: exchange=#{exchange} routing_key=#{routing_key}" , :debug channel . topic ( exchange , durable : true ) . publish ( payload , options . merge ( routing_key : routing_key , persistent : true ) ) end
334	def close flush ( ) @deflate_buffer << @deflater . finish unless @deflater . finished? begin until @deflate_buffer . empty? do @deflate_buffer . slice! ( 0 , delegate . write ( @deflate_buffer ) ) end rescue Errno :: EAGAIN , Errno :: EINTR retry if write_ready? end @checksum = @deflater . adler @compressed_size = @deflater . total_out @uncompressed_size = @deflater . total_in @deflater . close super ( ) nil end
1266	def do_move ( action ) options = do_move_options ( action ) path = @params . first @helper . send ( "#{action}_usage" ) unless path fn = @commands . send ( action , path , options ) puts "#{@src_dir}/#{fn}" end
529	def login ( username , password ) response = request_json ( '/api/v1/login' , method : :post , body : { username : username , password : password } ) Session . new self , Token . new ( response [ 'data' ] ) end
1291	def gen_usage puts 'Usage:' puts ' poole [ACTION] [ARG]' puts '' puts 'Actions:' puts ' draft Create a new draft in _drafts with title SLUG' puts ' post Create a new timestamped post in _posts with title SLUG' puts ' publish Publish the draft with SLUG, timestamping appropriately' puts ' unpublish Move a post to _drafts, untimestamping appropriately' exit end
1168	def default_collection_event return if registration . nil? pcl = registration . protocol || return pcl . add_defaults if pcl . events . empty? ev = pcl . sorted_events . first || return logger . debug { "Default #{qp} collection event is the registration protocol #{pcl.qp} first event #{ev.qp}." } ev end
1235	def init_key_columns ( key_scheme ) @key_titles = [ ] @key_columns = [ ] keys = key_scheme . scan ( / \d \w / ) keys . each do | key | @key_titles << key [ 1 ] @key_columns << key [ 0 ] . to_i end end
483	def ft_sugget ( attribute : , prefix : ) key = "#{@model}:#{attribute}" REDI_SEARCH . call ( 'FT.SUGGET' , key , prefix ) rescue Exception => e Rails . logger . error e if defined? Rails return e . message end
616	def next_node peer = nil if ! parent . nil? and parent . respond_to? ( :children ) index = parent . children . index ( self ) peer = parent . children [ index + 1 ] end peer end
604	def no_write! will_change! permissions . keys . each do | perm | permissions [ perm ] . write! false end end
1094	def controlled_value ( value ) return if value . blank? ControlledValues . instance . find ( @attribute , value ) or raise ControlledValueError . new ( "#{@attribute} value '#{value}' is not a recognized controlled value." ) end
373	def record_dependency ( dependency , * files ) if @reloader files = Unreloader . expand_paths ( files ) Unreloader . expand_paths ( dependency ) . each do | path | @reloader . record_dependency ( path , files ) end end end
991	def list ( type ) request = Net :: HTTP :: Get . new URI . join ( @base_uri . to_s , "cloudlets/api/v2/origins?type=#{type}" ) . to_s response = @http_host . request ( request ) response . body end
889	def build_dependency_graph ( objects ) DependencyGraph . new . tap do | graph | objects . each do | id , object | graph [ id ] = [ ] object . foreign_keys . each do | property | value = object [ property ] if value graph [ id ] << value end end end end end
893	def add_group_result ( result , group : nil ) data = { result : result } if group data [ :group ] = group end if result . present? @group_results << data end end
198	def copy ( new_folder ) new_folder = new_folder . id if new_folder . kind_of? ( GenericFolder ) copy_opts = { :to_folder_id => { :id => new_folder } , :item_ids => [ { :item_id => { :id => self . id } } ] } resp = @ews . copy_item ( copy_opts ) rmsg = resp . response_messages [ 0 ] if rmsg . success? obj = rmsg . items . first itype = obj . keys . first obj [ itype ] [ :elems ] [ 0 ] [ :item_id ] [ :attribs ] [ :id ] else raise EwsError , "Could not copy item. #{rmsg.response_code}: #{rmsg.message_text}" end end
629	def subscript style = CharacterStyle . new style . subscript = true if block_given? apply ( style ) { | node | yield node } else apply ( style ) end end
411	def verify! if signature . missing? && assertion . signature . missing? raise Samlr :: SignatureError . new ( "Neither response nor assertion signed with a certificate" ) end signature . verify! unless signature . missing? assertion . verify! true end
449	def read ( from , overwrite = false , raise = true ) tempfile = Tempfile . new to = tempfile . path tempfile . unlink get from , to , overwrite , raise File . read to end
787	def rename ( id , name = "" ) drop = Drop . find ( id ) drop . update ( :name => name ) end
273	def visit? ( url ) ! visited? ( url ) && visit_scheme? ( url . scheme ) && visit_host? ( url . host ) && visit_port? ( url . port ) && visit_link? ( url . to_s ) && visit_url? ( url ) && visit_ext? ( url . path ) && robot_allowed? ( url . to_s ) end
659	def to_s ( indent = 0 ) prefix = indent > 0 ? ' ' * indent : '' text = StringIO . new text << "#{prefix}Information" text << "\n#{prefix} Title: #{@title}" unless @title . nil? text << "\n#{prefix} Author: #{@author}" unless @author . nil? text << "\n#{prefix} Company: #{@company}" unless @company . nil? text << "\n#{prefix} Comments: #{@comments}" unless @comments . nil? text << "\n#{prefix} Created: #{@created}" unless @created . nil? text . string end
458	def has_transition? ( state , symbol ) return false unless @transitions . has_key? state if @transitions [ state ] . has_key? symbol actions = @transitions [ state ] [ symbol ] return false if actions [ 'pop' ] && @stack . last != actions [ 'pop' ] return true else return false end end
253	def cookie_params params = { } cookies . each do | value | value . split ( ';' ) . each do | param | param . strip! name , value = param . split ( '=' , 2 ) unless name =~ RESERVED_COOKIE_NAMES params [ name ] = ( value || '' ) end end end return params end
496	def set_primary_contact ( email ) options = { :query => { :email => email } } response = put ( "/primarycontact.json" , options ) Hashie :: Mash . new ( response ) end
1374	def _logical_operator ( delegated , * conditions ) unless conditions . all? { | c | conditionable? c } raise TypeError , 'wrong object for condition' end -> v { conditions . __send__ ( delegated ) { | condition | _valid? condition , v } } end
92	def extract_exception_data ( soap_fault , exception_name ) exception_type = get_full_type_signature ( exception_name ) process_attributes ( soap_fault , false ) soap_fault = normalize_fields ( soap_fault , exception_type [ :fields ] ) return soap_fault end
741	def transform_text ( type , text ) return type , text if ! config [ 'transform' ] || ! ( transforms = config [ 'transform' ] [ type ] ) if RUBY_VERSION < "1.9" require 'iconv' ic = Iconv . new ( 'UTF-8' , 'ISO-8859-1' ) text = ic . iconv ( text ) text << ic . iconv ( nil ) ic . close end transforms . each do | transform | next unless transform . size == 2 p = transform . first r = transform . last text = text . gsub ( p , r ) rescue text end return type , text end
75	def get_report_response ( report_definition , cid , & block ) definition_text = get_report_definition_text ( report_definition ) data = '__rdxml=%s' % CGI . escape ( definition_text ) return make_adhoc_request ( data , cid , & block ) end
571	def venue_categories ( options = { } ) response = connection . get do | req | req . url "venues/categories" , options end return_error_or_body ( response , response . body . response . categories ) end
384	def configure_virtual_attributes ( attributes ) @virtual_attributes = if attributes == true VirtualAttributes . new ( true ) elsif attributes . is_a? ( Hash ) VirtualAttributes . new ( true , attributes ) else VirtualAttributes . new ( false ) end end
542	def user_photos ( options = { } ) response = connection . get do | req | req . url "users/self/photos" , options end return_error_or_body ( response , response . body . response . photos ) end
696	def send_request ( params , payload = nil , content_type = nil ) req_params = setup_request ( params , payload , content_type ) handled_request ( req_params ) do request = RestClient :: Request . new ( req_params ) response = request . execute if ! [ 200 , 201 , 202 , 204 ] . include? ( response . code ) @logger . warn "Warning: unattended code #{response.code}" end parsed_response = Nokogiri :: XML ( response ) @logger . debug "Send request result: #{parsed_response}" [ parsed_response , response . headers ] end end
428	def update ( attributes ) attributes . each do | key , value | self [ key ] = value end begin resource_gateway . update ( id , attributes ) rescue RestClient :: Exception => e raise_failed_request_error ( e ) end self end
1133	def execute File . open ( out_file , 'w' ) do | o | File . new ( in_file , 'r' ) . each_with_index do | line , index | extraction = col_filter . process ( row_filter . process ( line . chomp , row : index ) ) o . puts extraction unless extraction . nil? end end end
410	def referenced_node ( id ) nodes = document . xpath ( "//*[@ID='#{id}']" ) if nodes . size != 1 raise SignatureError . new ( "Reference validation error: Invalid element references" , "Expected 1 element with id #{id}, found #{nodes.size}" ) end nodes . first end
725	def format ( format ) format = format . to_s formatters . all . include? ( format ) || raise ( Errors :: InvalidFormatError ) @format = format self end
1297	def missing_specs_from_file ( path ) Spectro :: Spec :: Parser . parse ( path ) . select do | spec | index_spec = Spectro :: Database . index [ path ] && Spectro :: Database . index [ path ] [ spec . signature . name ] index_spec . nil? || index_spec [ 'spec_md5' ] != spec . md5 end end
776	def matrices rows = data . size cols = n_classes lower_class_limits = * Matrix . zero ( rows + 1 , cols + 1 ) variance_combinations = * Matrix . zero ( rows + 1 , cols + 1 ) variance = 0 for i in 1 .. cols lower_class_limits [ 1 ] [ i ] = 1 variance_combinations [ 1 ] [ i ] = 0 for j in 2 .. rows variance_combinations [ j ] [ i ] = Float :: INFINITY end end for l in 2 .. rows sum = 0 sum_squares = 0 w = 0 for m in 1 .. l lower_class_limit = l - m + 1 val = data [ lower_class_limit - 1 ] w += 1 sum += val sum_squares += ( val ** 2 ) variance = sum_squares - ( sum ** 2 ) / w i4 = lower_class_limit - 1 if i4 != 0 for j in 2 .. cols if variance_combinations [ l ] [ j ] >= ( variance + variance_combinations [ i4 ] [ j - 1 ] ) lower_class_limits [ l ] [ j ] = lower_class_limit variance_combinations [ l ] [ j ] = variance + variance_combinations [ i4 ] [ j - 1 ] end end end end lower_class_limits [ l ] [ 1 ] = 1 variance_combinations [ l ] [ 1 ] = variance end [ lower_class_limits , variance_combinations ] end
145	def format idx case idx when Integer @formats [ idx ] || @default_format || Format . new when String @formats . find do | fmt | fmt . name == idx end end end
700	def set_vm_disk_info ( vmid , disk_info = { } ) get_response , headers = __get_disk_info ( vmid ) if disk_info [ :add ] data = add_disk ( get_response , disk_info ) else data = edit_disk ( get_response , disk_info ) end params = { 'method' => :put , 'command' => "/vApp/vm-#{vmid}/virtualHardwareSection/disks" } put_response , headers = send_request ( params , data , "application/vnd.vmware.vcloud.rasdItemsList+xml" ) task_id = headers [ :location ] . gsub ( / \/ \/ / , "" ) task_id end
183	def end_time_zone! ( zone ) attributes = { } attributes [ 'Id' ] = zone [ :id ] if zone [ :id ] attributes [ 'Name' ] = zone [ :name ] if zone [ :name ] nbuild [ NS_EWS_TYPES ] . EndTimeZone ( attributes ) end
1020	def user_by_name ( name ) data = api ( 'user.get_id' , :name => name ) user = self . user ( data [ 'userid' ] ) user . attributes = { 'name' => name } user end
396	def unsubscribe_proc ( channel , proc ) df = EM :: DefaultDeferrable . new if @sub_callbacks [ channel ] . delete ( proc ) if @sub_callbacks [ channel ] . any? df . succeed else unsubscribe ( channel ) . callback { | _ | df . succeed } end else df . fail end return df end
256	def kill! ( url ) url = URI ( url ) key = key_for ( url ) if ( sess = @sessions [ key ] ) begin sess . finish rescue IOError end @sessions . delete ( key ) end end
895	def print_artifacts artifacts = build . artifacts return if artifacts . empty? content = "### Jenkins artifacts:\n\n" content << "<img width='40' align='right' src='#{JENKINS_ICON}'></img>\n" artifacts . each do | artifact | content << "* #{artifact_link(artifact)}\n" end markdown content end
418	def rewindable ( request ) input = request . getInputStream @options [ :rewindable ] ? Rack :: RewindableInput . new ( input . to_io . binmode ) : RewindableInputStream . new ( input ) . to_io . binmode end
438	def spinner ( name , locator ) define_method ( name ) do adapter . spinner ( locator ) . value end define_method ( "#{name}=" ) do | value | adapter . spinner ( locator ) . value = value end define_method ( "increment_#{name}" ) do adapter . spinner ( locator ) . increment end define_method ( "decrement_#{name}" ) do adapter . spinner ( locator ) . decrement end define_method ( "#{name}_view" ) do adapter . spinner ( locator ) . view end end
573	def add_venue ( options = { } ) response = connection . post do | req | req . url "venues/add" , options end return_error_or_body ( response , response . body . response . venue ) end
518	def send_preview ( recipients , personalize = "fallback" ) options = { :body => { :PreviewRecipients => recipients . kind_of? ( String ) ? [ recipients ] : recipients , :Personalize => personalize } . to_json } post "sendpreview" , options end
366	def fit_power ( xs , ys ) a , b , rr = fit ( xs , ys , tran_x : -> ( x ) { Math . log ( x ) } , tran_y : -> ( y ) { Math . log ( y ) } ) [ a , Math . exp ( b ) , rr ] end
1068	def create current_count = UniqueKey . where ( list_key_params ) . count if params [ :max ] == 'Infinity' || current_count < params [ :max ] . to_i unique_key = list_key_params . merge ( position : current_count + 1 ) viewable = UniqueKey . create_localized_viewable! ( unique_key ) if unique_key [ :viewable_type ] != 'Viewable::Block' path = rails_admin . edit_path ( model_name : unique_key [ :viewable_type ] . to_s . underscore . gsub ( '/' , '~' ) , id : viewable . id ) redirect_to path else redirect_to :back end else redirect_to :back end end
562	def venuegroup ( group_id , options = { } ) response = connection . get do | req | req . url "venuegroups/#{group_id}" , options end return_error_or_body ( response , response . body . response . venueGroup ) end
395	def unsubscribe ( channel ) @sub_callbacks . delete ( channel ) @subs . delete ( channel ) raw_send_command ( :unsubscribe , [ channel ] ) return pubsub_deferrable ( channel ) end
1139	def log_configuration_information Mako . logger . info "Configuration File: #{Mako.config.config_file}" Mako . logger . info "Theme: #{Mako.config.theme}" Mako . logger . info "Destination: #{Mako.config.destination}" end
1210	def number_range ( col , start_number , end_number , arg , block ) operation = " #{start_number} <= [value] && [value] <= #{end_number}" pivot [ "#{start_number}-#{end_number}" ] = { col : col , operation : operation } end
221	def get_room_lists req = build_soap! do | type , builder | if ( type == :header ) else builder . room_lists! end end do_soap_request ( req , response_class : EwsSoapRoomlistResponse ) end
65	def run_user_block ( extractor , response , body , & block ) header = extractor . extract_header_data ( response ) case block . arity when 1 then yield ( header ) when 2 then yield ( header , body ) else raise AdsCommon :: Errors :: ApiException , "Wrong number of block parameters: %d" % block . arity end return nil end
524	def bounces ( date = "" , page = 1 , page_size = 1000 , order_field = "date" , order_direction = "asc" ) paged_result_by_date ( "bounces" , date , page , page_size , order_field , order_direction ) end
884	def load_scraped_objects { } . tap do | objects | @store . read_multi ( @store . entries ) . each do | properties | object = load_scraped_object ( properties ) objects [ object . _id ] = object end end end
1080	def copy_child_types ( other ) child_storage_types . merge! ( other . child_storage_types ) child_specimen_array_types . merge! ( other . child_specimen_array_types ) child_specimen_classes . merge! ( other . child_specimen_classes ) end
7	def cookie_jar return @cookie_jar if defined? ( @cookie_jar ) && @cookie_jar jar = @request . cookie_jar . dup headers . fetch ( :set_cookie , [ ] ) . each do | cookie | jar . parse ( cookie , @request . uri ) end @cookie_jar = jar end
160	def destroy_many! ( client , ids , association = Association . new ( :class => self ) ) response = client . connection . delete ( "#{association.generate_path}/destroy_many" ) do | req | req . params = { :ids => ids . join ( ',' ) } yield req if block_given? end JobStatus . new_from_response ( client , response ) end
1189	def active @active = client . user . playlists . all . any? { | playlist | playlist == self && playlist . active? } if @active . nil? @active end
589	def where ( constraints = nil ) return query . compile_where unless constraints . is_a? ( Hash ) query . where constraints query end
470	def submit ( request ) url = request . to_url ActiveSupport :: Notifications . instrument ( "amazon_flex_pay.api" , :action => request . action_name , :request => url ) do | payload | begin http = RestClient . get ( url ) payload [ :response ] = http . body payload [ :code ] = http . code response = request . class :: Response . from_xml ( http . body ) response . request = request response rescue RestClient :: BadRequest , RestClient :: Unauthorized , RestClient :: Forbidden => e payload [ :response ] = e . http_body payload [ :code ] = e . http_code er = AmazonFlexPay :: API :: BaseRequest :: ErrorResponse . from_xml ( e . response . body ) klass = AmazonFlexPay :: API . const_get ( er . errors . first . code ) raise klass . new ( er . errors . first . code , er . errors . first . message , er . request_id , request ) end end end
755	def save_to_photo_library ( jpeg_data , & block ) photo_library . performChanges ( -> { image = UIImage . imageWithData ( jpeg_data ) PHAssetChangeRequest . creationRequestForAssetFromImage ( image ) } , completionHandler : -> ( success , error ) { if error error_callback . call ( error ) else block . call ( nil ) end } ) end
1242	def default_derived_characteristics chrs = specimen_characteristics || return pas = chrs . class . nondomain_attributes . reject { | pa | pa == :identifier } chrs . copy ( pas ) end
783	def sign_out_url ( redirect_url = nil ) auth_server_url = Addressable :: URI . parse ( endpoint ) auth_server_url . path = '/users/sign_out' auth_server_url . query_values = { redirect_url : redirect_url } if redirect_url auth_server_url . to_s end
1098	def execute processed_header = false File . open ( outfile , 'w' ) do | out | File . open ( infile ) . each_with_index do | line , index | next if line . chomp . empty? || unstring ( line ) . chomp . split ( ';' ) . empty? unless processed_header header_row = header . process ( line . chomp ) header_row = @write_filter . process ( header_row ) unless @final_header out . puts header_row unless header_row . nil? or header_row . empty? processed_header = true next end next if row_filter . process ( line , row : index ) . nil? @columns = unstring ( line ) . chomp . split ( ';' ) formulae . each do | col , formula | @columns [ col . to_i ] = eval ( formula ) end out . puts @write_filter . process ( @columns . join ( ';' ) ) @columns . each_with_index do | column , index | column = 0 unless column . to_s =~ / \d \. / if @sum_row [ index ] @sum_row [ index ] += to_number column else @sum_row [ index ] = to_number column end end if add_sum_row end out . puts @write_filter . process ( @sum_row . join ( ';' ) ) if add_sum_row end end
72	def download_report_as_file_with_awql ( report_query , format , path , cid = nil ) report_body = download_report_with_awql ( report_query , format , cid ) save_to_file ( report_body , path ) return nil end
1270	def alert_add_entity ( entity_id , condition_id , entity_type = 'Server' ) nr_api . put do | req | req . url url ( 'alerts_entity_conditions' , entity_id ) req . params [ 'entity_type' ] = entity_type req . params [ 'condition_id' ] = condition_id end end
520	def opens ( date = "" , page = 1 , page_size = 1000 , order_field = "date" , order_direction = "asc" ) paged_result_by_date ( "opens" , date , page , page_size , order_field , order_direction ) end
23	def handle_name_override ( args , key , original_name ) rename_hash_key ( args , key , original_name ) replace_array_item ( args [ :order! ] , key , original_name ) return original_name end
493	def update ( name , html_url , zip_url ) options = { :body => { :Name => name , :HtmlPageURL => html_url , :ZipFileURL => zip_url } . to_json } put "/templates/#{template_id}.json" , options end
284	def to_absolute ( link ) link = link . to_s new_url = begin url . merge ( link ) rescue Exception return end if ( ! new_url . opaque ) && ( path = new_url . path ) if ( new_url . scheme == 'ftp' && ! path . start_with? ( '/' ) ) path . insert ( 0 , '/' ) end new_url . path = URI . expand_path ( path ) end return new_url end
431	def combo_box ( name , locator ) define_method ( "#{name}" ) do adapter . combo ( locator ) . value end define_method ( "clear_#{name}" ) do | item | adapter . combo ( locator ) . clear item end define_method ( "#{name}_selections" ) do adapter . combo ( locator ) . values end define_method ( "#{name}=" ) do | item | adapter . combo ( locator ) . set item end alias_method "select_#{name}" , "#{name}=" define_method ( "#{name}_options" ) do adapter . combo ( locator ) . options end define_method ( "#{name}_view" ) do adapter . combo ( locator ) . view end end
996	def convert_currency ( valueToConvert , firstUnit , secondUnit ) dictionary_api if validate_usd_unit ( firstUnit ) && validate_usd_unit ( secondUnit ) return valueToConvert elsif validate_usd_unit ( firstUnit ) && validate_usd_unit ( secondUnit ) == false if validate_currency_unit ( secondUnit ) finalValue = valueToConvert * @hash [ secondUnit ] return finalValue else return 0 end elsif validate_usd_unit ( firstUnit ) == false && validate_usd_unit ( secondUnit ) if validate_currency_unit ( firstUnit ) finalValue = valueToConvert / @hash [ firstUnit ] return finalValue else return 0 end else if data_validate_api ( firstUnit , secondUnit ) finalValue = ( valueToConvert / @hash [ firstUnit ] ) * @hash [ secondUnit ] return finalValue else return 0 end end end
271	def prepare_request_headers ( url ) headers = @default_headers . dup unless @host_headers . empty? @host_headers . each do | name , header | if url . host . match ( name ) headers [ 'Host' ] = header break end end end headers [ 'Host' ] ||= @host_header if @host_header headers [ 'User-Agent' ] = @user_agent if @user_agent headers [ 'Referer' ] = @referer if @referer if ( authorization = @authorized . for_url ( url ) ) headers [ 'Authorization' ] = "Basic #{authorization}" end if ( header_cookies = @cookies . for_host ( url . host ) ) headers [ 'Cookie' ] = header_cookies end return headers end
679	def get_vapp_by_name ( organization , vdcName , vAppName ) result = nil get_vdc_by_name ( organization , vdcName ) [ :vapps ] . each do | vapp | if vapp [ 0 ] . downcase == vAppName . downcase result = get_vapp ( vapp [ 1 ] ) end end result end
232	def contentful_user_agent header = { 'sdk' => sdk_info , 'app' => app_info , 'integration' => integration_info , 'platform' => platform_info , 'os' => os_info } result = [ ] header . each do | key , values | next unless values [ :name ] result << format_user_agent_header ( key , values ) end result . join ( ' ' ) end
535	def managed_pages ( options = { } ) response = connection . get do | req | req . url "pages/managing" , options end return_error_or_body ( response , response . body . response . managing ) end
364	def measure_execution_time ( data = nil , repeat : 1 , & work ) inputs = data || range ( 1 , 10_000 ) times = [ ] inputs . each_with_index do | input , i | GC . start measurements = [ ] repeat . times do measurements << clock_time { work . ( input , i ) } end times << measurements . reduce ( & :+ ) . to_f / measurements . size end [ inputs , times ] end
95	def normalize_array_field ( data , field_def ) result = data if check_key_value_struct ( result ) result = convert_key_value_to_hash ( result ) . inject ( { } ) do | s , ( k , v ) | s [ k ] = normalize_output_field ( v , field_def ) s end else result = data . map { | item | normalize_output_field ( item , field_def ) } end return result end
1000	def convert ( valueToConvert , firstUnit , secondUnit ) @api = Api :: Api . new @api . convert_currency ( valueToConvert , firstUnit , secondUnit ) end
1163	def league_entries ( summoner , optional = { } ) region = optional [ :region ] || @sightstone . region id = if summoner . is_a? Summoner summoner . id else summoner end uri = "https://prod.api.pvp.net/api/lol/#{region}/v2.3/league/by-summoner/#{id}/entry" response = _get_api_response ( uri ) _parse_response ( response ) { | resp | data = JSON . parse ( resp ) entries = [ ] data . each do | entry | entries << LeagueItem . new ( entry ) end if block_given? yield entries else return entries end } end
432	def radio ( name , locator ) define_method ( "#{name}" ) do adapter . radio ( locator ) . set end define_method ( "#{name}?" ) do adapter . radio ( locator ) . set? end define_method ( "#{name}_view" ) do adapter . radio ( locator ) . view end end
823	def validate_ipv4_addr ( value ) ipaddr = IPAddr . new ( value ) unless ipaddr . ipv4? raise ValidationError , "IP address '#{value}' is not IPv4" end ipaddr rescue ArgumentError => e raise ValidationError , "invalid IPv4 address '#{value}' - #{e.message}" end
1070	def load ( options = { } ) assert_valid_keys ( options , :song_log ) options = { :song_log => false } . merge ( options ) client = @client . url == url ? @client : Turntabler :: Client . new ( @client . user . id , @client . user . auth , :url => url , :timeout => @client . timeout ) begin data = api ( 'room.info' , :extended => options [ :song_log ] ) self . attributes = data [ 'room' ] . merge ( 'users' => data [ 'users' ] ) super ( ) ensure client . close if client != @client end end
749	def execute_and_auto_confirm ( sql , name = nil ) begin execute_system_command ( 'CHGJOB INQMSGRPY(*SYSRPYL)' ) execute_system_command ( "ADDRPYLE SEQNBR(9876) MSGID(CPA32B2) RPY('I')" ) rescue Exception => e raise unauthorized_error_message ( "CHGJOB INQMSGRPY(*SYSRPYL) and ADDRPYLE SEQNBR(9876) MSGID(CPA32B2) RPY('I')" , e ) end begin result = execute ( sql , name ) rescue Exception raise else result ensure begin execute_system_command ( 'CHGJOB INQMSGRPY(*DFT)' ) execute_system_command ( 'RMVRPYLE SEQNBR(9876)' ) rescue Exception => e raise unauthorized_error_message ( 'CHGJOB INQMSGRPY(*DFT) and RMVRPYLE SEQNBR(9876)' , e ) end end end
712	def get_organizations params = { 'method' => :get , 'command' => '/org' } response , headers = send_request ( params ) orgs = response . css ( 'OrgList Org' ) results = { } orgs . each do | org | results [ org [ 'name' ] ] = org [ 'href' ] . gsub ( / \/ \/ / , "" ) end results end
1019	def on ( event , options = { } , & block ) event = event . to_sym @event_handlers [ event ] ||= [ ] @event_handlers [ event ] << Handler . new ( event , options , & block ) true end
777	def fetch ( title , year = "" , tomatoes = false , plot = "short" ) res = network . call ( { t : title , y : year , tomatoes : tomatoes , plot : plot } ) if res [ :data ] [ "Response" ] == "False" { status : 404 } else { status : res [ :code ] , movie : parse_movie ( res [ :data ] ) } end end
304	def consumer_key ( k ) bot . deprecated "Setting consumer_key outside of your config file is deprecated!" , Kernel . caller . first bot . config [ :consumer_key ] = k end
353	def uniq_keys_candidates ( keys ) uniq_key_candidates = unique_indexes . each_with_object ( [ ] ) { | i , obj | obj << i if ( keys - i . columns . map ( & :to_sym ) ) . empty? } if unique_indexes . blank? || uniq_key_candidates . blank? raise "#{self} and its table #{model_class.table_name} must have a unique index defined " "covering columns #{keys} to be able to use saver_strategy :concurrent_safe_batch." end uniq_key_candidates end
1074	def skip assert_current_song api ( 'room.stop_song' , :songid => id , :djid => played_by . id , :roomid => room . id , :section => room . section ) true end
547	def user_set_friend_pings ( user_id , value ) response = connection . post do | req | req . url "users/#{user_id}/setpings" , value end return_error_or_body ( response , response . body . response ) end
1155	def write_result sum_line = [ sum_row_title ] ( heading . size - 2 ) . times { sum_line << "" } sum_line << sums [ sum_col_title ] row = 0 ; File . open ( outfile , 'w' ) do | out | out . puts sum_line . join ( ';' ) if row == sum_row ; row += 1 out . puts heading . join ( ';' ) key_values . each do | k , v | out . puts sum_line . join ( ';' ) if row == sum_row ; row += 1 out . puts [ k , v ] . join ( ';' ) end end end
484	def ft_sugdel_all ( attribute : ) @model . all . each { | record | ft_sugdel ( record : record , attribute : attribute ) } rescue Exception => e Rails . logger . error e if defined? Rails return e . message end
724	def all requester = Rescuetime :: Requester host = HOST parse_response requester . get ( host , params ) end
336	def each ( & b ) raise IOError , 'non-readable archive' unless readable? raise IOError , 'closed archive' if closed? unless @parse_complete then parse ( @archive ) @parse_complete = true end @entries . each ( & b ) end
157	def create_or_update! ( client , attributes , association = Association . new ( :class => self ) ) response = client . connection . post ( "#{association.generate_path}/create_or_update" ) do | req | req . body = { resource_name => attributes } yield req if block_given? end new_from_response ( client , response , Array ( association . options [ :include ] ) ) end
186	def calendar_view! ( cal_view ) attribs = { } cal_view . each_pair { | k , v | attribs [ camel_case ( k ) ] = v . to_s } @nbuild [ NS_EWS_MESSAGES ] . CalendarView ( attribs ) end
85	def add_report_definition_hash_order ( node , name = :root ) def_order = REPORT_DEFINITION_ORDER [ name ] var_order = def_order . reject { | field | ! node . include? ( field ) } node . keys . each do | key | if REPORT_DEFINITION_ORDER . include? ( key ) case node [ key ] when Hash add_report_definition_hash_order ( node [ key ] , key ) when Array node [ key ] . each do | item | add_report_definition_hash_order ( item , key ) end end end end node [ :order! ] = var_order return nil end
1129	def conditions_match? ( data ) if conditions conditions . all? { | ( key , value ) | data [ key ] == value } else true end end
1169	def default_receiver cep = collection_event_parameters cltr = cep . user if cep return cltr if cltr cp = collection_protocol || return rcv = cp . coordinators . first return rcv if rcv or cp . fetched? return cp . coordinators . first if cp . find cp . add_defaults cp . coordinators . first end
141	def update_row idx , * cells res = if row = @rows [ idx ] row [ 0 , cells . size ] = cells row else Row . new self , idx , cells end row_updated idx , res res end
1055	def find_subcontainer ( name , type ) logger . debug { "Finding box with name #{name}..." } ctr = CaTissue :: StorageContainer . new ( :name => name ) if ctr . find then logger . debug { "Container found: #{ctr}." } else logger . debug { "Container not found: #{name}." } create_subcontainer ( name , type ) end box end
1159	def place ( stone ) x , y = stone . to_coord internal_board [ y ] [ x ] = stone end
1317	def key_press ( keys ) dump_caller_stack if keys =~ / \+ / filtered_keys = "^+#{$1}" elsif keys =~ / \+ \+ / filtered_keys = "^+#{$1.downcase}" elsif keys =~ / / filtered_keys = "!+#{$1}" elsif keys =~ / \+ \+ / filtered_keys = "!+#{$1.downcase}" else filtered_keys = keys end filtered_keys = keys . gsub ( "Alt+" , "!+" ) . gsub ( "Ctrl+" , "^+" ) RFormSpec :: Keyboard . press ( filtered_keys ) sleep 0.5 end
1059	def attributes = ( attributes ) if attributes attributes . each do | attribute , value | attribute = attribute . to_s if attribute == 'metadata' self . attributes = value else __send__ ( "#{attribute}=" , value ) if respond_to? ( "#{attribute}=" , true ) end end end end
850	def bic_subjects subjects = product . subjects . select { | sub | sub . subject_scheme_id . to_i == 12 } subjects . collect { | sub | sub . subject_code } end
854	def proprietry_discount_code_for_rrp price = price_get ( 2 ) return nil if price . nil? discount = price . discounts_coded . find { | disc | disc . discount_code_type == 2 } discount . andand . discount_code end
947	def arrayorize ( value ) case value when nil then return [ ] when String then value . to_s . split when Symbol then value . to_s . split else value end end
1007	def parse_paths ( paths ) if paths paths . split ( File :: PATH_SEPARATOR ) . map do | path | Pathname . new ( path ) end else [ ] end end
980	def validate_metadata ( check = { } ) bad_metadata ( 'no variables' ) if @variables . empty? if @rectangularize msg = 'the rectangularize option requires data_structure=hier' bad_metadata ( msg ) unless @data_structure == 'hier' end if @data_structure == 'hier' or @select_vars_by_record_type bad_metadata ( 'no record types' ) if @record_types . empty? msg = 'record types must be unique' bad_metadata ( msg ) unless rec_type_lookup_hash . keys . size == @record_types . size msg = 'all variables must have a record type' bad_metadata ( msg ) unless @variables . find { | var | var . record_type . length == 0 } . nil? msg = 'with no common variables, every record type needs at least one variable (' if @variables . find { | var | var . is_common_var } . nil? @record_types . each do | rt | next if get_vars_by_record_type ( rt ) . size > 0 bad_metadata ( msg + rt + ')' ) end end end if @data_structure == 'hier' bad_metadata ( 'no record type variable' ) if record_type_var . nil? end return if check [ :minimal ] @variables . each do | v | v . start_column = v . start_column . to_i v . width = v . width . to_i v . implied_decimals = v . implied_decimals . to_i bad_metadata ( "#{v.name}, start_column" ) unless v . start_column > 0 bad_metadata ( "#{v.name}, width" ) unless v . width > 0 bad_metadata ( "#{v.name}, implied_decimals" ) unless v . implied_decimals >= 0 end end
517	def transfer_credits ( credits , can_use_my_credits_when_they_run_out ) options = { :body => { :Credits => credits , :CanUseMyCreditsWhenTheyRunOut => can_use_my_credits_when_they_run_out } . to_json } response = post 'credits' , options Hashie :: Mash . new ( response ) end
11	def options_call OmniAuth . config . before_options_phase . call ( env ) if OmniAuth . config . before_options_phase verbs = OmniAuth . config . allowed_request_methods . collect ( & :to_s ) . collect ( & :upcase ) . join ( ', ' ) [ 200 , { 'Allow' => verbs } , [ ] ] end
924	def generate_migration_body ( tables ) current_tables , new_tables = table_names ( tables ) . partition do | table_name | @db_table_names . include? ( table_name ) end add_line "change do" create_new_tables ( new_tables , tables ) alter_tables ( current_tables , tables ) add_line "end" end
620	def << ( text ) if ! last . nil? and last . respond_to? ( :text= ) last . append ( text ) else self . store ( TextNode . new ( self , text ) ) end end
674	def read_string ( index , on_failure = '' ) begin data = mutex . synchronize do if open? handle . string_descriptor_ascii ( index ) else usb_device . open { | handle | handle . string_descriptor_ascii ( index ) } end end HIDAPI . debug ( "read string at index #{index} for device #{path}: #{data.inspect}" ) data rescue => e HIDAPI . debug ( "failed to read string at index #{index} for device #{path}: #{e.inspect}" ) on_failure || '' end end
1260	def register_observer_class ( observer_class ) @observer_mutex . synchronize do return if @observed_models . include? ( observer_class ) @observed_models << observer_class log "EventListener: registering observer class #{observer_class}" observer_queue . bind ( models_exchange , routing_key : "#{Isimud.model_watcher_schema}.#{observer_class.base_class.name}.*" ) end end
933	def extract_browser ( value ) browser = value . to_s . split ( / \d / ) [ 0 ] browser = browser . to_s . split ( '|' ) [ 0 ] if browser . to_s . include? '|' browser end
917	def get_xy_tile ( xtile , ytile , zoom , style_id = nil , tile_size = nil ) style_id = self . default_style_id if style_id == nil tile_size = self . default_tile_size if tile_size == nil connect "/#{style_id}/#{tile_size}/#{zoom}/#{xtile}/#{ytile}.png" end
324	def run! before_run HANDLER_CALLS . each { | c | if ( h = @handlers [ c ] ) send ( c , * ( h . opts ) ) do | obj | h . call ( obj ) end end } after_run end
527	def stringify_hash_keys ( hash ) new_hash = { } hash . each do | key , value | new_hash [ key . to_s ] = if value . is_a? Hash stringify_hash_keys value else value end end new_hash end
132	def save ( file , overwrite : false , allow_negative_balance : false ) raise 'You have to join at least one wallet in' if empty? before = '' wallet = Wallet . new ( file ) before = wallet . digest if wallet . exists? Tempfile . open ( [ @id , Wallet :: EXT ] ) do | f | temp = Wallet . new ( f . path ) temp . init ( @id , @key , overwrite : overwrite , network : @network ) File . open ( f . path , 'a' ) do | t | @txns . each do | txn | next if Id :: BANNED . include? ( txn . bnf . to_s ) t . print "#{txn}\n" end end temp . refurbish if temp . balance . negative? && ! temp . id . root? && ! allow_negative_balance if wallet . exists? @log . info ( "The balance is negative, won't merge #{temp.mnemo} on top of #{wallet.mnemo}" ) else @log . info ( "The balance is negative, won't save #{temp.mnemo}" ) end else FileUtils . mkdir_p ( File . dirname ( file ) ) IO . write ( file , IO . read ( f . path ) ) end end before != wallet . digest end
1135	def get_doctype ( path ) doc_type = nil begin metadata = YAML . load_file ( path + 'template.yml' ) doc_type = metadata [ 'type' ] if doc_type . nil? say 'Type value not found. Check template.yml in the document directory' , :red say 'Make sure there is an entry `type: DOC_TYPE` in the file.' say " #{path}" raise_error ( 'DOC_TYPE not found in template.yml' ) end rescue Errno :: ENOENT say 'No template.yml found in the document directory. Did you forget to add it?' , :red say 'Did you run the command in the directory where the document is located?' say " #{path}" raise_error ( 'template.yml not found' ) end return doc_type end
841	def to_h { "required" => required , "short" => short , "long" => long , "desc" => desc , "default" => default , "filter" => filter , "action" => action , "cast" => cast , "valid" => valid , "validate" => validate } . reject { | k , v | v . nil? } end
1351	def wait ( mutex , timeout = nil ) validate_mutex ( mutex ) validate_timeout ( timeout ) waitable = waitable_for_current_thread @mutex . synchronize do @waitables . push ( waitable ) @waitables_to_resume . push ( waitable ) end waitable . wait ( mutex , timeout ) self end
387	def call ( worker , message , queue ) begin yield rescue Exception => ex raise ex if [ Interrupt , SystemExit , SignalException ] . include? ( ex . class ) SidekiqReporter . call ( ex , worker : worker , message : message , queue : queue ) raise ex end end
552	def mark_tip_todo ( tip_id , options = { } ) response = connection . post do | req | req . url "tips/#{tip_id}/marktodo" , options end return_error_or_body ( response , response . body . response ) end
894	def add_count ( option , value , group : nil ) data = { option : option , value : value } if group data [ :group ] = group end if option . present? && value . present? @counts << data end end
188	def attachment_ids! ( aids ) @nbuild . AttachmentIds { @nbuild . parent . default_namespace = @default_ns aids . each do | aid | attachment_id! ( aid ) end } end
1034	def normalize_scope ( object , context ) return object if object . is_a? ( Symbol ) @scope_recognizers . each_pair do | name , recognizers | return name if recognizers . any? { | r | lambda ( & r ) . call ( context , object ) } end @scope_converters . each do | converter | scope = lambda ( & converter ) . call ( context , object ) return normalize_scope ( scope , converter ) unless scope . nil? end return :default end
950	def get_request ( path ) resp = nil begin Timeout :: timeout ( 5 ) do resp = do_http_request ( path ) end rescue => e raise NetBooter :: Error . new ( "Error connecting to relay: #{e.message}" ) end resp end
699	def get_vm_disk_info ( vmid ) response , headers = __get_disk_info ( vmid ) disks = [ ] response . css ( "Item" ) . each do | entry | resource = entry . css ( "rasd|HostResource" ) . first next unless resource name = entry . css ( "rasd|ElementName" ) . first name = name . text unless name . nil? capacity = resource . attribute ( "capacity" ) . text disks << { :name => name , :capacity => "#{capacity} MB" } end disks end
838	def holiday? ( arg ) date = to_date ( arg ) holidays ( start_date : date , end_date : date + 1 . day , limit : 1 ) . length > 0 end
505	def campaigns response = get 'campaigns' response . map { | item | Hashie :: Mash . new ( item ) } end
733	def parse self . class . rules . each do | target , ( selector , delegate , plural ) | if plural send ( target ) . concat @doc . search ( selector ) . map { | i | parse_result ( i , delegate ) } else send ( "#{target}=" , parse_result ( @doc . at ( selector ) , delegate ) ) end end self end
862	def befriend new_friend run_callbacks :befriend do friendships . create friend_id : new_friend . id , friend_type : new_friend . class . name end end
206	def subscribe ( evtypes = [ :all ] , watermark = nil , timeout = 240 ) unsubscribe if subscribed? event_types = normalize_event_names ( evtypes ) folder = { id : self . id , change_key : self . change_key } resp = ews . pull_subscribe_folder ( folder , event_types , timeout , watermark ) rmsg = resp . response_messages . first if rmsg . success? @subscription_id = rmsg . subscription_id @watermark = rmsg . watermark true else raise EwsSubscriptionError , "Could not subscribe: #{rmsg.code}: #{rmsg.message_text}" end end
1148	def ping ( ) log . debug "Pinging" Timeout . timeout ( 1 ) do TCPSocket . new ( address , 22 ) . close end true rescue Timeout :: Error , Errno :: ECONNREFUSED fail "Failed to ping #{self}" end
504	def update ( new_email_address , name , access_level , password ) options = { :query => { :email => @email_address } , :body => { :EmailAddress => new_email_address , :Name => name , :AccessLevel => access_level , :Password => password } . to_json } put uri_for ( client_id ) , options @email_address = new_email_address end
1	def to_s super + ":\n" + format_observation ( result . control ) + "\n" + result . candidates . map { | candidate | format_observation ( candidate ) } . join ( "\n" ) + "\n" end
272	def prepare_request ( url , & block ) path = unless url . path . empty? url . path else '/' end path += "?#{url.query}" if url . query headers = prepare_request_headers ( url ) begin sleep ( @delay ) if @delay > 0 yield @sessions [ url ] , path , headers rescue SystemCallError , Timeout :: Error , SocketError , IOError , OpenSSL :: SSL :: SSLError , Net :: HTTPBadResponse , Zlib :: Error @sessions . kill! ( url ) failed ( url ) return nil end end
561	def add_checkin_reply ( checkin_id , options = { } ) response = connection . post do | req | req . url "checkins/#{checkin_id}/reply" , options end return_error_or_body ( response , response . body . response . reply ) end
1108	def with ( hash , quiet : false ) old_values = data . values_at ( hash . keys ) log . debug "with #{hash}" , quiet : quiet do set hash yield end ensure hash . keys . each . with_index do | key , i | @data [ key ] = old_values [ i ] end end
694	def get_task ( taskid ) params = { 'method' => :get , 'command' => "/task/#{taskid}" } response , headers = send_request ( params ) task = response . css ( 'Task' ) . first status = task [ 'status' ] start_time = task [ 'startTime' ] end_time = task [ 'endTime' ] { :status => status , :start_time => start_time , :end_time => end_time , :response => response } end
729	def where ( name : nil , document : nil ) name || raise ( ArgumentError , 'missing keyword: name' ) add_to_query restrict_thing : name , restrict_thingy : document end
190	def dispatch_update_type! ( update ) type = update . keys . first upd = update [ type ] case type when :append_to_item_field append_to_item_field! ( upd ) when :set_item_field set_item_field! ( upd ) when :delete_item_field delete_item_field! ( upd ) else raise EwsBadArgumentError , "Bad Update type. #{type}" end end
560	def add_checkin_comment ( checkin_id , options = { } ) response = connection . post do | req | req . url "checkins/#{checkin_id}/addcomment" , options end return_error_or_body ( response , response . body . response ) end
763	def add_association_to_attribute_map ( attribute , assoc ) current = @attributes [ attribute ] return if current && assoc . blank? case current when nil then @attributes [ attribute ] = [ assoc ] when Array then @attributes [ attribute ] . push ( assoc ) end end
752	def captureOutput ( output , didFinishProcessingPhoto : photo , error : error ) if error error_callback . call ( error ) else @capture_callback . call ( photo . fileDataRepresentation ) end end
55	def to_statement ( ) @api . utils_reporter . statement_builder_used ( ) validate ( ) ordering = @ascending ? 'ASC' : 'DESC' pql_query = PQLQuery . new pql_query << SELECT % @select unless @select . to_s . empty? pql_query << FROM % @from unless @from . to_s . empty? pql_query << WHERE % @where unless @where . to_s . empty? pql_query << ORDER % [ @order_by , ordering ] unless @order_by . to_s . empty? pql_query << LIMIT % @limit unless @limit . nil? pql_query << OFFSET % @offset unless @offset . nil? return { :query => pql_query . to_s ( ) , :values => @pql_values . values } end
521	def clicks ( date = "" , page = 1 , page_size = 1000 , order_field = "date" , order_direction = "asc" ) paged_result_by_date ( "clicks" , date , page , page_size , order_field , order_direction ) end
809	def read_pins p = FFI :: MemoryPointer . new ( :uchar , 1 ) check_result ( Ftdi . ftdi_read_pins ( ctx , p ) ) p . read_uchar end
1016	def retrieve_methods ( script ) code = File . read ( script ) methods = code . scan ( / \s \s \s / ) result = [ ] methods . each do | method | result << method [ 0 ] end result end
150	def fetch! ( reload = false ) if @resources && ( ! @fetchable || ! reload ) return @resources elsif association && association . options . parent && association . options . parent . new_record? return ( @resources = [ ] ) end @response = get_response ( @query || path ) handle_response ( @response . body ) @resources end
223	def build_soap! ( & block ) opts = { :server_version => server_version , :impersonation_type => impersonation_type , :impersonation_mail => impersonation_address } opts [ :time_zone_context ] = @time_zone_context if @time_zone_context EwsBuilder . new . build! ( opts , & block ) end
337	def add_entry ( entry ) raise IOError , 'non-writable archive' unless writable? raise IOError , 'closed archive' if closed? unless entry . kind_of? ( Entry ) then raise ArgumentError , 'Archive::Zip::Entry instance required' end @entries << entry self end
298	def - ( oth ) if oth . is_a? Integer self . prefix - oth else ( self . prefix - oth . prefix ) . abs end end
1386	def method_missing method , * args , & block if args . empty? @config . send ( method ) else @config . send ( "#{method}=" , args . first ) end end
531	def images inline_attachments = mail . attachments . select ( & :inline? ) inline_attachments . collect do | attachment | { name : attachment . cid , type : attachment . mime_type , content : Base64 . encode64 ( attachment . body . decoded ) } end end
728	def order_by ( order , interval : nil ) order = order . to_s interval = interval ? interval . to_s : nil unless valid_order? order raise Errors :: InvalidQueryError , "#{order} is not a valid order" end unless valid_interval? interval raise Errors :: InvalidQueryError , "#{interval} is not a valid interval" end add_to_query perspective : ( order == 'time' ? 'interval' : order ) , resolution_time : interval end
197	def move! ( new_folder ) new_folder = new_folder . id if new_folder . kind_of? ( GenericFolder ) move_opts = { :to_folder_id => { :id => new_folder } , :item_ids => [ { :item_id => { :id => self . id } } ] } resp = @ews . move_item ( move_opts ) rmsg = resp . response_messages [ 0 ] if rmsg . success? obj = rmsg . items . first itype = obj . keys . first obj [ itype ] [ :elems ] [ 0 ] [ :item_id ] [ :attribs ] [ :id ] else raise EwsError , "Could not move item. #{resp.code}: #{resp.message}" end end
1191	def add_specimens ( * args ) hash = args . pop spcs = args unless Hash === hash then raise ArgumentError . new ( "Collection parameters are missing when adding specimens to protocol #{self}" ) end unless hash . has_key? ( :registration ) || hash . has_key? ( :collection_protocol_registration ) then pnt = hash . delete ( :participant ) unless pnt then raise ArgumentError . new ( "Registration or participant missing from collection parameters: #{hash.qp}" ) end hash [ :registration ] = registration ( pnt ) || make_cpr ( pnt ) end scg = SpecimenCollectionGroup . new ( hash ) spcs . each { | spc | spc . specimen_collection_group = scg } scg end
510	def people response = get "people" response . map { | item | Hashie :: Mash . new ( item ) } end
1144	def publish_to_socket ( params ) message = params . is_a? ( String ) ? params : params . to_json data = "~m~#{message.length}~m~#{message}" @socket . send ( data ) end
1022	def search_song ( query , options = { } ) assert_valid_keys ( options , :artist , :duration , :page ) options = { :page => 1 } . merge ( options ) raise ( APIError , 'User must be in a room to search for songs' ) unless room if artist = options [ :artist ] query = "title: #{query}" query << " artist: #{artist}" end query << " duration: #{options[:duration]}" if options [ :duration ] api ( 'file.search' , :query => query , :page => options [ :page ] ) conditions = { 'query' => query } EventMachine . add_timer ( @timeout ) do trigger ( :search_failed , conditions ) end if @timeout songs = wait do | & resume | on ( :search_completed , :once => true , :if => conditions ) { | songs | resume . call ( songs ) } on ( :search_failed , :once => true , :if => conditions ) { resume . call } end @event_handlers [ :search_completed ] . delete_if { | handler | handler . conditions == conditions } @event_handlers [ :search_failed ] . delete_if { | handler | handler . conditions == conditions } songs || raise ( APIError , 'Search failed to complete' ) end
1021	def avatars data = api ( 'user.available_avatars' ) avatars = [ ] data [ 'avatars' ] . each do | avatar_group | avatar_group [ 'avatarids' ] . each do | avatar_id | avatars << Avatar . new ( self , :_id => avatar_id , :min => avatar_group [ 'min' ] , :acl => avatar_group [ 'acl' ] ) end end avatars end
429	def text ( name , locator ) define_method ( "#{name}" ) do adapter . text ( locator ) . value end define_method ( "#{name}=" ) do | text | adapter . text ( locator ) . set text end define_method ( "clear_#{name}" ) do adapter . text ( locator ) . clear end define_method ( "enter_#{name}" ) do | text | adapter . text ( locator ) . enter text end define_method ( "#{name}_view" ) do adapter . text ( locator ) . view end end
619	def store ( node ) if ! node . nil? @children . push ( node ) if ! @children . include? ( Node ) node . parent = self if node . parent != self end node end
1322	def parents page , parents = self , Array . new while page . parent page = page . parent parents << page end parents end
260	def is_content_type? ( type ) if type . include? ( '/' ) content_types . any? do | value | value = value . split ( ';' , 2 ) . first value == type end else content_types . any? do | value | value = value . split ( ';' , 2 ) . first value = value . split ( '/' , 2 ) . last value == type end end end
282	def each_link return enum_for ( __method__ ) unless block_given? filter = lambda { | url | yield url unless ( url . nil? || url . empty? ) } each_redirect ( & filter ) if is_redirect? if ( html? && doc ) doc . search ( '//a[@href]' ) . each do | a | filter . call ( a . get_attribute ( 'href' ) ) end doc . search ( '//frame[@src]' ) . each do | iframe | filter . call ( iframe . get_attribute ( 'src' ) ) end doc . search ( '//iframe[@src]' ) . each do | iframe | filter . call ( iframe . get_attribute ( 'src' ) ) end doc . search ( '//link[@href]' ) . each do | link | filter . call ( link . get_attribute ( 'href' ) ) end doc . search ( '//script[@src]' ) . each do | script | filter . call ( script . get_attribute ( 'src' ) ) end end end
1396	def create_resource_class raise "Please set the site for #{self} class." unless ( self . site ) created_class = Class . new ( MingleResource ) created_class . format = :xml setup_class ( created_class ) created_class end
1122	def blocks data = api ( 'block.list_all' ) data [ 'blocks' ] . map { | attrs | User . new ( client , attrs [ 'block' ] [ 'blocked' ] ) } end
1081	def generate opts = CliOptions . new ( options ) gen = CodeGenerator . new ( opts . input , opts . output ) gen . generate end
423	def mtime ( file ) begin return unless file stat = File . stat ( file ) stat . file? ? stat . mtime . to_i : nil rescue Errno :: ENOENT , Errno :: ENOTDIR , Errno :: ESRCH nil end end
577	def venues_timeseries ( options = { } ) options [ :venueId ] = options [ :venueId ] . join ( ',' ) response = connection . get do | req | req . url "venues/timeseries" , options end return_error_or_body ( response , response . body . response ) end
1392	def raise ( exception = nil ) exception = case when exception == nil then StandardError . new when exception . is_a? ( Exception ) then exception when Exception >= exception then exception . new else Kernel . raise ( TypeError , "'exception' must be nil or an instance of or descendant of Exception" ) end @mutex . synchronize do Kernel . raise ( Complete ) if @complete @complete = true @exception = exception @waiter . resume_all_indefinitely end nil end
475	def ft_add_all @model . all . each { | record | ft_add ( record : record ) } ft_optimize rescue Exception => e Rails . logger . error e if defined? Rails return e . message end
121	def includes_negative? ( id , bnf = nil ) raise 'The txn ID has to be of type Integer' unless id . is_a? ( Integer ) ! txns . find { | t | t . id == id && ( bnf . nil? || t . bnf == bnf ) && t . amount . negative? } . nil? end
909	def find_schedule minutes = { hourly : 58 , daily : 24 * 60 , weekly : 7 * 24 * 60 , monthly : 30 * 24 * 60 , yearly : 365 * 24 * 60 } now = DateTime . now [ :yearly , :monthly , :weekly , :daily , :hourly ] . each do | schedule | next if backups_to_keep ( schedule ) <= 0 list = list_backup_dir schedule date = list . map { | path | parse_backup_dir_name path , now . offset } . max return schedule if ! date || ( now - date ) * 24 * 60 >= minutes [ schedule ] end nil end
539	def user_friends ( user_id , options = { } ) response = connection . get do | req | req . url "users/#{user_id}/friends" , options end return_error_or_body ( response , response . body . response . friends ) end
180	def mailbox! ( mbox ) nbuild [ NS_EWS_TYPES ] . Mailbox { name! ( mbox [ :name ] ) if mbox [ :name ] email_address! ( mbox [ :email_address ] ) if mbox [ :email_address ] address! ( mbox [ :address ] ) if mbox [ :address ] routing_type! ( mbox [ :routing_type ] ) if mbox [ :routing_type ] mailbox_type! ( mbox [ :mailbox_type ] ) if mbox [ :mailbox_type ] item_id! ( mbox [ :item_id ] ) if mbox [ :item_id ] } end
847	def title composite = product . titles . first if composite . nil? nil else composite . title_text || composite . title_without_prefix end end
803	def usb_open_desc_index ( vendor , product , description , serial , index ) raise ArgumentError . new ( 'vendor should be Fixnum' ) unless vendor . kind_of? ( Fixnum ) raise ArgumentError . new ( 'product should be Fixnum' ) unless product . kind_of? ( Fixnum ) raise ArgumentError . new ( 'index should be Fixnum' ) unless index . kind_of? ( Fixnum ) raise ArgumentError . new ( 'index should be greater than or equal to zero' ) if index < 0 check_result ( Ftdi . ftdi_usb_open_desc_index ( ctx , vendor , product , description , serial , index ) ) end
158	def create_or_update_many! ( client , attributes ) association = Association . new ( :class => self ) response = client . connection . post ( "#{association.generate_path}/create_or_update_many" ) do | req | req . body = { resource_name => attributes } yield req if block_given? end JobStatus . new_from_response ( client , response ) end
1027	def reconnect_from ( * exceptions ) begin yield rescue * exceptions => ex if @reconnect logger . debug "Connection failed: #{ex.message}" EM :: Synchrony . sleep ( @reconnect_wait ) logger . debug 'Attempting to reconnect' retry else raise end end end
29	def add_attribute ( node , key , name , value ) node [ :attributes! ] ||= { } node [ :attributes! ] [ key ] ||= { } if node [ :attributes! ] [ key ] . include? ( name ) node [ :attributes! ] [ key ] [ name ] = arrayize ( node [ :attributes! ] [ key ] [ name ] ) node [ :attributes! ] [ key ] [ name ] << value else node [ :attributes! ] [ key ] [ name ] = value end end
1181	def create_sum_row line = [ ] header . clear_header_cols . each do | col | line << @sum_row [ col ] || "" end line . flatten . join ( ';' ) end
1142	def create_operands ( opts ) files = opts [ :files ] . split ( ',' ) rlabels = opts [ :rlabels ] . split ( ',' ) . collect { | l | l . upcase == "TRUE" } clabels = opts [ :clabels ] . split ( ',' ) . collect { | l | l . upcase == "TRUE" } operands = { } opts [ :aliases ] . split ( ',' ) . each_with_index do | a , i | operands [ a ] = SpreadSheet . new ( file : files [ i ] , ds : opts [ :ds ] , equalize : opts [ :equalize ] , r : rlabels [ i ] , c : clabels [ i ] ) end operands end
550	def venue_tips ( venue_id , options = { } ) query = options . delete ( :query ) response = connection . get do | req | req . url "venues/#{venue_id}/tips" , options end tips = return_error_or_body ( response , response . body . response . tips ) tips = Foursquare2 . filter ( tips , query ) if query tips end
680	def poweroff_vapp ( vAppId ) builder = Nokogiri :: XML :: Builder . new do | xml | xml . UndeployVAppParams ( "xmlns" => "http://www.vmware.com/vcloud/v1.5" ) { xml . UndeployPowerAction 'powerOff' } end params = { 'method' => :post , 'command' => "/vApp/vapp-#{vAppId}/action/undeploy" } response , headers = send_request ( params , builder . to_xml , "application/vnd.vmware.vcloud.undeployVAppParams+xml" ) task_id = headers [ :location ] . gsub ( / \/ \/ / , "" ) task_id end
556	def return_error_or_body ( response , response_body ) if response . body [ 'meta' ] . code == 200 response_body else raise Foursquare2 :: APIError . new ( response . body [ 'meta' ] , response . body [ 'response' ] ) end end
419	def servlet_to_rack ( request ) env = Hash . new env [ 'REQUEST_METHOD' ] = request . getMethod env [ 'QUERY_STRING' ] = request . getQueryString . to_s env [ 'SERVER_NAME' ] = request . getServerName env [ 'SERVER_PORT' ] = request . getServerPort . to_s env [ 'rack.version' ] = Rack :: VERSION env [ 'rack.url_scheme' ] = request . getScheme env [ 'HTTP_VERSION' ] = request . getProtocol env [ "SERVER_PROTOCOL" ] = request . getProtocol env [ 'REMOTE_ADDR' ] = request . getRemoteAddr env [ 'REMOTE_HOST' ] = request . getRemoteHost env [ 'REQUEST_PATH' ] = request . getRequestURI env [ 'PATH_INFO' ] = request . getRequestURI env [ 'SCRIPT_NAME' ] = "" env [ 'REQUEST_URI' ] = request . getRequestURL . to_s env [ 'REQUEST_URI' ] << "?#{env['QUERY_STRING']}" if env [ 'QUERY_STRING' ] env [ 'rack.multiprocess' ] = false env [ 'rack.multithread' ] = true env [ 'rack.run_once' ] = false env [ 'rack.input' ] = @server . rewindable ( request ) env [ 'rack.input' ] . set_encoding ( Encoding . find ( "ASCII-8BIT" ) ) if env [ 'rack.input' ] . respond_to? ( :set_encoding ) request . getHeaderNames . each do | header_name | header = header_name . to_s . upcase . tr ( '-' , '_' ) env [ "HTTP_#{header}" ] = request . getHeader ( header_name ) end env [ "CONTENT_TYPE" ] = env . delete ( "HTTP_CONTENT_TYPE" ) if env [ "HTTP_CONTENT_TYPE" ] env [ "CONTENT_LENGTH" ] = env . delete ( "HTTP_CONTENT_LENGTH" ) if env [ "HTTP_CONTENT_LENGTH" ] env [ 'rack.errors' ] ||= @server . logger env [ 'rack.logger' ] ||= @server . logger return ( env ) end
961	def inversion ( amount ) fail ArgumentError , 'Inversion amount must be greater than or equal to 1' if amount < 1 fail ArgumentError , 'Not enough notes in chord for inversion' if amount >= @notes . size note_array = @notes . to_a . sort notes = ( 0 ... amount ) . collect { note_array . shift . adjust_by_semitones ( 12 ) } Chord . new ( notes + note_array ) end
563	def add_venuegroup ( options = { } ) response = connection . post do | req | req . url "venuegroups/add" , options end return_error_or_body ( response , response . body . response . venueGroup ) end
1289	def ensure_jekyll_dir @orig_dir = Dir . pwd start_path = Pathname . new ( @orig_dir ) ok = File . exists? ( './_posts' ) new_path = nil if ! ok check_custom_src_dir! ok = File . exists? ( './_posts' ) new_path = Pathname . new ( Dir . pwd ) end if ok return ( new_path ? new_path . relative_path_from ( start_path ) : '.' ) else puts 'ERROR: Cannot locate _posts directory. Double check to make sure' puts ' that you are in a jekyll directory.' exit end end
464	def recipient_pipeline ( caller_reference , return_url , options = { } ) cbui Recipient . new ( options . merge ( :caller_reference => caller_reference , :return_url => return_url ) ) end
778	def find ( id , tomatoes = false , plot = "short" ) res = network . call ( { i : id , tomatoes : tomatoes , plot : plot } ) if res [ :data ] [ "Response" ] == "False" { status : 404 } else { status : res [ :code ] , movie : parse_movie ( res [ :data ] ) } end end
819	def matches ( regexp , word ) if regexp . respond_to? ( :match? ) regexp . match? ( word ) else regexp . match ( word ) end end
36	def find_value ( data , path ) return ( path . nil? or data . nil? ) ? nil : path . split ( '.' ) . inject ( data ) do | node , section | break if node . nil? key = section . to_sym ( node . is_a? ( Hash ) and node . include? ( key ) ) ? node [ key ] : nil end end
80	def log_headers ( headers ) @api . logger . debug ( 'HTTP headers: [%s]' % ( headers . map { | k , v | [ k , v ] . join ( ': ' ) } . join ( ', ' ) ) ) end
380	def request ( action , method = :get , payload = { } ) res = TwoCaptcha :: HTTP . request ( url : BASE_URL . gsub ( ':action' , action ) , timeout : timeout , method : method , payload : payload . merge ( key : key , soft_id : 800 ) ) validate_response ( res ) res end
1350	def ever_followed follow = [ ] self . followed_history . each do | h | follow << h . split ( '_' ) [ 0 ] . constantize . find ( h . split ( '_' ) [ 1 ] ) end follow end
717	def get_provider ( id , opts = { } ) matching_provider_args = providers . find_all { | args | args . first == id } matching_provider_args . sort! do | args_a , args_b | ( Provider . new ( * args_b ) . priority || self . default_priority ) <=> ( Provider . new ( * args_a ) . priority || self . default_priority ) end args = matching_provider_args [ opts [ :skip ] . to_i ] return args . nil? ? nil : Provider . new ( * args ) end
1315	def sort_link ( model , field , params , html_options = { } ) if ( field . to_sym == params [ :by ] || field == params [ :by ] ) && params [ :dir ] == "ASC" classname = "arrow-asc" dir = "DESC" elsif ( field . to_sym == params [ :by ] || field == params [ :by ] ) classname = "arrow-desc" dir = "ASC" else dir = "ASC" end options = { :anchor => html_options [ :anchor ] || nil , :by => field , :dir => dir , :query => params [ :query ] , :show => params [ :show ] } options [ :show ] = params [ :show ] unless params [ :show ] . blank? || params [ :show ] == 'all' html_options = { :class => "#{classname} #{html_options[:class]}" , :style => "color: white; font-weight: #{params[:by] == field ? "bold" : "normal"}; #{html_options[:style]}" , :title => "Sort by this field" } field_name = params [ :labels ] && params [ :labels ] [ field ] ? params [ :labels ] [ field ] : field . titleize _link = model . is_a? ( Symbol ) ? eval ( "#{model}_url(options)" ) : "/#{model}?#{options.to_params}" link_to ( field_name , _link , html_options ) end
877	def validate! if self . class . json_schema self . class . validator . instance_variable_set ( '@errors' , [ ] ) self . class . validator . instance_variable_set ( '@data' , stringify_keys ( to_h ( persist : true ) ) ) self . class . validator . validate true end end
245	def seed ( * args , & block ) SeedFu :: Seeder . new ( self , * parse_seed_fu_args ( args , block ) ) . seed end
1040	def to = ( location ) if location . nil? then raise ArgumentError . new ( "Specimen cannot be moved to an empty location" ) end self . to_container = location . container self . to_row = location . row self . to_column = location . column end
192	def dispatch_field_item! ( item , ns_prefix = nil ) item . values . first [ :xmlns_attribute ] = ns_prefix if ns_prefix build_xml! ( item ) end
101	def process_attributes ( data , keep_xsi_type = false ) if keep_xsi_type xsi_type = data . delete ( :" " ) data [ :xsi_type ] = xsi_type if xsi_type end data . reject! { | key , value | key . to_s . start_with? ( '@' ) } end
594	def decode ( list ) list . map { | m | Parse :: Object . build ( m , @table ) } . compact end
1194	def runebook ( summoner , optional = { } ) region = optional [ :region ] || @sightstone . region id = if summoner . is_a? Summoner summoner . id else summoner end uri = "https://prod.api.pvp.net/api/lol/#{region}/v1.3/summoner/#{id}/runes" response = _get_api_response ( uri ) _parse_response ( response ) { | resp | data = JSON . parse ( resp ) book = RuneBook . new ( data . values [ 0 ] ) if block_given? yield book else return book end } end
887	def build_losers_to_winners_map ( objects ) inverse = { } objects . each do | id , object | ( inverse [ object . to_h . except ( :_id ) ] ||= [ ] ) << id end { } . tap do | map | inverse . values . each do | ids | ids . drop ( 1 ) . each do | id | map [ id ] = ids [ 0 ] end end end end
740	def process_part ( part ) return if ignore_media? ( part . part_type? , part ) type , file = process_media ( part ) add_file ( type , file ) unless type . nil? || file . nil? end
964	def validate_presence ( field , value , setting ) if ( value . is_a? ( Numeric ) ) return true elsif value . is_a? ( String ) || value . nil? result = value . nil? || ( ( value . length == 0 ) == setting ) additional_message = setting ? "non-empty" : "non-empty" add_message ( field , "incorrect value supplied for #{field.to_s} -- should be #{additional_message}." ) if result return ! result end return false end
1217	def log out . sync = true @log ||= Logger . new ( out ) @log . formatter = proc do | severity , datetime , progname , msg | if verbose string = "#{severity} [#{datetime.strftime('%Y-%m-%d %H:%M:%S.%2N')}]: " else string = "[#{datetime.strftime('%H:%M:%S')}]: " end string += "#{msg}\n" string end @log end
1349	def followee_of? ( model ) 0 < self . followers . by_model ( model ) . limit ( 1 ) . count * model . followees . by_model ( self ) . limit ( 1 ) . count end
226	def subscribe ( subscriptions ) req = build_soap! do | type , builder | if ( type == :header ) else builder . nbuild . Subscribe { builder . nbuild . parent . default_namespace = @default_ns subscriptions . each do | sub | subtype = sub . keys . first if ( builder . respond_to? ( subtype ) ) builder . send subtype , sub [ subtype ] else raise EwsBadArgumentError , "Bad subscription type. #{subtype}" end end } end end do_soap_request ( req , response_class : EwsResponse ) end
102	def service ( name , version = nil ) name = name . to_sym version = ( version . nil? ) ? api_config . default_version : version . to_sym validate_service_request ( version , name ) wrapper = if @wrappers . include? ( version ) && @wrappers [ version ] [ name ] @wrappers [ version ] [ name ] else @wrappers [ version ] ||= { } @wrappers [ version ] [ name ] = prepare_wrapper ( version , name ) end return wrapper end
90	def get_extra_user_agents ( ) @extra_user_agents_lock . synchronize do user_agents = @extra_user_agents . collect do | k , v | v . nil? ? k : '%s/%s' % [ k , v ] end @extra_user_agents . clear return user_agents end end
295	def split ( subnets = 2 ) unless ( 1 .. ( 2 ** @prefix . host_prefix ) ) . include? subnets raise ArgumentError , "Value #{subnets} out of range" end networks = subnet ( newprefix ( subnets ) ) until networks . size == subnets networks = sum_first_found ( networks ) end return networks end
257	def sanitize_url ( url ) url = URI ( url ) url . fragment = nil if @strip_fragments url . query = nil if @strip_query return url end
93	def normalize_fields ( data , fields ) fields . each do | field | field_name = field [ :name ] if data . include? ( field_name ) field_data = data [ field_name ] field_data = normalize_output_field ( field_data , field ) field_data = check_array_collapse ( field_data , field ) data [ field_name ] = field_data unless field_data . nil? end end return data end
575	def suggest_completion_venues ( options = { } ) response = connection . get do | req | req . url "venues/suggestCompletion" , options end return_error_or_body ( response , response . body . response ) end
695	def wait_task_completion ( taskid ) errormsg = nil task = { } loop do task = get_task ( taskid ) break if task [ :status ] != 'running' sleep 1 end if task [ :status ] == 'error' errormsg = task [ :response ] . css ( "Error" ) . first errormsg = "Error code #{errormsg['majorErrorCode']} - #{errormsg['message']}" end { :status => task [ :status ] , :errormsg => errormsg , :start_time => task [ :start_time ] , :end_time => task [ :end_time ] } end
1058	def type_path_to ( storable ) shortest = nil holds_storage_types . each do | st | stp = st . path_to ( storable ) || next shortest = stp if shortest . nil? or stp . size < shortest . size end shortest end
731	def valid_credentials? return false unless api_key? ! activities . all . nil? rescue Rescuetime :: Errors :: InvalidCredentialsError false end
1301	def send_voice_confirmation! return false if _TC_voice_blocked return true if voice_confirmed? return false if _TC_phone_number . blank? format_phone_number confirmation_code = TwilioContactable . confirmation_code ( self , :voice ) response = TwilioContactable :: Gateway . initiate_voice_call ( self , _TC_formatted_phone_number ) if response . success? update_twilio_contactable_voice_confirmation confirmation_code end response end
140	def format_column idx , format = nil , opts = { } opts [ :worksheet ] = self res = case idx when Integer column = nil if format column = Column . new ( idx , format , opts ) end @columns [ idx ] = column else idx . collect do | col | format_column col , format , opts end end shorten @columns res end
625	def apply ( style ) if ! style . is_character_style? RTFError . fire ( "Non-character style specified to the " "CommandNode#apply() method." ) end root . colours << style . foreground unless style . foreground . nil? root . colours << style . background unless style . background . nil? root . fonts << style . font unless style . font . nil? node = CommandNode . new ( self , style . prefix ( root . fonts , root . colours ) ) yield node if block_given? self . store ( node ) end
416	def report_class ( jacoco_class ) counter = coverage_counter ( jacoco_class ) coverage = ( counter . covered . fdiv ( counter . covered + counter . missed ) * 100 ) . floor required_coverage = minimum_class_coverage_map [ jacoco_class . name ] required_coverage = minimum_class_coverage_percentage if required_coverage . nil? status = coverage_status ( coverage , required_coverage ) { covered : coverage , status : status , required_coverage_percentage : required_coverage } end
1325	def manager_ws_uri uri = URI . parse ( manager_uri ) uri . scheme = ( uri . scheme == "https" ? "wss" : "ws" ) uri . path = "/wsapi" return uri . to_s end
1111	def sh ( command , as : user , on : hosts , quiet : false , once : nil ) self . once once , quiet : quiet do log . info "sh #{command}" , quiet : quiet do hash_map ( hosts ) do | host | host . sh command , as : as , quiet : quiet end end end end
111	def symbolize_config_value ( key ) value_str = @config . read ( key ) . to_s if ! value_str . nil? and ! value_str . empty? value = value_str . upcase . to_sym @config . set ( key , value ) end end
742	def transform_text_part ( part ) type = part . part_type? text = part . body . decoded . strip transform_text ( type , text ) end
42	def has_next_landscape_page ( page ) raise ArgumentError , 'Cannot page through query with no LIMIT clause.' if @start_index . nil? return false unless page [ :entries ] total_landscape_points_in_page = 0 page [ :entries ] . each do | landscape | total_landscape_points_in_page += landscape [ :landscape_points ] . size end return total_landscape_points_in_page >= @page_size end
231	def os_info os_name = case :: RbConfig :: CONFIG [ 'host_os' ] when / /i then 'Windows' when / /i then 'macOS' when / /i then 'Linux' end { name : os_name , version : Gem :: Platform . local . version } end
262	def from_page ( page ) cookies = page . cookie_params unless cookies . empty? self [ page . url . host ] = cookies return true end return false end
461	def assign ( hash ) hash . each do | k , v | send ( "#{k.to_s.underscore}=" , v . respond_to? ( :strip ) ? v . strip : v ) end end
1308	def get_class ( name ) @class_list = get_class_list @class_list . select { | x | x . include? ( name ) } . collect { | y | y . strip } end
979	def modify_metadata if @all_vars_as_string @variables . each do | var | var . is_string_var = true var . is_double_var = false var . implied_decimals = 0 end end @select_vars_by_record_type = true if @rectangularize if @select_vars_by_record_type rt_lookup = rec_type_lookup_hash ( ) @variables = @variables . find_all { | var | var . is_common_var or rt_lookup [ var . record_type ] } end end
1314	def select_tag_for_filter ( model , nvpairs , params ) return unless model && nvpairs && ! nvpairs . empty? options = { :query => params [ :query ] } _url = url_for ( eval ( "#{model}_url(options)" ) ) _html = %{<label for="show">Show:</label><br />} _html << %{<select name="show" id="show" onchange="window.location='#{_url}' + '?show=' + this.value">} nvpairs . each do | pair | _html << %{<option value="#{pair[:scope]}"} if params [ :show ] == pair [ :scope ] || ( ( params [ :show ] . nil? || params [ :show ] . empty? ) && pair [ :scope ] == "all" ) _html << %{ selected="selected"} end _html << %{>#{pair[:label]}} _html << %{</option>} end _html << %{</select>} end
222	def validate_version ( exchange_version ) if server_version < exchange_version msg = 'The operation you are attempting to use is not compatible with' msg << " your configured Exchange Server version(#{server_version})." msg << " You must be running at least version (#{exchange_version})." raise EwsServerVersionError , msg end end
1100	def add_user ( user ) raise 'InvalidUser' unless user . respond_to? ( :dn ) direct_members = @raw_ldap_data [ Cratus . config . group_member_attribute ] return true if direct_members . include? ( user . dn ) direct_members << user . dn Cratus :: LDAP . replace_attribute ( dn , Cratus . config . group_member_attribute , direct_members . uniq ) end
134	def add ( content , host , port , score , time : Time . now , master : false ) raise "Content can't be empty" if content . empty? raise 'TCP port must be of type Integer' unless port . is_a? ( Integer ) raise "TCP port can't be negative: #{port}" if port . negative? raise 'Time must be of type Time' unless time . is_a? ( Time ) raise "Time must be in the past: #{time}" if time > Time . now raise 'Score must be Integer' unless score . is_a? ( Integer ) raise "Score can't be negative: #{score}" if score . negative? FileUtils . mkdir_p ( @dir ) Futex . new ( file , log : @log ) . open do list = load target = list . find do | s | f = File . join ( @dir , "#{s[:name]}#{Copies::EXT}" ) digest = OpenSSL :: Digest :: SHA256 . new ( content ) . hexdigest File . exist? ( f ) && OpenSSL :: Digest :: SHA256 . file ( f ) . hexdigest == digest end if target . nil? max = DirItems . new ( @dir ) . fetch . select { | f | File . basename ( f , Copies :: EXT ) =~ / / } . map ( & :to_i ) . max max = 0 if max . nil? name = ( max + 1 ) . to_s IO . write ( File . join ( @dir , "#{name}#{Copies::EXT}" ) , content ) else name = target [ :name ] end list . reject! { | s | s [ :host ] == host && s [ :port ] == port } list << { name : name , host : host , port : port , score : score , time : time , master : master } save ( list ) name end end
519	def email_client_usage response = get "emailclientusage" , { } response . map { | item | Hashie :: Mash . new ( item ) } end
1120	def fans data = api ( 'user.get_fans' ) data [ 'fans' ] . map { | id | User . new ( client , :_id => id ) } end
727	def find ( name ) formatter = formatters . find do | f | standardize ( f . name ) == standardize ( name ) end formatter || raise ( Rescuetime :: Errors :: InvalidFormatError ) end
22	def check_required_argument_present ( arg , field ) if field [ :min_occurs ] > 0 and arg . nil? raise AdsCommon :: Errors :: MissingPropertyError . new ( field [ :name ] , field [ :type ] ) end if ( field [ :max_occurs ] == :unbounded ) and ! ( arg . nil? or arg . kind_of? ( Array ) ) raise AdsCommon :: Errors :: TypeMismatchError . new ( Array , arg . class , field [ :name ] ) end if ( field [ :max_occurs ] == 1 ) and arg . kind_of? ( Array ) raise AdsCommon :: Errors :: TypeMismatchError . new ( field [ :type ] , Array , field [ :name ] ) end end
919	def reverse_each_item return to_enum ( __method__ ) { count } unless block_given? return if empty? item = list_tail loop do yield item item = item . prev end end
457	def feed ( input ) heads , @stack , accept = [ @start ] , [ ] , false eTrans = transition ( @start , '&' ) if has_transition? ( @start , '&' ) heads += eTrans puts "initial heads: #{heads}" puts "initial stack: #{@stack}" input . each_char do | symbol | newHeads = [ ] puts "Reading symbol: #{symbol}" heads . each do | head | puts "At head #{head}" if has_transition? ( head , symbol ) puts "Head #{head} transitions #{symbol}" puts "stack: #{@stack}" transition ( head , symbol ) . each { | t | newHeads << t } puts "heads: #{newHeads}" puts "stack: #{@stack}" end end heads = newHeads break if heads . empty? end puts "Loop finished" accept = includes_accept_state? heads puts "heads: #{heads}" puts "stack: #{stack}" puts "accept: #{accept}" resp = { input : input , accept : accept , heads : heads , stack : stack } end
657	def to_s ( indent = 0 ) prefix = indent > 0 ? ' ' * indent : '' text = StringIO . new text << "#{prefix}Colour Table (#{@colours.size} colours)" @colours . each { | colour | text << "\n#{prefix} #{colour}" } text . string end
636	def list ( kind = @kind ) node = ListLevelNode . new ( self , @template , kind , @level . level + 1 ) yield node self . store ( node ) end
155	def reload! response = @client . connection . get ( path ) do | req | yield req if block_given? end handle_response ( response ) attributes . clear_changes self end
735	def parse_result ( node , delegate ) if delegate method = delegate . is_a? ( Proc ) ? delegate : delegate . method ( delegate . respond_to? ( :call ) ? :call : :parse ) method . arity == 1 ? method [ node ] : method [ node , self ] else node end unless node . nil? end
459	def to_hash self . class . attribute_names . inject ( { } ) do | hash , name | val = format_value ( send ( name . underscore ) ) val . empty? ? hash : hash . merge ( format_key ( name ) => val ) end end
277	def every_rss_doc every_page do | page | if ( block_given? && page . rss? ) if ( doc = page . doc ) yield doc end end end end
1018	def api ( command , params = { } ) raise ( ConnectionError , 'Connection is not open' ) unless @connection && @connection . connected? message_id = @connection . publish ( params . merge ( :api => command ) ) data = wait do | & resume | on ( :response_received , :once => true , :if => { 'msgid' => message_id } ) { | data | resume . call ( data ) } end if data [ 'success' ] data else error = data [ 'error' ] || data [ 'err' ] raise APIError , "Command \"#{command}\" failed with message: \"#{error}\"" end end
601	def all_read! will_change! permissions . keys . each do | perm | permissions [ perm ] . read! true end end
252	def branch ( loader : nil , saver : nil , operations : nil , ** other_options ) options = respond_to? ( :options ) ? self . options : DEFAULT_OPTIONS options = options . merge ( loader : options [ :loader ] . merge ( loader ) ) if loader options = options . merge ( saver : options [ :saver ] . merge ( saver ) ) if saver options = options . merge ( operations : options [ :operations ] + operations ) if operations options = options . merge ( processor : self :: Processor ) unless self . is_a? ( Builder ) options = options . merge ( other_options ) options . freeze Builder . new ( options ) end
1354	def run_entry entry = get_entry ( ) output = '' ; @keys . keys . select { | k | @config [ 'key_fields' ] [ k ] && @keys [ k ] } . each do | key | output += [ key , @keys [ key ] ] . join ( ' ' ) + " " end unless entry $stderr . puts "#{ output } is not supported on #{ @page_name }" if @debug return end unless entry [ 'ready' ] == "1" $stderr . puts "#{ output } is not ready to run #{ @agent_name }" if @debug return false , entry end if entry [ 'complete' ] == "1" $stderr . puts "All goals are completed for #{ output }" if @debug return false , entry end if entry [ @agent_name ] ( status , running_hostname ) = entry [ @agent_name ] . split ( ':' ) case status when 'r' $stderr . puts " #{ output } is already running #{ @agent_name } on #{ running_hostname }" if @debug return false , entry when "1" $stderr . puts " #{ output } has already run #{ @agent_name }" if @debug return false , entry when 'F' $stderr . puts " #{ output } has already Failed #{ @agent_name }" if @debug return false , entry end end if @prerequisites @prerequisites . each do | prereq_field | unless entry [ prereq_field ] == "1" $stderr . puts " #{ output } has not finished #{ prereq_field }" if @debug return false , entry end end end hostname = Socket . gethostname ; begin entry . update @agent_name => "r:#{ hostname }" @worksheet . save rescue GoogleDrive :: Error $stderr . puts " #{ output } lost #{ @agent_name } on #{hostname}" if @debug return false , entry end sleep 3 begin @worksheet . reload rescue GoogleDrive :: Error $stderr . puts " #{ output } lost #{ @agent_name } on #{hostname}" if @debug return false , entry end check = entry [ @agent_name ] ( status , running_hostname ) = check . split ( ':' ) if hostname == running_hostname return true , entry end $stderr . puts " #{ output } lost #{ @agent_name } on #{hostname}" if @debug return false , entry end
898	def find ( params ) params = { type : params } if params . is_a? ( String ) found_objects = find_all do | object | params . any? { | key , value | object . send ( key ) == value . to_s } end . compact self . class . new found_objects end
1174	def ensure_primary_annotation_has_hook ( annotation ) hook = annotation . hook if hook . nil? then raise CaRuby :: DatabaseError . new ( "Cannot save annotation #{annotation} since it does not reference a hook entity" ) end if hook . identifier . nil? then logger . debug { "Ensuring that the annotation #{annotation.qp} hook entity #{hook.qp} exists in the database..." } ensure_exists ( hook ) end end
937	def extractNumber str match = STDNUMPAT . match str return nil unless match return ( match [ 1 ] . gsub ( / \- / , '' ) ) . upcase end
714	def get_vdc_id_by_name ( organization , vdcName ) result = nil organization [ :vdcs ] . each do | vdc | if vdc [ 0 ] . downcase == vdcName . downcase result = vdc [ 1 ] end end result end
1328	def sync_host_table uri = foreman_uri ( '/hosts?per_page=9999999' ) debug "Loading hosts from #{uri}" json = RestClient . get uri debug "Got JSON: #{json}" JSON . parse ( json ) [ 'results' ] . each do | rec | @db . execute "insert into host (id,name) values ( ?, ? )" , rec [ 'id' ] , rec [ 'name' ] end end
163	def method_missing ( method , * args , & block ) method = method . to_s options = args . last . is_a? ( Hash ) ? args . pop : { } @resource_cache [ method ] ||= { :class => nil , :cache => ZendeskAPI :: LRUCache . new } if ! options . delete ( :reload ) && ( cached = @resource_cache [ method ] [ :cache ] . read ( options . hash ) ) cached else @resource_cache [ method ] [ :class ] ||= method_as_class ( method ) raise "Resource for #{method} does not exist" unless @resource_cache [ method ] [ :class ] @resource_cache [ method ] [ :cache ] . write ( options . hash , ZendeskAPI :: Collection . new ( self , @resource_cache [ method ] [ :class ] , options ) ) end end
468	def refund ( transaction_id , caller_reference , options = { } ) submit Refund . new ( options . merge ( :transaction_id => transaction_id , :caller_reference => caller_reference ) ) end
826	def exists_locally? ( key_name ) return true if @cache . key? ( key_name ) || @writethrough . key? ( key_name ) meta = ensure_metadata_exists ( key_name ) @source . key? ( meta . source_key ) end
1329	def initialize_database @db = SQLite3 :: Database . new @database_path File . chmod 0600 , @database_path begin @db . execute 'drop table if exists host;' @db . execute <<-SQL SQL sync_host_table rescue File . unlink @database_path raise end end
63	def handle_errors ( response ) if response . soap_fault? exception = exception_for_soap_fault ( response ) raise exception end if response . http_error? raise AdsCommon :: Errors :: HttpError , "HTTP Error occurred: %s" % response . http_error end end
1285	def prepare_modes buf = [ 0 , 0 , 0 , 0 , 0 , 0 , '' ] . pack ( "IIIICCA*" ) $stdout . ioctl ( TCGETS , buf ) @old_modes = buf . unpack ( "IIIICCA*" ) new_modes = @old_modes . clone new_modes [ 3 ] &= ~ ECHO new_modes [ 3 ] &= ~ ICANON $stdout . ioctl ( TCSETS , new_modes . pack ( "IIIICCA*" ) ) print "\e[2J" print "\e[H" print "\e[?47h" print "\e[?1000h" self . cursor = false flush end
751	def peek ( aheadCount = 1 ) history = [ ] aheadCount . times { history << @input . getc } history . reverse . each { | chr | @input . ungetc ( chr ) } return history . last . chr end
444	def ls ( mask = '' , raise = true ) ls_items = [ ] mask = '"' + mask + '"' if mask . include? ' ' output = exec 'ls ' + mask output . lines . each do | line | ls_item = LsItem . from_line ( line ) ls_items << ls_item if ls_item end ls_items rescue Client :: RuntimeError => e raise e if raise [ ] end
1114	def write ( string , to , as : user , on : hosts , quiet : false , once : nil ) self . once once , quiet : quiet do log . info "write: #{string.bytesize} bytes -> #{to}" , quiet : quiet do hash_map ( hosts ) do | host | host . write string , to , as : as , quiet : quiet end end end end
489	def validate_token! ( access_token ) validator = Fridge . configuration . validator if validator . call ( access_token ) access_token else raise InvalidToken , 'Rejected by validator' end end
936	def extract_device ( value ) device = value . to_s . split ( '|' ) [ 2 ] if value . to_s . include? '|' sauce_devices @sauce_devices [ device ] if not device . nil? end
1247	def export! puts "Exporting translations:\n" if config [ :split ] translations . keys . each do | locale | if translations [ :en ] . nil? puts 'Missing english translation' exit end puts "\nLocale: #{locale}" fallback_english_hash = flat_hash ( translations [ :en ] ) translations_hash = flat_hash ( translations [ locale ] ) if locale != :en translations_hash . each do | key , value | english_fallback = fallback_english_hash [ key ] if value == nil || value == "" puts " #{key} missing!" puts " taking english default: '#{english_fallback}'" translations_hash [ key ] = english_fallback end end end save ( translations_hash , File . join ( export_dir , "translations_#{locale}.js" ) ) end else save ( flat_hash ( translations ) , File . join ( export_dir , 'translations.js' ) ) end end
1320	def add ( path ) str = "#{path} filter=rgc diff=rgc" if content . include? ( str ) abort "`#{str}\n` is already included in #{@location}." end File . open ( @location , 'a' ) do | f | f . write ( "#{str}\n" ) end rescue Errno :: ENOENT abort "File #{@location} does not exists." rescue Errno :: EACCES abort "File #{@location} is not accessible for writing." end
878	def to_h ( persist : false ) { } . tap do | hash | ( persist ? properties - foreign_objects : properties ) . each do | property | value = self [ property ] if value == false || value . present? hash [ property ] = value end end end end
220	def get_rooms ( roomDistributionList ) req = build_soap! do | type , builder | if ( type == :header ) else builder . nbuild . GetRooms { | x | x . parent . default_namespace = @default_ns builder . room_list! ( roomDistributionList ) } end end do_soap_request ( req , response_class : EwsSoapRoomResponse ) end
1199	def match_boolean_filter? ( values = [ ] ) return false if boolean_filter . empty? or values . empty? expression = boolean_filter columns = expression . scan ( / \d \| / ) columns . each do | c | value = case c [ 1 ] when 'n' values [ c [ 2 ] . to_i ] . empty? ? '0' : values [ c [ 2 ] . to_i ] when 's' "\"#{values[c[2].to_i]}\"" when 'd' begin Date . strptime ( values [ c [ 2 ] . to_i ] , date_format ) rescue Exception => e case c [ 3 ] when '<' , '<=' , '==' "#{c[4]}+1" when '>' , '>=' '0' when '!=' c [ 4 ] end else "Date.strptime('#{values[c[2].to_i]}', '#{date_format}')" end end expression = expression . gsub ( c [ 0 ] , value ) end eval ( expression ) end
122	def includes_positive? ( id , bnf ) raise 'The txn ID has to be of type Integer' unless id . is_a? ( Integer ) raise 'The bnf has to be of type Id' unless bnf . is_a? ( Id ) ! txns . find { | t | t . id == id && t . bnf == bnf && ! t . amount . negative? } . nil? end
1303	def call ( url , settings , & block ) uri = URI . parse ( url ) klass = adapter_class ( uri . scheme ) session = klass . new ( uri , settings . deep_dup ) session . start ( & block ) end
915	def realm_status ( * realms ) if realms . count > 0 BnetApi . make_request_with_params ( "/wow/realm/status" , { realms : realms . join ( ',' ) } ) else BnetApi . make_request ( "/wow/realm/status" ) end end
497	def create_custom_field ( field_name , data_type , options = [ ] , visible_in_preference_center = true ) options = { :body => { :FieldName => field_name , :DataType => data_type , :Options => options , :VisibleInPreferenceCenter => visible_in_preference_center } . to_json } response = post "customfields" , options response . parsed_response end
719	def for * classes , & proc classes . each { | receiver_class | ForClassContext . new ( self , receiver_class ) . instance_eval & proc } end
331	def login ( do_update_config = true ) if needs_api_key? get_api_key end if needs_auth_token? pin = get_oauth_verifier return false if pin . nil? begin @access_token = request_token . get_access_token ( :oauth_verifier => pin . chomp ) get_screen_name self . config [ :access_token ] = @access_token . token self . config [ :access_token_secret ] = @access_token . secret reset_client rescue OAuth :: Unauthorized => e display_oauth_error warn e . inspect return false end end return true end
0	def preparse ( unparsed , args = [ ] , opts = { } ) case unparsed when Hash then opts . merge! unparsed when Array then unparsed . each { | e | preparse ( e , args , opts ) } else args << unparsed . to_s end [ args , opts ] end
817	def to_georss ( * args ) xml = Geos :: Helper . xml_options ( * args ) [ 0 ] xml . georss ( :where ) do xml . gml ( :LineString ) do xml . gml ( :posList ) do xml << self . to_a . collect do | p | "#{p[1]} #{p[0]}" end . join ( ' ' ) end end end end
1207	def date ( col , comparator , date , args , block ) comparator = '==' if comparator == '=' operation = "Date.strptime(\"[value]\", \"#{date_format}\") #{comparator} " + "Date.strptime(\"#{date}\", \"#{date_format}\")" pivot [ "#{comparator}#{date}" ] = { col : col , operation : operation } end
383	def check_encryption ( encryption , tls_options = { } ) return unless encryption tls_options ||= { } case encryption . downcase . to_sym when :ssl , :simple_tls { method : :simple_tls , tls_options : tls_options } when :tls , :start_tls { method : :start_tls , tls_options : tls_options } end end
977	def filtered return self if filters . empty? filtered_results = filters . each_with_object ( { } ) do | ( key , options ) , results | results [ key ] = filter ( key , * options ) end self . class . new ( filtered_results ) end
391	def configure ( uri_string ) uri = URI ( uri_string ) if uri . scheme == "unix" @host = uri . path @port = nil else @host = uri . host @port = uri . port @password = uri . password path = uri . path [ 1 .. - 1 ] @db = path . to_i end end
8	def follow_get_redirection ( & block ) new_args = request . args . dup new_args [ :method ] = :get new_args . delete ( :payload ) _follow_redirection ( new_args , & block ) end
200	def dispatch_create_item! ( msg ) if msg . has_attachments? draft = msg . draft msg . draft = true resp = validate_created_item ( ews . create_item ( msg . to_ews ) ) msg . file_attachments . each do | f | next unless f . kind_of? ( File ) resp . add_file_attachment ( f ) end if draft resp . submit_attachments! resp else resp . submit! end else resp = ews . create_item ( msg . to_ews ) validate_created_item resp end end
564	def venuegroup_update ( group_id , options = { } ) response = connection . post do | req | req . url "venuegroups/#{group_id}/update" , options end return_error_or_body ( response , response . body . response . venueGroup ) end
246	def call ( save : true ) if save == false call_processor elsif destination handle_destination do call_processor ( destination : destination ) end else create_tempfile do | tempfile | call_processor ( destination : tempfile . path ) end end end
1324	def set_query_attributes! attr_names = self . class . search_query_attributes . map ( & :to_s ) self . query = attr_names . inject ( { } ) { | memo , attr | memo [ attr ] = self . send ( attr ) memo } end
798	def respond_to? method , include_private = false true if bootstrap_admin_config . respond_to? method super method , include_private end
1261	def register_observer ( observer ) @observer_mutex . synchronize do log "EventListener: registering observer #{observer.class} #{observer.id}" @observers [ observer_key_for ( observer . class , observer . id ) ] = observer . observe_events ( client ) end end
1259	def run bind_queues and return if test_env? start_shutdown_thread start_error_counter_thread client . on_exception do | e | count_error ( e ) end client . connect start_event_thread puts 'EventListener started. Hit Ctrl-C to exit' Thread . stop puts 'Main thread wakeup - exiting.' client . close end
666	def open ( vendor_id , product_id , serial_number = nil , options = { } ) dev = get_device ( vendor_id , product_id , serial_number , options ) dev . open if dev end
328	def reset_since_id config [ :since_id ] = 1 result = client . search ( "a" , since : Time . now - 10 ) . max_by ( & :id ) update_since_id ( result ) end
47	def get_wsdls ( version ) res = { } wsdl_base = get_wsdl_base ( version ) postfix = wsdl_base . start_with? ( 'http' ) ? '?wsdl' : '.wsdl' services ( version ) . each do | service | path = wsdl_base if ( ! subdir_config ( ) . nil? ) subdir_name = subdir ( version , service ) ; path = path + subdir_name if subdir_name and ! subdir_name . empty? end path = path + version . to_s + '/' + service . to_s + postfix res [ service . to_s ] = path end return res end
775	def intervals first , * rest = bounds . each_cons ( 2 ) . to_a [ first , * rest . map { | lower , upper | [ data [ data . rindex ( lower ) + 1 ] , upper ] } ] end
649	def read_source ( file , read , size = nil ) if block_given? done = false while ! done and ! file . eof? read << file . getbyte done = yield read [ - 1 ] end else if size != nil if size > 0 total = 0 while ! file . eof? and total < size read << file . getbyte total += 1 end end else file . each_byte { | byte | read << byte } end end end
839	def arrayize_arguments ( args ) array = [ ] until args . empty? || args . first . match ( / / ) array << args . shift end array end
586	def all ( constraints = { } ) q = query ( { limit : :max } . merge ( constraints ) ) if block_given? return q . present? ? q . results ( & Proc . new ) : collection . each ( & Proc . new ) end q . present? ? q . results : collection end
650	def get_dimensions dimensions = nil open_file do | file | file . pos = DIMENSIONS_OFFSET [ @type ] read = [ ] if @type == JPEG done = false while ! file . eof? and ! done read_source ( file , read ) { | c | c == 0xff } read_source ( file , read ) { | c | c != 0xff } if read [ - 1 ] >= 0xc0 && read [ - 1 ] <= 0xc3 read_source ( file , read , 7 ) dimensions = read [ - 4 , 4 ] . pack ( 'C4' ) . unpack ( 'nn' ) . reverse done = true else read_source ( file , read , 2 ) read_source ( file , read , read [ - 2 , 2 ] . pack ( 'C2' ) . unpack ( 'n' ) [ 0 ] - 2 ) end end elsif @type == PNG read_source ( file , read , 16 ) dimensions = read [ - 8 , 8 ] . pack ( 'C8' ) . unpack ( 'N2' ) elsif @type == BITMAP read_source ( file , read , 18 ) dimensions = [ to_integer ( read [ - 8 , 4 ] ) , to_integer ( read [ - 4 , 4 ] ) ] end end dimensions end
644	def left_border_width = ( width ) size = width . nil? ? 0 : width if size > 0 @borders [ LEFT ] = size . to_i else @borders [ LEFT ] = nil end end
1398	def start_websocket_client Bixby :: Log . setup_logger ( :level => Logging . appenders [ "file" ] . level ) logger . info "Started Bixby Agent #{Bixby::Agent::VERSION}" @client = Bixby :: WebSocket :: Client . new ( Bixby . agent . manager_ws_uri , AgentHandler ) trap_signals ( ) @client . start end
330	def get_screen_name ( t = @access_token ) return unless @screen_name . nil? return if t . nil? oauth_response = t . get ( '/1.1/account/verify_credentials.json' ) @screen_name = JSON . parse ( oauth_response . body ) [ "screen_name" ] end
789	def load ( attributes = { } ) attributes . each do | key , val | if key =~ / / and val begin dt = DateTime . strptime ( val , "%Y-%m-%dT%H:%M:%SZ" ) newval = Time . utc ( dt . year , dt . month , dt . day , dt . hour , dt . min , dt . sec ) rescue ArgumentError => ex newval = DateTime . strptime ( val , "%Y-%m-%d" ) end self . instance_variable_set ( "@#{key}" , newval ) else self . instance_variable_set ( "@#{key}" , val ) end end end
1371	def pop ( non_block = false ) @pop_mutex . lock do @mutex . synchronize do if empty? return if closed? raise ThreadError if non_block @mutex . unlock @waiter . wait @mutex . lock return if closed? end @items . shift end end end
1228	def equalize_rows ( rows ) column_sizes = rows . collect { | r | r . size } return rows if column_sizes . uniq . size == 1 max_size = column_sizes . max small_rows = [ ] column_sizes . each_with_index { | c , i | small_rows << i if c < max_size } small_rows . each do | i | rows [ i ] += [ NotAvailable ] * ( max_size - rows [ i ] . size ) end rows end
142	def merge_cells start_row , start_col , end_row , end_col @merged_cells . push [ start_row , end_row , start_col , end_col ] end
1138	def build log_configuration_information if subscription_list . empty? Mako . logger . warn 'No feeds were found in your subscriptions file. Please add feeds and try again.' return end log_time do request_and_build_feeds renderers . each do | renderer | renderer_instance = renderer . new ( bound : self ) writer . new ( renderer : renderer_instance , destination : File . expand_path ( renderer_instance . file_path , Mako . config . destination ) ) . write end end end
515	def set_payg_billing ( currency , can_purchase_credits , client_pays , markup_percentage , markup_on_delivery = 0 , markup_per_recipient = 0 , markup_on_design_spam_test = 0 ) options = { :body => { :Currency => currency , :CanPurchaseCredits => can_purchase_credits , :ClientPays => client_pays , :MarkupPercentage => markup_percentage , :MarkupOnDelivery => markup_on_delivery , :MarkupPerRecipient => markup_per_recipient , :MarkupOnDesignSpamTest => markup_on_design_spam_test } . to_json } put 'setpaygbilling' , options end
1359	def temporarily_release ( & block ) raise ArgumentError , 'no block given' unless block_given? unlock begin return_value = yield lock rescue Exception lock_immediately raise end return_value end
706	def set_vm_guest_customization ( vmid , computer_name , config = { } ) builder = Nokogiri :: XML :: Builder . new do | xml | xml . GuestCustomizationSection ( "xmlns" => "http://www.vmware.com/vcloud/v1.5" , "xmlns:ovf" => "http://schemas.dmtf.org/ovf/envelope/1" ) { xml [ 'ovf' ] . Info "VM Guest Customization configuration" xml . Enabled config [ :enabled ] if config [ :enabled ] xml . AdminPasswordEnabled config [ :admin_passwd_enabled ] if config [ :admin_passwd_enabled ] xml . AdminPassword config [ :admin_passwd ] if config [ :admin_passwd ] xml . CustomizationScript config [ :customization_script ] if config [ :customization_script ] xml . ComputerName computer_name } end params = { 'method' => :put , 'command' => "/vApp/vm-#{vmid}/guestCustomizationSection" } response , headers = send_request ( params , builder . to_xml , "application/vnd.vmware.vcloud.guestCustomizationSection+xml" ) task_id = headers [ :location ] . gsub ( / \/ \/ / , "" ) task_id end
179	def additional_properties! ( addprops ) @nbuild [ NS_EWS_TYPES ] . AdditionalProperties { addprops . each_pair { | k , v | dispatch_field_uri! ( { k => v } , NS_EWS_TYPES ) } } end
280	def each_meta_redirect return enum_for ( __method__ ) unless block_given? if ( html? && doc ) search ( '//meta[@http-equiv and @content]' ) . each do | node | if node . get_attribute ( 'http-equiv' ) =~ / /i content = node . get_attribute ( 'content' ) if ( redirect = content . match ( / \S / ) ) yield redirect [ 1 ] end end end end end
638	def shading_colour ( colour ) if block_given? 0 . upto ( self . size - 1 ) do | x | row = self [ x ] 0 . upto ( row . size - 1 ) do | y | apply = yield row [ y ] , x , y row [ y ] . shading_colour = colour if apply end end end end
791	def load_apis Dir . glob ( File . join ( root_path , "api" , "**" , "*.rb" ) ) . each do | api | require api end end
830	def transform_value ( value , transform ) case transform when nil value when Proc @parent . instance_exec ( value , & transform ) when Symbol value . public_send ( transform ) end end
1232	def process_count File . new ( infile ) . each_with_index do | line , index | result = col_filter . process ( row_filter . process ( line . chomp , row : index ) ) unless result . nil? or result . empty? key = unstring ( line ) . split ( ';' ) . values_at ( * key_columns ) key_value = key_values [ key ] || key_values [ key ] = { name : key , elements : Hash . new ( 0 ) , sum : 0 } result . chomp . split ( ';' ) . each do | column | heading << column if heading . index ( column ) . nil? key_value [ :elements ] [ column ] += 1 key_value [ :sum ] += 1 sums [ column ] += 1 end end end end
494	def clients response = get ( '/clients.json' ) response . map { | item | Hashie :: Mash . new ( item ) } end
1357	def play bangs_played = 0 while ! player . hand . find_all ( & :draws_cards? ) . empty? player . hand . find_all ( & :draws_cards? ) . each { | card | player . play_card ( card ) } end play_guns player . hand . each do | card | target = find_target ( card ) next if skippable? ( card , target , bangs_played ) bangs_played += 1 if card . type == Card . bang_card player . play_card ( card , target , :hand ) end end
514	def set_basics ( company , timezone , country ) options = { :body => { :CompanyName => company , :TimeZone => timezone , :Country => country } . to_json } put 'setbasics' , options end
1109	def on ( * hosts , quiet : false ) let :@hosts => hosts . flatten do log . info "on #{@hosts.map(&:name).join(", ")}" , quiet : quiet do yield end end end
1152	def sh ( command , as : nil , quiet : false ) as ||= @user output = "" synchronize do log . debug "sh #{command}" , quiet : quiet result = nil ch = ssh ( as ) . open_channel do | ch | ch . request_pty do | ch , success | "failed to acquire pty" unless success ch . exec ( command ) do | _ , success | fail "failed to execute command" unless success ch . on_data do | _ , data | log . trace "received #{data.bytesize} bytes stdout" , quiet : quiet output << data end ch . on_extended_data do | _ , _ , data | log . trace "received #{data.bytesize} bytes stderr" , quiet : quiet output << data . colorize ( :red ) end ch . on_request ( "exit-status" ) do | _ , data | result = data . read_long log . trace "received exit-status #{result}" , quiet : quiet end end end end ch . wait fail FailedCommand , output if result != 0 output end end
1276	def bind ( queue_name , exchange_name , * routing_keys , & block ) queue = create_queue ( queue_name , exchange_name , queue_options : { durable : true } , routing_keys : routing_keys ) subscribe ( queue , & block ) if block_given? end
381	def validate_response ( response ) if ( error = TwoCaptcha :: RESPONSE_ERRORS [ response ] ) fail ( error ) elsif response . to_s . empty? || response . match ( / \A \_ / ) fail ( TwoCaptcha :: Error , response ) end end
1330	def execute_hook_action @rename = false name = @rec [ 'host' ] [ 'name' ] id = @rec [ 'host' ] [ 'id' ] case @action when 'create' sql = "insert into host (id, name) values (?, ?)" params = [ id , name ] when 'update' @old_name = @db . get_first_row ( 'select name from host where id = ?' , id ) @old_name = @old_name [ 0 ] unless @old_name . nil? if @old_name . nil? warn 'received an update for a non-existent host' else @rename = @old_name != name end debug "checking for a rename: old=#{@old_name} new=#{name} rename?=#{@rename}" sql = 'update host set name = ? where id = ?' params = [ name , id ] when 'destroy' sql = 'delete from host where id = ?' params = [ id ] else raise ArgumentError , "unsupported action: #{ARGV[0]}" end debug "updating database; id=#{id} name=#{name} sql=#{sql}" stm = @db . prepare sql stm . bind_params * params stm . execute end
452	def to_all_parts me = DeepClone . clone ( self ) me . disable_id_attribute @relations << DocumentRelation . new ( type : "partOf" , identifier : nil , url : nil , bibitem : me ) @title . each ( & :remove_part ) @abstract = [ ] @docidentifier . each ( & :remove_part ) @docidentifier . each ( & :all_parts ) @all_parts = true end
995	def treat_data @hash_inter = Hash . new @hash = Hash . new if validate_api_return @hash_inter = @hash_local [ 'list' ] [ 'resources' ] [ 'resource' ] @hash_inter . each do | cout | simbol_string = cout [ 'field' ] [ 0 ] . to_s simbol = simbol_string . split ( "/" ) @hash [ simbol [ 1 ] ] = cout [ 'field' ] [ 1 ] . to_f end else @data = false end end
327	def on_blocklist? ( s ) search = if s . is_a? ( Twitter :: User ) s . name elsif s . respond_to? ( :user ) && ! s . is_a? ( Twitter :: NullObject ) from_user ( s ) else s end . downcase blocklist . any? { | b | search . include? ( b . downcase ) } end
1267	def do_move_options ( type ) options = OpenStruct . new opt_parser = OptionParser . new do | opts | if type == 'publish' opts . on ( '-d' , '--keep-draft' , "Keep draft post" ) do | d | options . keep_draft = d end else opts . on ( '-p' , '--keep-post' , "Do not delete post" ) do | p | options . keep_post = p end end opts . on ( '-t' , '--keep-timestamp' , "Keep existing timestamp" ) do | t | options . keep_timestamp = t end end opt_parser . parse! @params options end
303	def consumer_secret ( s ) bot . deprecated "Setting consumer_secret outside of your config file is deprecated!" , Kernel . caller . first bot . config [ :consumer_secret ] = s end
1061	def set api ( 'user.set_avatar' , :avatarid => id ) client . user . attributes = { 'avatarid' => id } client . user . avatar . attributes = { 'min' => minimum_points , 'acl' => acl } true end
987	def existing_rules request = Net :: HTTP :: Get . new URI . join ( @base_uri . to_s , "cloudlets/api/v2/policies/#{@policy_id}/versions/#{@version_id}?omitRules=false&matchRuleFormat=1.0" ) . to_s response = @http_host . request ( request ) response . body end
57	def to_h { :date => AdManagerApi :: AdManagerDate . new ( @api , @time . year , @time . month , @time . day ) . to_h , :hour => @time . hour , :minute => @time . min , :second => @time . sec , :time_zone_id => @timezone . identifier } end
1361	def wait continue = false trap "SIGINT" do puts "Continuing..." continue = true end puts "Waiting. Press ^C to continue test..." wait_until ( 3600 ) { continue } trap "SIGINT" , "DEFAULT" end
538	def user_checkins ( options = { } ) response = connection . get do | req | req . url "users/self/checkins" , options end return_error_or_body ( response , response . body . response . checkins ) end
414	def report ( path , report_url = '' , delimiter = %r{ \/ \/ \/ \/ } ) setup classes = classes ( delimiter ) parser = Jacoco :: SAXParser . new ( classes ) Nokogiri :: XML :: SAX :: Parser . new ( parser ) . parse ( File . open ( path ) ) total_covered = total_coverage ( path ) report_markdown = "### JaCoCO Code Coverage #{total_covered[:covered]}% #{total_covered[:status]}\n" report_markdown << "| Class | Covered | Meta | Status |\n" report_markdown << "|:---|:---:|:---:|:---:|\n" class_coverage_above_minimum = markdown_class ( parser , report_markdown , report_url ) markdown ( report_markdown ) report_fails ( class_coverage_above_minimum , total_covered ) end
880	def export_to_string ( options = { } ) hash = self . to_h image_layers = hash . delete ( :image_layers ) object_groups = hash . delete ( :object_groups ) hash [ :layers ] += image_layers hash [ :layers ] += object_groups hash [ :layers ] . sort_by! { | l | l [ :name ] } hash . delete ( :contents ) object_groups . each do | object_layer | object_layer [ "objects" ] . each do | object | object . delete ( "shape" ) object . delete ( "points" ) end end MultiJson . dump ( hash ) end
170	def custom_template_path_valid? Vanity . playground . custom_templates_path && File . exist? ( Vanity . playground . custom_templates_path ) && ! Dir [ File . join ( Vanity . playground . custom_templates_path , '*' ) ] . empty? end
1182	def _rewrap_array ( result ) if @wrap_results newcoll = @collection . class . new ( result ) self . class . new ( newcoll , @wrapfunc_in , @wrapfunc_out ) else @collection . class . new ( result . map ( & @wrapfunc_out ) ) end end
780	def create_user ( options = { } ) user = User . new ( options ) user . validate_for_create! body = user_hash ( user . to_hash ) response = oauth_access_token . post ( '/v1/users' , body : body ) User . new ( response . parsed ) end
274	def accept? ( data ) unless @accept . empty? @accept . any? { | rule | test_data ( data , rule ) } else ! @reject . any? { | rule | test_data ( data , rule ) } end end
958	def gte ( query_string , options = { :case_sensitive => false } ) do_comparison ( query_string , options ) do | comparator , item | comparator <= item end end
516	def set_monthly_billing ( currency , client_pays , markup_percentage , monthly_scheme = nil ) options = { :body => { :Currency => currency , :ClientPays => client_pays , :MarkupPercentage => markup_percentage , :MonthlyScheme => monthly_scheme } . to_json } put 'setmonthlybilling' , options end
582	def forward ( method , params = nil ) return unless @delegate && @delegate . respond_to? ( method ) params . nil? ? @delegate . send ( method ) : @delegate . send ( method , params ) end
512	def suppress ( emails ) options = { :body => { :EmailAddresses => emails . kind_of? ( String ) ? [ emails ] : emails } . to_json } post "suppress" , options end
1233	def write_result sum_line = [ sum_row_title ] + [ '' ] * ( key_titles . size - 1 ) headline = heading_sort ? heading . sort : original_pivot_sequence_heading headline << add_sum_col unless sum_col_title . nil? headline . each do | h | sum_line << sums [ h ] end row = 0 ; File . open ( outfile , 'w' ) do | out | out . puts sum_line . join ( ';' ) if row == sum_row ; row += 1 out . puts ( key_titles + headline ) . join ( ';' ) key_values . each do | k , v | out . puts sum_line . join ( ';' ) if row == sum_row ; row += 1 line = [ k ] headline . each do | h | line << v [ :elements ] [ h ] unless h == sum_col_title end line << v [ :sum ] unless sum_col_title . nil? out . puts line . join ( ';' ) end end end
698	def get_catalog ( catalogId ) params = { 'method' => :get , 'command' => "/catalog/#{catalogId}" } response , headers = send_request ( params ) description = response . css ( "Description" ) . first description = description . text unless description . nil? items = { } response . css ( "CatalogItem[type='application/vnd.vmware.vcloud.catalogItem+xml']" ) . each do | item | items [ item [ 'name' ] ] = item [ 'href' ] . gsub ( / \/ \/ / , "" ) end { :id => catalogId , :description => description , :items => items } end
79	def save_to_file ( data , path ) open ( path , 'wb' ) { | file | file . write ( data ) } if path end
454	def feed ( input ) head = @start . to_s input . each_char { | symbol | head = @transitions [ head ] [ symbol ] } accept = is_accept_state? head resp = { input : input , accept : accept , head : head } resp end
1256	def write_json ( file , object ) return unless file && object begin File . open ( file , 'w' ) { | f | f . write ( JSON . pretty_generate ( object ) ) } end end
848	def title = ( str ) composite = product . titles . first if composite . nil? composite = ONIX :: Title . new composite . title_type = 1 product . titles << composite end composite . title_text = str end
199	def get_item ( opts = { } ) args = get_item_args ( opts ) resp = ews . get_item ( args ) get_item_parser ( resp ) end
1112	def cp ( from , to , as : user , on : hosts , quiet : false , once : nil ) self . once once , quiet : quiet do log . info "cp: #{from} -> #{to}" , quiet : quiet do Dir . chdir File . dirname ( file ) do hash_map ( hosts ) do | host | host . cp from , to , as : as , quiet : quiet end end end end end
137	def find_record ( klass , id_or_record ) id_or_record . class . name == klass . name ? id_or_record : klass . find ( id_or_record ) end
882	def import @report [ :import ] = { } objects = deduplicate ( load_scraped_objects ) object_id_to_database_id = { } if use_dependency_graph? ( objects ) dependency_graph = build_dependency_graph ( objects ) dependency_graph . tsort . each do | id | object = objects [ id ] resolve_foreign_keys ( object , object_id_to_database_id ) database_id = import_object ( object ) object_id_to_database_id [ id ] = database_id object_id_to_database_id [ database_id ] = database_id end else size = objects . size loop do progress_made = false objects . delete_if do | id , object | begin resolve_foreign_keys ( object , object_id_to_database_id ) resolve_foreign_objects ( object , object_id_to_database_id ) progress_made = true database_id = import_object ( object ) object_id_to_database_id [ id ] = database_id object_id_to_database_id [ database_id ] = database_id rescue Pupa :: Errors :: MissingDatabaseIdError false end end break if objects . empty? || ! progress_made end unless objects . empty? raise Errors :: UnprocessableEntity , "couldn't resolve #{objects.size}/#{size} objects:\n #{objects.values.map{|object| JSON.dump(object.foreign_properties)}.join("\n ")}" end end counts = { } object_id_to_database_id . each do | object_id , database_id | unless object_id == database_id ( counts [ database_id ] ||= [ ] ) << object_id end end duplicates = counts . select do | _ , object_ids | object_ids . size > 1 end unless duplicates . empty? raise Errors :: DuplicateDocumentError , "multiple objects written to same document:\n" + duplicates . map { | database_id , object_ids | " #{database_id} <- #{object_ids.join(' ')}" } . join ( "\n" ) end end
1045	def enable if disabled? Cratus :: LDAP . replace_attribute ( dn , Cratus . config . user_account_control_attribute , [ '512' ] ) refresh else true end end
897	def commit flags = RPM :: C :: TransFlags [ :none ] callback = proc do | hdr , type , amount , total , key_ptr , data_ignored | key_id = key_ptr . address key = @keys . include? ( key_id ) ? @keys [ key_id ] : nil if block_given? package = hdr . null? ? nil : Package . new ( hdr ) data = CallbackData . new ( type , key , package , amount , total ) yield ( data ) else RPM :: C . rpmShowProgress ( hdr , type , amount , total , key , data_ignored ) end end callback = proc do | hdr , type , amount , total , key_ptr , data_ignored | key_id = key_ptr . address key = @keys . include? ( key_id ) ? @keys [ key_id ] : nil if block_given? package = hdr . null? ? nil : Package . new ( hdr ) data = CallbackData . new ( type , key , package , amount , total ) ret = yield ( data ) case type when :inst_open_file unless ret . is_a? ( :: File ) raise TypeError , "illegal return value type #{ret.class}. Expected File." end fdt = RPM :: C . fdDup ( ret . to_i ) if fdt . null? || RPM :: C . Ferror ( fdt ) != 0 raise "Can't use opened file #{data.key}: #{RPM::C.Fstrerror(fdt)}" RPM :: C . Fclose ( fdt ) unless fdt . nil? else fdt = RPM :: C . fdLink ( fdt ) @fdt = fdt end fdt when :inst_close_file fdt = @fdt RPM :: C . Fclose ( fdt ) @fdt = nil else ret end else RPM :: C . rpmShowProgress ( hdr , type , amount , total , key , data_ignored ) end end rc = RPM :: C . rpmtsSetNotifyCallback ( @ptr , callback , nil ) raise "Can't set commit callback" if rc != 0 rc = RPM :: C . rpmtsRun ( @ptr , nil , :none ) raise "#{self}: #{RPM::C.rpmlogMessage}" if rc < 0 if rc > 0 ps = RPM :: C . rpmtsProblems ( @ptr ) psi = RPM :: C . rpmpsInitIterator ( ps ) while RPM :: C . rpmpsNextIterator ( psi ) >= 0 problem = Problem . from_ptr ( RPM :: C . rpmpsGetProblem ( psi ) ) STDERR . puts problem end RPM :: C . rpmpsFree ( ps ) end end
738	def ignore_media? ( type , part ) ignores = config [ 'ignore' ] [ type ] || [ ] ignore = ignores . detect { | test | filename? ( part ) == test } ignore ||= ignores . detect { | test | filename? ( part ) =~ test if test . is_a? ( Regexp ) } ignore ||= ignores . detect { | test | part . body . decoded . strip =~ test if test . is_a? ( Regexp ) } ignore ||= ( part . body . decoded . strip . size == 0 ? true : nil ) ignore . nil? ? false : true end
687	def get_vapp_port_forwarding_rules ( vAppId ) params = { 'method' => :get , 'command' => "/vApp/vapp-#{vAppId}/networkConfigSection" } response , headers = send_request ( params ) config = response . css ( 'NetworkConfigSection/NetworkConfig/Configuration' ) fenceMode = config . css ( '/FenceMode' ) . text natType = config . css ( '/Features/NatService/NatType' ) . text raise InvalidStateError , "Invalid request because FenceMode must be set to natRouted." unless fenceMode == "natRouted" raise InvalidStateError , "Invalid request because NatType must be set to portForwarding." unless natType == "portForwarding" nat_rules = { } config . css ( '/Features/NatService/NatRule' ) . each do | rule | ruleId = rule . css ( 'Id' ) . text vmRule = rule . css ( 'VmRule' ) nat_rules [ rule . css ( 'Id' ) . text ] = { :ExternalIpAddress => vmRule . css ( 'ExternalIpAddress' ) . text , :ExternalPort => vmRule . css ( 'ExternalPort' ) . text , :VAppScopedVmId => vmRule . css ( 'VAppScopedVmId' ) . text , :VmNicId => vmRule . css ( 'VmNicId' ) . text , :InternalPort => vmRule . css ( 'InternalPort' ) . text , :Protocol => vmRule . css ( 'Protocol' ) . text } end nat_rules end
916	def get_tile ( lat , lon , zoom , style_id = nil , tile_size = nil ) get_xy_tile ( xtile ( lon , zoom ) , ytile ( lat , zoom ) , zoom , style_id , tile_size ) end
611	def first_or_create ( query_attrs = { } , resource_attrs = { } ) conditions ( query_attrs ) klass = Parse :: Model . find_class self . table if klass . blank? raise ArgumentError , "Parse model with class name #{self.table} is not registered." end hash_constraints = constraints ( true ) klass . first_or_create ( hash_constraints , resource_attrs ) end
808	def read_data chunksize = read_data_chunksize p = FFI :: MemoryPointer . new ( :char , chunksize ) bytes_read = Ftdi . ftdi_read_data ( ctx , p , chunksize ) check_result ( bytes_read ) r = p . read_bytes ( bytes_read ) r . force_encoding ( "ASCII-8BIT" ) if r . respond_to? ( :force_encoding ) r end
723	def observing_thread ( callable , initial_wait , periodic_wait ) thread = Thread . new ( & callable ) wait_for_exit ( thread , initial_wait ) loop do break if wait_for_exit ( thread , periodic_wait ) yield end thread . value end
377	def upload ( options = { } ) args = { } args [ :body ] = options [ :raw64 ] if options [ :raw64 ] args [ :method ] = options [ :method ] || 'base64' args . merge! ( options ) response = request ( 'in' , :multipart , args ) unless response . match ( / \A \| / ) fail ( TwoCaptcha :: Error , 'Unexpected API Response' ) end TwoCaptcha :: Captcha . new ( id : response . split ( '|' , 2 ) [ 1 ] , api_response : response ) end
151	def method_missing ( name , * args , & block ) if resource_methods . include? ( name ) collection_method ( name , * args , & block ) elsif [ ] . respond_to? ( name , false ) array_method ( name , * args , & block ) else next_collection ( name , * args , & block ) end end
1226	def to_s col_label_sizes = col_labels . collect { | c | c . to_s . size + 2 } row_label_size = row_labels . collect { | r | r . to_s . size + 2 } . max row_col_sizes = rows . transpose . collect { | r | r . collect { | c | c . to_s . size } } i = - 1 col_sizes = col_label_sizes . collect do | s | i += 1 [ row_col_sizes [ i ] , s ] . flatten . max + 1 end s = ( sprintf ( "%#{row_label_size}s" , " " ) ) col_labels . each_with_index { | l , i | s << ( sprintf ( "%#{col_sizes[i]}s" , "[#{l}]" ) ) } s << "\n" rows . each_with_index do | row , i | s << ( sprintf ( "%#{row_label_size}s" , "[#{row_labels[i]}]" ) ) row . each_with_index { | c , j | s << ( sprintf ( "%#{col_sizes[j]}s" , c ) ) } s << "\n" end s end
1304	def all_fields ( table , field_name , value ) body = savon . call ( :get_all_fields_records_given_a_field_name_and_value , message : { 'strFeatureClassOrTableName' => table , 'strFieldNameToSearchOn' => field_name , 'strValueOfFieldToSearchOn' => value } ) . body resp = body [ :get_all_fields_records_given_a_field_name_and_value_response ] rslt = resp [ :get_all_fields_records_given_a_field_name_and_value_result ] polys = rslt [ :diffgram ] [ :document_element ] [ :municipality_poly ] poly = if polys . is_a? Array polys . first elsif polys . is_a? Hash polys else fail "Unexpected polys #{polys.class.name}, wanted Array or Hash" end end
743	def temp_file ( part ) file_name = filename? ( part ) File . expand_path ( File . join ( msg_tmp_dir ( ) , File . basename ( file_name ) ) ) end
902	def method_missing ( method , * args , & block ) klass = class_for_api_command ( method ) return klass . new ( @socket ) . send ( method , * args , & block ) if klass super ( method , * args , & block ) end
672	def send_feature_report ( data ) raise ArgumentError , 'data must not be blank' if data . nil? || data . length < 1 raise HIDAPI :: DeviceNotOpen unless open? data , report_number , skipped_report_id = clean_output_data ( data ) mutex . synchronize do handle . control_transfer ( bmRequestType : LIBUSB :: REQUEST_TYPE_CLASS | LIBUSB :: RECIPIENT_INTERFACE | LIBUSB :: ENDPOINT_OUT , bRequest : 0x09 , wValue : ( 3 << 8 ) | report_number , wIndex : interface , dataOut : data ) end data . length + ( skipped_report_id ? 1 : 0 ) end
1372	def lookup ( key , opts = { } , & block ) unless addr = cache . has? ( key ) addr = link . send ( 'lookup' , key , opts , & block ) cache . save ( key , addr ) end yield addr if block_given? addr end
349	def find_in_batches ( batch_size : 1000 , attributes_index : { } ) attributes_index . each_slice ( batch_size ) do | batch | yield ( inventory_collection . db_collection_for_comparison_for ( batch ) ) end end
685	def set_vapp_network_config ( vappid , network , config = { } ) params = { 'method' => :get , 'command' => "/vApp/vapp-#{vappid}/networkConfigSection" } netconfig_response , headers = send_request ( params ) picked_network = netconfig_response . css ( "NetworkConfig" ) . select do | net | net . attribute ( 'networkName' ) . text == network [ :name ] end . first raise WrongItemIDError , "Network named #{network[:name]} not found." unless picked_network picked_network . css ( 'FenceMode' ) . first . content = config [ :fence_mode ] if config [ :fence_mode ] picked_network . css ( 'IsInherited' ) . first . content = "true" picked_network . css ( 'RetainNetInfoAcrossDeployments' ) . first . content = config [ :retain_network ] if config [ :retain_network ] if config [ :parent_network ] parent_network = picked_network . css ( 'ParentNetwork' ) . first new_parent = false unless parent_network new_parent = true ipscopes = picked_network . css ( 'IpScopes' ) . first parent_network = Nokogiri :: XML :: Node . new "ParentNetwork" , ipscopes . parent end parent_network [ "name" ] = "#{config[:parent_network][:name]}" parent_network [ "id" ] = "#{config[:parent_network][:id]}" parent_network [ "href" ] = "#{@api_url}/admin/network/#{config[:parent_network][:id]}" ipscopes . add_next_sibling ( parent_network ) if new_parent end data = netconfig_response . to_xml params = { 'method' => :put , 'command' => "/vApp/vapp-#{vappid}/networkConfigSection" } response , headers = send_request ( params , data , "application/vnd.vmware.vcloud.networkConfigSection+xml" ) task_id = headers [ :location ] . gsub ( / \/ \/ / , "" ) task_id end
1050	def execute File . open ( outfile , 'w' ) do | out | out . puts "#{';' unless @key.empty?}#{header_cols.join(';')}" files . each do | file | @current_key = create_current_key @current_source_header = @source_header . shift processed_header = false File . open ( file ) . each_with_index do | line , index | next if line . chomp . empty? unless processed_header create_file_header unstring ( line ) . split ( ';' ) processed_header = true next end out . puts create_line unstring ( line ) . split ( ';' ) end end end end
1088	def pull_text_until_end texts = [ ] loop do res = pull break unless res . text? texts << res [ 0 ] end texts . join end
294	def request_payload ( resource , headers ) if headers format_specified = headers [ 'Content-Type' ] if format_specified . nil? resource . to_xml elsif format_specified . downcase . include? ( 'xml' ) resource . to_xml elsif format_specified . downcase . include? ( 'json' ) resource . to_json else resource . to_xml end else resource . to_xml end end
1186	def find ( query , options = { } ) assert_valid_keys ( options , :limit , :skip ) options = { :limit => 20 , :skip => 0 } . merge ( options ) data = api ( 'room.search' , :query => query , :skip => options [ :skip ] ) data [ 'rooms' ] . map { | ( attrs , * ) | Room . new ( client , attrs ) } end
913	def compact_results ( items ) items . map do | subtest | subtests = subtest [ :subtests ] if subtests . size > 1 subtests elsif subtests . size == 1 compact_results ( subtests ) end end . flatten . compact end
921	def deregister ( * targets ) targets . each & Ducks . list . method ( :delete ) targets . each & decorators . method ( :delete ) end
424	def find ( id ) build ( resource_gateway . json_show ( id ) ) rescue RestClient :: ResourceNotFound raise NoSuchModelError , "Can't find any #{endpoint} with id \"#{id}\"" end
46	def module_name ( version , service ) return [ api_name , version . to_s . upcase , service . to_s ] . join ( '::' ) end
509	def lists_for_email ( email_address ) options = { :query => { :email => email_address } } response = get 'listsforemail' , options response . map { | item | Hashie :: Mash . new ( item ) } end
748	def prefetch_primary_key? ( table_name = nil ) return true if table_name . nil? table_name = table_name . to_s primary_keys ( table_name . to_s ) . size == 0 end
708	def get_vm_by_name ( organization , vdcName , vAppName , vmName ) result = nil get_vapp_by_name ( organization , vdcName , vAppName ) [ :vms_hash ] . each do | key , values | if key . downcase == vmName . downcase result = get_vm ( values [ :id ] ) end end result end
704	def add_vm_network ( vmId , network , config = { } ) params = { 'method' => :get , 'command' => "/vApp/vm-#{vmId}/networkConnectionSection" } netconfig_response , headers = send_request ( params ) parent_section = netconfig_response . css ( 'NetworkConnectionSection' ) . first netconfig_response . css ( "Link" ) . each { | n | n . remove } none_network = netconfig_response . css ( 'NetworkConnection' ) . find { | n | n . attribute ( 'network' ) . text == 'none' } none_network . remove if none_network networks_count = netconfig_response . css ( 'NetworkConnection' ) . count primary_index_node = netconfig_response . css ( 'PrimaryNetworkConnectionIndex' ) . first unless primary_index_node primary_index_node = Nokogiri :: XML :: Node . new "PrimaryNetworkConnectionIndex" , parent_section parent_section . add_child ( primary_index_node ) end primary_index_node . content = config [ :primary_index ] || 0 new_network = Nokogiri :: XML :: Node . new "NetworkConnection" , parent_section new_network [ "network" ] = network [ :name ] new_network [ "needsCustomization" ] = true idx_node = Nokogiri :: XML :: Node . new "NetworkConnectionIndex" , new_network idx_node . content = config [ :network_index ] || networks_count new_network . add_child ( idx_node ) if config [ :ip ] ip_node = Nokogiri :: XML :: Node . new "IpAddress" , new_network ip_node . content = config [ :ip ] new_network . add_child ( ip_node ) end is_connected_node = Nokogiri :: XML :: Node . new "IsConnected" , new_network is_connected_node . content = config [ :is_connected ] || true new_network . add_child ( is_connected_node ) allocation_node = Nokogiri :: XML :: Node . new "IpAddressAllocationMode" , new_network allocation_node . content = config [ :ip_allocation_mode ] || "POOL" new_network . add_child ( allocation_node ) parent_section . add_child ( new_network ) params = { 'method' => :put , 'command' => "/vApp/vm-#{vmId}/networkConnectionSection" } put_response , headers = send_request ( params , netconfig_response . to_xml , "application/vnd.vmware.vcloud.networkConnectionSection+xml" ) task_id = headers [ :location ] . gsub ( / \/ \/ / , "" ) task_id end
133	def clean ( max : 24 * 60 * 60 ) Futex . new ( file , log : @log ) . open do list = load list . reject! do | s | if s [ :time ] >= Time . now - max false else @log . debug ( "Copy ##{s[:name]}/#{s[:host]}:#{s[:port]} is too old, over #{Age.new(s[:time])}" ) true end end save ( list ) deleted = 0 files . each do | f | next unless list . find { | s | s [ :name ] == File . basename ( f , Copies :: EXT ) } . nil? file = File . join ( @dir , f ) size = File . size ( file ) File . delete ( file ) @log . debug ( "Copy at #{f} deleted: #{Size.new(size)}" ) deleted += 1 end list . select! do | s | cp = File . join ( @dir , "#{s[:name]}#{Copies::EXT}" ) wallet = Wallet . new ( cp ) begin wallet . refurbish raise "Invalid protocol #{wallet.protocol} in #{cp}" unless wallet . protocol == Zold :: PROTOCOL true rescue StandardError => e FileUtils . rm_rf ( cp ) @log . debug ( "Copy at #{cp} deleted: #{Backtrace.new(e)}" ) deleted += 1 false end end save ( list ) deleted end end
974	def handle_keyboard_will_hide ( notification ) return unless @table if UIEdgeInsetsEqualToEdgeInsets ( @table . contentInset , UIEdgeInsetsZero ) return end animationCurve = notification . userInfo . valueForKey ( UIKeyboardAnimationCurveUserInfoKey ) animationDuration = notification . userInfo . valueForKey ( UIKeyboardAnimationDurationUserInfoKey ) UIView . beginAnimations ( "changeTableViewContentInset" , context : nil ) UIView . setAnimationDuration ( animationDuration ) UIView . setAnimationCurve ( animationCurve ) @table . contentInset = UIEdgeInsetsZero ; UIView . commitAnimations end
129	def to_json @threads . map do | t | { name : t . name , status : t . status , alive : t . alive? , vars : Hash [ t . thread_variables . map { | v | [ v . to_s , t . thread_variable_get ( v ) ] } ] } end end
255	def [] ( url ) url = URI ( url ) key = key_for ( url ) unless @sessions [ key ] session = Net :: HTTP :: Proxy ( @proxy . host , @proxy . port , @proxy . user , @proxy . password ) . new ( url . host , url . port ) session . open_timeout = @open_timeout if @open_timeout session . read_timeout = @read_timeout if @read_timeout session . continue_timeout = @continue_timeout if @continue_timeout session . keep_alive_timeout = @keep_alive_timeout if @keep_alive_timeout if url . scheme == 'https' session . use_ssl = true session . verify_mode = OpenSSL :: SSL :: VERIFY_NONE session . ssl_timeout = @ssl_timeout session . start end @sessions [ key ] = session end return @sessions [ key ] end
202	def items_since ( date_time , opts = { } ) opts = opts . clone unless date_time . kind_of? ( Date ) raise EwsBadArgumentError , "First argument must be a Date or DateTime" end restr = { :restriction => { :is_greater_than_or_equal_to => [ { :field_uRI => { :field_uRI => 'item:DateTimeReceived' } } , { :field_uRI_or_constant => { :constant => { :value => date_time . to_datetime } } } ] } } items ( opts . merge ( restr ) ) end
1352	def validate_timeout ( timeout ) unless timeout == nil raise TypeError , "'timeout' must be nil or a Numeric" unless timeout . is_a? ( Numeric ) raise ArgumentError , "'timeout' must not be negative" if timeout . negative? end end
503	def webhooks response = get "webhooks" response . map { | item | Hashie :: Mash . new ( item ) } end
899	def next_lfsr25 ( seed ) i = 1 i = ( seed + 1 ) & MASK raise ArgumentError , "Seed #{seed} out of bounds" if seed && i == 0 i = ( seed + 1 ) & MASK while i == 0 i = ( i >> 1 ) | ( ( i [ 0 ] ^ i [ 1 ] ^ i [ 2 ] ^ i [ 3 ] ) << 0x18 ) i = ( i >> 1 ) | ( ( i [ 0 ] ^ i [ 1 ] ^ i [ 2 ] ^ i [ 3 ] ) << 0x18 ) while i > MASK i - 1 end
1288	def run daemon if Config . daemonize Manager . manage_alerts Manager . remove_nonreporting_servers ( Config . cleanup_age ) if Config . cleanup end
106	def create_auth_handler ( ) auth_method = @config . read ( 'authentication.method' , :OAUTH2 ) return case auth_method when :OAUTH raise AdsCommon :: Errors :: Error , 'OAuth authorization method is deprecated, use OAuth2 instead.' when :OAUTH2 AdsCommon :: Auth :: OAuth2Handler . new ( @config , api_config . config ( :oauth_scope ) ) when :OAUTH2_SERVICE_ACCOUNT AdsCommon :: Auth :: OAuth2ServiceAccountHandler . new ( @config , api_config . config ( :oauth_scope ) ) else raise AdsCommon :: Errors :: Error , "Unknown authentication method '%s'" % auth_method end end
579	def photo ( photo_id , options = { } ) response = connection . get do | req | req . url "photos/#{photo_id}" , options end return_error_or_body ( response , response . body . response . photo ) end
928	def create_table_statement ( table_name , table ) normalize_primary_key ( table ) add_line "create_table #{table_name.inspect}#{pretty_hash(table[:table_options])} do" indent do output_columns ( table [ :columns ] , table [ :primary_key ] ) output_indexes ( table [ :indexes ] ) output_primary_key ( table ) end add_line "end" end
608	def signup! ( passwd = nil ) self . password = passwd || password if username . blank? raise Parse :: Error :: UsernameMissingError , "Signup requires a username." end if password . blank? raise Parse :: Error :: PasswordMissingError , "Signup requires a password." end signup_attrs = attribute_updates signup_attrs . except! * Parse :: Properties :: BASE_FIELD_MAP . flatten response = client . create_user signup_attrs if response . success? apply_attributes! response . result return true end case response . code when Parse :: Response :: ERROR_USERNAME_MISSING raise Parse :: Error :: UsernameMissingError , response when Parse :: Response :: ERROR_PASSWORD_MISSING raise Parse :: Error :: PasswordMissingError , response when Parse :: Response :: ERROR_USERNAME_TAKEN raise Parse :: Error :: UsernameTakenError , response when Parse :: Response :: ERROR_EMAIL_TAKEN raise Parse :: Error :: EmailTakenError , response when Parse :: Response :: ERROR_EMAIL_INVALID raise Parse :: Error :: InvalidEmailAddress , response end raise Parse :: Client :: ResponseError , response end
215	def create_attachment ( opts ) opts = opts . clone [ :parent_id ] . each do | k | validate_param ( opts , k , true ) end validate_param ( opts , :files , false , [ ] ) validate_param ( opts , :items , false , [ ] ) req = build_soap! do | type , builder | if ( type == :header ) else builder . nbuild . CreateAttachment { | x | builder . nbuild . parent . default_namespace = @default_ns builder . parent_item_id! ( opts [ :parent_id ] ) x . Attachments { opts [ :files ] . each do | fa | builder . file_attachment! ( fa ) end opts [ :items ] . each do | ia | builder . item_attachment! ( ia ) end opts [ :inline_files ] . each do | fi | builder . inline_attachment! ( fi ) end } } end end do_soap_request ( req , response_class : EwsResponse ) end
267	def enqueue ( url , level = 0 ) url = sanitize_url ( url ) if ( ! ( queued? ( url ) ) && visit? ( url ) ) link = url . to_s begin @every_url_blocks . each { | url_block | url_block . call ( url ) } @every_url_like_blocks . each do | pattern , url_blocks | match = case pattern when Regexp link =~ pattern else ( pattern == link ) || ( pattern == url ) end if match url_blocks . each { | url_block | url_block . call ( url ) } end end rescue Actions :: Paused => action raise ( action ) rescue Actions :: SkipLink return false rescue Actions :: Action end @queue << url @levels [ url ] = level return true end return false end
244	def to_xml ( opts = { } ) builder = Builder :: XmlMarkup . new ( :indent => opts [ :indent ] || 0 ) builder . instruct! builder . cartridge_basiclti_link ( "xmlns" => "http://www.imsglobal.org/xsd/imslticc_v1p0" , "xmlns:blti" => 'http://www.imsglobal.org/xsd/imsbasiclti_v1p0' , "xmlns:lticm" => 'http://www.imsglobal.org/xsd/imslticm_v1p0' , "xmlns:lticp" => 'http://www.imsglobal.org/xsd/imslticp_v1p0' , "xmlns:xsi" => "http://www.w3.org/2001/XMLSchema-instance" , "xsi:schemaLocation" => "http://www.imsglobal.org/xsd/imslticc_v1p0 http://www.imsglobal.org/xsd/lti/ltiv1p0/imslticc_v1p0.xsd http://www.imsglobal.org/xsd/imsbasiclti_v1p0 http://www.imsglobal.org/xsd/lti/ltiv1p0/imsbasiclti_v1p0p1.xsd http://www.imsglobal.org/xsd/imslticm_v1p0 http://www.imsglobal.org/xsd/lti/ltiv1p0/imslticm_v1p0.xsd http://www.imsglobal.org/xsd/imslticp_v1p0 http://www.imsglobal.org/xsd/lti/ltiv1p0/imslticp_v1p0.xsd" ) do | blti_node | %w{ title description launch_url secure_launch_url icon secure_icon } . each do | key | blti_node . blti key . to_sym , self . send ( key ) if self . send ( key ) end vendor_keys = %w{ name code description url } if vendor_keys . any? { | k | self . send ( "vendor_#{k}" ) } || vendor_contact_email blti_node . blti :vendor do | v_node | vendor_keys . each do | key | v_node . lticp key . to_sym , self . send ( "vendor_#{key}" ) if self . send ( "vendor_#{key}" ) end if vendor_contact_email v_node . lticp :contact do | c_node | c_node . lticp :name , vendor_contact_name c_node . lticp :email , vendor_contact_email end end end end if ! @custom_params . empty? blti_node . tag! ( "blti:custom" ) do | custom_node | @custom_params . keys . sort . each do | key | val = @custom_params [ key ] custom_node . lticm :property , val , 'name' => key end end end if ! @extensions . empty? @extensions . keys . sort . each do | ext_platform | ext_params = @extensions [ ext_platform ] blti_node . blti ( :extensions , :platform => ext_platform ) do | ext_node | ext_params . keys . sort . each do | key | val = ext_params [ key ] if val . is_a? ( Hash ) ext_node . lticm ( :options , :name => key ) do | type_node | val . keys . sort . each do | p_key | p_val = val [ p_key ] type_node . lticm :property , p_val , 'name' => p_key end end else ext_node . lticm :property , val , 'name' => key end end end end end blti_node . cartridge_bundle ( :identifierref => @cartridge_bundle ) if @cartridge_bundle blti_node . cartridge_icon ( :identifierref => @cartridge_icon ) if @cartridge_icon end end
385	def complete? chunks ! chunks . empty? && chunks . last . id == "ENDM" && chunks . last . payload == "OK" end
1319	def parse ( args ) @options = Options . new opt_parser = OptionParser . new do | parser | @options . define_options ( parser ) end opt_parser . parse! ( args ) @options end
28	def validate_time_arg ( arg , parent , key ) xml_value = time_to_xml_hash ( arg ) parent [ key ] = xml_value return xml_value end
13	def mock_call! ( * ) return mock_request_call if on_request_path? && OmniAuth . config . allowed_request_methods . include? ( request . request_method . downcase . to_sym ) return mock_callback_call if on_callback_path? call_app! end
71	def download_report_as_file ( report_definition , path , cid = nil ) report_body = download_report ( report_definition , cid ) save_to_file ( report_body , path ) return nil end
1154	def process_aggregation File . new ( infile ) . each_with_index do | line , index | result = col_filter . process ( row_filter . process ( line . chomp , row : index ) ) unless result . nil? or result . empty? if heading . empty? and not headerless heading << result . split ( ';' ) next else @sum_col = [ result . split ( ';' ) . size , sum_col ] . max end key_values [ result ] += 1 sums [ sum_col_title ] += 1 end end heading . flatten! heading [ sum_col ] = sum_col_title end
371	def __expose! singleton = singleton_class singleton . private_instance_methods . each do | sym | singleton . send ( :public , sym ) end __module_info [ :private_constants ] . each do | sym | const_set ( sym , singleton . const_get ( sym ) ) end self end
78	def get_report_request_headers ( url , cid ) @header_handler ||= AdwordsApi :: ReportHeaderHandler . new ( @api . credential_handler , @api . get_auth_handler ( ) , @api . config ) return @header_handler . headers ( url , cid ) end
705	def delete_vm_network ( vmId , network ) params = { 'method' => :get , 'command' => "/vApp/vm-#{vmId}/networkConnectionSection" } netconfig_response , headers = send_request ( params ) picked_network = netconfig_response . css ( "NetworkConnection" ) . select do | net | net . attribute ( 'network' ) . text == network [ :name ] end . first raise WrongItemIDError , "Network #{network[:name]} not found on this VM." unless picked_network picked_network . remove params = { 'method' => :put , 'command' => "/vApp/vm-#{vmId}/networkConnectionSection" } put_response , headers = send_request ( params , netconfig_response . to_xml , "application/vnd.vmware.vcloud.networkConnectionSection+xml" ) task_id = headers [ :location ] . gsub ( / \/ \/ / , "" ) task_id end
1090	def process ( object , options = { } ) filtered = super ( object , options ) return nil if filtered . nil? values = filtered . split ( ';' ) values . each_with_index do | value , index | if types [ index ] == 'n' if value =~ / \. / number_value = value . to_f else number_value = value . to_i end values [ index ] = number_value elsif types [ index ] == 'd' if value . strip . empty? date = Date . strptime ( '9999-9-9' , '%Y-%m-%d' ) else begin date = Date . strptime ( value , date_format ) rescue puts "Error #{value}, #{index}" end end values [ index ] = date end end values end
686	def set_vapp_port_forwarding_rules ( vappid , network_name , config = { } ) builder = Nokogiri :: XML :: Builder . new do | xml | xml . NetworkConfigSection ( "xmlns" => "http://www.vmware.com/vcloud/v1.5" , "xmlns:ovf" => "http://schemas.dmtf.org/ovf/envelope/1" ) { xml [ 'ovf' ] . Info "Network configuration" xml . NetworkConfig ( "networkName" => network_name ) { xml . Configuration { xml . ParentNetwork ( "href" => "#{@api_url}/network/#{config[:parent_network]}" ) xml . FenceMode ( config [ :fence_mode ] || 'isolated' ) xml . Features { xml . NatService { xml . IsEnabled "true" xml . NatType "portForwarding" xml . Policy ( config [ :nat_policy_type ] || "allowTraffic" ) config [ :nat_rules ] . each do | nat_rule | xml . NatRule { xml . VmRule { xml . ExternalPort nat_rule [ :nat_external_port ] xml . VAppScopedVmId nat_rule [ :vm_scoped_local_id ] xml . VmNicId ( nat_rule [ :nat_vmnic_id ] || "0" ) xml . InternalPort nat_rule [ :nat_internal_port ] xml . Protocol ( nat_rule [ :nat_protocol ] || "TCP" ) } } end } } } } } end params = { 'method' => :put , 'command' => "/vApp/vapp-#{vappid}/networkConfigSection" } response , headers = send_request ( params , builder . to_xml , "application/vnd.vmware.vcloud.networkConfigSection+xml" ) task_id = headers [ :location ] . gsub ( / \/ \/ / , "" ) task_id end
821	def generate_belongs_to_foreign_key_name ( assoc ) source = assoc . source_table [ 0 .. 7 ] column = assoc . foreign_key_column [ 0 .. 7 ] destination = assoc . destination_table [ 0 .. 7 ] "fk_#{source}_#{column}_#{destination}_#{SecureRandom.hex}" end
716	def add! ( container ) container . providers . reverse . each do | definition | add_provider ( * definition ) end self . provides ( container . provides ) @fallback_provider = container . fallback_provider . block if container . fallback_provider give! ( container . data ) end
598	def put ( uri , body = nil , headers = { } ) request :put , uri , body : body , headers : headers end
871	def format_path ( entry ) server_path = entry . path if base_path && server_path [ 0 , base_path . length ] == base_path if server_path == base_path return "." elsif server_path [ base_path . length , 1 ] == "/" return server_path [ base_path . length + 1 , server_path . length - base_path . length - 1 ] elsif base_path == "/" && server_path [ 0 , 1 ] == "/" return server_path [ 1 , server_path . length - 1 ] end end server_path end
441	def refunds response = Charge . get ( URI . parse ( PinPayment . api_url ) . tap { | uri | uri . path = "/1/charges/#{token}/refunds" } ) response . map { | x | Refund . new ( x . delete ( 'token' ) , x ) } end
61	def execute_action ( action_name , args , & block ) registry = get_service_registry ( ) validator = ParametersValidator . new ( registry ) args = validator . validate_args ( action_name , args ) request_info , response = handle_soap_request ( action_name . to_sym , false , args , validator . extra_namespaces ) do_logging ( action_name , request_info , response ) handle_errors ( response ) extractor = ResultsExtractor . new ( registry ) result = extractor . extract_result ( response , action_name , & block ) run_user_block ( extractor , response , result , & block ) if block_given? return result end
329	def generate_authorize_url ( request_token ) request = consumer . create_signed_request ( :get , consumer . authorize_path , request_token , { :oauth_callback => 'oob' } ) params = request [ 'Authorization' ] . sub ( / \s / , '' ) . split ( / \s / ) . map do | param | key , value = param . split ( '=' ) value =~ / / "#{key}=#{CGI::escape($1)}" end . join ( '&' ) "#{base_url}#{request.path}?#{params}" end
1193	def names ( ids , optional = { } ) region = optional [ :region ] || @sightstone . region ids = ids . join ( ',' ) uri = "https://prod.api.pvp.net/api/lol/#{region}/v1.3/summoner/#{ids}/name" response = _get_api_response ( uri ) _parse_response ( response ) { | resp | data = JSON . parse ( resp ) names_hash = Hash . new data . each do | id , name | names_hash [ id . to_i ] = name end if block_given? yield names_hash else return names_hash end } end
701	def set_vm_cpus ( vmid , cpu_number ) params = { 'method' => :get , 'command' => "/vApp/vm-#{vmid}/virtualHardwareSection/cpu" } get_response , headers = send_request ( params ) get_response . css ( "rasd|ElementName" ) . first . content = "#{cpu_number} virtual CPU(s)" get_response . css ( "rasd|VirtualQuantity" ) . first . content = cpu_number params [ 'method' ] = :put put_response , headers = send_request ( params , get_response . to_xml , "application/vnd.vmware.vcloud.rasdItem+xml" ) task_id = headers [ :location ] . gsub ( / \/ \/ / , "" ) task_id end
1278	def subscribe ( queue , options = { } , & block ) queue . subscribe ( options . merge ( manual_ack : true ) ) do | delivery_info , properties , payload | current_channel = delivery_info . channel begin log "Isimud: queue #{queue.name} received #{properties[:message_id]} routing_key: #{delivery_info.routing_key}" , :debug Thread . current [ 'isimud_queue_name' ] = queue . name Thread . current [ 'isimud_delivery_info' ] = delivery_info Thread . current [ 'isimud_properties' ] = properties block . call ( payload ) if current_channel . open? log "Isimud: queue #{queue.name} finished with #{properties[:message_id]}, acknowledging" , :debug current_channel . ack ( delivery_info . delivery_tag ) else log "Isimud: queue #{queue.name} unable to acknowledge #{properties[:message_id]}" , :warn end rescue => e log ( "Isimud: queue #{queue.name} error processing #{properties[:message_id]} payload #{payload.inspect}: #{e.class.name} #{e.message}\n #{e.backtrace.join("\n ")}" , :warn ) retry_status = run_exception_handlers ( e ) log "Isimud: rejecting #{properties[:message_id]} requeue=#{retry_status}" , :warn current_channel . open? && current_channel . reject ( delivery_info . delivery_tag , retry_status ) end end end
810	def to_g_marker_api2 ( marker_options = { } , options = { } ) klass = if options [ :short_class ] 'GMarker' else 'google.maps.Marker' end opts = Geos :: Helper . camelize_keys ( marker_options ) "new #{klass}(#{self.centroid.to_g_lat_lng(options)}, #{opts.to_json})" end
910	def debug = ( mode ) @debug = mode if mode HTTPI . log = true HTTPI . log_level = :debug else HTTPI . log = false end end
747	def type_from_filename ( filename ) ext = filename . split ( '.' ) . last ent = MMS2R :: EXT . detect { | k , v | v == ext } ent . nil? ? nil : ent . first end
301	def safelist ( * args ) list = flatten_list_of_strings ( args ) if list . nil? || list . empty? bot . safelist = [ ] else bot . safelist += list end end
771	def unique_paths_for ( name , opts = { } ) tally = { } output = [ ] paths_for ( name , opts ) . reverse . each do | ary | tally [ ary [ 1 ] ] ||= ary [ 0 ] output << ary if tally [ ary [ 1 ] ] == ary [ 0 ] end output . reverse end
234	def run_request ( request ) url = request . absolute? ? request . url : base_url + request . url logger . info ( request : { url : url , query : request . query , header : request_headers } ) if logger Response . new ( self . class . get_http ( url , request_query ( request . query ) , request_headers , proxy_params , timeout_params ) , request ) end
1271	def alert_delete_entity ( entity_id , condition_id , entity_type = 'Server' ) nr_api . delete do | req | req . url url ( 'alerts_entity_conditions' , entity_id ) req . params [ 'entity_type' ] = entity_type req . params [ 'condition_id' ] = condition_id end end
1215	def execute File . new ( infile ) . each_with_index do | line , index | row = row_filter . process ( line , row : index ) next if row . nil? or row . chomp . empty? collection . each do | category , elements | values = elements [ :filter ] . process ( row ) values . chomp . split ( ';' ) . each do | value | elements [ :entries ] << value . chomp if elements [ :entries ] . index ( value . chomp ) . nil? end end end File . open ( outfile , 'w' ) do | out | collection . each do | category , elements | out . puts "[#{category}]" elements [ :entries ] . sort . each { | c | out . puts c } end end end
523	def spam ( date = "" , page = 1 , page_size = 1000 , order_field = "date" , order_direction = "asc" ) paged_result_by_date ( "spam" , date , page , page_size , order_field , order_direction ) end
1241	def report ( reason = '' ) api ( 'room.report_user' , :roomid => room . id , :section => room . section , :reported => id , :reason => reason ) true end
858	def price_get ( type ) supply = find_or_create_supply_detail if type . nil? supply . prices . first else supply . prices . find { | p | p . price_type_code == type } end end
905	def after return to_enum ( __callee__ ) unless block_given? return if chain_tail? item = self . next loop do yield item item = item . next end end
6	def cookies hash = { } cookie_jar . cookies ( @request . uri ) . each do | cookie | hash [ cookie . name ] = cookie . value end hash end
322	def load_config ( params = { } ) read_only_data = global_config . merge ( bot_config ) . merge ( params ) @config = Chatterbot :: ConfigManager . new ( config_file , read_only_data ) end
1388	def jd ( date = self ) index = ( 12 * ( date . year - 1 ) ) + date . month - 16260 mcjdn = date . day + HijriUmmAlqura :: UMMALQURA_DAT [ index - 1 ] - 1 mcjdn = mcjdn + 2400000 - 0.5 return mcjdn end
536	def search_users_by_tip ( options = { } ) name = options . delete ( :name ) options [ :limit ] = 500 tips = search_tips ( options ) user = [ ] tips . each do | tip | user << tip [ 'user' ] if check_name ( tip [ 'user' ] , name ) end user . uniq end
968	def set_belongs_to_attr ( col , owner , options = { } ) _col = column ( col ) unless belongs_to_synced? ( _col , owner ) _set_attr ( _col . name , owner ) rebuild_relation ( _col , owner , set_inverse : options [ :set_inverse ] ) if _col . polymorphic set_polymorphic_attr ( _col . name , owner ) else _set_attr ( _col . foreign_key , owner ? owner . id : nil ) end end owner end
764	def store_associations_on_object ( object , attribute , associations ) values = associations . collect do | assoc | assoc . internal . blank? ? assoc . value : assoc . internal end values . compact! case values . length when 0 then values = nil when 1 then values = values . first end object . send ( "#{attribute}=" , values ) end
1219	def create_lookup_table File . open ( source ) . each_with_index do | line | next if line . chomp . empty? values = unstring ( line ) . chomp . split ( ';' ) next if values . empty? @joiners . each do | joiner | key = values [ joiner . join [ 0 ] ] joiner . lookup [ :rows ] [ key ] = [ ] joiner . cols . each do | i | joiner . lookup [ :rows ] [ key ] << values [ i ] end end end end
1167	def make_default_consent_tier_statuses return if registration . nil? or registration . consent_tier_responses . empty? ctses = consent_tier_statuses . map { | cts | cts . consent_tier } registration . consent_tier_responses . each do | ctr | ct = ctr . consent_tier next if ctses . include? ( ct ) cts = CaTissue :: ConsentTierStatus . new ( :consent_tier => ct ) cts . add_defaults consent_tier_statuses << cts logger . debug { "Made default #{qp} #{cts.qp} for consent tier #{ct.qp}." } end end
1296	def configure ( argv = ARGV ) cli = Options . new cli . parse_options ( argv ) json_config = Util . parse_json ( cli . config [ :config_file ] || Config . config_file ) config = [ json_config , cli . config ] . compact . reduce ( :merge ) config . each { | k , v | Config . send ( "#{k}=" , v ) } end
1246	def default_user scg = specimen_collection_group || ( specimen . specimen_collection_group if specimen ) || return cp = scg . collection_protocol || return cp . coordinators . first || ( cp . sites . first . coordinator if cp . sites . size === 1 ) end
1293	def osx_notification ( message , subtitle , title ) TerminalNotifier . notify ( message , title : title , subtitle : subtitle ) end
1206	def col_regex ( col , r , args , block ) operation = "'[value]' =~ Regexp.new('#{r}')" pivot [ r ] = { col : col , operation : operation } end
673	def get_feature_report ( report_number , buffer_size = nil ) buffer_size ||= input_ep_max_packet_size mutex . synchronize do handle . control_transfer ( bmRequestType : LIBUSB :: REQUEST_TYPE_CLASS | LIBUSB :: RECIPIENT_INTERFACE | LIBUSB :: ENDPOINT_IN , bRequest : 0x01 , wValue : ( 3 << 8 ) | report_number , wIndex : interface , dataIn : buffer_size ) end end
1244	def collection_site return unless medical_identifiers . size == 1 site = medical_identifiers . first . site return if site . nil? site . site_type == Site :: SiteType :: COLLECTION ? site : nil end
818	def convert_to_price ( price_str ) raise SolidusImportProducts :: Exception :: InvalidPrice unless price_str punt = price_str . index ( '.' ) coma = price_str . index ( ',' ) if ! coma . nil? && ! punt . nil? price_str . gsub! ( punt < coma ? '.' : ',' , '' ) end price_str . tr ( ',' , '.' ) . to_f end
1010	def add_schema_hashes ( obj , key = nil ) if obj . is_a? ( Array ) obj . map! { | method | add_schema_hashes ( method ) } elsif obj . is_a? ( Hash ) obj . each { | k , v | obj [ k ] = add_schema_hashes ( v , k ) } if obj . include? ( "schema" ) case key when 'application/json' obj [ 'schema_hash' ] = JSON . parse ( obj [ 'schema' ] ) refactor_object = lambda do | lam_obj | lam_obj [ 'properties' ] . each do | name , param | param [ 'displayName' ] = name param [ 'required' ] = true if lam_obj . fetch ( 'required' , [ ] ) . include? ( name ) if param . include? ( 'example' ) and [ 'object' , 'array' ] . include? ( param [ 'type' ] ) param [ 'example' ] = JSON . pretty_generate ( JSON . parse ( param [ 'example' ] ) ) elsif param . include? ( 'properties' ) param [ 'properties' ] = JSON . pretty_generate ( param [ 'properties' ] ) elsif param . include? ( 'items' ) param [ 'items' ] = JSON . pretty_generate ( param [ 'items' ] ) end lam_obj [ 'properties' ] [ name ] = param end lam_obj end if obj [ 'schema_hash' ] . include? ( 'properties' ) obj [ 'schema_hash' ] = refactor_object . call ( obj [ 'schema_hash' ] ) end if obj [ 'schema_hash' ] . include? ( 'items' ) and obj [ 'schema_hash' ] [ 'items' ] . include? ( 'properties' ) obj [ 'schema_hash' ] [ 'items' ] = refactor_object . call ( obj [ 'schema_hash' ] [ 'items' ] ) end end end end obj end
442	def update email , account_or_token = nil attributes = self . class . attributes - [ :token , :created_at ] options = self . class . parse_options_for_request ( attributes , email : email , bank_account : account_or_token ) response = self . class . put ( URI . parse ( PinPayment . api_url ) . tap { | uri | uri . path = "/1/recipients/#{token}" } , options ) self . email = response [ 'email' ] self . bank_account = response [ 'bank_account' ] self end
756	def update_video_orientation! photo_output . connectionWithMediaType ( AVMediaTypeVideo ) . tap do | connection | device_orientation = UIDevice . currentDevice . orientation video_orientation = orientation_mapping . fetch ( device_orientation , AVCaptureVideoOrientationPortrait ) connection . setVideoOrientation ( video_orientation ) if connection . videoOrientationSupported? end end
265	def []= ( url , auth ) url = URI ( url ) path = URI . expand_path ( url . path ) key = [ url . scheme , url . host , url . port ] @credentials [ key ] ||= { } @credentials [ key ] [ path . split ( '/' ) ] = auth return auth end
278	def every_atom_doc every_page do | page | if ( block_given? && page . atom? ) if ( doc = page . doc ) yield doc end end end end
501	def segments response = get "segments" response . map { | item | Hashie :: Mash . new ( item ) } end
261	def []= ( host , cookies ) collected = self [ host ] cookies . each do | key , value | if collected [ key ] != value collected . merge! ( cookies ) @dirty << host break end end return cookies end
833	def add ( key , meta ) @collection [ key ] = meta if meta . required? @required_properties << key else @required_properties . delete ( key ) end meta end
208	def get_events begin if subscribed? resp = ews . get_events ( @subscription_id , @watermark ) rmsg = resp . response_messages [ 0 ] @watermark = rmsg . new_watermark rmsg . events . collect { | ev | type = ev . keys . first class_by_name ( type ) . new ( ews , ev [ type ] ) } else raise EwsSubscriptionError , "Folder <#{self.display_name}> not subscribed to. Issue a Folder#subscribe before checking events." end rescue EwsSubscriptionTimeout => e @subscription_id , @watermark = nil , nil raise e end end
389	def unlock EM . cancel_timer ( @expire_timer ) if @expire_timer df = EM :: DefaultDeferrable . new @redis . lock_release ( [ @key ] , [ @token ] ) . callback { | keys_removed | if keys_removed > 0 EM :: Hiredis . logger . debug "#{to_s} released" df . succeed else EM :: Hiredis . logger . debug "#{to_s} could not release, not held" df . fail ( "Cannot release a lock we do not hold" ) end } . errback { | e | EM :: Hiredis . logger . error "#{to_s} Error releasing lock #{e}" df . fail ( e ) } df end
565	def list_venuegroup ( options = { } ) response = connection . get do | req | req . url "venuegroups/list" , options end return_error_or_body ( response , response . body . response . venueGroups ) end
883	def dump_scraped_object ( object ) type = object . class . to_s . demodulize . underscore name = "#{type}_#{object._id.gsub(File::SEPARATOR, '_')}.json" if @store . write_unless_exists ( name , object . to_h ) info { "save #{type} #{object.to_s} as #{name}" } else raise Errors :: DuplicateObjectIdError , "duplicate object ID: #{object._id} (was the same objected yielded twice?)" end if @validate begin object . validate! rescue JSON :: Schema :: ValidationError => e warn { e . message } end end end
1071	def attributes = ( attrs ) if attrs super ( 'users' => attrs . delete ( 'users' ) ) if attrs [ 'users' ] super song_attributes = attrs [ 'metadata' ] && attrs [ 'metadata' ] . select { | key , value | %w( upvotes downvotes votelog ) . include? ( key ) } current_song . attributes = song_attributes if @current_song end end
1383	def find_or_create_authorization_by_note ( note ) found_auth = list_authorizations . find { | auth | auth . note == note } if found_auth found_auth . token else create_authorization ( note ) end end
647	def to_rtf text = StringIO . new count = 0 text << '{\*\shppict{\pict' text << "\\picscalex#{@x_scaling}" if @x_scaling != nil text << "\\picscaley#{@y_scaling}" if @y_scaling != nil text << "\\piccropl#{@left_crop}" if @left_crop != nil text << "\\piccropr#{@right_crop}" if @right_crop != nil text << "\\piccropt#{@top_crop}" if @top_crop != nil text << "\\piccropb#{@bottom_crop}" if @bottom_crop != nil text << "\\picwgoal#{@displayed_width}" if @displayed_width != nil text << "\\pichgoal#{@displayed_height}" if @displayed_height != nil text << "\\picw#{@width}\\pich#{@height}\\bliptag#{@id}" text << "\\#{@type.id2name}\n" open_file do | file | file . each_byte do | byte | hex_str = byte . to_s ( 16 ) hex_str . insert ( 0 , '0' ) if hex_str . length == 1 text << hex_str count += 1 if count == 40 text << "\n" count = 0 end end end text << "\n}}" text . string end
107	def prepare_wrapper ( version , service ) api_config . do_require ( version , service ) endpoint = api_config . endpoint ( version , service ) interface_class_name = api_config . interface_name ( version , service ) wrapper = class_for_path ( interface_class_name ) . new ( @config , endpoint ) auth_handler = get_auth_handler ( ) header_ns = api_config . config ( :header_ns ) + version . to_s soap_handler = soap_header_handler ( auth_handler , version , header_ns , wrapper . namespace ) wrapper . header_handler = soap_handler return wrapper end
1348	def reload ( ) self . clear self . concat File . read ( event_file ) . split ( / \r \n / ) . map { | e | Event . new ( e ) } end
522	def unsubscribes ( date = "" , page = 1 , page_size = 1000 , order_field = "date" , order_direction = "asc" ) paged_result_by_date ( "unsubscribes" , date , page , page_size , order_field , order_direction ) end
1146	def on_message ( event ) data = event . data response = data . match ( / \d / ) [ 1 ] message = case response when / / { 'command' => 'no_session' } when / / publish_to_socket ( $1 ) { 'command' => 'heartbeat' } else JSON . parse ( response ) end message [ 'command' ] = 'response_received' if message [ 'msgid' ] logger . debug "Message received: #{message.inspect}" dispatch ( message ) end
1009	def do_once ( action_name , opts = { } ) return if action_applied? ( action_name ) result = yield job_done = opts [ :job_done_when ] . blank? || opts [ :job_done_when ] . call ( result ) apply_action ( action_name ) if job_done end
138	def moderation_state_visible_to_user? ( user ) moderation_state_visible_to_all? || ( ! user . thredded_anonymous? && ( user_id == user . id || user . thredded_can_moderate_messageboard? ( messageboard ) ) ) end
621	def to_rtf text = StringIO . new text << '{' if wrap? text << @prefix if @prefix self . each do | entry | text << "\n" if split? text << entry . to_rtf end text << "\n" if split? text << @suffix if @suffix text << '}' if wrap? text . string end
173	def folder_shape! ( folder_shape ) @nbuild . FolderShape { @nbuild . parent . default_namespace = @default_ns base_shape! ( folder_shape [ :base_shape ] ) if ( folder_shape [ :additional_properties ] ) additional_properties! ( folder_shape [ :additional_properties ] ) end } end
115	def exists? ( details ) ! @wallet . txns . find { | t | t . details . start_with? ( "#{PREFIX} " ) && t . details == details } . nil? end
603	def no_read! will_change! permissions . keys . each do | perm | permissions [ perm ] . read! false end end
1137	def span_to ( spanner ) Vector . new ( ( @x - spanner . x ) . abs , ( @y - spanner . y ) . abs ) end
1390	def add ( date = self , offset , period ) y = period == 'y' ? ( date . year + offset ) : date . year m = period == 'm' ? ( month_of_year ( date . year , date . month ) + offset ) : month_of_year ( date . year , date . month ) d = date . day begin if ( period == 'd' || period == 'w' ) week_days = period == 'w' ? 7 : 1 j_date = jd j_date = j_date + offset * week_days result = HijriUmmAlqura . jd ( j_date ) return result elsif ( period == 'm' ) rys = resync_year_month ( y , m ) y = rys [ 0 ] m = rys [ 1 ] return HijriUmmAlqura . format_date ( [ y , m , d ] ) elsif ( period == 'y' ) return HijriUmmAlqura . format_date ( [ y , m , d ] ) end rescue Exception => e puts "Exception details: #{e.class} #{e.message}" end end
651	def header = ( header ) if header . type == HeaderNode :: UNIVERSAL @headers [ 0 ] = header elsif header . type == HeaderNode :: LEFT_PAGE @headers [ 1 ] = header elsif header . type == HeaderNode :: RIGHT_PAGE @headers [ 2 ] = header elsif header . type == HeaderNode :: FIRST_PAGE @headers [ 3 ] = header end end
228	def coerce ( * ) return nil if value . nil? return value if value . is_a? ( Date ) DateTime . parse ( value ) end
19	def validate_arguments ( args_hash , fields_list , type_ns = nil ) check_extra_fields ( args_hash , array_from_named_list ( fields_list ) ) add_order_key ( args_hash , fields_list ) fields_list . each do | field | key = field [ :name ] item = args_hash [ key ] check_required_argument_present ( item , field ) unless item . nil? original_name = field [ :original_name ] if original_name key = handle_name_override ( args_hash , key , original_name ) end item_type = get_full_type_signature ( field [ :type ] ) item_ns = field [ :ns ] || type_ns key = handle_namespace_override ( args_hash , key , item_ns ) if item_ns unless validate_choice_argument ( item , args_hash , key , item_type ) validate_arg ( item , args_hash , key , item_type ) end end end return args_hash end
230	def entry ( id , query = { } ) normalize_select! ( query ) query [ 'sys.id' ] = id entries = Request . new ( self , environment_url ( '/entries' ) , query ) . get return entries if configuration [ :raw_mode ] entries . first end
436	def table ( name , locator ) define_method ( "#{name}" ) do adapter . table ( locator ) end define_method ( "#{name}=" ) do | which_item | adapter . table ( locator ) . select which_item end define_method ( "add_#{name}" ) do | hash_info | adapter . table ( locator ) . add hash_info end define_method ( "select_#{name}" ) do | hash_info | adapter . table ( locator ) . select hash_info end define_method ( "find_#{name}" ) do | hash_info | adapter . table ( locator ) . find_row_with hash_info end define_method ( "clear_#{name}" ) do | hash_info | adapter . table ( locator ) . clear hash_info end define_method ( "#{name}_headers" ) do adapter . table ( locator ) . headers end define_method ( "#{name}_view" ) do adapter . table ( locator ) . view end end
319	def slurp_file ( f ) f = File . expand_path ( f ) tmp = { } if File . exist? ( f ) File . open ( f ) { | yf | tmp = YAML :: load ( yf ) } end tmp . symbolize_keys! unless tmp == false end
434	def link ( name , locator ) define_method ( "#{name}_text" ) do adapter . link ( locator ) . value end define_method ( "click_#{name}" ) do adapter . link ( locator ) . click end define_method ( "#{name}_view" ) do adapter . link ( locator ) . view end end
626	def bold style = CharacterStyle . new style . bold = true if block_given? apply ( style ) { | node | yield node } else apply ( style ) end end
1310	def wake_deadline ( start_time , timeout ) timeout = process_timeout ( timeout ) deadline = start_time + timeout if timeout end
971	def get_nokogiri ( path ) uri = URI . join ( 'https://stellar.mit.edu' , path ) raw_html = @mech . get_file uri Nokogiri . HTML raw_html , uri . to_s end
875	def rotation = ( val ) permissible = [ 0 , 90 , 180 , 270 ] fail ArgumentError , "invalid rotation, permissible: #{permissible.join(', ')}" unless permissible . include? ( val % 360 ) @rotation = val % 360 push_all_pixels end
759	def stack ( name = nil , opts = { } ) if self :: StackMiddleware . _mwares [ name ] && mw = self :: StackMiddleware . _mwares [ name ] unless mw . stack == self mw = self :: StackMiddleware . _mwares [ name ] = self :: StackMiddleware . _mwares [ name ] . dup end mw else self :: StackMiddleware . new ( name , self , opts ) end end
477	def ft_addhash redis_key : REDI_SEARCH . call ( 'FT.ADDHASH' , @index_name , redis_key , @score , 'REPLACE' ) rescue Exception => e Rails . logger . error e if defined? Rails return e . message end
643	def bottom_border_width = ( width ) size = width . nil? ? 0 : width if size > 0 @borders [ BOTTOM ] = size . to_i else @borders [ BOTTOM ] = nil end end
403	def advanced_search ( args ) raise ArgumentError . new ( "Args cannot be blank" ) if args . nil? || args . empty? request_path = "#{base_url}/advanced_search?#{Rack::Utils.build_nested_query(args)}" get_json ( request_path ) end
84	def check_report_definition_hash ( report_definition ) REQUIRED_FIELDS . each do | field | unless report_definition . include? ( field ) raise AdwordsApi :: Errors :: InvalidReportDefinitionError , "Required field '%s' is missing in the definition" % field end end unless report_definition [ :selector ] . include? ( :fields ) raise AdwordsApi :: Errors :: InvalidReportDefinitionError , 'Fields list is required' end unless report_definition [ :selector ] [ :fields ] . kind_of? ( Array ) raise AdwordsApi :: Errors :: InvalidReportDefinitionError , 'Fields list must be an array' end if report_definition [ :selector ] [ :fields ] . empty? raise AdwordsApi :: Errors :: InvalidReportDefinitionError , 'At least one field needs to be requested' end end
1221	def create_joiners ( j , c , p ) js = j . split ( ';' ) . collect { | j | j . split ( '=' ) . collect { | j | j . to_i } } cs = c . split ( ';' ) . collect { | c | c . split ( ',' ) . collect { | c | c . to_i } } ps = col_positions ( p , cs ) @joiners = [ ] ( 0 ... js . size ) . each do | i | @joiners << Joiner . new ( js [ i ] , ps [ i ] , cs [ i ] , { rows : { } } ) end ps . flatten end
757	def select_levels ( data , backtrack , kmin , kmax ) return kmin if kmin == kmax method = :normal kopt = kmin base = 1 n = data . size - base max_bic = 0.0 for k in kmin .. kmax cluster_sizes = [ ] kbacktrack = backtrack [ 0 .. k ] backtrack ( kbacktrack ) do | cluster , left , right | cluster_sizes [ cluster ] = right - left + 1 end index_left = base index_right = 0 likelihood = 0 bin_left , bin_right = 0 for i in 0 .. ( k - 1 ) points_in_bin = cluster_sizes [ i + base ] index_right = index_left + points_in_bin - 1 if data [ index_left ] < data [ index_right ] bin_left = data [ index_left ] bin_right = data [ index_right ] elsif data [ index_left ] == data [ index_right ] bin_left = index_left == base ? data [ base ] : ( data [ index_left - 1 ] + data [ index_left ] ) / 2 bin_right = index_right < n - 1 + base ? ( data [ index_right ] + data [ index_right + 1 ] ) / 2 : data [ n - 1 + base ] else raise "ERROR: binLeft > binRight" end bin_width = bin_right - bin_left if method == :uniform likelihood += points_in_bin * Math . log ( points_in_bin / bin_width / n ) else mean = 0.0 variance = 0.0 for j in index_left .. index_right mean += data [ j ] variance += data [ j ] ** 2 end mean /= points_in_bin variance = ( variance - points_in_bin * mean ** 2 ) / ( points_in_bin - 1 ) if points_in_bin > 1 if variance > 0 for j in index_left .. index_right likelihood += - ( data [ j ] - mean ) ** 2 / ( 2.0 * variance ) end likelihood += points_in_bin * ( Math . log ( points_in_bin / Float ( n ) ) - 0.5 * Math . log ( 2 * Math :: PI * variance ) ) else likelihood += points_in_bin * Math . log ( 1.0 / bin_width / n ) end end index_left = index_right + 1 end bic = 2 * likelihood - ( 3 * k - 1 ) * Math . log ( Float ( n ) ) if k == kmin max_bic = bic kopt = kmin elsif bic > max_bic max_bic = bic kopt = k end end kopt end
1062	def champions ( optional = { } ) region = optional [ :region ] || @sightstone . region free_to_play = optional [ :free_to_play ] || false uri = "https://prod.api.pvp.net/api/lol/#{region}/v1.1/champion" response = _get_api_response ( uri , { 'freeToPlay' => free_to_play } ) _parse_response ( response ) { | resp | data = JSON . parse ( resp ) champions = [ ] data [ 'champions' ] . each do | champ | champions << Champion . new ( champ ) end if block_given? yield champions else return champions end } end
399	def punsubscribe_proc ( pattern , proc ) df = EM :: DefaultDeferrable . new if @psub_callbacks [ pattern ] . delete ( proc ) if @psub_callbacks [ pattern ] . any? df . succeed else punsubscribe ( pattern ) . callback { | _ | df . succeed } end else df . fail end return df end
98	def determine_choice ( field_data , field_choices ) result = nil key_name = field_data . keys . first unless key_name . nil? choice = find_named_entry ( field_choices , key_name ) result = choice [ :type ] unless choice . nil? end return result end
340	def dump ( io ) bytes_written = 0 @entries . each do | entry | bytes_written += entry . dump_local_file_record ( io , bytes_written ) end central_directory_offset = bytes_written @entries . each do | entry | bytes_written += entry . dump_central_file_record ( io ) end central_directory_length = bytes_written - central_directory_offset bytes_written += io . write ( EOCD_SIGNATURE ) bytes_written += io . write ( [ 0 , 0 , @entries . length , @entries . length , central_directory_length , central_directory_offset , comment . bytesize ] . pack ( 'vvvvVVv' ) ) bytes_written += io . write ( comment ) bytes_written end
1041	def input o = if @input . nil? Steamd . language_dir else @input end raise 'input must be a directory' unless File . directory? ( o ) File . expand_path ( o ) end
900	def parse ( argv = [ ] ) @option_parser . parse! ( argv ) options . each do | option | if option . required? and ! option . has_value? Shebang . error ( "The -#{option.short} option is required" ) end end return argv end
456	def transition ( read , write , move ) if read == @memory [ @head ] @memory [ @head ] = write case move when 'R' @memory << '@' if @memory [ @head + 1 ] @head += 1 when 'L' @memory . unshift ( '@' ) if @head == 0 @head -= 1 end return true else return false end end
1274	def get_servers_labeled ( labels ) label_query = Array ( labels ) . reject { | x | ! x . include? ( ':' ) } . join ( ';' ) return [ ] unless label_query nr_api . get ( url ( 'servers' ) , 'filter[labels]' => label_query ) . body end
1198	def method_missing ( id , * args , & block ) boolean_row_regex = %r{ \( \d \. \( \) \d \) \| \| \( \d \. \( \) \d \) }xi return boolean_row ( $1 , args , block ) if id =~ boolean_row_regex return equal ( $1 , args , block ) if id =~ / \d / return equal_type ( $1 , $2 , args , block ) if id =~ / \d / return range ( $1 , $2 , args , block ) if id =~ / \d \d / return range_type ( $1 , $2 , $3 , args , block ) if id =~ / \d \d / return regex ( $1 , args , block ) if id =~ / \/ \/ / return col_regex ( $1 , $2 , args , block ) if id =~ / \d \/ \/ / return date ( $1 , $2 , $3 , args , block ) if id =~ / \d \d \d \d / return date_range ( $1 , $2 , $3 , args , block ) if id =~ / \d \d \d \d \d \d \d / return number ( $1 , $2 , $3 , args , block ) if id =~ / \d \d / return number_range ( $1 , $2 , $3 , args , block ) if id =~ / \d \d \d / super end
87	def credentials ( credentials_override = nil ) credentials = @credentials . dup ( ) credentials . merge! ( credentials_override ) unless credentials_override . nil? return credentials end
1290	def get_layout ( layout_path ) if layout_path . nil? contents = "---\n" contents << "title:\n" contents << "layout: post\n" contents << "date:\n" contents << "---\n" ext = nil else begin contents = File . open ( layout_path , "r" ) . read ( ) ext = layout_path . match ( / \. / ) [ 1 ] rescue Errno :: ENOENT bad_path ( layout_path ) end end return contents , ext end
447	def del ( path , raise = true ) path = '"' + path + '"' if path . include? ' ' exec 'del ' + path true rescue Client :: RuntimeError => e raise e if raise false end
942	def add ( word , categories ) categories . each do | category | @cwords [ category ] = [ ] if @cwords [ category ] . nil? @cwords [ category ] . push word @scores [ category ] += 1 end @words . push word @word_count += 1 end
24	def handle_namespace_override ( args , key , ns ) add_extra_namespace ( ns ) new_key = prefix_key_with_namespace ( key . to_s . lower_camelcase , ns ) rename_hash_key ( args , key , new_key ) replace_array_item ( args [ :order! ] , key , new_key ) return new_key end
10	def call! ( env ) unless env [ 'rack.session' ] error = OmniAuth :: NoSessionError . new ( 'You must provide a session to use OmniAuth.' ) raise ( error ) end @env = env @env [ 'omniauth.strategy' ] = self if on_auth_path? return mock_call! ( env ) if OmniAuth . config . test_mode return options_call if on_auth_path? && options_request? return request_call if on_request_path? && OmniAuth . config . allowed_request_methods . include? ( request . request_method . downcase . to_sym ) return callback_call if on_callback_path? return other_phase if respond_to? ( :other_phase ) @app . call ( env ) end
88	def credentials = ( new_credentials ) diff = new_credentials . inject ( [ ] ) do | result , ( key , value ) | result << [ key , value ] if value != @credentials [ key ] result end diff = @credentials . inject ( diff ) do | result , ( key , _ ) | result << [ key , nil ] unless new_credentials . include? ( key ) result end diff . each { | entry | set_credential ( entry [ 0 ] , entry [ 1 ] ) } return nil end
152	def side_load ( resources , side_loads ) key = "#{options.name}_id" plural_key = "#{Inflection.singular options.name.to_s}_ids" resources . each do | resource | if resource . key? ( plural_key ) side_load_from_child_ids ( resource , side_loads , plural_key ) elsif resource . key? ( key ) || options . singular side_load_from_child_or_parent_id ( resource , side_loads , key ) else side_load_from_parent_id ( resource , side_loads , key ) end end end
499	def update_custom_field_options ( custom_field_key , new_options , keep_existing_options ) custom_field_key = CGI . escape ( custom_field_key ) options = { :body => { :Options => new_options , :KeepExistingOptions => keep_existing_options } . to_json } put "customfields/#{custom_field_key}/options" , options end
766	def mount ( mounted_app , path , options = { } ) mounted_app = MountedApplication . new ( mounted_app , path , options ) self . class . mounted_applications << mounted_app mounted_app end
1318	def open_file_dialog ( title , filepath , text = "" ) wait_and_focus_window ( title ) dialog = RFormSpec :: OpenFileDialog . new ( title , text ) dialog . enter_filepath ( filepath ) sleep 1 dialog . click_open end
1047	def saver_proxy xfr = specimen . event_parameters . detect do | sep | CaTissue :: TransferEventParameters === sep and sep . to == location end xfr ||= CaTissue :: TransferEventParameters . new ( :specimen => specimen , :to => location ) if snapshot and changed? then xfr . from_storage_container = snapshot [ :storage_container ] xfr . from_position_dimension_one = snapshot [ :position_dimension_one ] xfr . from_position_dimension_two = snapshot [ :position_dimension_two ] end xfr end
1283	def publish ( draftpath , opts = { } ) opts = @helper . ensure_open_struct ( opts ) tail = File . basename ( draftpath ) begin infile = File . open ( draftpath , "r" ) rescue Errno :: ENOENT @helper . bad_path ( draftpath ) end date = @helper . get_date_stamp time = @helper . get_time_stamp outpath = File . join ( POSTS_FOLDER , "#{date}-#{tail}" ) outfile = File . open ( outpath , "w" ) infile . each_line do | line | line . sub! ( / / , "date: #{date} #{time}\n" ) unless opts . keep_timestamp outfile . write ( line ) end infile . close outfile . close FileUtils . rm ( draftpath ) unless opts . keep_draft outpath end
175	def indexed_page_item_view! ( indexed_page_item_view ) attribs = { } indexed_page_item_view . each_pair { | k , v | attribs [ camel_case ( k ) ] = v . to_s } @nbuild [ NS_EWS_MESSAGES ] . IndexedPageItemView ( attribs ) end
427	def save! if persisted? update ( to_h ) else self . id = resource_gateway . create ( to_h ) end self rescue RestClient :: Exception => e raise_failed_request_error ( e ) end
1036	def set_center_coordinates ( center_coordinate , zoom_level , animated = false ) zoom_level = [ zoom_level , 18 ] . min span = self . class . coordinate_span_with_map_view ( self , center_coordinate , zoom_level ) region = CoordinateRegion . new ( center_coordinate , span ) self . setRegion ( region . api , animated : animated ) end
1185	def with_friends data = api ( 'room.directory_graph' ) data [ 'rooms' ] . map do | ( attrs , friends ) | Room . new ( client , attrs . merge ( :friends => friends ) ) end end
417	def total_coverage ( report_path ) jacoco_report = Nokogiri :: XML ( File . open ( report_path ) ) report = jacoco_report . xpath ( 'report/counter' ) . select { | item | item [ 'type' ] == 'INSTRUCTION' } missed_instructions = report . first [ 'missed' ] . to_f covered_instructions = report . first [ 'covered' ] . to_f total_instructions = missed_instructions + covered_instructions covered_percentage = ( covered_instructions * 100 / total_instructions ) . round ( 2 ) coverage_status = coverage_status ( covered_percentage , minimum_project_coverage_percentage ) { covered : covered_percentage , status : coverage_status } end
976	def call ( env ) if rand ( 1 .. 100 ) <= @percent if @modify == :response response = @handler . call ( * @app . call ( env ) ) else modified_env = @handler . call ( env ) || env response = @app . call ( modified_env ) end else response = @app . call ( env ) end response end
149	def << ( item ) fetch if item . is_a? ( Resource ) if item . is_a? ( @resource_class ) @resources << item else raise "this collection is for #{@resource_class}" end else @resources << wrap_resource ( item , true ) end end
1334	def write_list ( name , val ) raise "RedisAssist: tried to store a #{val.class.name} as Array" unless val . is_a? ( Array ) lists [ name ] = val end
1183	def add_dependency ( key , dependencies = [ ] ) raise SelfDependencyError , "An object's dependencies cannot contain itself" if dependencies . include? key node = node_for_key_or_new key dependencies . each do | dependency | node . addEdge ( node_for_key_or_new ( dependency ) ) end resolve_dependencies end
68	def format_fault ( message ) if message . length > MAX_FAULT_LOG_LENGTH message = message [ 0 , MAX_FAULT_LOG_LENGTH ] end return message . gsub ( "\n" , ' ' ) end
1035	def build ( attrs ) playlist = Playlist . new ( client , attrs ) if existing = @playlists [ playlist . id ] playlist = existing playlist . attributes = attrs else @playlists [ playlist . id ] = playlist end playlist end
1046	def unlock if locked? && enabled? Cratus :: LDAP . replace_attribute ( dn , Cratus . config . user_lockout_attribute , [ '0' ] ) refresh elsif disabled? false else true end end
233	def request_headers headers = { 'X-Contentful-User-Agent' => contentful_user_agent } headers [ 'Authorization' ] = "Bearer #{configuration[:access_token]}" if configuration [ :authentication_mechanism ] == :header headers [ 'Content-Type' ] = "application/vnd.contentful.delivery.v#{configuration[:api_version].to_i}+json" if configuration [ :api_version ] headers [ 'Accept-Encoding' ] = 'gzip' if configuration [ :gzip_encoded ] headers end
689	def add_network_to_vapp ( vAppId , network_section ) params = { 'method' => :put , 'command' => "/vApp/vapp-#{vAppId}/networkConfigSection" } response , headers = send_request ( params , network_section , "application/vnd.vmware.vcloud.networkConfigSection+xml" ) task_id = headers [ :location ] . gsub ( / \/ \/ / , "" ) task_id end
376	def decode ( options = { } ) decode! ( options ) rescue TwoCaptcha :: Error => ex TwoCaptcha :: Captcha . new end
801	def usb_open ( vendor , product ) raise ArgumentError . new ( 'vendor should be Fixnum' ) unless vendor . kind_of? ( Fixnum ) raise ArgumentError . new ( 'product should be Fixnum' ) unless product . kind_of? ( Fixnum ) check_result ( Ftdi . ftdi_usb_open ( ctx , vendor , product ) ) end
972	def field_at ( index ) data = self . class . instance_variable_get ( '@binding_data' . to_sym ) data [ index ] . tag = index + 1 data [ index ] end
99	def normalize_item ( item , field_def ) return case field_def [ :type ] when 'long' , 'int' then Integer ( item ) when 'double' , 'float' then Float ( item ) when 'boolean' then item . kind_of? ( String ) ? item . casecmp ( 'true' ) == 0 : item else item end end
856	def add_subject ( str , type = "12" ) subject = :: ONIX :: Subject . new subject . subject_scheme_id = type . to_i subject . subject_code = str product . subjects << subject end
614	def to_rtf ( indent = 0 ) prefix = indent > 0 ? ' ' * indent : '' text = StringIO . new text << "#{prefix}{\\fonttbl" @fonts . each_index do | index | text << "\n#{prefix}{\\f#{index}#{@fonts[index].to_rtf}}" end text << "\n#{prefix}}" text . string end
144	def set_custom_color idx , red , green , blue raise 'Invalid format' if [ red , green , blue ] . find { | c | ! ( 0 .. 255 ) . include? ( c ) } @palette [ idx ] = [ red , green , blue ] end
1294	def analyze ( string , options = { } ) x = [ ] @fst . _analyze ( string ) do | a | if options [ :symbol_sequence ] x << a . map { | s | s . match ( / / ) ? $1 . to_sym : s } else x << a . join end end x end
1342	def find_in_batches ( options = { } ) start = options [ :start ] || 0 marker = start batch_size = options [ :batch_size ] || 500 record_ids = redis . zrange ( index_key_for ( :id ) , marker , marker + batch_size - 1 ) while record_ids . length > 0 records_count = record_ids . length marker += records_count records = find ( record_ids ) yield records break if records_count < batch_size record_ids = redis . zrange ( index_key_for ( :id ) , marker , marker + batch_size - 1 ) end end
196	def get_user_availability ( email_address , start_time , end_time ) opts = { mailbox_data : [ :email => { :address => email_address } ] , free_busy_view_options : { time_window : { start_time : start_time , end_time : end_time } , } } resp = ( Viewpoint :: EWS :: EWS . instance ) . ews . get_user_availability ( opts ) if ( resp . status == 'Success' ) return resp . items else raise EwsError , "GetUserAvailability produced an error: #{resp.code}: #{resp.message}" end end
1104	def find ( public_id_or_alias , value , recursive = false ) pid = ControlledValue . standard_public_id ( public_id_or_alias ) value_cv_hash = @pid_value_cv_hash [ pid ] cv = value_cv_hash [ value ] if recursive then fetch_descendants ( cv , value_cv_hash ) end cv end
658	def created = ( setting ) if setting . instance_of? ( Time ) @created = setting else datetime = Date . _parse ( setting . to_s ) . values_at ( :year , :mon , :mday , :hour , :min , :sec , :zone , :wday ) if datetime == nil RTFError . fire ( "Invalid document creation date/time information " "specified." ) end @created = Time . local ( datetime [ 0 ] , datetime [ 1 ] , datetime [ 2 ] , datetime [ 3 ] , datetime [ 4 ] , datetime [ 5 ] ) end end
500	def custom_fields response = get "customfields" response . map { | item | Hashie :: Mash . new ( item ) } end
440	def display_flash_messages ( closable : true , key_matching : { } ) key_matching = DEFAULT_KEY_MATCHING . merge ( key_matching ) key_matching . default = :primary capture do flash . each do | key , value | next if ignored_key? ( key . to_sym ) alert_class = key_matching [ key . to_sym ] concat alert_box ( value , alert_class , closable ) end end end
59	def create_savon_client ( endpoint , namespace ) client = GoogleAdsSavon :: Client . new do | wsdl , httpi | wsdl . endpoint = endpoint wsdl . namespace = namespace AdsCommon :: Http . configure_httpi ( @config , httpi ) end client . config . raise_errors = false client . config . logger . subject = NoopLogger . new return client end
238	def reload ( client = nil ) return client . send ( Support . snakify ( self . class . name . split ( '::' ) . last ) , id ) unless client . nil? false end
1205	def range_type ( type , start_value , end_value , args , block ) filter_size_before = filter . size range ( start_value , end_value , args , block ) ( filter . size - filter_size_before ) . times { types << type } end
596	def get ( uri , query = nil , headers = { } ) request :get , uri , query : query , headers : headers end
326	def skip_me? ( s ) search = s . respond_to? ( :text ) ? s . text : s exclude . detect { | e | search . downcase . include? ( e ) } != nil end
530	def attachments regular_attachments = mail . attachments . reject ( & :inline? ) regular_attachments . collect do | attachment | { name : attachment . filename , type : attachment . mime_type , content : Base64 . encode64 ( attachment . body . decoded ) } end end
62	def handle_soap_request ( action , xml_only , args , extra_namespaces ) original_action_name = get_service_registry . get_method_signature ( action ) [ :original_name ] original_action_name = action if original_action_name . nil? request_info = nil response = @client . request ( original_action_name ) do | soap , wsdl , http | soap . body = args @header_handler . prepare_request ( http , soap ) soap . namespaces . merge! ( extra_namespaces ) unless extra_namespaces . nil? return soap . to_xml if xml_only request_info = RequestInfo . new ( soap . to_xml , http . headers , http . url ) end return request_info , response end
834	def validate_constraints ( value ) options . each do | option , arg | if validator_class = Respect . validator_for ( option ) validator_class . new ( arg ) . validate ( value ) end end end
793	def call ( env ) if @app . nil? || env [ PATH_INFO ] == @route_path statuses = [ ] t = Time . now statuses = Filter . run_filters ( @filters ) render ( statuses , Time . now - t ) else @app . call ( env ) end end
435	def menu_item ( name , locator ) define_method ( "#{name}" ) do adapter . menu_item ( locator ) . select end define_method ( "click_#{name}" ) do adapter . menu_item ( locator ) . click end end
814	def to_georss ( * args ) xml = Geos :: Helper . xml_options ( * args ) [ 0 ] xml . georss ( :where ) do xml . gml ( :Point ) do xml . gml ( :pos , "#{self.lat} #{self.lng}" ) end end end
827	def write_attribute ( key_name , new_value ) meta = ensure_metadata_exists ( key_name ) @source . delete ( meta . source_key ) @writethrough [ key_name ] = @cache [ key_name ] = new_value end
612	def save_all ( expressions = { } ) conditions ( expressions ) klass = Parse :: Model . find_class self . table if klass . blank? raise ArgumentError , "Parse model with class name #{self.table} is not registered." end hash_constraints = constraints ( true ) klass . save_all ( hash_constraints , & Proc . new ) if block_given? klass . save_all ( hash_constraints ) end
784	def list_users response = oauth_access_token . get ( "/v1/users" ) response . parsed . collect { | parsed_user | User . new ( parsed_user ) } end
835	def validate ( object ) sanitized_object = validate_type ( object ) validate_constraints ( sanitized_object ) unless sanitized_object . nil? && allow_nil? self . sanitized_object = sanitized_object true rescue ValidationError => e self . sanitized_object = nil raise e end
655	def to_rtf text = StringIO . new text << "{#{prefix}\\#{@character_set.id2name}" text << "\\deff#{@default_font}" text << "\\deflang#{@language}" if ! @language . nil? text << "\\plain\\fs24\\fet1" text << "\n#{@fonts.to_rtf}" text << "\n#{@colours.to_rtf}" if @colours . size > 0 text << "\n#{@information.to_rtf}" text << "\n#{@lists.to_rtf}" if @headers . compact != [ ] text << "\n#{@headers[3].to_rtf}" if ! @headers [ 3 ] . nil? text << "\n#{@headers[2].to_rtf}" if ! @headers [ 2 ] . nil? text << "\n#{@headers[1].to_rtf}" if ! @headers [ 1 ] . nil? if @headers [ 1 ] . nil? or @headers [ 2 ] . nil? text << "\n#{@headers[0].to_rtf}" end end if @footers . compact != [ ] text << "\n#{@footers[3].to_rtf}" if ! @footers [ 3 ] . nil? text << "\n#{@footers[2].to_rtf}" if ! @footers [ 2 ] . nil? text << "\n#{@footers[1].to_rtf}" if ! @footers [ 1 ] . nil? if @footers [ 1 ] . nil? or @footers [ 2 ] . nil? text << "\n#{@footers[0].to_rtf}" end end text << "\n#{@style.prefix(self)}" if ! @style . nil? self . each { | entry | text << "\n#{entry.to_rtf}" } text << "\n}" text . string end
4	def maybe_convert_extension ( ext ) unless ext =~ / \A \z / return ext end types = MIME :: Types . type_for ( ext ) if types . empty? ext else types . first . content_type end end
867	def collect_directories ( glob_pattern , file_pattern = '' ) Pathname . glob ( glob_pattern ) . select { | f | f . basename . to_s . include? ( file_pattern ) } . map ( & :dirname ) . uniq . map ( & :realpath ) end
118	def balance txns . inject ( Amount :: ZERO ) { | sum , t | sum + t . amount } end
1125	def update_status ( status = self . status ) assert_valid_values ( status , * %w( available unavailable away ) ) now = Time . now . to_i result = api ( 'presence.update' , :status => status ) client . reset_keepalive ( result [ 'interval' ] ) client . clock_delta = ( ( now + Time . now . to_i ) / 2 - result [ 'now' ] ) . round self . attributes = { 'status' => status } true end
1180	def add_to_sum_row ( value , column ) return unless @sum_row_patterns @sum_row_patterns . each do | pattern | if pattern =~ / \( \d / header_column = evaluate ( pattern , "" ) else header_column = pattern end if header_column == column @sum_row [ header_column ] ||= 0 @sum_row [ header_column ] += value end end end
117	def init ( id , pubkey , overwrite : false , network : 'test' ) raise "File '#{path}' already exists" if File . exist? ( path ) && ! overwrite raise "Invalid network name '#{network}'" unless network =~ / / FileUtils . mkdir_p ( File . dirname ( path ) ) IO . write ( path , "#{network}\n#{PROTOCOL}\n#{id}\n#{pubkey.to_pub}\n\n" ) @txns . flush @head . flush end
466	def to_param params = to_hash . merge ( 'callerKey' => AmazonFlexPay . access_key , 'signatureVersion' => 2 , 'signatureMethod' => 'HmacSHA256' ) params [ 'signature' ] = AmazonFlexPay . sign ( AmazonFlexPay . pipeline_endpoint , params ) AmazonFlexPay :: Util . query_string ( params ) end
840	def to_a [ required , short , long , desc , default , filter , action , cast , valid , validate ] . compact end
291	def set_no_auth FHIR . logger . info 'Configuring the client to use no authentication.' @use_oauth2_auth = false @use_basic_auth = false @security_headers = { } @client = RestClient @client . proxy = proxy unless proxy . nil? @client end
1338	def can? ( method , object , user = current_user ) policy = policy_for ( object ) policy . can? ( method , user ) end
1275	def observe_events ( client ) return unless enable_listener? queue = create_queue ( client ) client . subscribe ( queue ) do | message | event = Event . parse ( message ) handle_event ( event ) end end
765	def setup_form ( group , type , attr_definition ) attr_trans = single_attribute_translator . new ( source : @source , form : @form , group : group , type : type , attribute_definition : attr_definition ) attr_trans . add_associations_to_form end
375	def get_queue ( value ) ms = ( Time . now . to_f * 1000 ) . to_i - value . to_i ms < 0 ? 0 : ms end
1161	def execute ( command , params ) params [ :Bugzilla_login ] ||= username params [ :Bugzilla_password ] ||= password self . last_command = command_string ( command , params ) xmlrpc_client . call ( command , params ) end
607	def link_auth_data! ( service_name , ** data ) response = client . set_service_auth_data ( id , service_name , data ) raise Parse :: Client :: ResponseError , response if response . error? apply_attributes! ( response . result ) end
1190	def add ( name , options = { } , & coercer ) name = name . to_sym value = Attribute . new ( name , options , & coercer ) clone_with do @attributes = attributes . merge ( name => value ) @transformer = nil end end
813	def to_bbox ( long_or_short_names = :long ) case long_or_short_names when :long { :north => self . north , :east => self . east , :south => self . south , :west => self . west } when :short { :n => self . north , :e => self . east , :s => self . south , :w => self . west } else raise ArgumentError . new ( "Expected either :long or :short for long_or_short_names argument" ) end end
652	def footer = ( footer ) if footer . type == FooterNode :: UNIVERSAL @footers [ 0 ] = footer elsif footer . type == FooterNode :: LEFT_PAGE @footers [ 1 ] = footer elsif footer . type == FooterNode :: RIGHT_PAGE @footers [ 2 ] = footer elsif footer . type == FooterNode :: FIRST_PAGE @footers [ 3 ] = footer end end
1209	def number ( col , comparator , number , args , block ) comparator = '==' if comparator == '=' operation = "[value] #{comparator} #{number}" pivot [ "#{comparator}#{number}" ] = { col : col , operation : operation } end
1136	def execute allocation = { } File . open ( infile ) . each_with_index do | line , index | row = row_filter . process ( line , row : index ) next if row . nil? or row . empty? key = key_filter . process ( row ) allocation [ key ] = [ ] if allocation [ key ] . nil? allocation [ key ] << col_filter . process ( row ) . split ( ';' ) end File . open ( outfile , 'w' ) do | out | allocation . each do | key , values | out . puts "#{key};#{values.flatten.uniq.sort.join(';')}" end end end
1394	def site = ( site ) if site != self . site @site = site uri = URI . parse ( site ) @user = URI . decode ( uri . user ) if ( uri . user ) @password = URI . decode ( uri . password ) if ( uri . password ) @resource_class = self . send ( :create_resource_class ) end @site end
469	def verify_request ( request ) verify_signature ( request . protocol + request . host_with_port + request . path , request . get? ? request . query_string : request . raw_post ) end
526	def flush ( async = true ) loop do @lock . synchronize do @queue . synchronize do @results_unprocessed += 1 end @queue << @buffer @buffer = [ ] end if not async LOGGER . info ( 'Starting synchronous flush' ) @queue . synchronize do @all_processed_condition . wait_while { @results_unprocessed > 0 } LOGGER . info ( 'Finished synchronous flush' ) end end break if @buffer . size < 1 end end
769	def dirs_for ( name , opts = { } ) if _load_paths [ name ] . blank? [ ] else result = [ ] invert = ! ! opts [ :invert ] load_paths = invert ? _load_paths [ name ] . reverse : _load_paths [ name ] roots . each do | root | load_paths . each do | paths , glob | paths = paths . reverse if invert result << paths . map { | p | File . join ( root , p ) } end end result . flatten end end
1343	def load_keymap ( map ) @maps ||= Hash . new if @maps [ map ] . nil? && File . file? ( File . join ( self . storage_path , map . to_s + "_map.yml" ) ) @maps [ map ] = YAML . load ( File . open ( File . join ( self . storage_path , map . to_s + "_map.yml" ) ) ) logger . debug ( "#{self.class.to_s} lazy loaded #{map} successfully." ) end end
312	def tweet ( txt , params = { } , original = nil ) return if require_login == false txt = replace_variables ( txt , original ) if debug_mode? debug "I'm in debug mode, otherwise I would tweet: #{txt}" else debug txt if params . has_key? ( :media ) file = params . delete ( :media ) if ! file . is_a? ( File ) file = File . new ( file ) end client . update_with_media txt , file , params else client . update txt , params end end rescue Twitter :: Error :: Forbidden => e debug e false end
1222	def add_defaults_local super self . title ||= short_title self . short_title ||= title self . start_date ||= Java :: JavaUtil :: Date . new end
555	def connection params = { } params [ :client_id ] = @client_id if @client_id params [ :client_secret ] = @client_secret if @client_secret params [ :oauth_token ] = @oauth_token if @oauth_token params [ :v ] = @api_version if @api_version params [ :locale ] = @locale if @locale @connection ||= Faraday :: Connection . new ( :url => api_url , :ssl => @ssl , :params => params , :headers => default_headers ) do | builder | @connection_middleware . each do | middleware | builder . use * middleware end builder . adapter Faraday . default_adapter end end
805	def write_data_chunksize p = FFI :: MemoryPointer . new ( :uint , 1 ) check_result ( Ftdi . ftdi_write_data_get_chunksize ( ctx , p ) ) p . read_uint end
404	def process_request ( request ) request [ 'User-Agent' ] = @user_agent request [ 'Content-Type' ] = 'application/json' request [ 'X-BitPay-Plugin-Info' ] = 'Rubylib' + VERSION begin response = @https . request request rescue => error raise BitPay :: ConnectionError , "#{error.message}" end if response . kind_of? Net :: HTTPSuccess return JSON . parse ( response . body ) elsif JSON . parse ( response . body ) [ "error" ] raise ( BitPayError , "#{response.code}: #{JSON.parse(response.body)['error']}" ) else raise BitPayError , "#{response.code}: #{JSON.parse(response.body)}" end end
205	def sync_items! ( sync_state = nil , sync_amount = 256 , sync_all = false , opts = { } ) item_shape = opts . has_key? ( :item_shape ) ? opts . delete ( :item_shape ) : { :base_shape => :default } sync_state ||= @sync_state resp = ews . sync_folder_items item_shape : item_shape , sync_folder_id : self . folder_id , max_changes_returned : sync_amount , sync_state : sync_state rmsg = resp . response_messages [ 0 ] if rmsg . success? @synced = rmsg . includes_last_item_in_range? @sync_state = rmsg . sync_state rhash = { } rmsg . changes . each do | c | ctype = c . keys . first rhash [ ctype ] = [ ] unless rhash . has_key? ( ctype ) if ctype == :delete || ctype == :read_flag_change rhash [ ctype ] << c [ ctype ] [ :elems ] [ 0 ] [ :item_id ] [ :attribs ] else type = c [ ctype ] [ :elems ] [ 0 ] . keys . first item = class_by_name ( type ) . new ( ews , c [ ctype ] [ :elems ] [ 0 ] [ type ] ) rhash [ ctype ] << item end end rhash else raise EwsError , "Could not synchronize: #{rmsg.code}: #{rmsg.message_text}" end end
50	def evaluate ( instance , & block ) original_self = eval "self" , block . binding proxy = Object . new proxy . instance_eval do class << self attr_accessor :original_self , :instance end def method_missing ( method , * args , & block ) instance . send ( method , * args , & block ) rescue NoMethodError original_self . send ( method , * args , & block ) end end proxy . instance = instance proxy . original_self = original_self proxy . instance_eval & block end
1143	def publish ( params ) params [ :msgid ] = message_id = next_message_id params = @default_params . merge ( params ) logger . debug "Message sent: #{params.inspect}" if HTTP_APIS . include? ( params [ :api ] ) publish_to_http ( params ) else publish_to_socket ( params ) end EventMachine . add_timer ( @timeout ) do dispatch ( 'msgid' => message_id , 'command' => 'response_received' , 'error' => 'timed out' ) end if @timeout message_id end
103	def authorize ( parameters = { } , & block ) parameters . each_pair do | key , value | @credential_handler . set_credential ( key , value ) end auth_handler = get_auth_handler ( ) token = auth_handler . get_token ( ) if token . nil? begin credentials = @credential_handler . credentials token = auth_handler . get_token ( credentials ) rescue AdsCommon :: Errors :: OAuth2VerificationRequired => e verification_code = ( block_given? ) ? yield ( e . oauth_url ) : nil if verification_code @credential_handler . set_credential ( :oauth2_verification_code , verification_code ) retry else raise e end end end return token end
786	def bookmark ( * args ) if args [ 0 ] . is_a? Array Drop . create ( :bookmarks , args ) else url , name = args [ 0 ] , ( args [ 1 ] || "" ) Drop . create ( :bookmark , { :name => name , :redirect_url => url } ) end end
1075	def vote ( direction = :up ) assert_current_song api ( 'room.vote' , :roomid => room . id , :section => room . section , :val => direction , :songid => id , :vh => digest ( "#{room.id}#{direction}#{id}" ) , :th => digest ( rand ) , :ph => digest ( rand ) ) true end
963	def error_messages_for ( field ) key = field . to_sym error_messages . select { | message | message . has_key? ( key ) } . map { | message | message [ key ] } end
293	def set_bearer_token ( token ) FHIR . logger . info 'Configuring the client to use Bearer Token authentication.' value = "Bearer #{token}" @security_headers = { 'Authorization' => value } @use_oauth2_auth = false @use_basic_auth = true @client = RestClient @client . proxy = proxy unless proxy . nil? @client end
832	def currencies ( table_rows ) table_rows . lazy . map do | e | e . css ( 'img' ) . map { | img | img . attribute ( 'src' ) . value } end . force . flatten end
533	def guess_min_peek_range ( tubes ) min = 0 tubes . each do | tube | response = tube . peek ( 'ready' ) if response if min == 0 min = response . id . to_i else min = [ min , response . id . to_i ] . min end end end jitter_min = ( min - ( GUESS_PEEK_RANGE * 0.25 ) ) . to_i [ 1 , jitter_min ] . max end
405	def refresh_tokens response = get ( path : 'tokens' ) [ "data" ] token_array = response || { } tokens = { } token_array . each do | t | tokens [ t . keys . first ] = t . values . first end @tokens = tokens return tokens end
89	def generate_user_agent ( extra_ids = [ ] , agent_app = nil ) agent_app ||= File . basename ( $0 ) agent_data = extra_ids agent_data << 'Common-Ruby/%s' % AdsCommon :: ApiConfig :: CLIENT_LIB_VERSION agent_data << 'GoogleAdsSavon/%s' % GoogleAdsSavon :: VERSION ruby_engine = defined? ( RUBY_ENGINE ) ? RUBY_ENGINE : 'ruby' agent_data << [ ruby_engine , RUBY_VERSION ] . join ( '/' ) agent_data << 'HTTPI/%s' % HTTPI :: VERSION agent_data << HTTPI :: Adapter . use . to_s agent_data += get_extra_user_agents ( ) return '%s (%s)' % [ agent_app , agent_data . join ( ', ' ) ] end
1358	def sleep ( timeout = nil ) validate_timeout ( timeout ) unlock do if timeout == nil || timeout == Float :: INFINITY elapsed_time = ( timer { Thread . stop } ) . round else elapsed_time = Kernel . sleep ( timeout ) end end end
347	def detect_cycle ( edge , acyclic_edges , escalation = nil ) starting_node = edge . second edges = [ edge ] + acyclic_edges traverse_dependecies ( [ ] , starting_node , starting_node , edges , node_edges ( edges , starting_node ) , escalation ) end
730	def add_to_query ( ** terms ) if is_a? Rescuetime :: Collection self << terms self else Rescuetime :: Collection . new ( BASE_PARAMS , state , terms ) end end
667	def get_device_by_path ( path , options = { } ) if File . exist? ( path ) hidapi_regex = / \/ \/ \/ / usb_bus_regex = / \/ \/ \/ \/ \d \/ \d / if hidapi_regex . match ( path ) path = File . expand_path ( File . readlink ( path ) , File . dirname ( path ) ) elsif ! usb_bus_regex . match ( path ) raise HIDAPI :: DevicePathInvalid , 'Cannot open file paths other than /dev/hidapi/XXX or /dev/bus/usb/XXX/XXX paths.' end match = usb_bus_regex . match ( path ) raise HIDAPI :: DevicePathInvalid , "Link target does not appear valid (#{path})." unless match interface = ( options . delete ( :interface ) || 0 ) . to_s ( 16 ) path = HIDAPI :: Device . validate_path ( "#{match['BUS']}:#{match['ADDR']}:#{interface}" ) end valid_path = HIDAPI :: Device . validate_path ( path ) raise HIDAPI :: DevicePathInvalid , "Path should be in BUS:ADDRESS:INTERFACE format with each value being in hexadecimal (ie - 0001:01A:00), not #{path}." unless valid_path path = valid_path klass = ( options || { } ) . delete ( :as ) || 'HIDAPI::Device' klass = Object . const_get ( klass ) unless klass == :no_mapping enumerate ( as : :no_mapping ) . each do | usb_dev | usb_dev . settings . each do | intf_desc | if intf_desc . bInterfaceClass == HID_CLASS dev_path = HIDAPI :: Device . make_path ( usb_dev , intf_desc . bInterfaceNumber ) if dev_path == path if klass != :no_mapping return klass . new ( usb_dev , intf_desc . bInterfaceNumber ) else return usb_dev end end end end end end
1116	def once ( key , store : "/var/cache/blower.json" , quiet : false ) return yield unless key log . info "once: #{key}" , quiet : quiet do hash_map ( hosts ) do | host | done = begin JSON . parse ( host . read ( store , quiet : true ) ) rescue => e { } end unless done [ key ] on [ host ] do yield end done [ key ] = true host . write ( done . to_json , store , quiet : true ) end end end end
1093	def get_content ( & func ) data = Array . new @feed . to_a . each do | single_post | begin if func . nil? data << clean_post_content ( single_post , & @message_parser ) else data << clean_post_content ( single_post , & func ) end rescue end end data end
1272	def get_server_id ( server_id ) return nil unless server_id =~ / / ret = nr_api . get ( url ( 'servers' , server_id ) ) . body ret [ 'server' ] rescue Faraday :: ResourceNotFound , NoMethodError nil end
285	def post ( options = { } , & block ) response = http . post_uri ( options . merge ( :body => serialize ) , & block ) handle_response ( response ) end
989	def activate ( network ) request = Net :: HTTP :: Post . new ( URI . join ( @base_uri . to_s , "/cloudlets/api/v2/policies/#{@policy_id}/versions/#{@version_id}/activations" ) . to_s , { 'Content-Type' => 'application/json' } ) request . body = { "network" : network } . to_json response = @http_host . request ( request ) response . body end
1031	def tolerant_match? ( other , attributes ) attributes . all? { | pa | Resource . tolerant_value_match? ( send ( pa ) , other . send ( pa ) ) } end
407	def sns? json_body . is_a? ( Hash ) && ( %w[ Message Type TopicArn MessageId ] - json_body . keys ) . empty? end
951	def encodeWithCoder ( coder ) columns . each do | attr | unless [ :belongs_to , :has_many , :has_one ] . include? column ( attr ) . type value = self . send ( attr ) unless value . nil? coder . encodeObject ( value , forKey : attr . to_s ) end end end end
26	def validate_array_arg ( arg , parent , key , arg_type ) result = arg . map do | item | validate_arg ( item , parent , key , arg_type ) end return result end
82	def check_for_xml_error ( report_body , response_code ) unless report_body . nil? error_response = get_nori ( ) . parse ( report_body ) if error_response . include? ( :report_download_error ) and error_response [ :report_download_error ] . include? ( :api_error ) api_error = error_response [ :report_download_error ] [ :api_error ] raise AdwordsApi :: Errors :: ReportXmlError . new ( response_code , api_error [ :type ] , api_error [ :trigger ] , api_error [ :field_path ] ) end end end
1220	def col_positions ( pos , cols ) if pos . nil? || pos . empty? pos = [ ] cols . each { | c | pos << Array . new ( c . size ) { | c | c } } pos else pos . split ( ';' ) . collect { | p | p . split ( ',' ) . collect { | p | p . to_i } } end end
939	def set_default_left_and_right maxright = nested_set_scope . remove_order_by . max ( right_field_name ) || 0 self [ left_field_name ] = maxright + 1 self [ right_field_name ] = maxright + 2 self [ :depth ] = 0 end
153	def save ( options = { } , & block ) save! ( options , & block ) rescue ZendeskAPI :: Error :: RecordInvalid => e @errors = e . errors false rescue ZendeskAPI :: Error :: ClientError false end
490	def update ( new_email_address , name , custom_fields , resubscribe , consent_to_track , restart_subscription_based_autoresponders = false ) options = { :query => { :email => @email_address } , :body => { :EmailAddress => new_email_address , :Name => name , :CustomFields => custom_fields , :Resubscribe => resubscribe , :RestartSubscriptionBasedAutoresponders => restart_subscription_based_autoresponders , :ConsentToTrack => consent_to_track } . to_json } put "/subscribers/#{@list_id}.json" , options @email_address = new_email_address end
1060	def available? client . user . points >= minimum_points && ( ! acl || client . user . acl >= acl ) end
736	def get_document ( url ) URI === url ? Nokogiri :: HTML :: Document . parse ( open ( url ) , url . to_s , 'UTF-8' ) : url rescue OpenURI :: HTTPError $stderr . puts "ERROR opening #{url}" Nokogiri ( '' ) end
1347	def valid? ( options = { } ) options = { :input => { } } . merge ( options ) errors = [ ] sandbox = _source ( options ) sandbox [ :inputs ] = options [ :input ] validity = @filters . map do | filter_name , filter | sandbox [ :input ] = options [ :input ] [ filter [ :key ] ] if options [ :input ] . is_a? ( Hash ) filter_validity = filter [ :valid ] . nil? || sandbox . instance_eval ( & filter [ :valid ] ) if filter_validity == false if ! sandbox [ :input ] . to_s . blank? errors << "#{filter_name} is invalid." false else if sandbox [ :input ] . to_s . blank? && ! filter [ :require ] . blank? errors << "#{filter_name} is required." false else true end end elsif filter_validity == true if sandbox [ :input ] . to_s . blank? && ! filter [ :require ] . blank? errors << "#{filter_name} is required." false else true end elsif ! filter_validity . nil? && ! filter_validity [ :status ] . nil? && filter_validity [ :status ] == false if ! sandbox [ :input ] . to_s . blank? || filter_validity [ :force_error ] == true errors << filter_validity [ :errors ] false else if sandbox [ :input ] . to_s . blank? && ! filter [ :require ] . blank? errors << "#{filter_name} is required." false else true end end end end return { :status => ! validity . include? ( false ) , :errors => errors } end
194	def sync_folder_hierarchy ( opts ) opts = opts . clone req = build_soap! do | type , builder | if ( type == :header ) else builder . nbuild . SyncFolderHierarchy { builder . nbuild . parent . default_namespace = @default_ns builder . folder_shape! ( opts [ :folder_shape ] ) builder . sync_folder_id! ( opts [ :sync_folder_id ] ) if opts [ :sync_folder_id ] builder . sync_state! ( opts [ :sync_state ] ) if opts [ :sync_state ] } end end do_soap_request ( req , response_class : EwsResponse ) end
240	def each_page page = first_page yield page if block_given? until completed? page = page . next_page yield page if block_given? end end
357	def dependency_attributes_for ( inventory_collections ) attributes = Set . new inventory_collections . each do | inventory_collection | attributes += filtered_dependency_attributes . select { | _key , value | value . include? ( inventory_collection ) } . keys end attributes end
378	def captcha ( captcha_id ) response = request ( 'res' , :get , action : 'get' , id : captcha_id ) decoded_captcha = TwoCaptcha :: Captcha . new ( id : captcha_id ) decoded_captcha . api_response = response if response . match ( / \A \| / ) decoded_captcha . text = response . split ( '|' , 2 ) [ 1 ] end decoded_captcha end
1171	def update_changed_dependent ( owner , property , dependent , autogenerated ) if CollectibleEventParameters === dependent then logger . debug { "Work around a caTissue bug by resaving the collected #{owner} #{dependent} directly rather than via a cascade..." } update_from_template ( dependent ) elsif CaTissue :: User === owner and property . attribute == :address then update_user_address ( owner , dependent ) elsif CaTissue :: Specimen === owner and CaTissue :: Specimen === dependent then logger . debug { "Work around caTissue bug to update #{dependent} separately after the parent #{owner} update..." } prepare_specimen_for_update ( dependent ) update_from_template ( dependent ) logger . debug { "Updated the #{owner} child #{dependent}." } elsif CaTissue :: ConsentTierStatus === dependent then update_from_template ( owner ) else super end end
191	def dispatch_field_uri! ( uri , ns = NS_EWS_MESSAGES ) type = uri . keys . first vals = uri [ type ] . is_a? ( Array ) ? uri [ type ] : [ uri [ type ] ] case type when :field_uRI , :field_uri vals . each do | val | value = val . is_a? ( Hash ) ? val [ type ] : val nbuild [ ns ] . FieldURI ( 'FieldURI' => value ) end when :indexed_field_uRI , :indexed_field_uri vals . each do | val | nbuild [ ns ] . IndexedFieldURI ( 'FieldURI' => ( val [ :field_uRI ] || val [ :field_uri ] ) , 'FieldIndex' => val [ :field_index ] ) end when :extended_field_uRI , :extended_field_uri vals . each do | val | nbuild [ ns ] . ExtendedFieldURI { nbuild . parent [ 'DistinguishedPropertySetId' ] = val [ :distinguished_property_set_id ] if val [ :distinguished_property_set_id ] nbuild . parent [ 'PropertySetId' ] = val [ :property_set_id ] if val [ :property_set_id ] nbuild . parent [ 'PropertyTag' ] = val [ :property_tag ] if val [ :property_tag ] nbuild . parent [ 'PropertyName' ] = val [ :property_name ] if val [ :property_name ] nbuild . parent [ 'PropertyId' ] = val [ :property_id ] if val [ :property_id ] nbuild . parent [ 'PropertyType' ] = val [ :property_type ] if val [ :property_type ] } end else raise EwsBadArgumentError , "Bad URI type. #{type}" end end
1286	def extract_subjects ( subject ) return extract_subjects ( subject . to_permission_instance ) if subject . respond_to? :to_permission_instance return subject [ :any ] if subject . is_a? Hash and subject . key? :any [ subject ] end
392	def reconnect! ( new_uri = nil ) @connection . close_connection configure ( new_uri ) if new_uri @auto_reconnect = true EM . next_tick { reconnect_connection } end
1399	def fix_ownership return if Process . uid != 0 begin uid = Etc . getpwnam ( "bixby" ) . uid gid = Etc . getgrnam ( "bixby" ) . gid File . chown ( uid , gid , Bixby . path ( "var" ) , Bixby . path ( "etc" ) ) rescue ArgumentError end end
888	def use_dependency_graph? ( objects ) objects . each do | id , object | object . foreign_objects . each do | property | if object [ property ] . present? return false end end end true end
1381	def search ( options = { } ) self . date = options [ :date ] || date self . hd = options [ :hd ] || hd response = HTTParty . get ( DEFAULT_URL , query : attributes ) handle_response ( response ) end
1231	def process ( operator , s ) s = coerce ( s ) || s raise "operand needs to be a SpreadSheet, " + "Numeric or Array" unless s . is_a? ( SpreadSheet ) result = [ ] rlabel = [ ] clabel = [ ] s1_row_count , s1_col_count = dim s2_row_count , s2_col_count = s . dim row_count = [ s1_row_count , s2_row_count ] . max col_count = [ s1_col_count , s2_col_count ] . max 0 . upto ( row_count - 1 ) do | r | r1 = r % s1_row_count r2 = r % s2_row_count rlabel << "#{row_labels[r1]}#{operator}#{s.row_labels[r2]}" element = [ ] 0 . upto ( col_count - 1 ) do | c | c1 = c % s1_col_count c2 = c % s2_col_count clabel << "#{col_labels[c1]}#{operator}#{s.col_labels[c2]}" element << rows [ r1 ] [ c1 ] . send ( operator , s . rows [ r2 ] [ c2 ] ) end result << element end SpreadSheet . new ( * result , row_labels : rlabel , col_labels : clabel ) end
17	def batch_job_utils ( version = nil ) version = api_config . default_version if version . nil? if ! api_config . versions . include? ( version ) raise AdsCommon :: Errors :: Error , "Unknown version '%s'" % version end return AdwordsApi :: BatchJobUtils . new ( self , version ) end
574	def mark_venue_todo ( venue_id , options = { } ) response = connection . post do | req | req . url "venues/#{venue_id}/marktodo" , options end return_error_or_body ( response , response . body . response ) end
1096	def append_and_write contents = append_and_render File . open ( destination , 'w+' , encoding : 'utf-8' ) do | f | f . write ( contents ) end end
1366	def echo_uploads_data = ( data ) parsed = JSON . parse Base64 . decode64 ( data ) unless parsed . is_a? Hash raise ArgumentError , "Invalid JSON structure in: #{parsed.inspect}" end parsed . each do | attr , attr_data | unless attr_data . is_a? Array raise ArgumentError , "Invalid JSON structure in: #{parsed.inspect}" end attr_data . each do | variant_data | unless variant_data . is_a? Hash raise ArgumentError , "Invalid JSON structure in: #{parsed.inspect}" end if meta = :: EchoUploads :: File . where ( id : variant_data [ 'id' ] , key : variant_data [ 'key' ] , temporary : true ) . first if send ( "#{attr}_tmp_metadata" ) . nil? send "#{attr}_tmp_metadata=" , [ ] end send ( "#{attr}_tmp_metadata" ) << meta end end end end
219	def get_user_availability ( opts ) opts = opts . clone req = build_soap! do | type , builder | if ( type == :header ) else builder . nbuild . GetUserAvailabilityRequest { | x | x . parent . default_namespace = @default_ns builder . time_zone! ( opts [ :time_zone ] ) builder . nbuild . MailboxDataArray { opts [ :mailbox_data ] . each do | mbd | builder . mailbox_data! ( mbd ) end } builder . free_busy_view_options! ( opts [ :free_busy_view_options ] ) builder . suggestions_view_options! ( opts [ :suggestions_view_options ] ) } end end do_soap_request ( req , response_class : EwsSoapFreeBusyResponse ) end
259	def content_charset content_types . each do | value | if value . include? ( ';' ) value . split ( ';' ) . each do | param | param . strip! if param . start_with? ( 'charset=' ) return param . split ( '=' , 2 ) . last end end end end return nil end
1073	def sticker_placements = ( user_placements ) user_placements . each do | user_id , placements | listener ( user_id ) . attributes = { 'placements' => placements } end end
108	def create_default_logger ( ) logger = Logger . new ( STDOUT ) logger . level = get_log_level_for_string ( @config . read ( 'library.log_level' , 'INFO' ) ) return logger end
239	def field_for ( field_id ) fields . detect { | f | Support . snakify ( f . id ) == Support . snakify ( field_id ) } end
193	def update_item! ( updates , options = { } ) item_updates = [ ] updates . each do | attribute , value | item_field = FIELD_URIS [ attribute ] [ :text ] if FIELD_URIS . include? attribute field = { field_uRI : { field_uRI : item_field } } if value . nil? && item_field item_updates << { delete_item_field : field } elsif item_field item = Viewpoint :: EWS :: Template :: CalendarItem . new ( attribute => value ) item_attributes = item . to_ews_item . map do | name , value | if value . is_a? String { name => { text : value } } elsif value . is_a? Hash node = { name => { } } value . each do | attrib_key , attrib_value | attrib_key = camel_case ( attrib_key ) unless attrib_key == :text node [ name ] [ attrib_key ] = attrib_value end node else { name => value } end end item_updates << { set_item_field : field . merge ( calendar_item : { sub_elements : item_attributes } ) } else end end if item_updates . any? data = { } data [ :conflict_resolution ] = options [ :conflict_resolution ] || 'AutoResolve' data [ :send_meeting_invitations_or_cancellations ] = options [ :send_meeting_invitations_or_cancellations ] || 'SendToNone' data [ :item_changes ] = [ { item_id : self . item_id , updates : item_updates } ] rm = ews . update_item ( data ) . response_messages . first if rm && rm . success? self . get_all_properties! self else raise EwsCreateItemError , "Could not update calendar item. #{rm.code}: #{rm.message_text}" unless rm end end end
957	def lt ( query_string , options = { :case_sensitive => false } ) do_comparison ( query_string , options ) do | comparator , item | comparator > item end end
925	def create_new_tables ( new_table_names , tables ) each_table ( new_table_names , tables ) do | table_name , table , last_table | create_table_statement table_name , table add_blank_line unless last_table end end
670	def open if open? self . open_count += 1 if open_count < 1 HIDAPI . debug "open_count for open device #{path} is #{open_count}" self . open_count = 1 end return self end self . open_count = 0 begin self . handle = usb_device . open raise 'no handle returned' unless handle begin if handle . kernel_driver_active? ( interface ) handle . detach_kernel_driver ( interface ) end rescue LIBUSB :: ERROR_NOT_SUPPORTED HIDAPI . debug 'cannot determine kernel driver status, continuing to open device' end handle . claim_interface ( interface ) self . input_endpoint = self . output_endpoint = nil usb_device . settings . keep_if { | item | item . bInterfaceNumber == interface } . each do | intf_desc | intf_desc . endpoints . each do | ep | if ep . transfer_type == :interrupt if input_endpoint . nil? && ep . direction == :in self . input_endpoint = ep . bEndpointAddress self . input_ep_max_packet_size = ep . wMaxPacketSize end if output_endpoint . nil? && ep . direction == :out self . output_endpoint = ep . bEndpointAddress end end break if input_endpoint && output_endpoint end end raise 'failed to locate input endpoint' unless input_endpoint self . input_reports = [ ] self . thread_initialized = false self . shutdown_thread = false self . thread = Thread . start ( self ) { | dev | dev . send ( :execute_read_thread ) } sleep 0.001 until thread_initialized rescue => e handle . close rescue nil self . handle = nil HIDAPI . debug "failed to open device #{path}: #{e.inspect}" raise DeviceOpenFailed , e . inspect end HIDAPI . debug "opened device #{path}" self . open_count = 1 self end
338	def extract ( destination , options = { } ) raise IOError , 'non-readable archive' unless readable? raise IOError , 'closed archive' if closed? options [ :directories ] = true unless options . has_key? ( :directories ) options [ :symlinks ] = false unless options . has_key? ( :symlinks ) options [ :overwrite ] = :all unless options [ :overwrite ] == :older || options [ :overwrite ] == :never options [ :create ] = true unless options . has_key? ( :create ) options [ :flatten ] = false unless options . has_key? ( :flatten ) options [ :directories ] = false if options [ :flatten ] directories = [ ] each do | entry | file_path = entry . zip_path file_path = File . basename ( file_path ) if options [ :flatten ] file_path = File . join ( destination , file_path ) file_exists = File . exist? ( file_path ) file_mtime = File . mtime ( file_path ) if file_exists begin if ( ! file_exists && ! options [ :create ] ) || ( file_exists && ( options [ :overwrite ] == :never || options [ :overwrite ] == :older && entry . mtime <= file_mtime ) ) || ( ! options [ :exclude ] . nil? && options [ :exclude ] [ entry ] ) then next end if options [ :password ] . kind_of? ( String ) then entry . password = options [ :password ] elsif ! options [ :password ] . nil? then entry . password = options [ :password ] [ entry ] end if entry . directory? then directories << entry elsif entry . file? || ( entry . symlink? && options [ :symlinks ] ) then entry . extract ( options . merge ( :file_path => file_path ) ) end rescue StandardError => error unless options [ :on_error ] . nil? then case options [ :on_error ] [ entry , error ] when :retry retry when :skip else raise end else raise end end end if options [ :directories ] then directories . sort { | a , b | b . zip_path <=> a . zip_path } . each do | entry | begin entry . extract ( options . merge ( :file_path => File . join ( destination , entry . zip_path ) ) ) rescue StandardError => error unless options [ :on_error ] . nil? then case options [ :on_error ] [ entry , error ] when :retry retry when :skip else raise end else raise end end end end nil end
311	def search ( queries , opts = { } , & block ) debug "check for tweets since #{since_id}" max_tweets = opts . delete ( :limit ) || MAX_SEARCH_TWEETS exact_match = if opts . key? ( :exact ) opts . delete ( :exact ) else true end if queries . is_a? ( String ) queries = [ queries ] end query = queries . map { | q | if exact_match == true q = wrap_search_query ( q ) end q } . join ( " OR " ) debug "search: #{query} #{default_opts.merge(opts)}" @current_tweet = nil client . search ( query , default_opts . merge ( opts ) ) . take ( max_tweets ) . each { | s | update_since_id ( s ) debug s . text if block_given? && valid_tweet? ( s ) @current_tweet = s yield s end } @current_tweet = nil end
702	def set_vm_ram ( vmid , memory_size ) params = { 'method' => :get , 'command' => "/vApp/vm-#{vmid}/virtualHardwareSection/memory" } get_response , headers = send_request ( params ) get_response . css ( "rasd|ElementName" ) . first . content = "#{memory_size} MB of memory" get_response . css ( "rasd|VirtualQuantity" ) . first . content = memory_size params [ 'method' ] = :put put_response , headers = send_request ( params , get_response . to_xml , "application/vnd.vmware.vcloud.rasdItem+xml" ) task_id = headers [ :location ] . gsub ( / \/ \/ / , "" ) task_id end
1025	def on_session_missing user . authenticate user . fan_of user . update ( :status => user . status ) reset_keepalive end
624	def footnote ( text ) if ! text . nil? and text != '' mark = CommandNode . new ( self , '\fs16\up6\chftn' , nil , false ) note = CommandNode . new ( self , '\footnote {\fs16\up6\chftn}' , nil , false ) note . paragraph << text self . store ( mark ) self . store ( note ) end end
203	def items_between ( start_date , end_date , opts = { } ) items do | obj | obj . restriction = { :and => [ { :is_greater_than_or_equal_to => [ { :field_uRI => { :field_uRI => 'item:DateTimeReceived' } } , { :field_uRI_or_constant => { :constant => { :value => start_date } } } ] } , { :is_less_than_or_equal_to => [ { :field_uRI => { :field_uRI => 'item:DateTimeReceived' } } , { :field_uRI_or_constant => { :constant => { :value => end_date } } } ] } ] } end end
1341	def find ( ids , opts = { } ) ids . is_a? ( Array ) ? find_by_ids ( ids , opts ) : find_by_id ( ids , opts ) end
797	def call ( status ) begin ping ( @host , @port ) status . ok ( "#{@alias} is accepting connections on port #{@port.inspect}" ) rescue Errno :: ECONNREFUSED status . fail ( "#{@alias} is not accepting connections on port #{@port.inspect}" ) rescue SocketError => e status . fail ( "connection to #{@alias} on port #{@port.inspect} failed with '#{e.message}'" ) rescue Timeout :: Error status . fail ( "#{@alias} did not respond on port #{@port.inspect} within #{@timeout} seconds" ) end end
266	def run ( & block ) @running = true until ( @queue . empty? || paused? || limit_reached? ) begin visit_page ( dequeue , & block ) rescue Actions :: Paused return self rescue Actions :: Action end end @running = false @sessions . clear return self end
999	def calc_pointsize ( width , height , text , min_pointsize ) current_pointsize = min_pointsize metrics = nil loop { self . pointsize = current_pointsize last_metrics = metrics metrics = get_multiline_type_metrics ( text ) if metrics . width + stroke_padding > width or metrics . height + stroke_padding > height if current_pointsize > min_pointsize current_pointsize -= 1 metrics = last_metrics end break else current_pointsize += 1 end } [ current_pointsize , metrics ] end
532	def get_chart_data_hash ( tubes ) chart_data = { } chart_data [ "total_jobs_data" ] = Hash . new chart_data [ "buried_jobs_data" ] = Hash . new chart_data [ "total_jobs_data" ] [ "items" ] = Array . new chart_data [ "buried_jobs_data" ] [ "items" ] = Array . new tubes . each do | tube | stats = tube . stats add_chart_data_to_hash ( tube , stats [ :total_jobs ] , chart_data [ "total_jobs_data" ] [ "items" ] ) add_chart_data_to_hash ( tube , stats [ :current_jobs_buried ] , chart_data [ "buried_jobs_data" ] [ "items" ] ) end chart_data end
1089	def dom_classes if positive? t 'comparison.dom_classes.positive' , default : %i[ comparison.classes.positive ] elsif negative? t 'comparison.dom_classes.negative' , default : %i[ comparison.classes.negative ] else t 'comparison.dom_classes.nochange' , default : %i[ comparison.classes.nochange ] end end
580	def add_photo ( options = { } ) response = connection . post ( 'photos/add' , options ) return_error_or_body ( response , response . body . response . photo ) end
109	def load_config ( provided_config = nil ) @config = ( provided_config . nil? ) ? AdsCommon :: Config . new ( File . join ( ENV [ 'HOME' ] , api_config . default_config_filename ) ) : AdsCommon :: Config . new ( provided_config ) init_config ( ) end
488	def validate_token ( access_token ) validator = Fridge . configuration . validator validator . call ( access_token ) && access_token rescue false end
876	def check_coords ( x , y ) if 0 <= x && x < 8 && 0 <= y && y < 8 true else fail ArgumentError , "coord (#{x},#{y}) outside of permitted range ((0..7), (0..7))" end end
165	def track_args ( args ) case args when Hash timestamp , identity , values = args . values_at ( :timestamp , :identity , :values ) when Array values = args when Numeric values = [ args ] end identity ||= Vanity . context . vanity_identity rescue nil [ timestamp || Time . now , identity , values || [ 1 ] ] end
637	def column_shading_colour ( index , colour ) self . each do | row | cell = row [ index ] cell . shading_colour = colour if cell != nil end end
20	def validate_choice_argument ( item , parent , key , item_type ) result = false if item_type . kind_of? ( Hash ) && item_type . include? ( :choices ) if item . kind_of? ( Array ) parent [ key ] = [ ] item . each do | sub_item | unless validate_choice_argument ( sub_item , parent , key , item_type ) validate_arg ( sub_item , parent , key , item_type ) end end return true end new_root = { } choice_items = arrayize ( item ) choice_items . each do | choice_item | choice_type = choice_item . delete ( :xsi_type ) choice_item_type = find_choice_by_xsi_type ( choice_type , item_type [ :choices ] ) if choice_type . nil? || choice_item_type . nil? raise AdsCommon :: Errors :: TypeMismatchError . new ( 'choice subtype' , choice_type , choice_item . to_s ( ) ) end choice_item [ :xsi_type ] = choice_type choice_key = choice_item_type [ :original_name ] new_root [ choice_key ] = choice_item type_signature = get_full_type_signature ( choice_type ) validate_arg ( choice_item , new_root , choice_key , type_signature ) end if parent [ key ] . kind_of? ( Array ) parent [ key ] << new_root else parent [ key ] = new_root end result = true end return result end
1105	def create ( cv ) if cv . public_id . nil? then raise ArgumentError . new ( "Controlled value create is missing a public id" ) end if cv . value . nil? then raise ArgumentError . new ( "Controlled value create is missing a value" ) end cv . identifier ||= next_id logger . debug { "Creating controlled value #{cv} in the database..." } @executor . transact ( INSERT_STMT , cv . identifier , cv . parent_identifier , cv . public_id , cv . value ) logger . debug { "Controlled value #{cv.public_id} #{cv.value} created with identifier #{cv.identifier}" } @pid_value_cv_hash [ cv . public_id ] [ cv . value ] = cv end
1039	def from = ( location ) if location then self . from_container = location . container self . from_row = location . row self . from_column = location . column end location end
654	def footer ( type = FooterNode :: UNIVERSAL ) index = 0 if type == FooterNode :: LEFT_PAGE index = 1 elsif type == FooterNode :: RIGHT_PAGE index = 2 elsif type == FooterNode :: FIRST_PAGE index = 3 end @footers [ index ] end
935	def extract_platform ( value ) platform = value . to_s . split ( '|' ) [ 1 ] if value . to_s . include? '|' sauce_platforms @sauce_platforms [ platform ] if not platform . nil? end
944	def block ( method = nil , options = { } , & block ) options [ :error ] ||= error ( method ) if method components = "" . html_safe if method components << self . label ( method , options [ :label ] ) if options [ :label ] or options [ :label ] . nil? and method end components << @template . capture ( & block ) options [ :container ] ||= { } options [ :container ] [ :class ] = arrayorize ( options [ :container ] [ :class ] ) << :: Formula . block_class << method options [ :container ] [ :class ] << :: Formula . block_error_class if :: Formula . block_error_class . present? and error? ( method ) components << @template . content_tag ( :: Formula . hint_tag , options [ :hint ] , :class => :: Formula . hint_class ) if options [ :hint ] components << @template . content_tag ( :: Formula . error_tag , options [ :error ] , :class => :: Formula . error_class ) if options [ :error ] @template . content_tag ( :: Formula . block_tag , options [ :container ] ) do components end end
855	def proprietry_discount_code_for_rrp = ( code ) price = price_get ( 2 ) if price . nil? self . rrp_inc_sales_tax = 0 price = price_get ( 2 ) end discount = price . discounts_coded . find { | disc | disc . discount_code_type == 2 } if discount . nil? discount = ONIX :: DiscountCoded . new discount . discount_code_type = 2 price . discounts_coded << discount end discount . discount_code = code end
269	def post_page ( url , post_data = '' ) url = URI ( url ) prepare_request ( url ) do | session , path , headers | new_page = Page . new ( url , session . post ( path , post_data , headers ) ) @cookies . from_page ( new_page ) yield new_page if block_given? return new_page end end
1032	def parse_and_create parsed_feed = parse_feed return false unless parsed_feed feed = create_feed ( parsed_feed ) create_articles ( feed , parsed_feed ) feed end
480	def ft_info REDI_SEARCH . call ( 'FT.INFO' , @index_name ) rescue Exception => e Rails . logger . error e if defined? Rails return e . message end
1130	def add ( storable , * coordinate ) validate_type ( storable ) loc = create_location ( coordinate ) pos = storable . position || storable . position_class . new pos . location = loc pos . occupant = storable pos . holder = self logger . debug { "Added #{storable.qp} to #{qp} at #{loc.coordinate}." } update_full_flag self end
1118	def buddies data = api ( 'user.get_buddies' ) data [ 'buddies' ] . map { | id | User . new ( client , :_id => id ) } end
678	def _output_filename ( file ) sub_strings = File . basename ( file ) . split ( '.' ) base_name , extensions = sub_strings . first , sub_strings [ 1 .. - 1 ] if extensions . last == 'haml' extensions . pop if extensions . empty? [ base_name , options [ :default_ext ] ] . join ( '.' ) else [ base_name , extensions ] . flatten . join ( '.' ) end else [ base_name , extensions , options [ :default_ext ] ] . flatten . compact . join ( '.' ) end end
1363	def extract_file_rdoc ( file , from = nil , reverse = false ) lines = File . readlines ( file ) if from . nil? and reverse lines = lines . reverse elsif ! reverse lines = lines [ ( from || 0 ) .. - 1 ] else lines = lines [ 0 ... ( from || - 1 ) ] . reverse end doc , started = [ ] , false lines . each { | line | if / \s / =~ line doc << line started = true elsif started break end } doc = reverse ? doc . reverse [ 0 .. - 1 ] : doc [ 0 .. - 1 ] doc = doc . join ( "\n" ) doc . gsub ( / \s / , "" ) end
615	def previous_node peer = nil if ! parent . nil? and parent . respond_to? ( :children ) index = parent . children . index ( self ) peer = index > 0 ? parent . children [ index - 1 ] : nil end peer end
481	def ft_sugadd_all ( attribute : ) @model . all . each { | record | ft_sugadd ( record : record , attribute : attribute ) } rescue Exception => e Rails . logger . error e if defined? Rails return e . message end
64	def exception_for_soap_fault ( response ) begin fault = response [ :fault ] if fault [ :detail ] and fault [ :detail ] [ :api_exception_fault ] exception_fault = fault [ :detail ] [ :api_exception_fault ] exception_name = ( exception_fault [ :application_exception_type ] || FALLBACK_API_ERROR_EXCEPTION ) exception_class = get_module ( ) . const_get ( exception_name ) return exception_class . new ( exception_fault ) elsif fault [ :faultstring ] fault_message = fault [ :faultstring ] return AdsCommon :: Errors :: ApiException . new ( "Unknown exception with error: %s" % fault_message ) else raise ArgumentError . new ( fault . to_s ) end rescue Exception => e return AdsCommon :: Errors :: ApiException . new ( "Failed to resolve exception (%s), SOAP fault: %s" % [ e . message , response . soap_fault ] ) end end
1052	def statement_match? ( other ) ct = consent_tier oct = other . consent_tier ct . nil? or oct . nil? or ct . identifier == oct . identifier or ct . statement == oct . statement end
176	def folder_ids! ( fids , act_as = nil ) ns = @nbuild . parent . name . match ( / /i ) ? NS_EWS_TYPES : NS_EWS_MESSAGES @nbuild [ ns ] . FolderIds { fids . each do | fid | fid [ :act_as ] = act_as if act_as != nil dispatch_folder_id! ( fid ) end } end
412	def decode_definition_and_options ( definition_and_options ) if definition_and_options . size == 1 && definition_and_options . first . is_a? ( Hash ) options = definition_and_options . first . each_with_object ( { } ) do | ( key , value ) , current_options | current_options [ key ] = definition_and_options . first . delete ( key ) if key . is_a? ( Symbol ) end definition_and_options = [ ] if definition_and_options . first . empty? elsif definition_and_options . last . is_a? ( Hash ) options = definition_and_options . pop else options = { } end [ definition_and_options , options ] end
1188	def update ( attributes = { } ) assert_valid_keys ( attributes , :id ) id = attributes . delete ( :id ) update_id ( id ) if id true end
641	def top_border_width = ( width ) size = width . nil? ? 0 : width if size > 0 @borders [ TOP ] = size . to_i else @borders [ TOP ] = nil end end
1017	def close ( allow_reconnect = false ) if @connection reconnect = @reconnect @reconnect = reconnect && allow_reconnect @keepalive_timer . cancel if @keepalive_timer @keepalive_timer = nil @connection . close wait do | & resume | on ( :session_ended , :once => true ) { resume . call } end @reconnect = reconnect end true end
1131	def copy_container_type_capacity return unless container_type and container_type . capacity self . capacity = cpc = container_type . capacity . copy ( :rows , :columns ) logger . debug { "Initialized #{qp} capacity from #{container_type.qp} capacity #{cpc}." } update_full_flag cpc end
1121	def stickers_purchased data = api ( 'sticker.get_purchased_stickers' ) data [ 'stickers' ] . map { | sticker_id | Sticker . new ( client , :_id => sticker_id ) } end
1397	def run! agent = load_agent ( ) fix_ownership ( ) if @config [ :debug ] then Logging :: Logger . root . add_appenders ( "stdout" ) return start_websocket_client ( ) end validate_argv ( ) daemon_dir = Bixby . path ( "var" ) ensure_state_dir ( daemon_dir ) close_fds ( ) daemon_opts = { :dir => daemon_dir , :dir_mode => :normal , :log_output => true , :stop_proc => lambda { logger . info "Agent shutdown on service stop command" } } Daemons . run_proc ( "bixby-agent" , daemon_opts ) do Logging . logger . root . clear_appenders start_websocket_client ( ) end end
1102	def name middle = middle_name if respond_to? ( :middle_name ) Name . new ( last_name , first_name , middle ) if last_name end
669	def usb_code_for_current_locale @usb_code_for_current_locale ||= begin locale = I18n . locale if locale locale = locale . to_s . partition ( '.' ) [ 0 ] result = HIDAPI :: Language . get_by_code ( locale ) unless result locale = locale . partition ( '_' ) [ 0 ] result = HIDAPI :: Language . get_by_code ( locale ) end result ? result [ :usb_code ] : 0 else 0 end end end
1095	def defaults { group_dn_attribute : :cn , group_member_attribute : :member , group_description_attribute : :description , group_objectclass : :group , group_basedn : 'ou=groups,dc=example,dc=com' , group_memberof_attribute : :memberOf , user_dn_attribute : :samaccountname , user_objectclass : :user , user_basedn : 'ou=users,dc=example,dc=com' , user_account_control_attribute : :userAccountControl , user_department_attribute : :department , user_lockout_attribute : :lockouttime , user_mail_attribute : :mail , user_displayname_attribute : :displayName , user_memberof_attribute : :memberOf , host : 'ldap.example.com' , port : 389 , basedn : 'dc=example,dc=com' , username : 'username' , password : 'p@assedWard!' , include_distribution_groups : true } end
398	def punsubscribe ( pattern ) @psub_callbacks . delete ( pattern ) @psubs . delete ( pattern ) raw_send_command ( :punsubscribe , [ pattern ] ) return pubsub_deferrable ( pattern ) end
450	def exec ( cmd ) @write1 . puts cmd text = @read2 . read @read2 . close @read2 , @write2 = IO . pipe raise Client :: RuntimeError , text if text . start_with? 'NT_STATUS_' text end
1265	def do_create ( action ) options = do_creation_options options . title ||= @params . first @helper . send ( "#{action}_usage" ) unless options . title fn = @commands . send ( action , options ) puts "#{@src_dir}/#{fn}" end
825	def to_h ( strict : false ) todo = @key_metadata . keys - @cache . keys todo . each_with_object ( { } ) do | key , hsh | loaded_key = ( strict ? load_key_strict ( key ) : load_key_lenient ( key ) ) hsh [ key ] = loaded_key if exists_locally? ( key ) end end
1166	def collection_status = ( value ) if value == 'Complete' then specimens . each { | spc | spc . collection_status = 'Collected' if spc . pending? } end setCollectionStatus ( value ) end
335	def to_time second = ( ( 0b11111 & @dos_time ) ) * 2 minute = ( ( 0b111111 << 5 & @dos_time ) >> 5 ) hour = ( ( 0b11111 << 11 & @dos_time ) >> 11 ) day = ( ( 0b11111 << 16 & @dos_time ) >> 16 ) month = ( ( 0b1111 << 21 & @dos_time ) >> 21 ) year = ( ( 0b1111111 << 25 & @dos_time ) >> 25 ) + 1980 return Time . local ( year , month , day , hour , minute , second ) end
1126	def << ( input ) if input . index ( / \s / ) . nil? word = normalize_word input self . word = word unless word == '' elsif input . scan ( SENTENCE_DELIMITER ) . length < 2 self . sentence = input . gsub ( SENTENCE_DELIMITER , '' ) else self . passage = input end end
1391	def + ( n ) case n when Numeric then j_date = jd + n * 1 result = HijriUmmAlqura . jd ( j_date ) return result end raise TypeError , 'expected numeric' end
1253	def download_to_file url , file url = URI . parse ( URI . encode ( url . strip ) ) File . new ( file , File :: CREAT ) Net :: HTTP . start ( url . host ) { | http | resp = http . get ( url . path ) open ( file , "wb" ) { | file | file . write ( resp . body ) } } end
1387	def to_s today = arabno_to_hindi ( day ) + " " today = today + HijriUmmAlqura :: MONTHNAMES [ month ] + " " today = today + arabno_to_hindi ( year ) + " " end
310	def on_safelist? ( s ) search = from_user ( s ) . downcase safelist . any? { | b | search . include? ( b . downcase ) } end
715	def get_vdc_by_name ( organization , vdcName ) result = nil organization [ :vdcs ] . each do | vdc | if vdc [ 0 ] . downcase == vdcName . downcase result = get_vdc ( vdc [ 1 ] ) end end result end
943	def button ( value = nil , options = { } ) options [ :button ] ||= { } options [ :container ] ||= { } options [ :container ] [ :class ] = arrayorize ( options [ :container ] [ :class ] ) << :: Formula . block_class @template . content_tag ( :: Formula . block_tag , options [ :container ] ) do submit value , options [ :button ] end end
1184	def resolve_dependency ( node ) node . seen = true @seen_this_pass << node node . edges . each do | edge | unless @resolved . include? edge unless @seen_this_pass . include? edge unless edge . seen? resolve_dependency edge end else raise CircularDependencyError , "Circular reference detected: #{node.key.to_s} - #{edge.key.to_s}" end end end @resolved << node end
288	def each page = fetch ( @first_query ) loop do if page [ 'items' ] . empty? break if page [ 'last_page' ] page = fetch ( page [ 'next' ] ) break if page [ 'items' ] . empty? end item = page [ 'items' ] . shift yield translate ( item ) end end
595	def compile ( encode : true , includeClassName : false ) run_callbacks :prepare do q = { } q [ :limit ] = @limit if @limit . is_a? ( Numeric ) && @limit > 0 q [ :skip ] = @skip if @skip > 0 q [ :include ] = @includes . join ( ',' ) unless @includes . empty? q [ :keys ] = @keys . join ( ',' ) unless @keys . empty? q [ :order ] = @order . join ( ',' ) unless @order . empty? unless @where . empty? q [ :where ] = Parse :: Query . compile_where ( @where ) q [ :where ] = q [ :where ] . to_json if encode end if @count && @count > 0 q [ :limit ] = 0 q [ :count ] = 1 end if includeClassName q [ :className ] = @table end q end end
393	def configure_inactivity_check ( trigger_secs , response_timeout ) raise ArgumentError ( 'trigger_secs must be > 0' ) unless trigger_secs . to_i > 0 raise ArgumentError ( 'response_timeout must be > 0' ) unless response_timeout . to_i > 0 @inactivity_trigger_secs = trigger_secs . to_i @inactivity_response_timeout = response_timeout . to_i schedule_inactivity_checks if @connected end
938	def extract_multiple_numbers ( str ) return [ ] if str == '' || str . nil? str . scan ( STDNUMPAT_MULTIPLE ) . flatten . map { | i | i . gsub ( / \- / , '' ) . upcase } end
1273	def get_server_name ( server , exact = true ) ret = nr_api . get ( url ( 'servers' ) , 'filter[name]' => server ) . body return ret [ 'servers' ] unless exact ret [ 'servers' ] . find { | x | x [ 'name' ] . casecmp ( server ) . zero? } rescue NoMethodError nil end
1251	def parse download_files parsing_clients = false parsing_prefile = false parsing_general = false parsing_servers = false parsing_voice_servers = false File . open ( DATA_FILE_PATH , 'r:ascii-8bit' ) . each { | line | if line . start_with? ";" parsing_clients = false parsing_prefile = false parsing_general = false parsing_servers = false parsing_voice_servers = false elsif parsing_clients clienttype = line . split ( ":" ) [ 3 ] if clienttype . eql? "PILOT" @pilots << Pilot . new ( line ) elsif clienttype . eql? "ATC" @atc << ATC . new ( line ) end elsif parsing_prefile @prefiles << Prefile . new ( line ) elsif parsing_general line_split = line . split ( "=" ) @general [ line_split [ 0 ] . strip . downcase . gsub ( " " , "_" ) ] = line_split [ 1 ] . strip elsif parsing_servers @servers << Server . new ( line ) elsif parsing_voice_servers @voice_servers << VoiceServer . new ( line ) if line . length > 2 end parsing_clients = true if line . start_with? "!CLIENTS:" parsing_prefile = true if line . start_with? "!PREFILE:" parsing_general = true if line . start_with? "!GENERAL:" parsing_servers = true if line . start_with? "!SERVERS:" parsing_voice_servers = true if line . start_with? "!VOICE SERVERS:" } end
952	def order ( field = nil , & block ) if block_given? @collection = @collection . sort { | o1 , o2 | yield ( o1 , o2 ) } else raise ArgumentError . new ( 'you must supply a field name to sort unless you supply a block.' ) if field . nil? @collection = @collection . sort { | o1 , o2 | o1 . send ( field ) <=> o2 . send ( field ) } end self end
485	def ft_suglen ( attribute : ) key = "#{@model}:#{attribute}" REDI_SEARCH . call ( 'FT.SUGLEN' , key ) rescue Exception => e Rails . logger . error e if defined? Rails return e . message end
908	def execute_ssh ( commands ) commands = [ commands ] unless commands . is_a? Array result = "" Net :: SSH . start settings . remote_server , settings . remote_user do | ssh | commands . each do | command | was_error = false logger . info "ssh: #{command}" ssh . exec! command do | channel , stream , data | case stream when :stdout logger . info data result += "#{data}\n" unless data . empty? when :stderr logger . error data was_error = true end end throw "Exception during ssh, look in log file" if was_error end end result end
460	def format_value ( val ) case val when AmazonFlexPay :: Model val . to_hash when Time val . utc . strftime ( '%Y-%m-%dT%H:%M:%SZ' ) when TrueClass , FalseClass val . to_s . capitalize when Array val . join ( ',' ) else val . to_s end end
965	def validate_length ( field , value , setting ) if value . is_a? ( String ) || value . nil? result = value . nil? || ( value . length < setting . first || value . length > setting . last ) add_message ( field , "incorrect value supplied for #{field.to_s} -- should be between #{setting.first} and #{setting.last} characters long." ) if result return ! result end return false end
543	def user_venue_history ( options = { } ) response = connection . get do | req | req . url "users/self/venuehistory" , options end return_error_or_body ( response , response . body . response . venues ) end
546	def user_friend_request ( user_id , options = { } ) response = connection . post do | req | req . url "users/#{user_id}/request" , options end return_error_or_body ( response , response . body . response ) end
914	def pet_stats ( species_id , options = { } ) level = options [ :level ] || 1 breedId = options [ :breedId ] || 3 qualityId = options [ :qualityId ] || 1 BnetApi . make_request_with_params ( "/wow/pet/stats/#{species_id}" , { level : level , breedId : breedId , qualityId : qualityId } ) end
541	def user_todos ( user_id , options = { } ) response = connection . get do | req | req . url "users/#{user_id}/todos" , options end return_error_or_body ( response , response . body . response . todos ) end
97	def determine_choice_type_override ( field_data , field_def ) result = nil if field_data . kind_of? ( Hash ) and field_def . include? ( :choices ) result = determine_choice ( field_data , field_def [ :choices ] ) end return result end
212	def move_folder ( to_folder_id , * sources ) req = build_soap! do | type , builder | if ( type == :header ) else builder . nbuild . MoveFolder { builder . nbuild . parent . default_namespace = @default_ns builder . to_folder_id! ( to_folder_id ) builder . folder_ids! ( sources . flatten ) } end end do_soap_request ( req ) end
978	def filter ( key , * options ) if options . present? && options . first . instance_of? ( Hash ) options = options . first . with_indifferent_access if options . key? ( :only ) return filter_only_values ( key , options [ :only ] ) elsif options . key? ( :except ) return filter_excluded_values ( key , options [ :except ] ) end else return fetch ( key , * options ) end end
77	def make_adhoc_request ( data , cid , & block ) @api . utils_reporter . report_utils_used ( ) url = @api . api_config . adhoc_report_download_url ( @version ) headers = get_report_request_headers ( url , cid ) log_request ( url , headers , data ) if block_given? AdsCommon :: Http . post_stream ( url , data , @api . config , headers , & block ) return nil else response = AdsCommon :: Http . post_response ( url , data , @api . config , headers ) log_headers ( response . headers ) check_for_errors ( response ) return response end end
1051	def create_file_header ( columns ) columns . each_with_index do | c , i | next if i == @current_key columns [ i ] = c . scan ( Regexp . new ( @current_source_header ) ) . flatten [ 0 ] end @file_header = @current_key ? [ @current_key . to_i ] : [ ] header_cols . each do | h | @file_header << columns . index ( h ) end @file_header . compact! end
126	def exec ( cmd , nohup_log ) start = Time . now Open3 . popen2e ( { 'MALLOC_ARENA_MAX' => '2' } , cmd ) do | stdin , stdout , thr | nohup_log . print ( "Started process ##{thr.pid} from process ##{Process.pid}: #{cmd}\n" ) stdin . close until stdout . eof? begin line = stdout . gets rescue IOError => e line = Backtrace . new ( e ) . to_s end nohup_log . print ( line ) end nohup_log . print ( "Nothing else left to read from ##{thr.pid}\n" ) code = thr . value . to_i nohup_log . print ( "Exit code of process ##{thr.pid} is #{code}, was alive for #{Age.new(start)}: #{cmd}\n" ) code end end
406	def fixtures_class if defined? ( ActiveRecord :: FixtureSet ) ActiveRecord :: FixtureSet elsif defined? ( ActiveRecord :: Fixtures ) ActiveRecord :: Fixtures else :: Fixtures end end
25	def validate_arg ( arg , parent , key , arg_type ) result = case arg when Array validate_array_arg ( arg , parent , key , arg_type ) when Hash validate_hash_arg ( arg , parent , key , arg_type ) when Time arg = validate_time_arg ( arg , parent , key ) validate_hash_arg ( arg , parent , key , arg_type ) else arg end return result end
836	def []= ( name , schema ) case name when Symbol , String , Regexp if @properties . has_key? ( name ) raise InvalidSchemaError , "property '#{name}' already defined" end @properties [ name ] = schema else raise InvalidSchemaError , "unsupported property name type #{name}:#{name.class}" end end
